
<intrinsic_list>


<!-- _mm256_abs_epi8 / vpabsb -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_abs_epi8'>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m256i'/>
	<description>Compute the absolute value of packed 8-bit integers in "a", and store the unsigned results in "dst". </description>
	<description code='true'>
FOR j := 0 to 31
	i := j*8
	dst[i+7:i] := ABS(a[i+7:i])
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpabsb'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_abs_epi16 / vpabsw -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_abs_epi16'>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m256i'/>
	<description>Compute the absolute value of packed 16-bit integers in "a", and store the unsigned results in "dst". </description>
	<description code='true'>
FOR j := 0 to 15
	i := j*16
	dst[i+15:i] := ABS(a[i+15:i])
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpabsw'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_abs_epi32 / vpabsd -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_abs_epi32'>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m256i'/>
	<description>Compute the absolute value of packed 32-bit integers in "a", and store the unsigned results in "dst". </description>
	<description code='true'>
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := ABS(a[i+31:i])
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpabsd'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_add_epi8 / vpaddb -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_add_epi8'>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Add packed 8-bit integers in "a" and "b", and store the results in "dst".</description>
	<description code='true'>
FOR j := 0 to 31
	i := j*8
	dst[i+7:i] := a[i+7:i] + b[i+7:i]
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpaddb'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_add_epi16 / vpaddb -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_add_epi16'>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Add packed 16-bit integers in "a" and "b", and store the results in "dst".</description>
	<description code='true'>
FOR j := 0 to 15
	i := j*16
	dst[i+15:i] := a[i+15:i] + b[i+15:i]
ENDFOR
dst[MAX:256] := 0
	</description>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_add_epi32 / vpaddd -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_add_epi32'>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Add packed 32-bit integers in "a" and "b", and store the results in "dst".</description>
	<description code='true'>
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := a[i+31:i] + b[i+31:i]
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpaddd'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_add_epi64 / vpaddq -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_add_epi64'>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Add packed 64-bit integers in "a" and "b", and store the results in "dst".</description>
	<description code='true'>
FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := a[i+63:i] + b[i+63:i]
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpaddq'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_adds_epi8 / vpaddsb -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_adds_epi8'>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Add packed 8-bit integers in "a" and "b" using saturation, and store the results in "dst".</description>
	<description code='true'>
FOR j := 0 to 31
	i := j*8
	dst[i+7:i] := Saturate_To_Int8( a[i+7:i] + b[i+7:i] )
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpaddsb'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_adds_epi16 / vpaddsw -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_adds_epi16'>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Add packed 16-bit integers in "a" and "b" using saturation, and store the results in "dst".</description>
	<description code='true'>
FOR j := 0 to 15
	i := j*16
	dst[i+15:i] := Saturate_To_Int16( a[i+15:i] + b[i+15:i] )
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpaddsw'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_adds_epu8 / vpaddusb -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_adds_epu8'>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Add packed unsigned 8-bit integers in "a" and "b" using saturation, and store the results in "dst".</description>
	<description code='true'>
FOR j := 0 to 31
	i := j*8
	dst[i+7:i] := Saturate_To_UnsignedInt8( a[i+7:i] + b[i+7:i] )
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpaddusb'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_adds_epu16 / vpaddusw -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_adds_epu16'>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Add packed unsigned 16-bit integers in "a" and "b" using saturation, and store the results in "dst".</description>
	<description code='true'>
FOR j := 0 to 15
	i := j*16
	dst[i+15:i] := Saturate_To_UnsignedInt16( a[i+15:i] + b[i+15:i] )
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpaddusw'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_alignr_epi8 / vpalignr -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_alignr_epi8'>
	<CPUID>AVX2</CPUID>
	<category>Miscellaneous</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<parameter varname='count' type='const int'/>
	<description>Concatenate pairs of 16-byte blocks in "a" and "b" into a 32-byte temporary result, shift the result right by "count" bytes, and store the low 16 bytes in "dst". </description>
	<description code='true'>
FOR j := 0 to 1
	i := j*128
	tmp[255:0] := ((a[i+127:i] &lt;&lt; 128) OR b[i+127:i]) &gt;&gt; (count[7:0]*8)
	dst[i+127:i] := tmp[127:0]
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpalignr'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_and_si256 / vpand -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_and_si256'>
	<CPUID>AVX2</CPUID>
	<category>Logical</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Compute the bitwise AND of 256 bits (representing integer data) in "a" and "b", and store the result in "dst".</description>
	<description code='true'>
dst[255:0] := (a[255:0] AND b[255:0])
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpand'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_andnot_si256 / vpandn -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_andnot_si256'>
	<CPUID>AVX2</CPUID>
	<category>Logical</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Compute the bitwise AND NOT of 256 bits (representing integer data) in "a" and "b", and store the result in "dst".</description>
	<description code='true'>
dst[255:0] := ((NOT a[255:0]) AND b[255:0])
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpandn'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_avg_epu8 / vpavgb -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_avg_epu8'>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Average packed unsigned 8-bit integers in "a" and "b", and store the results in "dst".</description>
	<description code='true'>
FOR j := 0 to 31
	i := j*8
	dst[i+7:i] := (a[i+7:i] + b[i+7:i] + 1) &gt;&gt; 1
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpavgb'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_avg_epu16 / vpavgw -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_avg_epu16'>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Average packed unsigned 16-bit integers in "a" and "b", and store the results in "dst".</description>
	<description code='true'>
FOR j := 0 to 15
	i := j*16
	dst[i+15:i] := (a[i+15:i] + b[i+15:i] + 1) &gt;&gt; 1
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpavgw'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_blend_epi16 / vpblendw -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_blend_epi16'>
	<CPUID>AVX2</CPUID>
	<category>Miscellaneous</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<parameter varname='imm' type='const int'/>
	<description>Blend packed 16-bit integers from "a" and "b" using control mask "imm", and store the results in "dst".</description>
	<description code='true'>
FOR j := 0 to 15
	i := j*16
	IF imm[j]
		dst[i+15:i] := b[i+15:i]
	ELSE
		dst[i+15:i] := a[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpblendw'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm_blend_epi32 / vpblendd -->
<intrinsic tech='AVX2' rettype='__m128i' name='_mm_blend_epi32'>
	<CPUID>AVX2</CPUID>
	<category>Miscellaneous</category>
	<parameter varname='a' type='__m128i'/>
	<parameter varname='b' type='__m128i'/>
	<parameter varname='imm' type='const int'/>
	<description>Blend packed 32-bit integers from "a" and "b" using control mask "imm", and store the results in "dst".</description>
	<description code='true'>
FOR j := 0 to 3
	i := j*32
	IF imm[j]
		dst[i+31:i] := b[i+31:i]
	ELSE
		dst[i+31:i] := a[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</description>
	<mnemonic base='vpblendd'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_blend_epi32 / vpblendd -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_blend_epi32'>
	<CPUID>AVX2</CPUID>
	<category>Miscellaneous</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<parameter varname='imm' type='const int'/>
	<description>Blend packed 32-bit integers from "a" and "b" using control mask "imm", and store the results in "dst".</description>
	<description code='true'>
FOR j := 0 to 7
	i := j*32
	IF imm[j]
		dst[i+31:i] := b[i+31:i]
	ELSE
		dst[i+31:i] := a[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpblendd'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_blendv_epi8 / vpblendvb -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_blendv_epi8'>
	<CPUID>AVX2</CPUID>
	<category>Miscellaneous</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<parameter varname='mask' type='__m256i'/>
	<description>Blend packed 8-bit integers from "a" and "b" using "mask", and store the results in "dst".</description>
	<description code='true'>
FOR j := 0 to 31
	i := j*8
	IF mask[i+7]
		dst[i+7:i] := b[i+7:i]
	ELSE
		dst[i+7:i] := a[i+7:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpblendvb'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm_broadcastb_epi8 / vpbroadcastb -->
<intrinsic tech='AVX2' rettype='__m128i' name='_mm_broadcastb_epi8'>
	<CPUID>AVX2</CPUID>
	<category>Miscellaneous</category>
	<parameter varname='a' type='__m128i'/>
	<description>Broadcast the low packed 8-bit integer from "a" to all elements of "dst".</description>
	<description code='true'>
FOR j := 0 to 15
	i := j*8
	dst[i+7:i] := a[7:0]
ENDFOR
dst[MAX:128] := 0
	</description>
	<mnemonic base='vpbroadcastb'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_broadcastb_epi8 / vpbroadcastb -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_broadcastb_epi8'>
	<CPUID>AVX2</CPUID>
	<category>Miscellaneous</category>
	<parameter varname='a' type='__m256i'/>
	<description>Broadcast the low packed 8-bit integer from "a" to all elements of "dst".</description>
	<description code='true'>
FOR j := 0 to 31
	i := j*8
	dst[i+7:i] := a[7:0]
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpbroadcastb'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm_broadcastd_epi32 / vpbroadcastd -->
<intrinsic tech='AVX2' rettype='__m128i' name='_mm_broadcastd_epi32'>
	<CPUID>AVX2</CPUID>
	<category>Miscellaneous</category>
	<parameter varname='a' type='__m128i'/>
	<description>Broadcast the low packed 32-bit integer from "a" to all elements of "dst".</description>
	<description code='true'>
FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := a[31:0]
ENDFOR
dst[MAX:128] := 0
	</description>
	<mnemonic base='vpbroadcastd'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_broadcastd_epi32 / vpbroadcastd -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_broadcastd_epi32'>
	<CPUID>AVX2</CPUID>
	<category>Miscellaneous</category>
	<parameter varname='a' type='__m256i'/>
	<description>Broadcast the low packed 32-bit integer from "a" to all elements of "dst".</description>
	<description code='true'>
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := a[31:0]
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpbroadcastd'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm_broadcastq_epi64 / vpbroadcastq -->
<intrinsic tech='AVX2' rettype='__m128i' name='_mm_broadcastq_epi64'>
	<CPUID>AVX2</CPUID>
	<category>Miscellaneous</category>
	<parameter varname='a' type='__m128i'/>
	<description>Broadcast the low packed 64-bit integer from "a" to all elements of "dst". </description>
	<description code='true'>
FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := a[63:0]
ENDFOR
dst[MAX:128] := 0
	</description>
	<mnemonic base='vpbroadcastq'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_broadcastq_epi64 / vpbroadcastq -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_broadcastq_epi64'>
	<CPUID>AVX2</CPUID>
	<category>Miscellaneous</category>
	<parameter varname='a' type='__m256i'/>
	<description>Broadcast the low packed 64-bit integer from "a" to all elements of "dst". </description>
	<description code='true'>
FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := a[63:0]
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpbroadcastq'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm_broadcastsd_pd / movddup -->
<intrinsic tech='AVX2' vexEq='TRUE' rettype='__m128d' name='_mm_broadcastsd_pd'>
	<CPUID>AVX2</CPUID>
	<category>Miscellaneous</category>
	<parameter varname='a' type='__m128d'/>
	<description>Broadcast the low double-precision (64-bit) floating-point element from "a" to all elements of "dst".</description>
	<description code='true'>
FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := a[63:0]
ENDFOR
dst[MAX:128] := 0
	</description>
	<mnemonic parameters='' base='movddup'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_broadcastsd_pd / vbroadcastsd -->
<intrinsic tech='AVX2' rettype='__m256d' name='_mm256_broadcastsd_pd'>
	<CPUID>AVX2</CPUID>
	<category>Miscellaneous</category>
	<parameter varname='a' type='__m128d'/>
	<description>Broadcast the low double-precision (64-bit) floating-point element from "a" to all elements of "dst".</description>
	<description code='true'>
FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := a[63:0]
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vbroadcastsd'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_broadcastsi128_si256 / vbroadcasti128 -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_broadcastsi128_si256'>
	<CPUID>AVX2</CPUID>
	<category>Miscellaneous</category>
	<parameter varname='a' type='__m128i'/>
	<description>Broadcast 128 bits of integer data from "a" to all 128-bit lanes in "dst".
	</description>
	<description code='true'>
dst[127:0] := a[127:0]
dst[255:128] := a[127:0]
dst[MAX:256] := 0
	</description>
	<mnemonic base='vbroadcasti128'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm_broadcastss_ps / vbroadcastss -->
<intrinsic tech='AVX2' rettype='__m128' name='_mm_broadcastss_ps'>
	<CPUID>AVX2</CPUID>
	<category>Miscellaneous</category>
	<parameter varname='a' type='__m128'/>
	<description>Broadcast the low single-precision (32-bit) floating-point element from "a" to all elements of "dst".</description>
	<description code='true'>
FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := a[31:0]
ENDFOR
dst[MAX:128] := 0
	</description>
	<mnemonic base='vbroadcastss'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_broadcastss_ps / vbroadcastss -->
<intrinsic tech='AVX2' rettype='__m256' name='_mm256_broadcastss_ps'>
	<CPUID>AVX2</CPUID>
	<category>Miscellaneous</category>
	<parameter varname='a' type='__m128'/>
	<description>Broadcast the low single-precision (32-bit) floating-point element from "a" to all elements of "dst".</description>
	<description code='true'>
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := a[31:0]
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vbroadcastss'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm_broadcastw_epi16 / vpbroadcastw -->
<intrinsic tech='AVX2' rettype='__m128i' name='_mm_broadcastw_epi16'>
	<CPUID>AVX2</CPUID>
	<category>Miscellaneous</category>
	<parameter varname='a' type='__m128i'/>
	<description>Broadcast 16-bit integer "a" to all elements of "dst".</description>
	<description code='true'>
FOR j := 0 to 7
	i := j*16
	dst[i+15:i] := a[15:0]
ENDFOR
dst[MAX:128] := 0
	</description>
	<mnemonic base='vpbroadcastw'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_broadcastw_epi16 / vpbroadcastw -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_broadcastw_epi16'>
	<CPUID>AVX2</CPUID>
	<category>Miscellaneous</category>
	<parameter varname='a' type='__m256i'/>
	<description>Broadcast 16-bit integer "a" to all elements of "dst".</description>
	<description code='true'>
FOR j := 0 to 15
	i := j*16
	dst[i+15:i] := a[15:0]
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpbroadcastw'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_cmpeq_epi8 / vpcmpeqb -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_cmpeq_epi8'>
	<CPUID>AVX2</CPUID>
	<category>Compare</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>	
	<description>Compare packed 8-bit integers in "a" and "b" for equality, and store the results in "dst".</description>
	<description code='true'>
FOR j := 0 to 31
  i := j*8
  dst[i+7:i] := ( a[i+7:i] == b[i+7:i] ) ? 0xFF : 0
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpcmpeqb'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_cmpeq_epi16 / vpcmpeqw -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_cmpeq_epi16'>
 	<CPUID>AVX2</CPUID>
	<category>Compare</category>
 	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Compare packed 16-bit integers in "a" and "b" for equality, and store the results in "dst".</description>
	<description code='true'>
FOR j := 0 to 15
  i := j*16
  dst[i+15:i] := ( a[i+15:i] == b[i+15:i] ) ? 0xFFFF : 0
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpcmpeqw'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_cmpeq_epi32 / vpcmpeqd -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_cmpeq_epi32'>
	<CPUID>AVX2</CPUID>
	<category>Compare</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Compare packed 32-bit integers in "a" and "b" for equality, and store the results in "dst".</description>
	<description code='true'>
FOR j := 0 to 7
  i := j*32
  dst[i+31:i] := ( a[i+31:i] == b[i+31:i] ) ? 0xFFFFFFFF : 0
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpcmpeqd'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_cmpeq_epi64 / vpcmpeqq -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_cmpeq_epi64'>
	<CPUID>AVX2</CPUID>
	<category>Compare</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Compare packed 64-bit integers in "a" and "b" for equality, and store the results in "dst".</description>
	<description code='true'>
FOR j := 0 to 3
  i := j*64
  dst[i+63:i] := ( a[i+63:i] == b[i+63:i] ) ? 0xFFFFFFFFFFFFFFFF : 0
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpcmpeqq'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_cmpgt_epi8 / vpcmpgtb -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_cmpgt_epi8'>
	<CPUID>AVX2</CPUID>
	<category>Compare</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Compare packed 8-bit integers in "a" and "b" for greater-than, and store the results in "dst".</description>
	<description code='true'>
FOR j := 0 to 31
  i := j*8
  dst[i+7:i] := ( a[i+7:i] &gt; b[i+7:i] ) ? 0xFF : 0
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpcmpgtb'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_cmpgt_epi16 / vpcmpgtw -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_cmpgt_epi16'>
	<CPUID>AVX2</CPUID>
	<category>Compare</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Compare packed 16-bit integers in "a" and "b" for greater-than, and store the results in "dst".</description>
	<description code='true'>
FOR j := 0 to 15
  i := j*16
  dst[i+15:i] := ( a[i+15:i] &gt; b[i+15:i] ) ? 0xFFFF : 0
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpcmpgtw'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_cmpgt_epi32 / vpcmpgtd -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_cmpgt_epi32'>
	<CPUID>AVX2</CPUID>
	<category>Compare</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Compare packed 32-bit integers in "a" and "b" for greater-than, and store the results in "dst".</description>
	<description code='true'>
FOR j := 0 to 7
  i := j*32
  dst[i+31:i] := ( a[i+31:i] &gt; b[i+31:i] ) ? 0xFFFFFFFF : 0
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpcmpgtd'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_cmpgt_epi64 / vpcmpgtq -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_cmpgt_epi64'>
	<CPUID>AVX2</CPUID>
	<category>Compare</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Compare packed 64-bit integers in "a" and "b" for greater-than, and store the results in "dst".</description>
	<description code='true'>
FOR j := 0 to 3
  i := j*64
  dst[i+63:i] := ( a[i+63:i] &gt; b[i+63:i] ) ? 0xFFFFFFFFFFFFFFFF : 0
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpcmpgtq'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_cvtepi16_epi32 / vpmovsxwd -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_cvtepi16_epi32'>
	<CPUID>AVX2</CPUID>
	<category>Convert</category>
	<parameter varname='a' type='__m128i'/>
	<description>Sign extend packed 16-bit integers in "a" to packed 32-bit integers, and store the results in "dst".</description>
	<description code='true'>
FOR j:= 0 to 7
	i := 32*j
	k := 16*j
	dst[i+31:i] := SignExtend(a[k+15:k])
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpmovsxwd'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_cvtepi16_epi64 / vpmovsxwq -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_cvtepi16_epi64'>
	<CPUID>AVX2</CPUID>
	<category>Convert</category>
	<parameter varname='a' type='__m128i'/>
	<description>Sign extend packed 16-bit integers in "a" to packed 64-bit integers, and store the results in "dst".</description>
	<description code='true'>
FOR j:= 0 to 3
	i := 64*j
	k := 16*j
	dst[i+63:i] := SignExtend(a[k+15:k])
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpmovsxwq'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_cvtepi32_epi64 / vpmovsxdq -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_cvtepi32_epi64'>
	<CPUID>AVX2</CPUID>
	<category>Convert</category>
	<parameter varname='a' type='__m128i'/>
	<description>Sign extend packed 32-bit integers in "a" to packed 64-bit integers, and store the results in "dst".</description>
	<description code='true'>
FOR j:= 0 to 3
	i := 64*j
	k := 32*j
	dst[i+63:i] := SignExtend(a[k+31:k])
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpmovsxdq'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_cvtepi8_epi16 / vpmovsxbw -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_cvtepi8_epi16'>
	<CPUID>AVX2</CPUID>
	<category>Convert</category>
	<parameter varname='a' type='__m128i'/>
	<description>Sign extend packed 8-bit integers in "a" to packed 16-bit integers, and store the results in "dst".</description>
	<description code='true'>
FOR j := 0 to 15
	i := j*8
	l := j*16
	dst[l+15:l] := SignExtend(a[i+7:i])
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpmovsxbw'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_cvtepi8_epi32 / vpmovsxbd -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_cvtepi8_epi32'>
	<CPUID>AVX2</CPUID>
	<category>Convert</category>
	<parameter varname='a' type='__m128i'/>
	<description>Sign extend packed 8-bit integers in "a" to packed 32-bit integers, and store the results in "dst".</description>
	<description code='true'>
FOR j := 0 to 7
	i := 32*j
	k := 8*j
	dst[i+31:i] := SignExtend(a[k+7:k])
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpmovsxbd'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_cvtepi8_epi64 / vpmovsxbq -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_cvtepi8_epi64'>
	<CPUID>AVX2</CPUID>
	<category>Convert</category>
	<parameter varname='a' type='__m128i'/>
	<description>Sign extend packed 8-bit integers in the low 8 bytes of "a" to packed 64-bit integers, and store the results in "dst".</description>
	<description code='true'>
FOR j := 0 to 3
	i := 64*j
	k := 8*j
	dst[i+63:i] := SignExtend(a[k+7:k])
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpmovsxbq'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_cvtepu16_epi32 / vpmovzxwd -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_cvtepu16_epi32'>
	<CPUID>AVX2</CPUID>
	<category>Convert</category>
	<parameter varname='a' type='__m128i'/>
	<description>Zero extend packed unsigned 16-bit integers in "a" to packed 32-bit integers, and store the results in "dst".</description>
	<description code='true'>
FOR j := 0 to 7
	i := 32*j
	k := 16*j
	dst[i+31:i] := ZeroExtend(a[k+15:k])
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpmovzxwd'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_cvtepu16_epi64 / vpmovzxwq -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_cvtepu16_epi64'>
	<CPUID>AVX2</CPUID>
	<category>Convert</category>
	<parameter varname='a' type='__m128i'/>
	<description>Zero extend packed unsigned 16-bit integers in "a" to packed 64-bit integers, and store the results in "dst".</description>
	<description code='true'>
FOR j:= 0 to 3
	i := 64*j
	k := 16*j
	dst[i+63:i] := ZeroExtend(a[k+15:k])
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpmovzxwq'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_cvtepu32_epi64 / vpmovzxdq -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_cvtepu32_epi64'>
	<CPUID>AVX2</CPUID>
	<category>Convert</category>
	<parameter varname='a' type='__m128i'/>
	<description>Zero extend packed unsigned 32-bit integers in "a" to packed 64-bit integers, and store the results in "dst".</description>
	<description code='true'>
FOR j:= 0 to 3
	i := 64*j
	k := 32*j
	dst[i+63:i] := ZeroExtend(a[k+31:k])
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpmovzxdq'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_cvtepu8_epi16 / vpmovzxbw -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_cvtepu8_epi16'>
		 <CPUID>AVX2</CPUID>
	<category>Convert</category>
	<parameter varname='a' type='__m128i'/>
	<description>Zero extend packed unsigned 8-bit integers in "a" to packed 16-bit integers, and store the results in "dst".</description>
	<description code='true'>
FOR j := 0 to 15
	i := j*8
	l := j*16
	dst[l+15:l] := ZeroExtend(a[i+7:i])
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpmovzxbw'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_cvtepu8_epi32 / vpmovzxbd -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_cvtepu8_epi32'>
	<CPUID>AVX2</CPUID>
	<category>Convert</category>
	<parameter varname='a' type='__m128i'/>
	<description>Zero extend packed unsigned 8-bit integers in "a" to packed 32-bit integers, and store the results in "dst".</description>
	<description code='true'>
FOR j := 0 to 7
	i := 32*j
	k := 8*j
	dst[i+31:i] := ZeroExtend(a[k+7:k])
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpmovzxbd'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_cvtepu8_epi64 / vpmovzxbq -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_cvtepu8_epi64'>
	<CPUID>AVX2</CPUID>
	<category>Convert</category>
	<parameter varname='a' type='__m128i'/>
	<description>Zero extend packed unsigned 8-bit integers in the low 8 byte sof "a" to packed 64-bit integers, and store the results in "dst".</description>
	<description code='true'>
FOR j := 0 to 3
	i := 64*j
	k := 8*j
	dst[i+63:i] := ZeroExtend(a[k+7:k])
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpmovzxbq'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_extracti128_si256 / vextracti128 -->
<intrinsic tech='AVX2' rettype='__m128i' name='_mm256_extracti128_si256'>
	<CPUID>AVX2</CPUID>
	<category>Miscellaneous</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='imm' type='int'/>
	<description>Extract 128 bits (composed of integer data) from "a", selected with "imm", and store the result in "dst".</description>
	<description code='true'>
CASE imm of
	0: dst[127:0] := a[127:0]
	1: dst[127:0] := a[255:128]
ESAC
dst[MAX:128] := 0
	</description>
	<mnemonic base='vextracti128'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_hadd_epi16 / vphaddw -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_hadd_epi16'>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Horizontally add adjacent pairs of 16-bit integers in "a" and "b", and pack the signed 16-bit results in "dst".</description>
	<description code='true'>
dst[15:0] := a[31:16] + a[15:0]
dst[31:16] := a[63:48] + a[47:32]
dst[47:32] := a[95:80] + a[79:64]
dst[63:48] := a[127:112] + a[111:96]
dst[79:64] := b[31:16] + b[15:0]
dst[95:80] := b[63:48] + b[47:32]
dst[111:96] := b[95:80] + b[79:64]
dst[127:112] := b[127:112] + b[111:96]
dst[143:128] := a[159:144] + a[143:128]
dst[159:144] := a[191:176] + a[175:160]
dst[175:160] := a[223:208] + a[207:192]
dst[191:176] := a[255:240] + a[239:224]
dst[207:192] := b[127:112] + b[143:128]
dst[223:208] := b[159:144] + b[175:160]
dst[239:224] := b[191:176] + b[207:192]
dst[255:240] := b[223:208] + b[239:224]
dst[MAX:256] := 0
	</description>
	<mnemonic base='vphaddw'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_hadd_epi32 / vphaddd -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_hadd_epi32'>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Horizontally add adjacent pairs of 32-bit integers in "a" and "b", and pack the signed 32-bit results in "dst".</description>
	<description code='true'>
dst[31:0] := a[63:32] + a[31:0]
dst[63:32] := a[127:96] + a[95:64]
dst[95:64] := b[63:32] + b[31:0]
dst[127:96] := b[127:96] + b[95:64]
dst[159:128] := a[191:160] + a[159:128]
dst[191:160] := a[255:224] + a[223:192]
dst[223:192] := b[191:160] + b[159:128]
dst[255:224] := b[255:224] + b[223:192]
dst[MAX:256] := 0
	</description>
	<mnemonic base='vphaddd'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_hadds_epi16 / vphaddsw -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_hadds_epi16'>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Horizontally add adjacent pairs of 16-bit integers in "a" and "b" using saturation, and pack the signed 16-bit results in "dst".</description>
	<description code='true'>
dst[15:0]= Saturate_To_Int16(a[31:16] + a[15:0])
dst[31:16] = Saturate_To_Int16(a[63:48] + a[47:32])
dst[47:32] = Saturate_To_Int16(a[95:80] + a[79:64])
dst[63:48] = Saturate_To_Int16(a[127:112] + a[111:96])
dst[79:64] = Saturate_To_Int16(b[31:16] + b[15:0])
dst[95:80] = Saturate_To_Int16(b[63:48] + b[47:32])
dst[111:96] = Saturate_To_Int16(b[95:80] + b[79:64])
dst[127:112] = Saturate_To_Int16(b[127:112] + b[111:96])
dst[143:128] = Saturate_To_Int16(a[159:144] + a[143:128])
dst[159:144] = Saturate_To_Int16(a[191:176] + a[175:160])
dst[175:160] = Saturate_To_Int16( a[223:208] + a[207:192])
dst[191:176] = Saturate_To_Int16(a[255:240] + a[239:224])
dst[207:192] = Saturate_To_Int16(b[127:112] + b[143:128])
dst[223:208] = Saturate_To_Int16(b[159:144] + b[175:160])
dst[239:224] = Saturate_To_Int16(b[191-160] + b[159-128])
dst[255:240] = Saturate_To_Int16(b[255:240] + b[239:224])
dst[MAX:256] := 0
	</description>
	<mnemonic base='vphaddsw'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_hsub_epi16 / vphsubw -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_hsub_epi16'>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Horizontally subtract adjacent pairs of 16-bit integers in "a" and "b", and pack the signed 16-bit results in "dst".</description>
	<description code='true'>
dst[15:0] := a[15:0] - a[31:16]
dst[31:16] := a[47:32] - a[63:48]
dst[47:32] := a[79:64] - a[95:80]
dst[63:48] := a[111:96] - a[127:112]
dst[79:64] := b[15:0] - b[31:16]
dst[95:80] := b[47:32] - b[63:48]
dst[111:96] := b[79:64] - b[95:80]
dst[127:112] := b[111:96] - b[127:112]
dst[143:128] := a[143:128] - a[159:144]
dst[159:144] := a[175:160] - a[191:176]
dst[175:160] := a[207:192] - a[223:208]
dst[191:176] := a[239:224] - a[255:240]
dst[207:192] := b[143:128] - b[159:144]
dst[223:208] := b[175:160] - b[191:176]
dst[239:224] := b[207:192] - b[223:208]
dst[255:240] := b[239:224] - b[255:240]
dst[MAX:256] := 0
	</description>
	<mnemonic base='vphsubw'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_hsub_epi32 / vphsubd -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_hsub_epi32'>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Horizontally subtract adjacent pairs of 32-bit integers in "a" and "b", and pack the signed 32-bit results in "dst".</description>
	<description code='true'>
dst[31:0] := a[31:0] - a[63:32]
dst[63:32] := a[95:64] - a[127:96]
dst[95:64] := b[31:0] - b[63:32]
dst[127:96] := b[95:64] - b[127:96]
dst[159:128] := a[159:128] - a[191:160]
dst[191:160] := a[223:192] - a[255:224]
dst[223:192] := b[159:128] - b[191:160]
dst[255:224] := b[223:192] - b[255:224]
dst[MAX:256] := 0
	</description>
	<mnemonic base='vphsubd'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_hsubs_epi16 / vphsubsw -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_hsubs_epi16'>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Horizontally subtract adjacent pairs of 16-bit integers in "a" and "b" using saturation, and pack the signed 16-bit results in "dst".</description>
	<description code='true'>
dst[15:0]= Saturate_To_Int16(a[15:0] - a[31:16])
dst[31:16] = Saturate_To_Int16(a[47:32] - a[63:48])
dst[47:32] = Saturate_To_Int16(a[79:64] - a[95:80])
dst[63:48] = Saturate_To_Int16(a[111:96] - a[127:112])
dst[79:64] = Saturate_To_Int16(b[15:0] - b[31:16])
dst[95:80] = Saturate_To_Int16(b[47:32] - b[63:48])
dst[111:96] = Saturate_To_Int16(b[79:64] - b[95:80])
dst[127:112] = Saturate_To_Int16(b[111:96] - b[127:112])
dst[143:128]= Saturate_To_Int16(a[143:128] - a[159:144])
dst[159:144] = Saturate_To_Int16(a[175:160] - a[191:176])
dst[175:160] = Saturate_To_Int16(a[207:192] - a[223:208])
dst[191:176] = Saturate_To_Int16(a[239:224] - a[255:240])
dst[207:192] = Saturate_To_Int16(b[143:128] - b[159:144])
dst[223:208] = Saturate_To_Int16(b[175:160] - b[191:176])
dst[239:224] = Saturate_To_Int16(b[207:192] - b[223:208])
dst[255:240] = Saturate_To_Int16(b[239:224] - b[255:240])
dst[MAX:256] := 0
	</description>
	<mnemonic base='vphsubsw'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm_i32gather_pd / vgatherdpd -->
<intrinsic tech='AVX2' rettype='__m128d' name='_mm_i32gather_pd'>
	<CPUID>AVX2</CPUID>
	<category>Load</category>
	<parameter varname='base_addr' type='double const*'/>
	<parameter varname='vindex' type='__m128i'/>
	<parameter varname='scale' type='const int'/>
	<description>
	Gather double-precision (64-bit) floating-point elements from memory using 32-bit indices. 64-bit elements are loaded from addresses starting at "base_addr" and offset by each 32-bit element in "vindex" (each index is scaled by the factor in "scale"). Gathered elements are merged into "dst". "scale" should be 1, 2, 4 or 8.
	</description>
	<description code='true'>
FOR j := 0 to 1
	i := j*64
	m := j*32
	dst[i+63:i] := MEM[base_addr + SignExtend(vindex[m+31:m])*scale]
ENDFOR
dst[MAX:128] := 0
	</description>
	<mnemonic base='vgatherdpd'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_i32gather_pd / vgatherdpd -->
<intrinsic tech='AVX2' rettype='__m256d' name='_mm256_i32gather_pd'>
	<CPUID>AVX2</CPUID>
	<category>Load</category>
	<parameter varname='base_addr' type='double const*'/>
	<parameter varname='vindex' type='__m128i'/>
	<parameter varname='scale' type='const int'/>
	<description>
	Gather double-precision (64-bit) floating-point elements from memory using 32-bit indices. 64-bit elements are loaded from addresses starting at "base_addr" and offset by each 32-bit element in "vindex" (each index is scaled by the factor in "scale"). Gathered elements are merged into "dst". "scale" should be 1, 2, 4 or 8.
	</description>
	<description code='true'>
FOR j := 0 to 3
	i := j*64
	m := j*32
	dst[i+63:i] := MEM[base_addr + SignExtend(vindex[m+31:m])*scale]
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vgatherdpd'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm_i32gather_ps / vgatherdps -->
<intrinsic tech='AVX2' rettype='__m128' name='_mm_i32gather_ps'>
	<CPUID>AVX2</CPUID>
	<category>Load</category>
	<parameter varname='base_addr' type='float const*'/>
	<parameter varname='vindex' type='__m128i'/>
	<parameter varname='scale' type='const inst'/>
	<description>Gather single-precision (32-bit) floating-point elements from memory using 32-bit indices. 32-bit elements are loaded from addresses starting at "base_addr" and offset by each 32-bit element in "vindex" (each index is scaled by the factor in "scale"). Gathered elements are merged into "dst". "scale" should be 1, 2, 4 or 8.</description>
	<description code='true'>
FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := MEM[base_addr + SignExtend(vindex[i+31:i])*scale]
ENDFOR
dst[MAX:128] := 0
	</description>
	<mnemonic base='vgatherdps'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_i32gather_ps / vgatherdps -->
<intrinsic tech='AVX2' rettype='__m256' name='_mm256_i32gather_ps'>
	<CPUID>AVX2</CPUID>
	<category>Load</category>
	<parameter varname='base_addr' type='float const*'/>
	<parameter varname='vindex' type='__m256i'/>
	<parameter varname='scale' type='const int'/>
	<description>Gather single-precision (32-bit) floating-point elements from memory using 32-bit indices. 32-bit elements are loaded from addresses starting at "base_addr" and offset by each 32-bit element in "vindex" (each index is scaled by the factor in "scale"). Gathered elements are merged into "dst". "scale" should be 1, 2, 4 or 8.</description>
	<description code='true'>
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := MEM[base_addr + SignExtend(vindex[i+31:i])*scale]
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vgatherdps'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm_i32gather_epi32 / vpgatherdd -->
<intrinsic tech='AVX2' rettype='__m128i' name='_mm_i32gather_epi32'>
	<CPUID>AVX2</CPUID>
	<category>Load</category>
	<parameter varname='base_addr' type='int const*'/>
	<parameter varname='vindex' type='__m128i'/>
	<parameter varname='scale' type='const int'/>
	<description>
	Gather 32-bit integers from memory using 32-bit indices. 32-bit elements are loaded from addresses starting at "base_addr" and offset by each 32-bit element in "vindex" (each index is scaled by the factor in "scale"). Gathered elements are merged into "dst". "scale" should be 1, 2, 4 or 8.
	</description>
	<description code='true'>
FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := MEM[base_addr + SignExtend(vindex[i+31:i])*scale]
ENDFOR
dst[MAX:128] := 0
	</description>
	<mnemonic base='vpgatherdd'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_i32gather_epi32 / vpgatherdd -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_i32gather_epi32'>
	<CPUID>AVX2</CPUID>
	<category>Load</category>
	<parameter varname='base_addr' type='int const*'/>
	<parameter varname='vindex' type='__m256i'/>
	<parameter varname='scale' type='const int'/>
	<description>
	Gather 32-bit integers from memory using 32-bit indices. 32-bit elements are loaded from addresses starting at "base_addr" and offset by each 32-bit element in "vindex" (each index is scaled by the factor in "scale"). Gathered elements are merged into "dst". "scale" should be 1, 2, 4 or 8.
	</description>
	<description code='true'>
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := MEM[base_addr + SignExtend(vindex[i+31:i])*scale]
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpgatherdd'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm_i32gather_epi64 / vpgatherdq -->
<intrinsic tech='AVX2' rettype='__m128i' name='_mm_i32gather_epi64'>
	<CPUID>AVX2</CPUID>
	<category>Load</category>
	<parameter varname='base_addr' type='int const*'/>
	<parameter varname='vindex' type='__m128i'/>
	<parameter varname='scale' type='const int'/>
	<description>Gather 64-bit integers from memory using 32-bit indices. 64-bit elements are loaded from addresses starting at "base_addr" and offset by each 32-bit element in "vindex" (each index is scaled by the factor in "scale"). Gathered elements are merged into "dst". "scale" should be 1, 2, 4 or 8.
	</description>
	<description code='true'>
FOR j := 0 to 1
	i := j*64
	m := j*32
	dst[i+63:i] := MEM[base_addr + SignExtend(vindex[m+31:m])*scale]
ENDFOR
dst[MAX:128] := 0
	</description>
	<mnemonic base='vpgatherdq'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_i32gather_epi64 / vpgatherdq -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_i32gather_epi64'>
	<CPUID>AVX2</CPUID>
	<category>Load</category>
	<parameter varname='base_addr' type='int const*'/>
	<parameter varname='vindex' type='__m256i'/>
	<parameter varname='scale' type='const int'/>
	<description>Gather 64-bit integers from memory using 32-bit indices. 64-bit elements are loaded from addresses starting at "base_addr" and offset by each 32-bit element in "vindex" (each index is scaled by the factor in "scale"). Gathered elements are merged into "dst". "scale" should be 1, 2, 4 or 8.
	</description>
	<description code='true'>
FOR j := 0 to 3
	i := j*64
	m := j*32
	dst[i+63:i] := MEM[base_addr + SignExtend(vindex[m+31:m])*scale]
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpgatherdq'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm_i64gather_pd / vgatherqpd -->
<intrinsic tech='AVX2' rettype='__m128d' name='_mm_i64gather_pd'>
	<CPUID>AVX2</CPUID>
	<category>Load</category>
	<parameter varname='base_addr' type='double const*'/>
	<parameter varname='vindex' type='__m128i'/>
	<parameter varname='scale' type='const int'/>
	<description>
	Gather double-precision (64-bit) floating-point elements from memory using 64-bit indices. 64-bit elements are loaded from addresses starting at "base_addr" and offset by each 64-bit element in "vindex" (each index is scaled by the factor in "scale"). Gathered elements are merged into "dst". "scale" should be 1, 2, 4 or 8.
	</description>
	<description code='true'>
FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := MEM[base_addr + SignExtend(vindex[i+63:i])*scale]
ENDFOR
dst[MAX:128] := 0
	</description>
	<mnemonic base='vgatherqpd'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_i64gather_pd / vgatherqpd -->
<intrinsic tech='AVX2' rettype='__m256d' name='_mm256_i64gather_pd'>
	<CPUID>AVX2</CPUID>
	<category>Load</category>
	<parameter varname='base_addr' type='double const*'/>
	<parameter varname='vindex' type='__m256i'/>
	<parameter varname='scale' type='const int'/>
	<description>
	Gather double-precision (64-bit) floating-point elements from memory using 64-bit indices. 64-bit elements are loaded from addresses starting at "base_addr" and offset by each 64-bit element in "vindex" (each index is scaled by the factor in "scale"). Gathered elements are merged into "dst". "scale" should be 1, 2, 4 or 8.
	</description>
	<description code='true'>
FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := MEM[base_addr + SignExtend(vindex[i+63:i])*scale]
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vgatherqpd'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm_i64gather_ps / vgatherqps -->
<intrinsic tech='AVX2' rettype='__m128' name='_mm_i64gather_ps'>
	<CPUID>AVX2</CPUID>
	<category>Load</category>
	<parameter varname='base_addr' type='float const*'/>
	<parameter varname='vindex' type='__m128i'/>
	<parameter varname='scale' type='const int'/>
	<description>
	Gather single-precision (32-bit) floating-point elements from memory using 64-bit indices. 32-bit elements are loaded from addresses starting at "base_addr" and offset by each 64-bit element in "vindex" (each index is scaled by the factor in "scale"). Gathered elements are merged into "dst". "scale" should be 1, 2, 4 or 8.
	</description>
	<description code='true'>
FOR j := 0 to 1
	i := j*32
	m := j*64
	dst[i+31:i] := MEM[base_addr + SignExtend(vindex[i+63:i])*scale]
ENDFOR
dst[MAX:64] := 0
	</description>
	<mnemonic base='vgatherqps'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_i64gather_ps / vgatherqps -->
<intrinsic tech='AVX2' rettype='__m128' name='_mm256_i64gather_ps'>
	<CPUID>AVX2</CPUID>
	<category>Load</category>
	<parameter varname='base_addr' type='float const*'/>
	<parameter varname='vindex' type='__m256i'/>
	<parameter varname='scale' type='const int'/>
	<description>
	Gather single-precision (32-bit) floating-point elements from memory using 64-bit indices. 32-bit elements are loaded from addresses starting at "base_addr" and offset by each 64-bit element in "vindex" (each index is scaled by the factor in "scale"). Gathered elements are merged into "dst". "scale" should be 1, 2, 4 or 8.
	</description>
	<description code='true'>
FOR j := 0 to 3
	i := j*32
	m := j*64
	dst[i+31:i] := MEM[base_addr + SignExtend(vindex[i+63:i])*scale]
ENDFOR
dst[MAX:128] := 0
	</description>
	<mnemonic base='vgatherqps'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm_i64gather_epi32 / vpgatherqd -->
<intrinsic tech='AVX2' rettype='__m128i' name='_mm_i64gather_epi32'>
	<CPUID>AVX2</CPUID>
	<category>Load</category>
	<parameter varname='base_addr' type='int const*'/>
	<parameter varname='vindex' type='__m128i'/>
	<parameter varname='scale' type='const int'/>
	<description>Gather 32-bit integers from memory using 64-bit indices. 32-bit elements are loaded from addresses starting at "base_addr" and offset by each 64-bit element in "vindex" (each index is scaled by the factor in "scale"). Gathered elements are merged into "dst". "scale" should be 1, 2, 4 or 8.
	</description>
	<description code='true'>
FOR j := 0 to 1
	i := j*32
	m := j*64
	dst[i+31:i] := MEM[base_addr + SignExtend(vindex[i+63:i])*scale]
ENDFOR
dst[MAX:64] := 0
	</description>
	<mnemonic base='vpgatherqd'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_i64gather_epi32 / vpgatherqd -->
<intrinsic tech='AVX2' rettype='__m128i' name='_mm256_i64gather_epi32'>
	<CPUID>AVX2</CPUID>
	<category>Load</category>
	<parameter varname='base_addr' type='int const*'/>
	<parameter varname='vindex' type='__m256i'/>
	<parameter varname='scale' type='const int'/>
	<description>Gather 32-bit integers from memory using 64-bit indices. 32-bit elements are loaded from addresses starting at "base_addr" and offset by each 64-bit element in "vindex" (each index is scaled by the factor in "scale"). Gathered elements are merged into "dst". "scale" should be 1, 2, 4 or 8.
	</description>
	<description code='true'>
FOR j := 0 to 3
	i := j*32
	m := j*64
	dst[i+31:i] := MEM[base_addr + SignExtend(vindex[i+63:i])*scale]
ENDFOR
dst[MAX:128] := 0
	</description>
	<mnemonic base='vpgatherqd'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm_i64gather_epi64 / vpgatherqq -->
<intrinsic tech='AVX2' rettype='__m128i' name='_mm_i64gather_epi64'>
	<CPUID>AVX2</CPUID>
	<category>Load</category>
	<parameter varname='base_addr' type='int const*'/>
	<parameter varname='vindex' type='__m128i'/>
	<parameter varname='scale' type='const int'/>
	<description>Gather 64-bit integers from memory using 64-bit indices. 64-bit elements are loaded from addresses starting at "base_addr" and offset by each 64-bit element in "vindex" (each index is scaled by the factor in "scale"). Gathered elements are merged into "dst". "scale" should be 1, 2, 4 or 8.
	</description>
	<description code='true'>
FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := MEM[base_addr + SignExtend(vindex[i+63:i])*scale]
ENDFOR
dst[MAX:128] := 0
	</description>
	<mnemonic base='vpgatherqq'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_i64gather_epi64 / vpgatherqq -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_i64gather_epi64'>
	<CPUID>AVX2</CPUID>
	<category>Load</category>
	<parameter varname='base_addr' type='int const*'/>
	<parameter varname='vindex' type='__m256i'/>
	<parameter varname='scale' type='const int'/>
	<description>Gather 64-bit integers from memory using 64-bit indices. 64-bit elements are loaded from addresses starting at "base_addr" and offset by each 64-bit element in "vindex" (each index is scaled by the factor in "scale"). Gathered elements are merged into "dst". "scale" should be 1, 2, 4 or 8.
	</description>
	<description code='true'>
FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := MEM[base_addr + SignExtend(vindex[i+63:i])*scale]
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpgatherqq'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_inserti128_si256 / vinserti128 -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_inserti128_si256'>
	<CPUID>AVX2</CPUID>
	<category>Miscellaneous</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m128i'/>
	<parameter varname='imm' type='int'/>
	<description>Copy "a" to "dst", then insert 128 bits (composed of integer data) from "b" into "dst" at the location specified by "imm".</description>
	<description code='true'>
dst[255:0] := a[255:0]
CASE (imm[1:0]) of
	0: dst[127:0] := b[127:0]
	1: dst[255:128] := b[127:0]
ESAC
dst[MAX:256] := 0
	</description>
	<mnemonic base='vinserti128'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_madd_epi16 / vpmaddwd -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_madd_epi16'>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Multiply packed 16-bit integers in "a" and "b", producing intermediate 32-bit integers. Horizontally add adjacent pairs of intermediate 32-bit integers, and pack the saturated results in "dst".
	</description>
	<description code='true'>
FOR j := 0 to 7
	i := j*32
	st[i+31:i] := Saturate_To_Int32( a[i+31:i+16]*b[i+31:i+16] + a[i+15:i]*b[i+15:i] )
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpmaddwd'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_maddubs_epi16 / vpmaddubsw -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_maddubs_epi16'>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Vertically multiply each unsigned 8-bit integer from "a" with the corresponding signed 8-bit integer from "b", producing intermediate signed 16-bit integers. Horizontally add adjacent pairs of intermediate signed 16-bit integers, and pack the saturated results in "dst".
	</description>
	<description code='true'>
FOR j := 0 to 15
	i := j*16
	dst[i+15:i] := Saturate_To_Int16( a[i+15:i+8]*b[i+15:i+8] + a[i+7:i]*b[i+7:i] )
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpmaddubsw'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm_mask_i32gather_pd / vgatherdpd -->
<intrinsic tech='AVX2' rettype='__m128d' name='_mm_mask_i32gather_pd'>
	<CPUID>AVX2</CPUID>
	<category>Load</category>
	<parameter varname='src' type='__m128d'/>
	<parameter varname='base_addr' type='double const*'/>
	<parameter varname='vindex' type='__m128i'/>
	<parameter varname='mask' type='__m128d'/>
	<parameter varname='scale' type='const int'/>
	<description>
	Gather double-precision (64-bit) floating-point elements from memory using 32-bit indices. 64-bit elements are loaded from addresses starting at "base_addr" and offset by each 32-bit element in "vindex" (each index is scaled by the factor in "scale"). Gathered elements are merged into "dst" using "mask" (elements are copied from "src" when the highest bit is not set in the corresponding element). "scale" should be 1, 2, 4 or 8.
	</description>
	<description code='true'>
FOR j := 0 to 1
	i := j*64
	m := j*32
	IF mask[i+63]
		dst[i+63:i] := MEM[base_addr + SignExtend(vindex[m+31:m])*scale]
		mask[i+63] := 0
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
mask[MAX:128] := 0
dst[MAX:128] := 0
	</description>
	<mnemonic base='vgatherdpd'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_mask_i32gather_pd / vgatherdpd -->
<intrinsic tech='AVX2' rettype='__m256d' name='_mm256_mask_i32gather_pd'>
	<CPUID>AVX2</CPUID>
	<category>Load</category>
	<parameter varname='src' type='__m256d'/>
	<parameter varname='base_addr' type='double const*'/>
	<parameter varname='vindex' type='__m256i'/>
	<parameter varname='mask' type='__m256d'/>
	<parameter varname='scale' type='const int'/>	
	<description>
	Gather double-precision (64-bit) floating-point elements from memory using 32-bit indices. 64-bit elements are loaded from addresses starting at "base_addr" and offset by each 32-bit element in "vindex" (each index is scaled by the factor in "scale"). Gathered elements are merged into "dst" using "mask" (elements are copied from "src" when the highest bit is not set in the corresponding element). "scale" should be 1, 2, 4 or 8.
	</description>
	<description code='true'>
FOR j := 0 to 3
	i := j*64
	m := j*32
	IF mask[i+63]
		dst[i+63:i] := MEM[base_addr + SignExtend(vindex[m+31:m])*scale]
		mask[i+63] := 0
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
mask[MAX:256] := 0
dst[MAX:256] := 0
	</description>
	<mnemonic base='vgatherdpd'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm_mask_i32gather_ps / vgatherdps -->
<intrinsic tech='AVX2' rettype='__m128' name='_mm_mask_i32gather_ps'>
	<CPUID>AVX2</CPUID>
	<category>Load</category>
	<parameter varname='src' type='__m128'/>
	<parameter varname='base_addr' type='float const*'/>
	<parameter varname='vindex' type='__m128i'/>
	<parameter varname='mask' type='__m128'/>
	<parameter varname='scale' type='const int'/>
	<description>
	Gather single-precision (32-bit) floating-point elements from memory using 32-bit indices. 32-bit elements are loaded from addresses starting at "base_addr" and offset by each 32-bit element in "vindex" (each index is scaled by the factor in "scale"). Gathered elements are merged into "dst" using "mask" (elements are copied from "src" when the highest bit is not set in the corresponding element). "scale" should be 1, 2, 4 or 8.
	</description>
	<description code='true'>
FOR j := 0 to 3
	i := j*32
	IF mask[i+31]
		dst[i+31:i] := MEM[base_addr + SignExtend(vindex[i+31:i])*scale]
		mask[i+31] := 0
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
mask[MAX:128] := 0
dst[MAX:128] := 0
	</description>
	<mnemonic base='vgatherdps'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_mask_i32gather_ps / vgatherdps -->
<intrinsic tech='AVX2' rettype='__m256' name='_mm256_mask_i32gather_ps'>
	<CPUID>AVX2</CPUID>
	<category>Load</category>
	<parameter varname='src' type='__m256'/>
	<parameter varname='base_addr' type='float const*'/>
	<parameter varname='vindex' type='__m256i'/>
	<parameter varname='mask' type='__m256'/>
	<parameter varname='scale' type='const int'/>
	<description>
	Gather single-precision (32-bit) floating-point elements from memory using 32-bit indices. 32-bit elements are loaded from addresses starting at "base_addr" and offset by each 32-bit element in "vindex" (each index is scaled by the factor in "scale"). Gathered elements are merged into "dst" using "mask" (elements are copied from "src" when the highest bit is not set in the corresponding element). "scale" should be 1, 2, 4 or 8.
	</description>
	<description code='true'>
FOR j := 0 to 7
	i := j*32
	IF mask[i+31]
		dst[i+31:i] := MEM[base_addr + SignExtend(vindex[i+31:i])*scale]
		mask[i+31] := 0
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
mask[MAX:256] := 0
dst[MAX:256] := 0
	</description>
	<mnemonic base='vgatherdps'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm_mask_i32gather_epi32 / vpgatherdd -->
<intrinsic tech='AVX2' rettype='__m128i' name='_mm_mask_i32gather_epi32'>
	<CPUID>AVX2</CPUID>
	<category>Load</category>
	<parameter varname='src' type='__m128i'/>
	<parameter varname='base_addr' type='int const*'/>
	<parameter varname='vindex' type='__m128i'/>
	<parameter varname='mask' type='__m128i'/>
	<parameter varname='scale' type='const int'/>
	<description>
	Gather 32-bit integers from memory using 32-bit indices. 32-bit elements are loaded from addresses starting at "base_addr" and offset by each 32-bit element in "vindex" (each index is scaled by the factor in "scale"). Gathered elements are merged into "dst" using "mask" (elements are copied from "src" when the highest bit is not set in the corresponding element). "scale" should be 1, 2, 4 or 8.
	</description>
	<description code='true'>
FOR j := 0 to 3
	i := j*32
	IF mask[i+31]
		dst[i+31:i] := MEM[base_addr + SignExtend(vindex[i+31:i])*scale]
		mask[i+31] := 0
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
mask[MAX:128] := 0
dst[MAX:128] := 0
	</description>
	<mnemonic base='vpgatherdd'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_mask_i32gather_epi32 / vpgatherdd -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_mask_i32gather_epi32'>
	<CPUID>AVX2</CPUID>
	<category>Load</category>
	<parameter varname='src' type='__m256i'/>
	<parameter varname='base_addr' type='int const*'/>
	<parameter varname='vindex' type='__m256i'/>
	<parameter varname='mask' type='__m256i'/>
	<parameter varname='scale' type='const int'/>
	<description>
	Gather 32-bit integers from memory using 32-bit indices. 32-bit elements are loaded from addresses starting at "base_addr" and offset by each 32-bit element in "vindex" (each index is scaled by the factor in "scale"). Gathered elements are merged into "dst" using "mask" (elements are copied from "src" when the highest bit is not set in the corresponding element). "scale" should be 1, 2, 4 or 8.
	</description>
	<description code='true'>
FOR j := 0 to 7
	i := j*32
	IF mask[i+31]
		dst[i+31:i] := MEM[base_addr + SignExtend(vindex[i+31:i])*scale]
		mask[i+31] := 0
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
mask[MAX:256] := 0
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpgatherdd'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm_mask_i32gather_epi64 / vpgatherdq -->
<intrinsic tech='AVX2' rettype='__m128i' name='_mm_mask_i32gather_epi64'>
	<CPUID>AVX2</CPUID>
	<category>Load</category>
	<parameter varname='src' type='__m128i'/>
	<parameter varname='base_addr' type='int const*'/>
	<parameter varname='vindex' type='__m128i'/>
	<parameter varname='mask' type='__m128i'/>
	<parameter varname='scale' type='const int'/>
	<description>
	Gather 64-bit integers from memory using 32-bit indices. 64-bit elements are loaded from addresses starting at "base_addr" and offset by each 32-bit element in "vindex" (each index is scaled by the factor in "scale"). Gathered elements are merged into "dst" using "mask" (elements are copied from "src" when the highest bit is not set in the corresponding element). "scale" should be 1, 2, 4 or 8.
	</description>
	<description code='true'>
FOR j := 0 to 1
	i := j*64
	m := j*32
	IF mask[i+63]
		dst[i+63:i] := MEM[base_addr + SignExtend(vindex[m+31:m])*scale]
		mask[i+63] := 0
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
mask[MAX:128] := 0
dst[MAX:128] := 0
	</description>
	<mnemonic base='vpgatherdq'/>
	<header>immintrin.h</header>
</intrinsic>	


<!-- _mm256_mask_i32gather_epi64 / vpgatherdq -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_mask_i32gather_epi64'>
	<CPUID>AVX2</CPUID>
	<category>Load</category>
	<parameter varname='src' type='__m256i'/>
	<parameter varname='base_addr' type='int const*'/>
	<parameter varname='vindex' type='__m256i'/>
	<parameter varname='mask' type='__m256i'/>
	<parameter varname='scale' type='const int'/>
	<description>
	Gather 64-bit integers from memory using 32-bit indices. 64-bit elements are loaded from addresses starting at "base_addr" and offset by each 32-bit element in "vindex" (each index is scaled by the factor in "scale"). Gathered elements are merged into "dst" using "mask" (elements are copied from "src" when the highest bit is not set in the corresponding element). "scale" should be 1, 2, 4 or 8.
	</description>
	<description code='true'>
FOR j := 0 to 3
	i := j*64
	m := j*32
	IF mask[i+63]
		dst[i+63:i] := MEM[base_addr + SignExtend(vindex[m+31:m])*scale]
		mask[i+63] := 0
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
mask[MAX:256] := 0
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpgatherdq'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm_mask_i64gather_pd / vgatherqpd -->
<intrinsic tech='AVX2' rettype='__m128d' name='_mm_mask_i64gather_pd'>
	<CPUID>AVX2</CPUID>
	<category>Load</category>
	<parameter varname='src' type='__m128d'/>
	<parameter varname='base_addr' type='double const*'/>
	<parameter varname='vindex' type='__m128i'/>
	<parameter varname='mask' type='__m128d'/>
	<parameter varname='scale' type='const int'/>
	<description>
	Gather double-precision (64-bit) floating-point elements from memory using 64-bit indices. 64-bit elements are loaded from addresses starting at "base_addr" and offset by each 64-bit element in "vindex" (each index is scaled by the factor in "scale"). Gathered elements are merged into "dst" using "mask" (elements are copied from "src" when the highest bit is not set in the corresponding element). "scale" should be 1, 2, 4 or 8.
	</description>
	<description code='true'>
FOR j := 0 to 1
	i := j*64
	IF mask[i+63]
		dst[i+63:i] := MEM[base_addr + SignExtend(vindex[i+63:i])*scale]
		mask[i+63] := 0
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
mask[MAX:128] := 0
dst[MAX:128] := 0
	</description>
	<mnemonic base='vgatherqpd'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_mask_i64gather_pd / vgatherqpd -->
<intrinsic tech='AVX2' rettype='__m256d' name='_mm256_mask_i64gather_pd'>
	<CPUID>AVX2</CPUID>
	<category>Load</category>
	<parameter varname='src' type='__m256d'/>
	<parameter varname='base_addr' type='double const*'/>
	<parameter varname='vindex' type='__m256i'/>
	<parameter varname='mask' type='__m256d'/>
	<parameter varname='scale' type='const int'/>
	<description>
	Gather double-precision (64-bit) floating-point elements from memory using 64-bit indices. 64-bit elements are loaded from addresses starting at "base_addr" and offset by each 64-bit element in "vindex" (each index is scaled by the factor in "scale"). Gathered elements are merged into "dst" using "mask" (elements are copied from "src" when the highest bit is not set in the corresponding element). "scale" should be 1, 2, 4 or 8.
	</description>
	<description code='true'>
FOR j := 0 to 3
	i := j*64
	IF mask[i+63]
		dst[i+63:i] := MEM[base_addr + SignExtend(vindex[i+63:i])*scale]
		mask[i+63] := 0
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
mask[MAX:256] := 0
dst[MAX:256] := 0
	</description>
	<mnemonic base='vgatherqpd'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm_mask_i64gather_ps / vgatherqps -->
<intrinsic tech='AVX2' rettype='__m128' name='_mm_mask_i64gather_ps'>
	<CPUID>AVX2</CPUID>
	<category>Load</category>
	<parameter varname='src' type='__m128'/>
	<parameter varname='base_addr' type='float const*'/>
	<parameter varname='vindex' type='__m128i'/>
	<parameter varname='mask' type='__m128'/>
	<parameter varname='scale' type='const int'/>
	<description>
	Gather single-precision (32-bit) floating-point elements from memory using 64-bit indices. 32-bit elements are loaded from addresses starting at "base_addr" and offset by each 64-bit element in "vindex" (each index is scaled by the factor in "scale"). Gathered elements are merged into "dst" using "mask" (elements are copied from "src" when the highest bit is not set in the corresponding element). "scale" should be 1, 2, 4 or 8.
	</description>
	<description code='true'>
FOR j := 0 to 1
	i := j*32
	m := j*64
	IF mask[i+31]
		dst[i+31:i] := MEM[base_addr + SignExtend(vindex[i+63:i])*scale]
		mask[i+31] := 0
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
mask[MAX:64] := 0
dst[MAX:64] := 0
	</description>
	<mnemonic base='vgatherqps'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_mask_i64gather_ps / vgatherqps -->
<intrinsic tech='AVX2' rettype='__m128' name='_mm256_mask_i64gather_ps'>
	<CPUID>AVX2</CPUID>
	<category>Load</category>
	<parameter varname='src' type='__m128'/>
	<parameter varname='base_addr' type='float const*'/>
	<parameter varname='vindex' type='__m256i'/>
	<parameter varname='mask' type='__m128'/>
	<parameter varname='scale' type='const int'/>
	<description>
	Gather single-precision (32-bit) floating-point elements from memory using 64-bit indices. 32-bit elements are loaded from addresses starting at "base_addr" and offset by each 64-bit element in "vindex" (each index is scaled by the factor in "scale"). Gathered elements are merged into "dst" using "mask" (elements are copied from "src" when the highest bit is not set in the corresponding element). "scale" should be 1, 2, 4 or 8.
	</description>
	<description code='true'>
FOR j := 0 to 3
	i := j*32
	m := j*64
	IF mask[i+31]
		dst[i+31:i] := MEM[base_addr + SignExtend(vindex[i+63:i])*scale]
		mask[i+31] := 0
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
mask[MAX:128] := 0
dst[MAX:128] := 0
	</description>
	<mnemonic base='vgatherqps'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm_mask_i64gather_epi32 / vpgatherqd -->
<intrinsic tech='AVX2' rettype='__m128i' name='_mm_mask_i64gather_epi32'>
	<CPUID>AVX2</CPUID>
	<category>Load</category>
	<parameter varname='src' type='__m128i'/>
	<parameter varname='base_addr' type='int const*'/>
	<parameter varname='vindex' type='__m128i'/>
	<parameter varname='mask' type='__m128i'/>
	<parameter varname='scale' type='const int'/>
	<description>
	Gather 32-bit integers from memory using 64-bit indices. 32-bit elements are loaded from addresses starting at "base_addr" and offset by each 64-bit element in "vindex" (each index is scaled by the factor in "scale"). Gathered elements are merged into "dst" using "mask" (elements are copied from "src" when the highest bit is not set in the corresponding element). "scale" should be 1, 2, 4 or 8.
	</description>
	<description code='true'>
FOR j := 0 to 1
	i := j*32
	m := j*64
	IF mask[i+31]
		dst[i+31:i] := MEM[base_addr + SignExtend(vindex[i+63:i])*scale]
		mask[i+31] := 0
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
mask[MAX:64] := 0
dst[MAX:64] := 0
	</description>
	<mnemonic base='vpgatherqd'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_mask_i64gather_epi32 / vpgatherqd -->
<intrinsic tech='AVX2' rettype='__m128i' name='_mm256_mask_i64gather_epi32'>
	<CPUID>AVX2</CPUID>
	<category>Load</category>
	<parameter varname='src' type='__m128i'/>
	<parameter varname='base_addr' type='int const*'/>
	<parameter varname='vindex' type='__m256i'/>
	<parameter varname='mask' type='__m128i'/>
	<parameter varname='scale' type='const int'/>
	<description>
	Gather 32-bit integers from memory using 64-bit indices. 32-bit elements are loaded from addresses starting at "base_addr" and offset by each 64-bit element in "vindex" (each index is scaled by the factor in "scale"). Gathered elements are merged into "dst" using "mask" (elements are copied from "src" when the highest bit is not set in the corresponding element). "scale" should be 1, 2, 4 or 8.
	</description>
	<description code='true'>
FOR j := 0 to 3
	i := j*32
	m := j*64
	IF mask[i+31]
		dst[i+31:i] := MEM[base_addr + SignExtend(vindex[i+63:i])*scale]
		mask[i+31] := 0
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
mask[MAX:128] := 0
dst[MAX:128] := 0
	</description>
	<mnemonic base='vpgatherqd'/>
	<header>immintrin.h</header>
</intrinsic>	


<!-- _mm_mask_i64gather_epi64 / vpgatherqq -->
<intrinsic tech='AVX2' rettype='__m128i' name='_mm_mask_i64gather_epi64'>
	<CPUID>AVX2</CPUID>
	<category>Load</category>
	<parameter varname='src' type='__m128i'/>
	<parameter varname='base_addr' type='int const*'/>
	<parameter varname='vindex' type='__m128i'/>
	<parameter varname='mask' type='__m128i'/>
	<parameter varname='scale' type='const int'/>
	<description>
	Gather 64-bit integers from memory using 64-bit indices. 64-bit elements are loaded from addresses starting at "base_addr" and offset by each 64-bit element in "vindex" (each index is scaled by the factor in "scale"). Gathered elements are merged into "dst" using "mask" (elements are copied from "src" when the highest bit is not set in the corresponding element). "scale" should be 1, 2, 4 or 8.
	</description>
	<description code='true'>
FOR j := 0 to 1
	i := j*64
	IF mask[i+63]
		dst[i+63:i] := MEM[base_addr + SignExtend(vindex[i+63:i])*scale]
		mask[i+63] := 0
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
mask[MAX:128] := 0
dst[MAX:128] := 0
	</description>
	<mnemonic base='vpgatherqq'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_mask_i64gather_epi64 / vpgatherqq -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_mask_i64gather_epi64'>
	<CPUID>AVX2</CPUID>
	<category>Load</category>
	<parameter varname='src' type='__m256i'/>
	<parameter varname='base_addr' type='int const*'/>
	<parameter varname='vindex' type='__m256i'/>
	<parameter varname='mask' type='__m256i'/>
	<parameter varname='scale' type='const int'/>
	<description>
	Gather 64-bit integers from memory using 64-bit indices. 64-bit elements are loaded from addresses starting at "base_addr" and offset by each 64-bit element in "vindex" (each index is scaled by the factor in "scale"). Gathered elements are merged into "dst" using "mask" (elements are copied from "src" when the highest bit is not set in the corresponding element). "scale" should be 1, 2, 4 or 8.
	</description>
	<description code='true'>
FOR j := 0 to 3
	i := j*64
	IF mask[i+63]
		dst[i+63:i] := MEM[base_addr + SignExtend(vindex[i+63:i])*scale]
		mask[i+63] := 0
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
mask[MAX:256] := 0
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpgatherqq'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm_maskload_epi32 / vpmaskmovd -->
<intrinsic tech='AVX2' rettype='__m128i' name='_mm_maskload_epi32'>
	<CPUID>AVX2</CPUID>
	<category>Load</category>
	<parameter varname='mem_addr' type='int const*'/>
	<parameter varname='mask' type='__m128i'/>
	<description>Load packed 32-bit integers from memory into "dst" using "mask" (elements are zeroed out when the highest bit is not set in the corresponding element).
	"mem_addr" must be aligned on a 16-byte boundary or a general-protection exception will be generated.</description>
	<description code='true'>
FOR j := 0 to 3
	i := j*32
	IF mask[i+31]
		dst[i+31:i] := MEM[mem_addr+i+31:mem_addr+i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</description>
	<mnemonic base='vpmaskmovd'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_maskload_epi32 / vpmaskmovd -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_maskload_epi32'>
	<CPUID>AVX2</CPUID>
	<category>Load</category>
	<parameter varname='mem_addr' type='const int*'/>
	<parameter varname='mask' type='__m256i'/>		
	<description>Load packed 32-bit integers from memory into "dst" using "mask" (elements are zeroed out when the highest bit is not set in the corresponding element).
	"mem_addr" must be aligned on a 32-byte boundary or a general-protection exception will be generated.</description>
	<description code='true'>
FOR j := 0 to 7
	i := j*32
	IF mask[i+31]
		dst[i+31:i] := MEM[mem_addr+i+31:mem_addr+i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpmaskmovd'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm_maskload_epi64 / vpmaskmovq -->
<intrinsic tech='AVX2' rettype='__m128i' name='_mm_maskload_epi64'>
	<CPUID>AVX2</CPUID>
	<category>Load</category>
	<parameter varname='mem_addr' type='int const*'/>
	<parameter varname='mask' type='__m128i'/>
	<description>Load packed 64-bit integers from memory into "dst" using "mask" (elements are zeroed out when the highest bit is not set in the corresponding element).
	"mem_addr" must be aligned on a 16-byte boundary or a general-protection exception will be generated.</description>
	<description code='true'>
FOR j := 0 to 1
	i := j*64
	IF mask[i+63]
		dst[i+63:i] := MEM[mem_addr+i+63:mem_addr+i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</description>
	<mnemonic base='vpmaskmovq'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_maskload_epi64 / vpmaskmovq -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_maskload_epi64'>
	<CPUID>AVX2</CPUID>
	<category>Load</category>
	<parameter varname='mem_addr' type='__int64 const*'/>
	<parameter varname='mask' type='__m256i'/>
	<description>Load packed 64-bit integers from memory into "dst" using "mask" (elements are zeroed out when the highest bit is not set in the corresponding element).
	"mem_addr" must be aligned on a 32-byte boundary or a general-protection exception will be generated.</description>
	<description code='true'>
FOR j := 0 to 3
	i := j*64
	IF mask[i+63]
		dst[i+63:i] := MEM[mem_addr+i+63:mem_addr+i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpmaskmovq'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm_maskstore_epi32 / vpmaskmovd -->
<intrinsic tech='AVX2' rettype='void' name='_mm_maskstore_epi32'>
	<CPUID>AVX2</CPUID>
	<category>Store</category>
	<parameter varname='mem_addr' type='int*'/>
	<parameter varname='mask' type='__m128i'/>
	<parameter varname='a' type='__m128'/>
	<description>Store packed 32-bit integers from "a" into memory using "mask" (elements are not stored when the highest bit is not set in the corresponding element).
	"mem_addr" must be aligned on a 16-byte boundary or a general-protection exception will be generated.
	</description>
	<description code='true'>
FOR j := 0 to 3
	i := j*32
	IF mask[i+31]
		MEM[mem_addr+i+31:mem_addr+i] := a[i+31:i]
	FI
ENDFOR
	</description>
	<mnemonic base='vpmaskmovd'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_maskstore_epi32 / vpmaskmovd -->
<intrinsic tech='AVX2' rettype='void' name='_mm256_maskstore_epi32'>
	<CPUID>AVX2</CPUID>
	<category>Store</category>
	<parameter varname='mem_addr' type='int*'/>
	<parameter varname='mask' type='__m256i'/>	
	<parameter varname='a' type='__m256i'/>		
	<description>Store packed 32-bit integers from "a" into memory using "mask" (elements are not stored when the highest bit is not set in the corresponding element).
	"mem_addr" must be aligned on a 32-byte boundary or a general-protection exception will be generated.
	</description>
	<description code='true'>
FOR j := 0 to 7
	i := j*32
	IF mask[i+31]
		MEM[mem_addr+i+31:mem_addr+i] := a[i+31:i]
	FI
ENDFOR
	</description>
	<mnemonic base='vpmaskmovd'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm_maskstore_epi64 / vpmaskmovq -->
<intrinsic tech='AVX2' rettype='void' name='_mm_maskstore_epi64'>
	<CPUID>AVX2</CPUID>
	<category>Store</category>
	<parameter varname='mem_addr' type='__int64*'/>
	<parameter varname='mask' type='__m128i'/>
	<parameter varname='a' type='__m128i'/>
	<description>Store packed 64-bit integers from "a" into memory using "mask" (elements are not stored when the highest bit is not set in the corresponding element).
	"mem_addr" must be aligned on a 16-byte boundary or a general-protection exception will be generated.
	</description>
	<description code='true'>
FOR j := 0 to 1
	i := j*64
	IF mask[i+63]
		MEM[mem_addr+i+63:mem_addr+i] := a[i+63:i]
	FI
ENDFOR
	</description>
	<mnemonic base='vpmaskmovq'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_maskstore_epi64 / vpmaskmovq -->
<intrinsic tech='AVX2' rettype='void' name='_mm256_maskstore_epi64'>
	<CPUID>AVX2</CPUID>
	<category>Store</category>
	<parameter varname='mem_addr' type='__int64*'/>
	<parameter varname='mask' type='__m256i'/>
	<parameter varname='a' type='__m256d'/>
	<description>Store packed 64-bit integers from "a" into memory using "mask" (elements are not stored when the highest bit is not set in the corresponding element).
	"mem_addr" must be aligned on a 32-byte boundary or a general-protection exception will be generated.
	</description>
	<description code='true'>
FOR j := 0 to 3
	i := j*64
	IF mask[i+63]
		MEM[mem_addr+i+63:mem_addr+i] := a[i+63:i]
	FI
ENDFOR
	</description>
	<mnemonic base='vpmaskmovq'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_max_epi8 / vpmaxsb -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_max_epi8'>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Compare packed 8-bit integers in "a" and "b", and store packed maximum values in "dst". </description>
	<description code='true'>
FOR j := 0 to 31
	i := j*8
	IF a[i+7:i] &gt; b[i+7:i]
		dst[i+7:i] := a[i+7:i]
	ELSE
		dst[i+7:i] := b[i+7:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpmaxsb'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_max_epi16 / vpmaxsw -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_max_epi16'>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Compare packed 16-bit integers in "a" and "b", and store packed maximum values in "dst".
	</description>
	<description code='true'>
FOR j := 0 to 15
	i := j*16
	IF a[i+15:i] &gt; b[i+15:i]
		dst[i+15:i] := a[i+15:i]
	ELSE
		dst[i+15:i] := b[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpmaxsw'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_max_epi32 / vpmaxsd -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_max_epi32'>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Compare packed 32-bit integers in "a" and "b", and store packed maximum values in "dst".</description>
	<description code='true'>
FOR j := 0 to 7
	i := j*32
	IF a[i+31:i] &gt; b[i+31:i]
		dst[i+31:i] := a[i+31:i]
	ELSE
		dst[i+31:i] := b[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpmaxsd'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_max_epu8 / vpmaxub -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_max_epu8'>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Compare packed unsigned 8-bit integers in "a" and "b", and store packed maximum values in "dst".
	</description>
	<description code='true'>
FOR j := 0 to 31
	i := j*8
	IF a[i+7:i] &gt; b[i+7:i]
		dst[i+7:i] := a[i+7:i]
	ELSE
		dst[i+7:i] := b[i+7:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpmaxub'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_max_epu16 / vpmaxuw -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_max_epu16'>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Compare packed unsigned 16-bit integers in "a" and "b", and store packed maximum values in "dst".
	</description>
	<description code='true'>
FOR j := 0 to 15
	i := j*16
	IF a[i+15:i] &gt; b[i+15:i]
		dst[i+15:i] := a[i+15:i]
	ELSE
		dst[i+15:i] := b[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpmaxuw'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_max_epu32 / vpmaxud -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_max_epu32'>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Compare packed unsigned 32-bit integers in "a" and "b", and store packed maximum values in "dst".</description>
	<description code='true'>
FOR j := 0 to 7
	i := j*32
	IF a[i+31:i] &gt; b[i+31:i]
		dst[i+31:i] := a[i+31:i]
	ELSE
		dst[i+31:i] := b[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpmaxud'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_min_epi8 / vpminsb -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_min_epi8'>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Compare packed 8-bit integers in "a" and "b", and store packed minimum values in "dst".
	</description>
	<description code='true'>
FOR j := 0 to 31
	i := j*8
	IF a[i+7:i] &lt; b[i+7:i]
		dst[i+7:i] := a[i+7:i]
	ELSE
		dst[i+7:i] := b[i+7:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpminsb'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_min_epi16 / vpminsw -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_min_epi16'>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Compare packed 16-bit integers in "a" and "b", and store packed minimum values in "dst".
	</description>
	<description code='true'>
FOR j := 0 to 15
	i := j*16
	IF a[i+15:i] &lt; b[i+15:i]
		dst[i+15:i] := a[i+15:i]
	ELSE
		dst[i+15:i] := b[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpminsw'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_min_epi32 / vpminsd -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_min_epi32'>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Compare packed 32-bit integers in "a" and "b", and store packed minimum values in "dst".
	</description>
	<description code='true'>
FOR j := 0 to 7
	i := j*32
	IF a[i+31:i] &lt; b[i+31:i]
		dst[i+31:i] := a[i+31:i]
	ELSE
		dst[i+31:i] := b[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpminsd'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_min_epu8 / vpminub -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_min_epu8'>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Compare packed unsigned 8-bit integers in "a" and "b", and store packed minimum values in "dst".
	</description>
	<description code='true'>
FOR j := 0 to 31
	i := j*8
	IF a[i+7:i] &lt; b[i+7:i]
		dst[i+7:i] := a[i+7:i]
	ELSE
		dst[i+7:i] := b[i+7:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpminub'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_min_epu16 / vpminuw -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_min_epu16'>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Compare packed unsigned 16-bit integers in "a" and "b", and store packed minimum values in "dst".
	</description>
	<description code='true'>
FOR j := 0 to 15
	i := j*16
	IF a[i+15:i] &lt; b[i+15:i]
		dst[i+15:i] := a[i+15:i]
	ELSE
		dst[i+15:i] := b[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpminuw'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_min_epu32 / vpminud -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_min_epu32'>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Compare packed unsigned 32-bit integers in "a" and "b", and store packed minimum values in "dst".
	</description>
	<description code='true'>
FOR j := 0 to 7
	i := j*32
	IF a[i+31:i] &lt; b[i+31:i]
		dst[i+31:i] := a[i+31:i]
	ELSE
		dst[i+31:i] := b[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpminud'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_movemask_epi8 / vpmovmskb -->
<intrinsic tech='AVX2' rettype='int' name='_mm256_movemask_epi8'>
	<CPUID>AVX2</CPUID>
	<category>Miscellaneous</category>
	<parameter varname='a' type='__m256i'/>
	<description>
Create mask from the most significant bit of each 8-bit element in "a", and store the result in "dst".
	</description>
	<description code='true'>
FOR j := 0 to 31
	i := j*8
	dst[j] := a[i+7]
ENDFOR
	</description>
	<mnemonic base='vpmovmskb'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_mpsadbw_epu8 / vmpsadbw -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_mpsadbw_epu8'>
	<CPUID>AVX2</CPUID>	<category>Application-Targeted</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<parameter varname='imm' type='const int'/>
	<description>Compute the sum of absolute differences (SADs) of quadruplets of unsigned 8-bit integers in "a" compared to those in "b", and store the 16-bit results in "dst".
	Eight SADs are performed for each 128-bit lane using one quadruplet from "b" and eight quadruplets from "a". One quadruplet is selected from "b" starting at on the offset specified in "imm". Eight quadruplets are formed from sequential 8-bit integers selected from "a" starting at the offset specified in "imm".</description>
	<description code='true'>
MPSADBW(a[127:0], b[127:0], imm[2:0]) {
	i := imm[2]*32
	b_offset := imm[1:0]*32
	FOR j := 0 to 7
		i := j*8
		k := a_offset+i
		l := b_offset
		tmp[i+15:i] := ABS(a[k+7:k] - b[l+7:l]) +
					   ABS(a[k+15:k+8] - b[l+15:l+8]) +
					   ABS(a[k+23:k+16] - b[l+23:l+16]) +
					   ABS(a[k+31:k+24] - b[l+31:l+24])
	ENDFOR
	RETURN tmp[127:0]
}

dst[127:0] := MPSADBW(a[127:0], b[127:0], imm[2:0])
dst[255:128] := MPSADBW(a[255:128], b[255:128], imm[5:3])
dst[MAX:256] := 0
	</description>
	<mnemonic base='vmpsadbw'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_mul_epi32 / vpmuldq -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_mul_epi32'>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Multiply the low 32-bit integers from each packed 64-bit element in "a" and "b", and store the signed 64-bit results in "dst". </description>
	<description code='true'>
FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := a[i+31:i] * b[i+31:i]
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpmuldq'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_mul_epu32 / vpmuludq -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_mul_epu32'>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Multiply the low unsigned 32-bit integers from each packed 64-bit element in "a" and "b", and store the unsigned 64-bit results in "dst". </description>
	<description code='true'>
FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := a[i+31:i] * b[i+31:i]
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpmuludq'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_mulhi_epi16 / vpmulhw -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_mulhi_epi16'>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Multiply the packed 16-bit integers in "a" and "b", producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in "dst". </description>
	<description code='true'>
FOR j := 0 to 15
	i := j*16
	tmp[31:0] := a[i+15:i] * b[i+15:i]
	dst[i+15:i] := tmp[31:16]
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpmulhw'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_mulhi_epu16 / vpmulhuw -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_mulhi_epu16'>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Multiply the packed unsigned 16-bit integers in "a" and "b", producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in "dst". </description>
	<description code='true'>
FOR j := 0 to 15
	i := j*16
	tmp[31:0] := a[i+15:i] * b[i+15:i]
	dst[i+15:i] := tmp[31:16]
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpmulhuw'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_mulhrs_epi16 / vpmulhrsw -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_mulhrs_epi16'>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Multiply packed 16-bit integers in "a" and "b", producing intermediate signed 32-bit integers. Truncate each intermediate integer to the 18 most significant bits, round by adding 1, and store bits [16:1] to "dst". </description>
	<description code='true'>
FOR j := 0 to 15
	i := j*16
	tmp[31:0] := ((a[i+15:i] * b[i+15:i]) &gt;&gt; 14) + 1
	dst[i+15:i] := tmp[16:1]
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpmulhrsw'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_mullo_epi16 / vpmullw -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_mullo_epi16'>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Multiply the packed 16-bit integers in "a" and "b", producing intermediate 32-bit integers, and store the low 16 bits of the intermediate integers in "dst". </description>
	<description code='true'>
FOR j := 0 to 15
	i := j*16
	tmp[31:0] := a[i+15:i] * b[i+15:i]
	dst[i+15:i] := tmp[15:0]
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpmullw'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_mullo_epi32 / vpmulld -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_mullo_epi32'>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Multiply the packed 32-bit integers in "a" and "b", producing intermediate 64-bit integers, and store the low 32 bits of the intermediate integers in "dst". </description>
	<description code='true'>
FOR j := 0 to 7
	i := j*32
	tmp[63:0] := a[i+31:i] * b[i+31:i]
	dst[i+31:i] := tmp[31:0]
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpmulld'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_or_si256 / vpor -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_or_si256'>
	<CPUID>AVX2</CPUID>
	<category>Logical</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Compute the bitwise OR of 256 bits (representing integer data) in "a" and "b", and store the result in "dst".</description>
	<description code='true'>
dst[255:0] := (a[255:0] OR b[255:0])
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpor'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_packs_epi16 / vpacksswb -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_packs_epi16'>
	<CPUID>AVX2</CPUID>
	<category>Miscellaneous</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Convert packed 16-bit integers from "a" and "b" to packed 8-bit integers using signed saturation, and store the results in "dst".
	</description>
	<description code='true'>
dst[7:0] := Saturate_Int16_To_Int8 (a[15:0])
dst[15:8] := Saturate_Int16_To_Int8 (a[31:16])
dst[23:16] := Saturate_Int16_To_Int8 (a[47:32])
dst[31:24] := Saturate_Int16_To_Int8 (a[63:48])
dst[39:32] := Saturate_Int16_To_Int8 (a[79:64])
dst[47:40] := Saturate_Int16_To_Int8 (a[95:80])
dst[55:48] := Saturate_Int16_To_Int8 (a[111:96])
dst[63:56] := Saturate_Int16_To_Int8 (a[127:112])
dst[71:64] := Saturate_Int16_To_Int8 (b[15:0])
dst[79:72] := Saturate_Int16_To_Int8 (b[31:16])
dst[87:80] := Saturate_Int16_To_Int8 (b[47:32])
dst[95:88] := Saturate_Int16_To_Int8 (b[63:48])
dst[103:96] := Saturate_Int16_To_Int8 (b[79:64])
dst[111:104] := Saturate_Int16_To_Int8 (b[95:80])
dst[119:112] := Saturate_Int16_To_Int8 (b[111:96])
dst[127:120] := Saturate_Int16_To_Int8 (b[127:112])
dst[135:128] := Saturate_Int16_To_Int8 (a[143:128])
dst[143:136] := Saturate_Int16_To_Int8 (a[159:144])
dst[151:144] := Saturate_Int16_To_Int8 (a[175:160])
dst[159:152] := Saturate_Int16_To_Int8 (a[191:176])
dst[167:160] := Saturate_Int16_To_Int8 (a[207:192])
dst[175:168] := Saturate_Int16_To_Int8 (a[223:208])
dst[183:176] := Saturate_Int16_To_Int8 (a[239:224])
dst[191:184] := Saturate_Int16_To_Int8 (a[255:240])
dst[199:192] := Saturate_Int16_To_Int8 (b[143:128])
dst[207:200] := Saturate_Int16_To_Int8 (b[159:144])
dst[215:208] := Saturate_Int16_To_Int8 (b[175:160])
dst[223:216] := Saturate_Int16_To_Int8 (b[191:176])
dst[231:224] := Saturate_Int16_To_Int8 (b[207:192])
dst[239:232] := Saturate_Int16_To_Int8 (b[223:208])
dst[247:240] := Saturate_Int16_To_Int8 (b[239:224])
dst[255:248] := Saturate_Int16_To_Int8 (b[255:240])
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpacksswb'/>
	<header>immintrin.h</header>
</intrinsic>	


<!-- _mm256_packs_epi32 / vpackssdw -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_packs_epi32'>
	<CPUID>AVX2</CPUID>
	<category>Miscellaneous</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Convert packed 32-bit integers from "a" and "b" to packed 16-bit integers using signed saturation, and store the results in "dst".</description>
	<description code='true'>
dst[15:0] := Saturate_Int32_To_Int16 (a[31:0])
dst[31:16] := Saturate_Int32_To_Int16 (a[63:32])
dst[47:32] := Saturate_Int32_To_Int16 (a[95:64])
dst[63:48] := Saturate_Int32_To_Int16 (a[127:96])
dst[79:64] := Saturate_Int32_To_Int16 (b[31:0])
dst[95:80] := Saturate_Int32_To_Int16 (b[63:32])
dst[111:96] := Saturate_Int32_To_Int16 (b[95:64])
dst[127:112] := Saturate_Int32_To_Int16 (b[127:96])
dst[143:128] := Saturate_Int32_To_Int16 (a[159:128])
dst[159:144] := Saturate_Int32_To_Int16 (a[191:160])
dst[175:160] := Saturate_Int32_To_Int16 (a[223:192])
dst[191:176] := Saturate_Int32_To_Int16 (a[255:224])
dst[207:192] := Saturate_Int32_To_Int16 (b[159:128])
dst[223:208] := Saturate_Int32_To_Int16 (b[191:160])
dst[239:224] := Saturate_Int32_To_Int16 (b[223:192])
dst[255:240] := Saturate_Int32_To_Int16 (b[255:224])
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpackssdw'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_packus_epi16 / vpackuswb -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_packus_epi16'>
	<CPUID>AVX2</CPUID>
	<category>Miscellaneous</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Convert packed 16-bit integers from "a" and "b" to packed 8-bit integers using unsigned saturation, and store the results in "dst".</description>
	<description code='true'>
dst[7:0] := Saturate_Int16_To_UnsignedInt8 (a[15:0])
dst[15:8] := Saturate_Int16_To_UnsignedInt8 (a[31:16])
dst[23:16] := Saturate_Int16_To_UnsignedInt8 (a[47:32])
dst[31:24] := Saturate_Int16_To_UnsignedInt8 (a[63:48])
dst[39:32] := Saturate_Int16_To_UnsignedInt8 (a[79:64])
dst[47:40] := Saturate_Int16_To_UnsignedInt8 (a[95:80])
dst[55:48] := Saturate_Int16_To_UnsignedInt8 (a[111:96])
dst[63:56] := Saturate_Int16_To_UnsignedInt8 (a[127:112])
dst[71:64] := Saturate_Int16_To_UnsignedInt8 (b[15:0])
dst[79:72] := Saturate_Int16_To_UnsignedInt8 (b[31:16])
dst[87:80] := Saturate_Int16_To_UnsignedInt8 (b[47:32])
dst[95:88] := Saturate_Int16_To_UnsignedInt8 (b[63:48])
dst[103:96] := Saturate_Int16_To_UnsignedInt8 (b[79:64])
dst[111:104] := Saturate_Int16_To_UnsignedInt8 (b[95:80])
dst[119:112] := Saturate_Int16_To_UnsignedInt8 (b[111:96])
dst[127:120] := Saturate_Int16_To_UnsignedInt8 (b[127:112])
dst[135:128] := Saturate_Int16_To_UnsignedInt8 (a[143:128])
dst[143:136] := Saturate_Int16_To_UnsignedInt8 (a[159:144])
dst[151:144] := Saturate_Int16_To_UnsignedInt8 (a[175:160])
dst[159:152] := Saturate_Int16_To_UnsignedInt8 (a[191:176])
dst[167:160] := Saturate_Int16_To_UnsignedInt8 (a[207:192])
dst[175:168] := Saturate_Int16_To_UnsignedInt8 (a[223:208])
dst[183:176] := Saturate_Int16_To_UnsignedInt8 (a[239:224])
dst[191:184] := Saturate_Int16_To_UnsignedInt8 (a[255:240])
dst[199:192] := Saturate_Int16_To_UnsignedInt8 (b[143:128])
dst[207:200] := Saturate_Int16_To_UnsignedInt8 (b[159:144])
dst[215:208] := Saturate_Int16_To_UnsignedInt8 (b[175:160])
dst[223:216] := Saturate_Int16_To_UnsignedInt8 (b[191:176])
dst[231:224] := Saturate_Int16_To_UnsignedInt8 (b[207:192])
dst[239:232] := Saturate_Int16_To_UnsignedInt8 (b[223:208])
dst[247:240] := Saturate_Int16_To_UnsignedInt8 (b[239:224])
dst[255:248] := Saturate_Int16_To_UnsignedInt8 (b[255:240])
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpackuswb'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_packus_epi32 / vpackusdw -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_packus_epi32'>
	<CPUID>AVX2</CPUID>
	<category>Miscellaneous</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Convert packed 32-bit integers from "a" and "b" to packed 16-bit integers using unsigned saturation, and store the results in "dst".</description>
	<description code='true'>
dst[15:0] := Saturate_Int32_To_UnsignedInt16 (a[31:0])
dst[31:16] := Saturate_Int32_To_UnsignedInt16 (a[63:32])
dst[47:32] := Saturate_Int32_To_UnsignedInt16 (a[95:64])
dst[63:48] := Saturate_Int32_To_UnsignedInt16 (a[127:96])
dst[79:64] := Saturate_Int32_To_UnsignedInt16 (b[31:0])
dst[95:80] := Saturate_Int32_To_UnsignedInt16 (b[63:32])
dst[111:96] := Saturate_Int32_To_UnsignedInt16 (b[95:64])
dst[127:112] := Saturate_Int32_To_UnsignedInt16 (b[127:96])
dst[143:128] := Saturate_Int32_To_UnsignedInt16 (a[159:128])
dst[159:144] := Saturate_Int32_To_UnsignedInt16 (a[191:160])
dst[175:160] := Saturate_Int32_To_UnsignedInt16 (a[223:192])
dst[191:176] := Saturate_Int32_To_UnsignedInt16 (a[255:224])
dst[207:192] := Saturate_Int32_To_UnsignedInt16 (b[159:128])
dst[223:208] := Saturate_Int32_To_UnsignedInt16 (b[191:160])
dst[239:224] := Saturate_Int32_To_UnsignedInt16 (b[223:192])
dst[255:240] := Saturate_Int32_To_UnsignedInt16 (b[255:224])
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpackusdw'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_permute2x128_si256 / vperm2i128 -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_permute2x128_si256'>
	<CPUID>AVX2</CPUID>
	<category>Miscellaneous</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<parameter varname='imm' type='int'/>
	<description>Shuffle 128-bits (composed of integer data) selected by "imm" from "a" and "b", and store the results in "dst". </description>
	<description code='true'>
SELECT4(src1, src2, control){
	CASE(control[1:0])
		0:	tmp[127:0] := src1[127:0]
		1:	tmp[127:0] := src1[255:128]
		2:	tmp[127:0] := src2[127:0]
		3: 	tmp[127:0] := src2[255:128]
	ESAC
	IF control[3]
		tmp[127:0] := 0
	ENDIF
	RETURN tmp[127:0]
}

dst[127:0] := SELECT4(a[255:0], b[255:0], imm[3:0])
dst[255:128] := SELECT4(b[255:0], b[255:0], imm[7:4])
dst[MAX:256] := 0
	</description>
	<mnemonic base='vperm2i128'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_permute4x64_epi64 / vpermq -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_permute4x64_epi64'>
	<CPUID>AVX2</CPUID>
	<category>Miscellaneous</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='imm' type='int'/>
	<description>Shuffle 64-bit integers in "a" across lanes using the control in "imm", and store the results in "dst".</description>
	<description code='true'>
SELECT4(src, control){
	CASE(control[1:0])
		0:	tmp[63:0] := src[63:0]
		1:	tmp[63:0] := src[127:64]
		2:	tmp[63:0] := src[191:128]
		3:	tmp[63:0] := src[255:192]
	ESAC
	RETURN tmp[63:0]
}

dst[63:0] := SELECT4(a[255:0], imm[1:0])
dst[127:64] := SELECT4(a[255:0], imm[3:2])
dst[191:128] := SELECT4(a[255:0], imm[5:4])
dst[255:192] := SELECT4(a[255:0], imm[7:6])
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpermq'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_permute4x64_pd / vpermpd -->
<intrinsic tech='AVX2' rettype='__m256d' name='_mm256_permute4x64_pd'>
	<CPUID>AVX2</CPUID>
	<category>Miscellaneous</category>
	<parameter varname='a' type='__m256d'/>
	<parameter varname='imm' type='int'/>
	<description>Shuffle double-precision (64-bit) floating-point elements in "a" across lanes using the control in "imm", and store the results in "dst".</description>
	<description code='true'>
SELECT4(src, control){
	CASE(control[1:0])
		0:	tmp[63:0] := src[63:0]
		1:	tmp[63:0] := src[127:64]
		2:	tmp[63:0] := src[191:128]
		3:	tmp[63:0] := src[255:192]
	ESAC
	RETURN tmp[63:0]
}

dst[63:0] := SELECT4(a[255:0], imm[1:0])
dst[127:64] := SELECT4(a[255:0], imm[3:2])
dst[191:128] := SELECT4(a[255:0], imm[5:4])
dst[255:192] := SELECT4(a[255:0], imm[7:6])
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpermpd'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_permutevar8x32_epi32 / vpermd -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_permutevar8x32_epi32'>
	<CPUID>AVX2</CPUID>
	<category>Miscellaneous</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='idx' type='__m256i'/>
	<description>Shuffle 32-bit integers in "a" across lanes using the corresponding index in "idx", and store the results in "dst".
	</description>
	<description code='true'>
FOR j := 0 to 7
	i := j*32
	id := idx[i+2:i]*32
	dst[i+31:i] := a[id+31:id]
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpermd'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_permutevar8x32_ps / vpermps -->
<intrinsic tech='AVX2' rettype='__m256' name='_mm256_permutevar8x32_ps'>
	<CPUID>AVX2</CPUID>
	<category>Miscellaneous</category>
	<parameter varname='a' type='__m256'/>
	<parameter varname='idx' type='__m256'/>
	<description>Shuffle single-precision (32-bit) floating-point elements in "a" across lanes using the corresponding index in "idx".</description>
	<description code='true'>
FOR j := 0 to 7
	i := j*32
	id := idx[i+2:i]*32
	dst[i+31:i] := a[id+31:id]
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpermps'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_sad_epu8 / vpsadbw -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_sad_epu8'>
	<CPUID>AVX2</CPUID>
	<category>Miscellaneous</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Compute the absolute differences of packed unsigned 8-bit integers in "a" and "b", then horizontally sum each consecutive 8 differences to produce four unsigned 16-bit integers, and pack these unsigned 16-bit integers in the low 16 bits of 64-bit elements in "dst".</description>
	<description code='true'>
FOR j := 0 to 31
	i := j*8
	tmp[i+7:i] := ABS(a[i+7:i] - b[i+7:i])
ENDFOR
FOR j := 0 to 4
	i := j*64
	dst[i+15:i] := tmp[i+7:i] + tmp[i+15:i+8] + tmp[i+23:i+16] + tmp[i+31:i+24] 
				 + tmp[i+39:i+32] + tmp[i+47:i+40] + tmp[i+55:i+48] + tmp[i+63:i+56]
	dst[i+63:i+16] := 0
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpsadbw'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_shuffle_epi32 / vpshufd -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_shuffle_epi32'>
	<CPUID>AVX2</CPUID>
	<category>Miscellaneous</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='imm' type='const int'/>
	<description>Shuffle 32-bit integers in "a" within 128-bit lanes using the control in "imm", and store the results in "dst".</description>
	<description code='true'>
SELECT4(src, control){
	CASE(control[1:0])
		0:	tmp[31:0] := src[31:0]
		1:	tmp[31:0] := src[63:32]
		2:	tmp[31:0] := src[95:64]
		3:	tmp[31:0] := src[127:96]
	ESAC
	RETURN tmp[31:0]
}

dst[31:0] := SELECT4(a[127:0], imm[1:0])
dst[63:32] := SELECT4(a[127:0], imm[3:2])
dst[95:64] := SELECT4(a[127:0], imm[5:4])
dst[127:96] := SELECT4(a[127:0], imm[7:6])
dst[159:128] := SELECT4(a[255:128], imm[1:0])
dst[191:160] := SELECT4(a[255:128], imm[3:2])
dst[223:192] := SELECT4(a[255:128], imm[5:4])
dst[255:224] := SELECT4(a[255:128], imm[7:6])
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpshufd'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_shuffle_epi8 / vpshufb -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_shuffle_epi8'>
	<CPUID>AVX2</CPUID>
	<category>Miscellaneous</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Shuffle packed 8-bit integers in "a" according to shuffle control mask in the corresponding 8-bit element of "b", and store the results in "dst".</description>
	<description code='true'>
FOR j := 0 to 31
	i := j*8
	IF b[i+7] == 1
		dst[i+7:i] := 0
	ELSE
		index[3:0] := b[i+3:i]
		dst[i+7:i] := a[index*8+7:index*8]
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpshufb'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_shufflehi_epi16 / vpshufhw -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_shufflehi_epi16'>
	<CPUID>AVX2</CPUID>
	<category>Miscellaneous</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='imm' type='const int'/>
	<description>Shuffle 16-bit integers in the high 64 bits of 128-bit lanes of "a" using the control in "imm". Store the results in the high 64 bits of 128-bit lanes of "dst", with the low 64 bits of 128-bit lanes being copied from from "a" to "dst".</description>
	<description code='true'>
dst[63:0] := a[63:0]
dst[79:64] := (a >> (imm[1:0] * 16))[79:64]
dst[95:80] := (a >> (imm[3:2] * 16))[79:64]
dst[111:96] := (a >> (imm[5:4] * 16))[79:64]
dst[127:112] := (a >> (imm[7:6] * 16))[79:64]
dst[191:128] := a[191:128]
dst[207:192] := (a >> (imm[1:0] * 16))[207:192]
dst[223:208] := (a >> (imm[3:2] * 16))[207:192]
dst[239:224] := (a >> (imm[5:4] * 16))[207:192]
dst[255:240] := (a >> (imm[7:6] * 16))[207:192]
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpshufhw'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_shufflelo_epi16 / vpshuflw -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_shufflelo_epi16'>
	<CPUID>AVX2</CPUID>
	<category>Miscellaneous</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='imm' type='const int'/>
	<description>Shuffle 16-bit integers in the low 64 bits of 128-bit lanes of "a" using the control in "imm". Store the results in the low 64 bits of 128-bit lanes of "dst", with the high 64 bits of 128-bit lanes being copied from from "a" to "dst".</description>
	<description code='true'>
dst[15:0] := (a >> (imm[1:0] * 16))[15:0]
dst[31:16] := (a >> (imm[3:2] * 16))[15:0]
dst[47:32] := (a >> (imm[5:4] * 16))[15:0]
dst[63:48] := (a >> (imm[7:6] * 16))[15:0]
dst[127:64] := a[127:64]
dst[143:128] := (a >> (imm[1:0] * 16))[143:128]
dst[159:144] := (a >> (imm[3:2] * 16))[143:128]
dst[175:160] := (a >> (imm[5:4] * 16))[143:128]
dst[191:176] := (a >> (imm[7:6] * 16))[143:128]
dst[255:192] := a[255:192]
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpshuflw'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_sign_epi8 / vpsignb -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_sign_epi8'>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Negate packed 8-bit integers in "a" when the corresponding signed 8-bit integer in "b" is negative, and store the results in "dst". Element in "dst" are zeroed out when the corresponding element in "b" is zero.</description>
	<description code='true'>
FOR j := 0 to 31
	i := j*8
	IF b[i+7:i] &lt; 0
		dst[i+7:i] := NEG(a[i+7:i])
	ELSE IF b[i+7:i] = 0
		dst[i+7:i] := 0
	ELSE
		dst[i+7:i] := a[i+7:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpsignb'/>
	<header>immintrin.h</header>
</intrinsic>	


<!-- _mm256_sign_epi16 / vpsignw -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_sign_epi16'>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Negate packed 16-bit integers in "a" when the corresponding signed 16-bit integer in "b" is negative, and store the results in "dst". Element in "dst" are zeroed out when the corresponding element in "b" is zero.</description>
	<description code='true'>
FOR j := 0 to 15
	i := j*16
	IF b[i+15:i] &lt; 0
		dst[i+15:i] := NEG(a[i+15:i])
	ELSE IF b[i+15:i] = 0
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := a[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpsignw'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_sign_epi32 / vpsignd -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_sign_epi32'>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Negate packed 32-bit integers in "a" when the corresponding signed 32-bit integer in "b" is negative, and store the results in "dst". Element in "dst" are zeroed out when the corresponding element in "b" is zero.</description>
	<description code='true'>
FOR j := 0 to 7
	i := j*32
	IF b[i+31:i] &lt; 0
		dst[i+31:i] := NEG(a[i+31:i])
	ELSE IF b[i+31:i] = 0
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := a[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpsignd'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_slli_si256 / vpslldq -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_slli_si256'>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='imm' type='int'/>
	<description>Shift 128-bit lanes in "a" left by "imm" bytes while shifting in zeros, and store the results in "dst".</description>
	<description code='true'>
dst[127:0] := a[127:0] &lt;&lt; (imm*8)
dst[255:128] := a[255:128] &lt;&lt; (imm*8)
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpslldq'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_bslli_epi128 / vpslldq -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_bslli_epi128'>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='imm' type='const int'/>
	<description>Shift 128-bit lanes in "a" left by "imm" bytes while shifting in zeros, and store the results in "dst".</description>
	<description code='true'>
dst[127:0] := a[127:0] &lt;&lt; (imm*8)
dst[255:128] := a[255:128] &lt;&lt; (imm*8)
dst[MAX:256] := 0
	</description>
	<mnemonic parameters='ymm, ymm' base='vpslldq'/>
  	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_sll_epi16 / vpsllw -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_sll_epi16'>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='count' type='__m128i'/>
	<description>Shift packed 16-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst". </description>
	<description code='true'>
FOR j := 0 to 15
	i := j*16
	IF count[63:0] &gt; 15
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := ZeroExtend(a[i+15:i] &lt;&lt; count[63:0])
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpsllw'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_slli_epi16 / vpsllw -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_slli_epi16'>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='imm' type='int'/>
	<description>Shift packed 16-bit integers in "a" left by "imm" while shifting in zeros, and store the results in "dst". </description>
	<description code='true'>
FOR j := 0 to 15
	i := j*16
	IF imm &gt; 15
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := ZeroExtend(a[i+15:i] &lt;&lt; imm)
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpsllw'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_sll_epi32 / vpslld -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_sll_epi32'>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='count' type='__m128i'/>
	<description>Shift packed 32-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst". </description>
	<description code='true'>
FOR j := 0 to 7
	i := j*32
	IF count[63:0] &gt; 31
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := ZeroExtend(a[i+31:i] &lt;&lt; count[63:0])
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpslld'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_slli_epi32 / vpslld -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_slli_epi32'>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='imm' type='int'/>
	<description>Shift packed 32-bit integers in "a" left by "imm" while shifting in zeros, and store the results in "dst".</description>
	<description code='true'>
FOR j := 0 to 7
	i := j*32
	IF imm &gt; 31
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := ZeroExtend(a[i+31:i] &lt;&lt; imm)
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpslld'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_sll_epi64 / vpsllq -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_sll_epi64'>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
		<parameter varname='a' type='__m256i'/>
	<parameter varname='count' type='__m128i'/>
	<description>Shift packed 64-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst". </description>
	<description code='true'>
FOR j := 0 to 3
	i := j*64
	IF count[63:0] &gt; 63
		dst[i+63:i] := 0
	ELSE
		dst[i+63:i] := ZeroExtend(a[i+63:i] &lt;&lt; count[63:0])
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpsllq'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_slli_epi64 / vpsllq -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_slli_epi64'>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='imm' type='int'/>
	<description>Shift packed 64-bit integers in "a" left by "imm" while shifting in zeros, and store the results in "dst". </description>
	<description code='true'>
FOR j := 0 to 3
	i := j*64
	IF imm &gt; 63
		dst[i+63:i] := 0
	ELSE
		dst[i+63:i] := ZeroExtend(a[i+63:i] &lt;&lt; imm)
	FI
ENDFOR
dst[MAX:256] := 0
	</description>	
	<mnemonic base='vpsllq'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm_sllv_epi32 / vpsllvd -->
<intrinsic tech='AVX2' rettype='__m128i' name='_mm_sllv_epi32'>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<parameter varname='a' type='__m128i'/>
	<parameter varname='count' type='__m128i'/>
	<description>Shift packed 32-bit integers in "a" left by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst". </description>
	<description code='true'>
FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := ZeroExtend(a[i+31:i] &lt;&lt; count[i+4:i])
ENDFOR
dst[MAX:128] := 0
	</description>
	<mnemonic base='vpsllvd'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_sllv_epi32 / vpsllvd -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_sllv_epi32'>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='count' type='__m256i'/>
	<description>Shift packed 32-bit integers in "a" left by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst". </description>
	<description code='true'>
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := ZeroExtend(a[i+31:i] &lt;&lt; count[i+4:i])
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpsllvd'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm_sllv_epi64 / vpsllvq -->
<intrinsic tech='AVX2' rettype='__m128i' name='_mm_sllv_epi64'>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<parameter varname='a' type='__m128i'/>
	<parameter varname='count' type='__m128i'/>
	<description>Shift packed 64-bit integers in "a" left by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst". </description>
	<description code='true'>
FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := ZeroExtend(a[i+63:i] &lt;&lt; count[i+5:i])	
ENDFOR
dst[MAX:128] := 0
	</description>
	<mnemonic base='vpsllvq'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_sllv_epi64 / vpsllvq -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_sllv_epi64'>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='count' type='__m256i'/>
	<description>Shift packed 64-bit integers in "a" left by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst". </description>
	<description code='true'>
FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := ZeroExtend(a[i+63:i] &lt;&lt; count[i+5:i])	
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpsllvq'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_sra_epi16 / vpsraw -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_sra_epi16'>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='count' type='__m128i'/>
	<description>Shift packed 16-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst". </description>
	<description code='true'>
FOR j := 0 to 15
	i := j*16
	IF count[63:0] &gt; 15
		dst[i+15:i] := SignBit
	ELSE
		dst[i+15:i] := SignExtend(a[i+15:i] &gt;&gt; count[63:0])
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpsraw'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_srai_epi16 / vpsraw -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_srai_epi16'>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='imm' type='int'/>
	<description>Shift packed 16-bit integers in "a" right by "imm" while shifting in sign bits, and store the results in "dst". </description>
	<description code='true'>
FOR j := 0 to 15
	i := j*16
	IF imm &gt; 15
		dst[i+15:i] := SignBit
	ELSE
		dst[i+15:i] := SignExtend(a[i+15:i] &gt;&gt; imm)
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpsraw'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_sra_epi32 / vpsrad -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_sra_epi32'>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='count' type='__m128i'/>
	<description>Shift packed 32-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst". </description>
	<description code='true'>
FOR j := 0 to 7
	i := j*32
	IF count[63:0] &gt; 31
		dst[i+31:i] := SignBit
	ELSE
		dst[i+31:i] := SignExtend(a[i+31:i] &gt;&gt; count[63:0])
	FI
ENDFOR
dst[MAX:256] := 0
	</description>	
	<mnemonic base='vpsrad'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_srai_epi32 / vpsrad -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_srai_epi32'>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='imm' type='int'/>
	<description>Shift packed 32-bit integers in "a" right by "imm" while shifting in sign bits, and store the results in "dst". </description>
	<description code='true'>
FOR j := 0 to 7
	i := j*32
	IF imm &gt; 31
		dst[i+31:i] := SignBit
	ELSE
		dst[i+31:i] := SignExtend(a[i+31:i] &gt;&gt; imm)
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpsrad'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm_srav_epi32 / vpsravd -->
<intrinsic tech='AVX2' rettype='__m128i' name='_mm_srav_epi32'>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<parameter varname='a' type='__m128i'/>
	<parameter varname='count' type='__m128i'/>
	<description>Shift packed 32-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in sign bits, and store the results in "dst". </description>
	<description code='true'>
FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := SignExtend(a[i+31:i] &gt;&gt; count[i+4:i])
ENDFOR
dst[MAX:128] := 0
	</description>
	<mnemonic base='vpsravd'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_srav_epi32 / vpsravd -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_srav_epi32'>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='count' type='__m256i'/>
	<description>Shift packed 32-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in sign bits, and store the results in "dst". </description>
	<description code='true'>
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := SignExtend(a[i+31:i] &gt;&gt; count[i+4:i])
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpsravd'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_srli_si256 / vpsrldq -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_srli_si256'>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='imm' type='int'/>
	<description>Shift 128-bit lanes in "a" right by "imm" bytes while shifting in zeros, and store the results in "dst".</description>
	<description code='true'>
dst[127:0] := a[127:0] &gt;&gt; (imm*8)
dst[255:128] := a[255:128] &gt;&gt; (imm*8)
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpsrldq'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_bsrli_epi128 / vpsrldq -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_bsrli_epi128'>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='imm' type='const int'/>
	<description>Shift 128-bit lanes in "a" right by "imm" bytes while shifting in zeros, and store the results in "dst".</description>
	<description code='true'>
dst[127:0] := a[127:0] &gt;&gt; (imm*8)
dst[255:128] := a[255:128] &gt;&gt; (imm*8)
dst[MAX:256] := 0
	</description>
	<mnemonic parameters='ymm, ymm' base='vpsrldq'/>
  	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_srl_epi16 / vpsrlw -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_srl_epi16'>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='count' type='__m128i'/>
	<description>Shift packed 16-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst". </description>
	<description code='true'>
FOR j := 0 to 15
	i := j*16
	IF count[63:0] &gt; 15
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := ZeroExtend(a[i+15:i] &gt;&gt; count[63:0])
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpsrlw'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_srli_epi16 / vpsrlw -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_srli_epi16'>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='imm' type='int'/>
	<description>Shift packed 16-bit integers in "a" right by "imm" while shifting in zeros, and store the results in "dst". </description>
	<description code='true'>
FOR j := 0 to 15
	i := j*16
	IF imm &gt; 15
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := ZeroExtend(a[i+15:i] &gt;&gt; imm)
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpsrlw'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_srl_epi32 / vpsrld -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_srl_epi32'>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='count' type='__m128i'/>
	<description>Shift packed 32-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst". </description>
	<description code='true'>
FOR j := 0 to 7
	i := j*32
	IF count[63:0] &gt; 31
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := ZeroExtend(a[i+31:i] &gt;&gt; count[63:0])
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpsrld'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_srli_epi32 / vpsrld -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_srli_epi32'>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='imm' type='int'/>
	<description>Shift packed 32-bit integers in "a" right by "imm" while shifting in zeros, and store the results in "dst".</description>
	<description code='true'>
FOR j := 0 to 7
	i := j*32
	IF imm &gt; 31
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := ZeroExtend(a[i+31:i] &gt;&gt; imm)
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpsrld'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_srl_epi64 / vpsrlq -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_srl_epi64'>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='count' type='__m128i'/>
	<description>Shift packed 64-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst". </description>
	<description code='true'>
FOR j := 0 to 3
	i := j*64
	IF count[63:0] &gt; 63
		dst[i+63:i] := 0
	ELSE
		dst[i+63:i] := ZeroExtend(a[i+63:i] &gt;&gt; count[63:0])
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpsrlq'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_srli_epi64 / vpsrlq -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_srli_epi64'>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='imm' type='int'/>
	<description>Shift packed 64-bit integers in "a" right by "imm" while shifting in zeros, and store the results in "dst". </description>
	<description code='true'>
FOR j := 0 to 3
	i := j*64
	IF imm &gt; 63
		dst[i+63:i] := 0
	ELSE
		dst[i+63:i] := ZeroExtend(a[i+63:i] &gt;&gt; imm)
	FI
ENDFOR
dst[MAX:256] := 0
	</description>	
	<mnemonic base='vpsrlq'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm_srlv_epi32 / vpsrlvd -->
<intrinsic tech='AVX2' rettype='__m128i' name='_mm_srlv_epi32'>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<parameter varname='a' type='__m128i'/>
	<parameter varname='count' type='__m128i'/>
	<description>Shift packed 32-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst". </description>
	<description code='true'>
FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := ZeroExtend(a[i+31:i] &gt;&gt; count[i+4:i])
ENDFOR
dst[MAX:128] := 0
	</description>
	<mnemonic base='vpsrlvd'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_srlv_epi32 / vpsrlvd -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_srlv_epi32'>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='count' type='__m256i'/>
	<description>Shift packed 32-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst". </description>
	<description code='true'>
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := ZeroExtend(a[i+31:i] &gt;&gt; count[i+4:i])
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpsrlvd'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm_srlv_epi64 / vpsrlvq -->
<intrinsic tech='AVX2' rettype='__m128i' name='_mm_srlv_epi64'>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<parameter varname='a' type='__m128i'/>
	<parameter varname='count' type='__m128i'/>
	<description>Shift packed 64-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst". </description>
	<description code='true'>
FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := ZeroExtend(a[i+63:i] &gt;&gt; count[i+5:i])	
ENDFOR
dst[MAX:128] := 0
	</description>
	<mnemonic base='vpsrlvq'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_srlv_epi64 / vpsrlvq -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_srlv_epi64'>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='count' type='__m256i'/>
	<description>Shift packed 64-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst". </description>
	<description code='true'>
FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := ZeroExtend(a[i+63:i] &gt;&gt; count[i+5:i])	
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpsrlvq'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_stream_load_si256 / vmovntdqa -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_stream_load_si256'>
	<CPUID>AVX2</CPUID>
	<category>Load</category>
	<parameter varname='mem_addr' type='__m256i*'/>
	<description>Load 256-bits of integer data from memory into "dst" using a non-temporal memory hint.
	"mem_addr" must be aligned on a 32-byte boundary or a general-protection exception will be generated.</description>
	<description code='true'>
dst[255:0] := MEM[mem_addr+255:mem_addr]
dst[MAX:256] := 0
	</description>
	<mnemonic base='vmovntdqa'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_sub_epi8 / vpsubb -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_sub_epi8'>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Subtract packed 8-bit integers in "b" from packed 8-bit integers in "a", and store the results in "dst".</description>
	<description code='true'>
FOR j := 0 to 31
	i := j*8
	dst[i+7:i] := a[i+7:i] - b[i+7:i]
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpsubb'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_sub_epi16 / vpsubw -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_sub_epi16'>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Subtract packed 16-bit integers in "b" from packed 16-bit integers in "a", and store the results in "dst".</description>
	<description code='true'>
FOR j := 0 to 15
	i := j*16
	dst[i+15:i] := a[i+15:i] - b[i+15:i]
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpsubw'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_sub_epi32 / vpsubd -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_sub_epi32'>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Subtract packed 32-bit integers in "b" from packed 32-bit integers in "a", and store the results in "dst".</description>
	<description code='true'>
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := a[i+31:i] - b[i+31:i]
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpsubd'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_sub_epi64 / vpsubq -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_sub_epi64'>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Subtract packed 64-bit integers in "b" from packed 64-bit integers in "a", and store the results in "dst".</description>
	<description code='true'>
FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := a[i+63:i] - b[i+63:i]
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpsubq'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_subs_epi8 / vpsubsb -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_subs_epi8'>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Subtract packed 8-bit integers in "b" from packed 8-bit integers in "a" using saturation, and store the results in "dst".</description>
	<description code='true'>
FOR j := 0 to 31
	i := j*8
	dst[i+7:i] := Saturate_To_Int8(a[i+7:i] - b[i+7:i])	
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpsubsb'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_subs_epi16 / vpsubsw -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_subs_epi16'>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Subtract packed 16-bit integers in "b" from packed 16-bit integers in "a" using saturation, and store the results in "dst".</description>
	<description code='true'>
FOR j := 0 to 15
	i := j*16
	dst[i+15:i] := Saturate_To_Int16(a[i+15:i] - b[i+15:i])
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpsubsw'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_subs_epu8 / vpsubusb -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_subs_epu8'>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Subtract packed unsigned 8-bit integers in "b" from packed unsigned 8-bit integers in "a" using saturation, and store the results in "dst".</description>
	<description code='true'>
FOR j := 0 to 31
	i := j*8
	dst[i+7:i] := Saturate_To_UnsignedInt8(a[i+7:i] - b[i+7:i])	
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpsubusb'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_subs_epu16 / vpsubusw -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_subs_epu16'>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Subtract packed unsigned 16-bit integers in "b" from packed unsigned 16-bit integers in "a" using saturation, and store the results in "dst".</description>
	<description code='true'>
FOR j := 0 to 15
	i := j*16
	dst[i+15:i] := Saturate_To_UnsignedInt16(a[i+15:i] - b[i+15:i])	
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpsubusw'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_xor_si256 / vpxor -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_xor_si256'>
	<CPUID>AVX2</CPUID>
	<category>Logical</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Compute the bitwise OR of 256 bits (representing integer data) in "a" and "b", and store the result in "dst".</description>
	<description code='true'>
dst[255:0] := (a[255:0] XOR b[255:0])
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpxor'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_unpackhi_epi8 / vpunpckhbw -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_unpackhi_epi8'>
	<CPUID>AVX2</CPUID>
	<category>Miscellaneous</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Unpack and interleave 8-bit integers from the high half of each 128-bit lane in "a" and "b", and store the results in "dst". </description>
	<description code='true'>
INTERLEAVE_HIGH_BYTES(src1[127:0], src2[127:0]){
	dst[7:0] := src1[71:64] 
	dst[15:8] := src2[71:64] 
	dst[23:16] := src1[79:72] 
	dst[31:24] := src2[79:72] 
	dst[39:32] := src1[87:80] 
	dst[47:40] := src2[87:80] 
	dst[55:48] := src1[95:88] 
	dst[63:56] := src2[95:88] 
	dst[71:64] := src1[103:96] 
	dst[79:72] := src2[103:96] 
	dst[87:80] := src1[111:104] 
	dst[95:88] := src2[111:104] 
	dst[103:96] := src1[119:112] 
	dst[111:104] := src2[119:112] 
	dst[119:112] := src1[127:120] 
	dst[127:120] := src2[127:120] 
	RETURN dst[127:0]
}	
	
dst[127:0] := INTERLEAVE_HIGH_BYTES(a[127:0], b[127:0])
dst[255:128] := INTERLEAVE_HIGH_BYTES(a[255:128], b[255:128])
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpunpckhbw'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_unpackhi_epi16 / vpunpckhwd -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_unpackhi_epi16'>
	<CPUID>AVX2</CPUID>
	<category>Miscellaneous</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Unpack and interleave 16-bit integers from the high half of each 128-bit lane in "a" and "b", and store the results in "dst". </description>
	<description code='true'>
INTERLEAVE_HIGH_WORDS(src1[127:0], src2[127:0]){
	dst[15:0] := src1[79:64]
	dst[31:16] := src2[79:64] 
	dst[47:32] := src1[95:80] 
	dst[63:48] := src2[95:80] 
	dst[79:64] := src1[111:96] 
	dst[95:80] := src2[111:96] 
	dst[111:96] := src1[127:112] 
	dst[127:112] := src2[127:112] 
	RETURN dst[127:0]
}

dst[127:0] := INTERLEAVE_HIGH_WORDS(a[127:0], b[127:0])
dst[255:128] := INTERLEAVE_HIGH_WORDS(a[255:128], b[255:128])
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpunpckhwd'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_unpackhi_epi32 / vpunpckhdq -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_unpackhi_epi32'>
	<CPUID>AVX2</CPUID>
	<category>Miscellaneous</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Unpack and interleave 32-bit integers from the high half of each 128-bit lane in "a" and "b", and store the results in "dst". </description>
	<description code='true'>
INTERLEAVE_HIGH_DWORDS(src1[127:0], src2[127:0]){
	dst[31:0] := src1[95:64] 
	dst[63:32] := src2[95:64] 
	dst[95:64] := src1[127:96] 
	dst[127:96] := src2[127:96] 
	RETURN dst[127:0]
}	
	
dst[127:0] := INTERLEAVE_HIGH_DWORDS(a[127:0], b[127:0])
dst[255:128] := INTERLEAVE_HIGH_DWORDS(a[255:128], b[255:128])
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpunpckhdq'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_unpackhi_epi64 / vpunpckhqdq -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_unpackhi_epi64'>
	<CPUID>AVX2</CPUID>
	<category>Miscellaneous</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Unpack and interleave 64-bit integers from the high half of each 128-bit lane in "a" and "b", and store the results in "dst". </description>
	<description code='true'>
INTERLEAVE_HIGH_QWORDS(src1[127:0], src2[127:0]){
	dst[63:0] := src1[127:64] 
	dst[127:64] := src2[127:64] 
	RETURN dst[127:0]
}	
	
dst[127:0] := INTERLEAVE_HIGH_QWORDS(a[127:0], b[127:0])
dst[255:128] := INTERLEAVE_HIGH_QWORDS(a[255:128], b[255:128])
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpunpckhqdq'/>
	<header>immintrin.h</header>
</intrinsic>	


<!-- _mm256_unpacklo_epi8 / vpunpcklbw -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_unpacklo_epi8'>
	<CPUID>AVX2</CPUID>
	<category>Miscellaneous</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Unpack and interleave 8-bit integers from the low half of each 128-bit lane in "a" and "b", and store the results in "dst". </description>
	<description code='true'>
INTERLEAVE_BYTES(src1[127:0], src2[127:0]){
	dst[7:0] := src1[7:0] 
	dst[15:8] := src2[7:0] 
	dst[23:16] := src1[15:8] 
	dst[31:24] := src2[15:8] 
	dst[39:32] := src1[23:16] 
	dst[47:40] := src2[23:16] 
	dst[55:48] := src1[31:24] 
	dst[63:56] := src2[31:24] 
	dst[71:64] := src1[39:32]
	dst[79:72] := src2[39:32] 
	dst[87:80] := src1[47:40] 
	dst[95:88] := src2[47:40] 
	dst[103:96] := src1[55:48] 
	dst[111:104] := src2[55:48] 
	dst[119:112] := src1[63:56] 
	dst[127:120] := src2[63:56] 
	RETURN dst[127:0]
}	

dst[127:0] := INTERLEAVE_BYTES(a[127:0], b[127:0])
dst[255:128] := INTERLEAVE_BYTES(a[255:128], b[255:128])
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpunpcklbw'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_unpacklo_epi16 / vpunpcklwd -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_unpacklo_epi16'>
	<CPUID>AVX2</CPUID>
	<category>Miscellaneous</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Unpack and interleave 16-bit integers from the low half of each 128-bit lane in "a" and "b", and store the results in "dst". </description>
	<description code='true'>
INTERLEAVE_WORDS(src1[127:0], src2[127:0]){
	dst[15:0] := src1[15:0] 
	dst[31:16] := src2[15:0] 
	dst[47:32] := src1[31:16] 
	dst[63:48] := src2[31:16] 
	dst[79:64] := src1[47:32] 
	dst[95:80] := src2[47:32] 
	dst[111:96] := src1[63:48] 
	dst[127:112] := src2[63:48] 
	RETURN dst[127:0]
}	

dst[127:0] := INTERLEAVE_WORDS(a[127:0], b[127:0])
dst[255:128] := INTERLEAVE_WORDS(a[255:128], b[255:128])
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpunpcklwd'/>
	<header>immintrin.h</header>
</intrinsic>	


<!-- _mm256_unpacklo_epi32 / vpunpckldq -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_unpacklo_epi32'>
	<CPUID>AVX2</CPUID>
	<category>Miscellaneous</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Unpack and interleave 32-bit integers from the low half of each 128-bit lane in "a" and "b", and store the results in "dst". </description>
	<description code='true'>
INTERLEAVE_DWORDS(src1[127:0], src2[127:0]){
	dst[31:0] := src1[31:0] 
	dst[63:32] := src2[31:0] 
	dst[95:64] := src1[63:32] 
	dst[127:96] := src2[63:32] 
	RETURN dst[127:0]
}	

dst[127:0] := INTERLEAVE_DWORDS(a[127:0], b[127:0])
dst[255:128] := INTERLEAVE_DWORDS(a[255:128], b[255:128])
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpunpckldq'/>
	<header>immintrin.h</header>
</intrinsic>


<!-- _mm256_unpacklo_epi64 / vpunpcklqdq -->
<intrinsic tech='AVX2' rettype='__m256i' name='_mm256_unpacklo_epi64'>
	<CPUID>AVX2</CPUID>
	<category>Miscellaneous</category>
	<parameter varname='a' type='__m256i'/>
	<parameter varname='b' type='__m256i'/>
	<description>Unpack and interleave 64-bit integers from the low half of each 128-bit lane in "a" and "b", and store the results in "dst". </description>
	<description code='true'>
INTERLEAVE_QWORDS(src1[127:0], src2[127:0]){
	dst[63:0] := src1[63:0] 
	dst[127:64] := src2[63:0] 
	RETURN dst[127:0]
}

dst[127:0] := INTERLEAVE_QWORDS(a[127:0], b[127:0])
dst[255:128] := INTERLEAVE_QWORDS(a[255:128], b[255:128])
dst[MAX:256] := 0
	</description>
	<mnemonic base='vpunpcklqdq'/>
	<header>immintrin.h</header>
</intrinsic>


</intrinsic_list>
