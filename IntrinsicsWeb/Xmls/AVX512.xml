<?xml version="1.0"?>
<intrinsic_list>


<!-- _mm512_kandn / kandnw -->
<intrinsic tech="AVX-512" rettype="__mmask16" name="_mm512_kandn">
	<type>Mask</type>
	<CPUID>AVX-512</CPUID>
	<category>Logical</category>
	<parameter varname="a" type="__mmask16"/>
	<parameter varname="b" type="__mmask16"/>
	<description>Compute the bitwise AND NOT of 16-bit masks "a" and "b", and store the result in "k".</description>
	<description code="true">
k[15:0] := (NOT a[15:0]) AND b[15:0]
k[MAX:16] := 0
	</description>
	<mnemonic base="kandnw"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_kand / kandw -->
<intrinsic tech="AVX-512" rettype="__mmask16" name="_mm512_kand">
	<type>Mask</type>
	<CPUID>AVX-512</CPUID>
	<category>Logical</category>
	<parameter varname="a" type="__mmask16"/>
	<parameter varname="b" type="__mmask16"/>
	<description>Compute the bitwise AND of 16-bit masks "a" and "b", and store the result in "k".</description>
	<description code="true">
k[15:0] := a[15:0] AND b[15:0]
k[MAX:16] := 0
	</description>
	<mnemonic base="kandw"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_kmov / kmovw -->
<intrinsic tech="AVX-512" rettype="__mmask16" name="_mm512_kmov">
	<type>Mask</type>
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="a" type="__mmask16"/>
	<description>Copy 16-bit mask "a" to "k".</description>
	<description code="true">
k[15:0] := a[15:0]
k[MAX:16] := 0
	</description>
	<mnemonic base="kmovw"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_knot / knotw -->
<intrinsic tech="AVX-512" rettype="__mmask16" name="_mm512_knot">
	<type>Mask</type>
	<CPUID>AVX-512</CPUID>
	<category>Logical</category>
	<parameter varname="a" type="__mmask16"/>
	<description>Compute the bitwise NOT of 16-bit mask "a", and store the result in "k".</description>
	<description code="true">
k[15:0] := NOT a[15:0]
k[MAX:16] := 0
	</description>
	<mnemonic base="knotw"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_kor / korw -->
<intrinsic tech="AVX-512" rettype="__mmask16" name="_mm512_kor">
	<type>Mask</type>
	<CPUID>AVX-512</CPUID>
	<category>Logical</category>
	<parameter varname="a" type="__mmask16"/>
	<parameter varname="b" type="__mmask16"/>
	<description>Compute the bitwise OR of 16-bit masks "a" and "b", and store the result in "k".</description>
	<description code="true">
k[15:0] := a[15:0] OR b[15:0]
k[MAX:16] := 0
	</description>
	<mnemonic base="korw"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_kunpackb / kunpckbw -->
<intrinsic tech="AVX-512" rettype="__mmask16" name="_mm512_kunpackb">
	<type>Mask</type>
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="a" type="__mmask16"/>
	<parameter varname="b" type="__mmask16"/>
	<description>Unpack and interleave 8 bits from masks "a" and "b", and store the 16-bit result in "k".</description>
	<description code="true">
k[7:0] := b[7:0]
k[15:8] := a[7:0]
k[MAX:16] := 0
	</description>
	<mnemonic base="kunpckbw"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_kxnor / kxnorw -->
<intrinsic tech="AVX-512" rettype="__mmask16" name="_mm512_kxnor">
	<type>Mask</type>
	<CPUID>AVX-512</CPUID>
	<category>Logical</category>
	<parameter varname="a" type="__mmask16"/>
	<parameter varname="b" type="__mmask16"/>
	<description>Compute the bitwise XNOR of 16-bit masks "a" and "b", and store the result in "k".</description>
	<description code="true">
k[15:0] := NOT (a[15:0] XOR b[15:0])
k[MAX:16] := 0
	</description>
	<mnemonic base="kxnorw"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_kxor / kxorw -->
<intrinsic tech="AVX-512" rettype="__mmask16" name="_mm512_kxor">
	<type>Mask</type>
	<CPUID>AVX-512</CPUID>
	<category>Logical</category>
	<parameter varname="a" type="__mmask16"/>
	<parameter varname="b" type="__mmask16"/>
	<description>Compute the bitwise XOR of 16-bit masks "a" and "b", and store the result in "k".</description>
	<description code="true">
k[15:0] := a[15:0] XOR b[15:0]
k[MAX:16] := 0
	</description>
	<mnemonic base="kxorw"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_add_pd / vaddpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_add_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<description>Add packed double-precision (64-bit) floating-point elements in "a" and "b", and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := a[i+63:i] + b[i+63:i]
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vaddpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_add_round_pd / vaddpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_add_round_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="rounding" type="int"/>
	<description>Add packed double-precision (64-bit) floating-point elements in "a" and "b", and store the results in "dst".
	[round_note]
	</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := a[i+63:i] + b[i+63:i]
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vaddpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_add_pd / vaddpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_add_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="src" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<description>Add packed double-precision (64-bit) floating-point elements in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] + b[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vaddpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_add_round_pd / vaddpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_add_round_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="src" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="rounding" type="int"/>
	<description>Add packed double-precision (64-bit) floating-point elements in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). 
	[round_note]
	</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] + b[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vaddpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_add_pd / vaddpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_add_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<description>Add packed double-precision (64-bit) floating-point elements in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] + b[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vaddpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_add_round_pd / vaddpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_add_round_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="rounding" type="int"/>
	<description>Add packed double-precision (64-bit) floating-point elements in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).
	[round_note]
	</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] + b[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vaddpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_add_ps / vaddps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_add_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<description>Add packed single-precision (32-bit) floating-point elements in "a" and "b", and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := a[i+31:i] + b[i+31:i]
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vaddps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_add_round_ps / vaddps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_add_round_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="rounding" type="int"/>
	<description>Add packed single-precision (32-bit) floating-point elements in "a" and "b", and store the results in "dst".
	[round_note]
	</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := a[i+31:i] + b[i+31:i]
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vaddps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_add_ps / vaddps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_add_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="src" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<description>Add packed single-precision (32-bit) floating-point elements in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i] + b[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vaddps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_add_round_ps / vaddps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_add_round_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="src" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="rounding" type="int"/>
	<description>Add packed single-precision (32-bit) floating-point elements in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). 
	[round_note]
	</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i] + b[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vaddps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_add_ps / vaddps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_add_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<description>Add packed single-precision (32-bit) floating-point elements in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i] + b[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vaddps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_add_round_ps / vaddps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_add_round_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="rounding" type="int"/>
	<description>Add packed single-precision (32-bit) floating-point elements in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).
	[round_note]
	</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i] + b[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vaddps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_add_round_sd / vaddsd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_add_round_sd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="rounding" type="int"/>
	<description>Add the lower double-precision (64-bit) floating-point element in "a" and "b", store the result in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst".
	[round_note]
	</description>
	<description code="true">
dst[63:0] := a[63:0] + b[63:0]
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vaddsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_add_round_sd / vaddsd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_mask_add_round_sd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="src" type="__m128d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="rounding" type="int"/>
	<description>Add the lower double-precision (64-bit) floating-point element in "a" and "b", store the result in the lower element of "dst" using writemask "k" (the element is copied from "src" when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst".
		[round_note]
		</description>
	<description code="true">
IF k[0]
	dst[63:0] := a[63:0] + b[63:0]
ELSE
	dst[63:0] := src[63:0]
FI
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vaddsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_add_sd / vaddsd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_mask_add_sd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="src" type="__m128d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<description>Add the lower double-precision (64-bit) floating-point element in "a" and "b", store the result in the lower element of "dst" using writemask "k" (the element is copied from "src" when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst". </description>
	<description code="true">
IF k[0]
	dst[63:0] := a[63:0] + b[63:0]
ELSE
	dst[63:0] := src[63:0]
FI
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vaddsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_add_round_sd / vaddsd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_maskz_add_round_sd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="rounding" type="int"/>
	<description>Add the lower double-precision (64-bit) floating-point element in "a" and "b", store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst".
		[round_note]
		</description>
	<description code="true">
IF k[0]
	dst[63:0] := a[63:0] + b[63:0]
ELSE
	dst[63:0] := 0
FI
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vaddsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_add_sd / vaddsd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_maskz_add_sd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<description>Add the lower double-precision (64-bit) floating-point element in "a" and "b", store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst".</description>
	<description code="true">
IF k[0]
	dst[63:0] := a[63:0] + b[63:0]
ELSE
	dst[63:0] := 0
FI
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vaddsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_add_round_ss / vaddss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_add_round_ss">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="rounding" type="int"/>
	<description>Add the lower single-precision (32-bit) floating-point element in "a" and "b", store the result in the lower element of "dst", and copy the upper 3 packed elements from "a" to the upper elements of "dst".
		[round_note]
		</description>
	<description code="true">
dst[31:0] := a[31:0] + b[31:0]
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vaddss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_add_round_ss / vaddss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_mask_add_round_ss">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="src" type="__m128"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="rounding" type="int"/>
	<description>Add the lower single-precision (32-bit) floating-point element in "a" and "b", store the result in the lower element of "dst" using writemask "k" (the element is copied from "src" when mask bit 0 is not set), and copy the upper 3 packed elements from "a" to the upper elements of "dst". 
		[round_note]
		</description>
	<description code="true">
IF k[0]
	dst[31:0] := a[31:0] + b[31:0]
ELSE
	dst[31:0] := src[31:0]
FI
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vaddss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_add_ss / vaddss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_mask_add_ss">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="src" type="__m128"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<description>Add the lower single-precision (32-bit) floating-point element in "a" and "b", store the result in the lower element of "dst" using writemask "k" (the element is copied from "src" when mask bit 0 is not set), and copy the upper 3 packed elements from "a" to the upper elements of "dst". </description>
	<description code="true">
IF k[0]
	dst[31:0] := a[31:0] + b[31:0]
ELSE
	dst[31:0] := src[31:0]
FI
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vaddss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_add_round_ss / vaddss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_maskz_add_round_ss">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="rounding" type="int"/>
	<description>Add the lower single-precision (32-bit) floating-point element in "a" and "b", store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from "a" to the upper elements of "dst".
	[round_note]
	</description>
	<description code="true">
IF k[0]
	dst[31:0] := a[31:0] + b[31:0]
ELSE
	dst[31:0] := 0
FI
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vaddss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_add_ss / vaddss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_maskz_add_ss">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<description>Add the lower single-precision (32-bit) floating-point element in "a" and "b", store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from "a" to the upper elements of "dst".</description>
	<description code="true">
IF k[0]
	dst[31:0] := a[31:0] + b[31:0]
ELSE
	dst[31:0] := 0
FI
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vaddss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_alignr_epi32 / valignd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_alignr_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<parameter varname="count" type="const int"/>
	<description>Concatenate "a" and "b" into a 128-byte immediate result, shift the result right by "count" 32-bit elements, and store the low 64 bytes (16 elements) in "dst".</description>
	<description code="true">
temp[1023:512] := a[511:0]
temp[511:0] := b[511:0]
temp[1023:0] := temp[1023:0] &gt;&gt; (32*count)
dst[511:0] := temp[511:0]
dst[MAX:512] := 0
	</description>
	<mnemonic base="valignd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_alignr_epi32 / valignd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_alignr_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<parameter varname="count" type="const int"/>
	<description>Concatenate "a" and "b" into a 128-byte immediate result, shift the result right by "count" 32-bit elements, and store the low 64 bytes (16 elements) in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
temp[1023:512] := a[511:0]
temp[511:0] := b[511:0]
temp[1023:0] := temp[1023:0] &gt;&gt; (32*count)
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := temp[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="valignd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_alignr_epi32 / valignd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_alignr_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<parameter varname="count" type="const int"/>
	<description>Concatenate "a" and "b" into a 128-byte immediate result, shift the result right by "count" 32-bit elements, and stores the low 64 bytes (16 elements) in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
temp[1023:512] := a[511:0]
temp[511:0] := b[511:0]
temp[1023:0] := temp[1023:0] &gt;&gt; (32*count)
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := temp[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="valignd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_alignr_epi64 / valignq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_alignr_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<parameter varname="count" type="const int"/>
	<description>Concatenate "a" and "b" into a 128-byte immediate result, shift the result right by "count" 64-bit elements, and store the low 64 bytes (8 elements) in "dst".</description>
	<description code="true">
temp[1023:512] := a[511:0]
temp[511:0] := b[511:0]
temp[1023:0] := temp[1023:0] &gt;&gt; (64*count)
dst[511:0] := temp[511:0]
dst[MAX:512] := 0
	</description>
	<mnemonic base="valignq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_alignr_epi64 / valignq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_alignr_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<parameter varname="count" type="const int"/>
	<description>Concatenate "a" and "b" into a 128-byte immediate result, shift the result right by "count" 64-bit elements, and store the low 64 bytes (8 elements) in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
temp[1023:512] := a[511:0]
temp[511:0] := b[511:0]
temp[1023:0] := temp[1023:0] &gt;&gt; (64*count)
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := temp[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="valignq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_alignr_epi64 / valignq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_alignr_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<parameter varname="count" type="const int"/>
	<description>Concatenate "a" and "b" into a 128-byte immediate result, shift the result right by "count" 64-bit elements, and stores the low 64 bytes (8 elements) in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
temp[1023:512] := a[511:0]
temp[511:0] := b[511:0]
temp[1023:0] := temp[1023:0] &gt;&gt; (64*count)
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := temp[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="valignq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_blend_pd / vblendmpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_blend_pd">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<description>Blend packed double-precision (64-bit) floating-point elements from "a" and "b" using control mask "k", and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := b[i+63:i]
	ELSE
		dst[i+63:i] := a[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vblendmpd"/>
	<header>zmmintrin.h</header>
</intrinsic>



<!-- _mm512_mask_blend_ps / vblendmps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_blend_ps">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<description>Blend packed single-precision (32-bit) floating-point elements from "a" and "b" using control mask "k", and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := b[i+31:i]
	ELSE
		dst[i+31:i] := a[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vblendmps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_broadcast_f32x4 / vbroadcastf32x4 -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_broadcast_f32x4">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="a" type="__m128"/>
	<description>Broadcast the 4 packed single-precision (32-bit) floating-point elements from "a" to all elements of "dst".</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	n := (j mod 4)*32
	dst[i+31:i] := a[n+31:n]
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vbroadcastf32x4"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_broadcast_f32x4 / vbroadcastf32x4 -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_broadcast_f32x4">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="src" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m128"/>
	<description>Broadcast the 4 packed single-precision (32-bit) floating-point elements from "a" to all elements of "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	n := (j mod 4)*32
	IF k[j]
		dst[i+31:i] := a[n+31:n]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vbroadcastf32x4"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_broadcast_f32x4 / vbroadcastf32x4 -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_broadcast_f32x4">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m128"/>
	<description>Broadcast the 4 packed single-precision (32-bit) floating-point elements from "a" to all elements of "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	n := (j mod 4)*32
	IF k[j]
		dst[i+31:i] := a[n+31:n]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vbroadcastf32x4"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_broadcast_f64x4 / vbroadcastf64x4 -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_broadcast_f64x4">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="a" type="__m256d"/>
	<description>Broadcast the 4 packed double-precision (64-bit) floating-point elements from "a" to all elements of "dst".</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	n := (j mod 4)*64
	dst[i+63:i] := a[n+63:n]
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vbroadcastf64x4"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_broadcast_f64x4 / vbroadcastf64x4 -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_broadcast_f64x4">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="src" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m256d"/>
	<description>Broadcast the 4 packed double-precision (64-bit) floating-point elements from "a" to all elements of "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	n := (j mod 4)*64
	IF k[j]
		dst[i+63:i] := a[n+63:n]
	ELSE
		dst[i+63:i] := src[n+63:n]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vbroadcastf64x4"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_broadcast_f64x4 / vbroadcastf64x4 -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_broadcast_f64x4">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m256d"/>
	<description>Broadcast the 4 packed double-precision (64-bit) floating-point elements from "a" to all elements of "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	n := (j mod 4)*64
	IF k[j]
		dst[i+63:i] := a[n+63:n]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vbroadcastf64x4"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_broadcast_i32x4 / vbroadcasti32x4 -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_broadcast_i32x4">
	<type>Integer</type>
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="a" type="__m128i"/>
	<description>Broadcast the 4 packed 32-bit integers from "a" to all elements of "dst".</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	n := (j mod 4)*32
	dst[i+31:i] := a[n+31:n]
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vbroadcasti32x4"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_broadcast_i32x4 / vbroadcasti32x4 -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_broadcast_i32x4">
	<type>Integer</type>
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m128i"/>
	<description>Broadcast the 4 packed 32-bit integers from "a" to all elements of "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	n := (j mod 4)*32
	IF k[j]
		dst[i+31:i] := a[n+31:n]
	ELSE
		dst[i+31:i] := src[n+31:n]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vbroadcasti32x4"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_broadcast_i32x4 / vbroadcasti32x4 -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_broadcast_i32x4">
	<type>Integer</type>
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m128i"/>
	<description>Broadcast the 4 packed 32-bit integers from "a" to all elements of "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	n := (j mod 4)*32
	IF k[j]
		dst[i+31:i] := a[n+31:n]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vbroadcasti32x4"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_broadcast_i64x4 / vbroadcasti64x4 -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_broadcast_i64x4">
	<type>Integer</type>
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="a" type="__m256i"/>
	<description>Broadcast the 4 packed 64-bit integers from "a" to all elements of "dst".</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	n := (j mod 4)*64
	dst[i+63:i] := a[n+63:n]
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vbroadcasti64x4"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_broadcast_i64x4 / vbroadcasti64x4 -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_broadcast_i64x4">
	<type>Integer</type>
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m256i"/>
	<description>Broadcast the 4 packed 64-bit integers from "a" to all elements of "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	n := (j mod 4)*64
	IF k[j]
		dst[i+63:i] := a[n+63:n]
	ELSE
		dst[i+63:i] := src[n+63:n]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vbroadcasti64x4"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_broadcast_i64x4 / vbroadcasti64x4 -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_broadcast_i64x4">
	<type>Integer</type>
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m256i"/>
	<description>Broadcast the 4 packed 64-bit integers from "a" to all elements of "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	n := (j mod 4)*64
	IF k[j]
		dst[i+63:i] := a[n+63:n]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vbroadcasti64x4"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_broadcastsd_pd / vbroadcastsd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_broadcastsd_pd">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="a" type="__m128d"/>
	<description>Broadcast the low double-precision (64-bit) floating-point element from "a" to all elements of "dst".</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := a[63:0]
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vbroadcastsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_broadcastsd_pd / vbroadcastsd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_broadcastsd_pd">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="src" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<description>Broadcast the low double-precision (64-bit) floating-point element from "a" to all elements of "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[63:0]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vbroadcastsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_broadcastsd_pd / vbroadcastsd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_broadcastsd_pd">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<description>Broadcast the low double-precision (64-bit) floating-point element from "a" to all elements of "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[63:0]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vbroadcastsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_broadcastss_ps / vbroadcastss -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_broadcastss_ps">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="a" type="__m128"/>
	<description>Broadcast the low single-precision (32-bit) floating-point element from "a" to all elements of "dst".</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := a[31:0]
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vbroadcastss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_broadcastss_ps / vbroadcastss -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_broadcastss_ps">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="src" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m128"/>
	<description>Broadcast the low single-precision (32-bit) floating-point element from "a" to all elements of "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := a[31:0]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vbroadcastss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_broadcastss_ps / vbroadcastss -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_broadcastss_ps">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m128"/>
	<description>Broadcast the low single-precision (32-bit) floating-point element from "a" to all elements of "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := a[31:0]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vbroadcastss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cmp_pd_mask / vcmppd -->
<intrinsic tech="AVX-512" rettype="__mmask8" name="_mm512_cmp_pd_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="imm" type="const int"/>
	<description>Compare packed double-precision (64-bit) floating-point elements in "a" and "b" based on the comparison operand specified by "imm", and store the results in mask vector "k".</description>
	<description code="true">
CASE (imm) of
  0: OP := _CMP_EQ_OQ
  1: OP := _CMP_LT_OS
  2: OP := _CMP_LE_OS
  3: OP := _CMP_UNORD_Q 
  4: OP := _CMP_NEQ_UQ
  5: OP := _CMP_NLT_US
  6: OP := _CMP_NLE_US
  7: OP := _CMP_ORD_Q
  8: OP := _CMP_EQ_UQ
  9: OP := _CMP_NGE_US
  10: OP := _CMP_NGT_US
  11: OP := _CMP_FALSE_OQ
  12: OP := _CMP_NEQ_OQ
  13: OP := _CMP_GE_OS
  14: OP := _CMP_GT_OS
  15: OP := _CMP_TRUE_UQ
  16: OP := _CMP_EQ_OS
  17: OP := _CMP_LT_OQ
  18: OP := _CMP_LE_OQ
  19: OP := _CMP_UNORD_S
  20: OP := _CMP_NEQ_US
  21: OP := _CMP_NLT_UQ
  22: OP := _CMP_NLE_UQ
  23: OP := _CMP_ORD_S
  24: OP := _CMP_EQ_US
  25: OP := _CMP_NGE_UQ 
  26: OP := _CMP_NGT_UQ 
  27: OP := _CMP_FALSE_OS 
  28: OP := _CMP_NEQ_OS 
  29: OP := _CMP_GE_OQ
  30: OP := _CMP_GT_OQ
  31: OP := _CMP_TRUE_US
ESAC
FOR j := 0 to 7
  i := j*64
  k[j] := (a[i+63:i] OP b[i+63:i]) ? 1 : 0
ENDFOR
k[MAX:8] := 0
	</description>
	<mnemonic base="vcmppd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cmp_round_pd_mask / vcmppd -->
<intrinsic tech="AVX-512" rettype="__mmask8" name="_mm512_cmp_round_pd_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="imm" type="const int"/>
	<parameter varname="sae" type="const int"/>
	<description>Compare packed double-precision (64-bit) floating-point elements in "a" and "b" based on the comparison operand specified by "imm", and store the results in mask vector "k".
	Pass __MM_FROUND_NO_EXC to "sae" to suppress all exceptions.</description>
	<description code="true">
CASE (imm) of
  0: OP := _CMP_EQ_OQ
  1: OP := _CMP_LT_OS
  2: OP := _CMP_LE_OS
  3: OP := _CMP_UNORD_Q 
  4: OP := _CMP_NEQ_UQ
  5: OP := _CMP_NLT_US
  6: OP := _CMP_NLE_US
  7: OP := _CMP_ORD_Q
  8: OP := _CMP_EQ_UQ
  9: OP := _CMP_NGE_US
  10: OP := _CMP_NGT_US
  11: OP := _CMP_FALSE_OQ
  12: OP := _CMP_NEQ_OQ
  13: OP := _CMP_GE_OS
  14: OP := _CMP_GT_OS
  15: OP := _CMP_TRUE_UQ
  16: OP := _CMP_EQ_OS
  17: OP := _CMP_LT_OQ
  18: OP := _CMP_LE_OQ
  19: OP := _CMP_UNORD_S
  20: OP := _CMP_NEQ_US
  21: OP := _CMP_NLT_UQ
  22: OP := _CMP_NLE_UQ
  23: OP := _CMP_ORD_S
  24: OP := _CMP_EQ_US
  25: OP := _CMP_NGE_UQ 
  26: OP := _CMP_NGT_UQ 
  27: OP := _CMP_FALSE_OS 
  28: OP := _CMP_NEQ_OS 
  29: OP := _CMP_GE_OQ
  30: OP := _CMP_GT_OQ
  31: OP := _CMP_TRUE_US
ESAC
FOR j := 0 to 7
  i := j*64
  k[j] := (a[i+63:i] OP b[i+63:i]) ? 1 : 0
ENDFOR
k[MAX:8] := 0
	</description>
	<mnemonic base="vcmppd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cmpeq_pd_mask / vcmppd -->
<intrinsic tech="AVX-512" rettype="__mmask8" name="_mm512_cmpeq_pd_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<description>Compare packed double-precision (64-bit) floating-point elements in "a" and "b" for equality, and store the results in mask vector "k".</description>
	<description code="true">
FOR j := 0 to 7
  i := j*64
  k[j] := (a[i+63:i] == b[i+63:i]) ? 1 : 0
ENDFOR	
k[MAX:8] := 0
	</description>
	<mnemonic base="vcmppd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cmple_pd_mask / vcmppd -->
<intrinsic tech="AVX-512" rettype="__mmask8" name="_mm512_cmple_pd_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<description>Compare packed double-precision (64-bit) floating-point elements in "a" and "b" for less-than-or-equal, and store the results in mask vector "k".</description>
	<description code="true">
FOR j := 0 to 7
  i := j*64
  k[j] := (a[i+63:i] &lt;= b[i+63:i]) ? 1 : 0
ENDFOR
k[MAX:8] := 0
	</description>
	<mnemonic base="vcmppd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cmplt_pd_mask / vcmppd -->
<intrinsic tech="AVX-512" rettype="__mmask8" name="_mm512_cmplt_pd_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<description>Compare packed double-precision (64-bit) floating-point elements in "a" and "b" for less-than, and store the results in mask vector "k".</description>
	<description code="true">
FOR j := 0 to 7
  i := j*64
  k[j] := (a[i+63:i] &lt; b[i+63:i]) ? 1 : 0
ENDFOR
k[MAX:8] := 0
	</description>
	<mnemonic base="vcmppd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cmpneq_pd_mask / vcmppd -->
<intrinsic tech="AVX-512" rettype="__mmask8" name="_mm512_cmpneq_pd_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<description>Compare packed double-precision (64-bit) floating-point elements in "a" and "b" for not-equal, and store the results in mask vector "k".</description>
	<description code="true">
FOR j := 0 to 7
  i := j*64
  k[j] := (a[i+63:i] != b[i+63:i]) ? 1 : 0
ENDFOR
k[MAX:8] := 0
	</description>
	<mnemonic base="vcmppd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cmpnle_pd_mask / vcmppd -->
<intrinsic tech="AVX-512" rettype="__mmask8" name="_mm512_cmpnle_pd_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<description>Compare packed double-precision (64-bit) floating-point elements in "a" and "b" for not-less-than-or-equal, and store the results in mask vector "k".</description>
	<description code="true">
FOR j := 0 to 7
  i := j*64
  k[j] := !(a[i+63:i] &lt;= b[i+63:i]) ? 1 : 0
ENDFOR
k[MAX:8] := 0
	</description>
	<mnemonic base="vcmppd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cmpnlt_pd_mask / vcmppd -->
<intrinsic tech="AVX-512" rettype="__mmask8" name="_mm512_cmpnlt_pd_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<description>Compare packed double-precision (64-bit) floating-point elements in "a" and "b" for not-less-than, and store the results in mask vector "k".</description>
	<description code="true">
FOR j := 0 to 7
  i := j*64
  k[j] := !(a[i+63:i] &lt; b[i+63:i]) ? 1 : 0
ENDFOR
k[MAX:8] := 0
	</description>
	<mnemonic base="vcmppd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cmpord_pd_mask / vcmppd -->
<intrinsic tech="AVX-512" rettype="__mmask8" name="_mm512_cmpord_pd_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<description>Compare packed double-precision (64-bit) floating-point elements in "a" and "b" to see if neither is NaN, and store the results in mask vector "k".</description>
	<description code="true">
FOR j := 0 to 7
  i := j*64
  k[j] := (a[i+63:i] != NaN AND b[i+63:i] != NaN) ? 1 : 0 
ENDFOR
k[MAX:8] := 0
	</description>
	<mnemonic base="vcmppd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cmpunord_pd_mask / vcmppd -->
<intrinsic tech="AVX-512" rettype="__mmask8" name="_mm512_cmpunord_pd_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<description>Compare packed double-precision (64-bit) floating-point elements in "a" and "b" to see if either is NaN, and store the results in mask vector "k".</description>
	<description code="true">
FOR j := 0 to 7
  i := j*64
  k[j] := (a[i+63:i] == NaN OR b[i+63:i] == NaN) ? 1 : 0 
ENDFOR
k[MAX:8] := 0
	</description>
	<mnemonic base="vcmppd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cmp_pd_mask / vcmppd -->
<intrinsic tech="AVX-512" rettype="__mmask8" name="_mm512_mask_cmp_pd_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="k1" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="imm" type="const int"/>
	<description>Compare packed double-precision (64-bit) floating-point elements in "a" and "b" based on the comparison operand specified by "imm", and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
CASE (imm) of
  0: OP := _CMP_EQ_OQ
  1: OP := _CMP_LT_OS
  2: OP := _CMP_LE_OS
  3: OP := _CMP_UNORD_Q 
  4: OP := _CMP_NEQ_UQ
  5: OP := _CMP_NLT_US
  6: OP := _CMP_NLE_US
  7: OP := _CMP_ORD_Q
  8: OP := _CMP_EQ_UQ
  9: OP := _CMP_NGE_US
  10: OP := _CMP_NGT_US
  11: OP := _CMP_FALSE_OQ
  12: OP := _CMP_NEQ_OQ
  13: OP := _CMP_GE_OS
  14: OP := _CMP_GT_OS
  15: OP := _CMP_TRUE_UQ
  16: OP := _CMP_EQ_OS
  17: OP := _CMP_LT_OQ
  18: OP := _CMP_LE_OQ
  19: OP := _CMP_UNORD_S
  20: OP := _CMP_NEQ_US
  21: OP := _CMP_NLT_UQ
  22: OP := _CMP_NLE_UQ
  23: OP := _CMP_ORD_S
  24: OP := _CMP_EQ_US
  25: OP := _CMP_NGE_UQ 
  26: OP := _CMP_NGT_UQ 
  27: OP := _CMP_FALSE_OS 
  28: OP := _CMP_NEQ_OS 
  29: OP := _CMP_GE_OQ
  30: OP := _CMP_GT_OQ
  31: OP := _CMP_TRUE_US
ESAC
FOR j := 0 to 7
  i := j*64
  IF k1[j]
	  k[j] := ( a[i+63:i] OP b[i+63:i] ) ? 1 : 0
  ELSE 
	k[j] := 0
  FI
ENDFOR
k[MAX:8] := 0
	</description>
	<mnemonic base="vcmppd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cmp_round_pd_mask / vcmppd -->
<intrinsic tech="AVX-512" rettype="__mmask8" name="_mm512_mask_cmp_round_pd_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="k1" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="imm" type="const int"/>
	<parameter varname="sae" type="const int"/>
	<description>Compare packed double-precision (64-bit) floating-point elements in "a" and "b" based on the comparison operand specified by "imm", and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set). 
	Pass __MM_FROUND_NO_EXC to "sae" to suppress all exceptions.</description>
	<description code="true">
CASE (imm) of
  0: OP := _CMP_EQ_OQ
  1: OP := _CMP_LT_OS
  2: OP := _CMP_LE_OS
  3: OP := _CMP_UNORD_Q 
  4: OP := _CMP_NEQ_UQ
  5: OP := _CMP_NLT_US
  6: OP := _CMP_NLE_US
  7: OP := _CMP_ORD_Q
  8: OP := _CMP_EQ_UQ
  9: OP := _CMP_NGE_US
  10: OP := _CMP_NGT_US
  11: OP := _CMP_FALSE_OQ
  12: OP := _CMP_NEQ_OQ
  13: OP := _CMP_GE_OS
  14: OP := _CMP_GT_OS
  15: OP := _CMP_TRUE_UQ
  16: OP := _CMP_EQ_OS
  17: OP := _CMP_LT_OQ
  18: OP := _CMP_LE_OQ
  19: OP := _CMP_UNORD_S
  20: OP := _CMP_NEQ_US
  21: OP := _CMP_NLT_UQ
  22: OP := _CMP_NLE_UQ
  23: OP := _CMP_ORD_S
  24: OP := _CMP_EQ_US
  25: OP := _CMP_NGE_UQ 
  26: OP := _CMP_NGT_UQ 
  27: OP := _CMP_FALSE_OS 
  28: OP := _CMP_NEQ_OS 
  29: OP := _CMP_GE_OQ
  30: OP := _CMP_GT_OQ
  31: OP := _CMP_TRUE_US
ESAC
FOR j := 0 to 7
  i := j*64
  IF k1[j]
	  k[j] := ( a[i+63:i] OP b[i+63:i] ) ? 1 : 0
  ELSE 
	k[j] := 0
  FI
ENDFOR
k[MAX:8] := 0
	</description>
	<mnemonic base="vcmppd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cmpeq_pd_mask / vcmppd -->
<intrinsic tech="AVX-512" rettype="__mmask8" name="_mm512_mask_cmpeq_pd_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="k1" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<description>Compare packed double-precision (64-bit) floating-point elements in "a" and "b" for equality, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
  i := j*64
  IF k1[j]
	  k[j] := (a[i+63:i] == b[i+63:i]) ? 1 : 0
  ELSE 
	k[j] := 0
  FI
ENDFOR	
k[MAX:8] := 0
	</description>
	<mnemonic base="vcmppd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cmple_pd_mask / vcmppd -->
<intrinsic tech="AVX-512" rettype="__mmask8" name="_mm512_mask_cmple_pd_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="k1" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<description>Compare packed double-precision (64-bit) floating-point elements in "a" and "b" for less-than-or-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
  i := j*64
  IF k1[j]
	  k[j] := (a[i+63:i] &lt;= b[i+63:i]) ? 1 : 0
  ELSE 
	k[j] := 0
  FI
ENDFOR
k[MAX:8] := 0
	</description>
	<mnemonic base="vcmppd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cmplt_pd_mask / vcmppd -->
<intrinsic tech="AVX-512" rettype="__mmask8" name="_mm512_mask_cmplt_pd_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="k1" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<description>Compare packed double-precision (64-bit) floating-point elements in "a" and "b" for less-than, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
  i := j*64
  IF k1[j]
	  k[j] := (a[i+63:i] &lt; b[i+63:i]) ? 1 : 0
  ELSE 
	k[j] := 0
  FI
ENDFOR
k[MAX:8] := 0
	</description>
	<mnemonic base="vcmppd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cmpneq_pd_mask / vcmppd -->
<intrinsic tech="AVX-512" rettype="__mmask8" name="_mm512_mask_cmpneq_pd_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="k1" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<description>Compare packed double-precision (64-bit) floating-point elements in "a" and "b" for not-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
  i := j*64
  IF k1[j]
	k[j] := (a[i+63:i] != b[i+63:i]) ? 1 : 0
  ELSE 
	k[j] := 0
  FI
ENDFOR
k[MAX:8] := 0
	</description>
	<mnemonic base="vcmppd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cmpnle_pd_mask / vcmppd -->
<intrinsic tech="AVX-512" rettype="__mmask8" name="_mm512_mask_cmpnle_pd_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="k1" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<description>Compare packed double-precision (64-bit) floating-point elements in "a" and "b" for not-less-than-or-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
  i := j*64
  IF k1[j]
	k[j] := !(a[i+63:i] &lt;= b[i+63:i]) ? 1 : 0
  ELSE 
	k[j] := 0
  FI
ENDFOR
k[MAX:8] := 0
	</description>
	<mnemonic base="vcmppd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cmpnlt_pd_mask / vcmppd -->
<intrinsic tech="AVX-512" rettype="__mmask8" name="_mm512_mask_cmpnlt_pd_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="k1" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<description>Compare packed double-precision (64-bit) floating-point elements in "a" and "b" for not-less-than, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
  i := j*64
  IF k1[j]
	k[j] := !(a[i+63:i] &lt; b[i+63:i]) ? 1 : 0
  ELSE 
	k[j] := 0
  FI
ENDFOR
k[MAX:8] := 0
	</description>
	<mnemonic base="vcmppd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cmpord_pd_mask / vcmppd -->
<intrinsic tech="AVX-512" rettype="__mmask8" name="_mm512_mask_cmpord_pd_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="k1" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<description>Compare packed double-precision (64-bit) floating-point elements in "a" and "b" to see if neither is NaN, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
  i := j*64
  IF k1[j]
	k[j] := (a[i+63:i] != NaN AND b[i+63:i] != NaN) ? 1 : 0 
  ELSE 
	k[j] := 0
  FI
ENDFOR
k[MAX:8] := 0
	</description>
	<mnemonic base="vcmppd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cmpunord_pd_mask / vcmppd -->
<intrinsic tech="AVX-512" rettype="__mmask8" name="_mm512_mask_cmpunord_pd_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="k1" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<description>Compare packed double-precision (64-bit) floating-point elements in "a" and "b" to see if either is NaN, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
  i := j*64
  IF k1[j]
	k[j] := (a[i+63:i] == NaN OR b[i+63:i] == NaN) ? 1 : 0 
  ELSE 
	k[j] := 0
  FI
ENDFOR
k[MAX:8] := 0
	</description>
	<mnemonic base="vcmppd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cmp_ps_mask / vcmpps -->
<intrinsic tech="AVX-512" rettype="__mmask16" name="_mm512_cmp_ps_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="imm" type="const int"/>
	<description>Compare packed single-precision (32-bit) floating-point elements in "a" and "b" based on the comparison operand specified by "imm", and store the results in mask vector "k".</description>
	<description code="true">
CASE (imm) of
  0: OP := _CMP_EQ_OQ
  1: OP := _CMP_LT_OS
  2: OP := _CMP_LE_OS
  3: OP := _CMP_UNORD_Q 
  4: OP := _CMP_NEQ_UQ
  5: OP := _CMP_NLT_US
  6: OP := _CMP_NLE_US
  7: OP := _CMP_ORD_Q
  8: OP := _CMP_EQ_UQ
  9: OP := _CMP_NGE_US
  10: OP := _CMP_NGT_US
  11: OP := _CMP_FALSE_OQ
  12: OP := _CMP_NEQ_OQ
  13: OP := _CMP_GE_OS
  14: OP := _CMP_GT_OS
  15: OP := _CMP_TRUE_UQ
  16: OP := _CMP_EQ_OS
  17: OP := _CMP_LT_OQ
  18: OP := _CMP_LE_OQ
  19: OP := _CMP_UNORD_S
  20: OP := _CMP_NEQ_US
  21: OP := _CMP_NLT_UQ
  22: OP := _CMP_NLE_UQ
  23: OP := _CMP_ORD_S
  24: OP := _CMP_EQ_US
  25: OP := _CMP_NGE_UQ 
  26: OP := _CMP_NGT_UQ 
  27: OP := _CMP_FALSE_OS 
  28: OP := _CMP_NEQ_OS 
  29: OP := _CMP_GE_OQ
  30: OP := _CMP_GT_OQ
  31: OP := _CMP_TRUE_US
ESAC
FOR j := 0 to 15
  i := j*32
  k[j] := (a[i+31:i] OP b[i+31:i]) ? 1 : 0
ENDFOR
k[MAX:16] := 0
	</description>
	<mnemonic base="vcmpps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cmp_round_ps_mask / vcmpps -->
<intrinsic tech="AVX-512" rettype="__mmask16" name="_mm512_cmp_round_ps_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="imm" type="const int"/>
	<parameter varname="sae" type="const int"/>
	<description>Compare packed single-precision (32-bit) floating-point elements in "a" and "b" based on the comparison operand specified by "imm", and store the results in mask vector "k".
	Pass __MM_FROUND_NO_EXC to "sae" to suppress all exceptions.</description>
	<description code="true">
CASE (imm) of
  0: OP := _CMP_EQ_OQ
  1: OP := _CMP_LT_OS
  2: OP := _CMP_LE_OS
  3: OP := _CMP_UNORD_Q 
  4: OP := _CMP_NEQ_UQ
  5: OP := _CMP_NLT_US
  6: OP := _CMP_NLE_US
  7: OP := _CMP_ORD_Q
  8: OP := _CMP_EQ_UQ
  9: OP := _CMP_NGE_US
  10: OP := _CMP_NGT_US
  11: OP := _CMP_FALSE_OQ
  12: OP := _CMP_NEQ_OQ
  13: OP := _CMP_GE_OS
  14: OP := _CMP_GT_OS
  15: OP := _CMP_TRUE_UQ
  16: OP := _CMP_EQ_OS
  17: OP := _CMP_LT_OQ
  18: OP := _CMP_LE_OQ
  19: OP := _CMP_UNORD_S
  20: OP := _CMP_NEQ_US
  21: OP := _CMP_NLT_UQ
  22: OP := _CMP_NLE_UQ
  23: OP := _CMP_ORD_S
  24: OP := _CMP_EQ_US
  25: OP := _CMP_NGE_UQ 
  26: OP := _CMP_NGT_UQ 
  27: OP := _CMP_FALSE_OS 
  28: OP := _CMP_NEQ_OS 
  29: OP := _CMP_GE_OQ
  30: OP := _CMP_GT_OQ
  31: OP := _CMP_TRUE_US
ESAC
FOR j := 0 to 15
  i := j*32
  k[j] := (a[i+31:i] OP b[i+31:i]) ? 1 : 0
ENDFOR
k[MAX:16] := 0
	</description>
	<mnemonic base="vcmpps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cmpeq_ps_mask / vcmpps -->
<intrinsic tech="AVX-512" rettype="__mmask16" name="_mm512_cmpeq_ps_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<description>Compare packed single-precision (32-bit) floating-point elements in "a" and "b" for equality, and store the results in mask vector "k".</description>
	<description code="true">
FOR j := 0 to 15
  i := j*32
  k[j] := (a[i+31:i] == b[i+31:i]) ? 1 : 0
ENDFOR	
k[MAX:16] := 0		
	</description>
	<mnemonic base="vcmpps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cmple_ps_mask / vcmpps -->
<intrinsic tech="AVX-512" rettype="__mmask16" name="_mm512_cmple_ps_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<description>Compare packed single-precision (32-bit) floating-point elements in "a" and "b" for less-than-or-equal, and store the results in mask vector "k".</description>
	<description code="true">
FOR j := 0 to 15
  i := j*32
  k[j] := (a[i+31:i] &lt;= b[i+31:i]) ? 1 : 0
ENDFOR
k[MAX:16] := 0
	</description>
	<mnemonic base="vcmpps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cmplt_ps_mask / vcmpps -->
<intrinsic tech="AVX-512" rettype="__mmask16" name="_mm512_cmplt_ps_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<description>Compare packed single-precision (32-bit) floating-point elements in "a" and "b" for less-than, and store the results in mask vector "k".</description>
	<description code="true">
FOR j := 0 to 15
  i := j*32
  k[j] := (a[i+31:i] &lt; b[i+31:i]) ? 1 : 0
ENDFOR
k[MAX:16] := 0
	</description>
	<mnemonic base="vcmpps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cmpneq_ps_mask / vcmpps -->
<intrinsic tech="AVX-512" rettype="__mmask16" name="_mm512_cmpneq_ps_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<description>Compare packed single-precision (32-bit) floating-point elements in "a" and "b" for not-equal, and store the results in mask vector "k".</description>
	<description code="true">
FOR j := 0 to 15
  i := j*32
  k[j] := (a[i+31:i] != b[i+31:i]) ? 1 : 0
ENDFOR
k[MAX:16] := 0
	</description>
	<mnemonic base="vcmpps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cmpnle_ps_mask / vcmpps -->
<intrinsic tech="AVX-512" rettype="__mmask16" name="_mm512_cmpnle_ps_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<description>Compare packed single-precision (32-bit) floating-point elements in "a" and "b" for not-less-than-or-equal, and store the results in mask vector "k".</description>
	<description code="true">
FOR j := 0 to 15
  i := j*32
  k[j] := !(a[i+31:i] &lt;= b[i+31:i]) ? 1 : 0
ENDFOR
k[MAX:16] := 0
	</description>
	<mnemonic base="vcmpps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cmpnlt_ps_mask / vcmpps -->
<intrinsic tech="AVX-512" rettype="__mmask16" name="_mm512_cmpnlt_ps_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<description>Compare packed single-precision (32-bit) floating-point elements in "a" and "b" for not-less-than, and store the results in mask vector "k".</description>
	<description code="true">
FOR j := 0 to 15
  i := j*32
  k[j] := !(a[i+31:i] &lt; b[i+31:i]) ? 1 : 0
ENDFOR
k[MAX:16] := 0
	</description>
	<mnemonic base="vcmpps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cmpord_ps_mask / vcmpps -->
<intrinsic tech="AVX-512" rettype="__mmask16" name="_mm512_cmpord_ps_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<description>Compare packed single-precision (32-bit) floating-point elements in "a" and "b" to see if neither is NaN, and store the results in mask vector "k".</description>
	<description code="true">
FOR j := 0 to 15
  i := j*32
  k[j] := (a[i+31:i] != NaN AND b[i+31:i] != NaN) ? 1 : 0 
ENDFOR
k[MAX:16] := 0
	</description>
	<mnemonic base="vcmpps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cmpunord_ps_mask / vcmpps -->
<intrinsic tech="AVX-512" rettype="__mmask16" name="_mm512_cmpunord_ps_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<description>Compare packed single-precision (32-bit) floating-point elements in "a" and "b" to see if either is NaN, and store the results in mask vector "k".</description>
	<description code="true">
FOR j := 0 to 15
  i := j*32
  k[j] := (a[i+31:i] == NaN OR b[i+31:i] == NaN) ? 1 : 0 
ENDFOR
k[MAX:16] := 0
	</description>
	<mnemonic base="vcmpps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cmp_ps_mask / vcmpps -->
<intrinsic tech="AVX-512" rettype="__mmask16" name="_mm512_mask_cmp_ps_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="k1" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="imm" type="const int"/>
	<description>Compare packed single-precision (32-bit) floating-point elements in "a" and "b" based on the comparison operand specified by "imm", and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
CASE (imm) of
  0: OP := _CMP_EQ_OQ
  1: OP := _CMP_LT_OS
  2: OP := _CMP_LE_OS
  3: OP := _CMP_UNORD_Q 
  4: OP := _CMP_NEQ_UQ
  5: OP := _CMP_NLT_US
  6: OP := _CMP_NLE_US
  7: OP := _CMP_ORD_Q
  8: OP := _CMP_EQ_UQ
  9: OP := _CMP_NGE_US
  10: OP := _CMP_NGT_US
  11: OP := _CMP_FALSE_OQ
  12: OP := _CMP_NEQ_OQ
  13: OP := _CMP_GE_OS
  14: OP := _CMP_GT_OS
  15: OP := _CMP_TRUE_UQ
  16: OP := _CMP_EQ_OS
  17: OP := _CMP_LT_OQ
  18: OP := _CMP_LE_OQ
  19: OP := _CMP_UNORD_S
  20: OP := _CMP_NEQ_US
  21: OP := _CMP_NLT_UQ
  22: OP := _CMP_NLE_UQ
  23: OP := _CMP_ORD_S
  24: OP := _CMP_EQ_US
  25: OP := _CMP_NGE_UQ 
  26: OP := _CMP_NGT_UQ 
  27: OP := _CMP_FALSE_OS 
  28: OP := _CMP_NEQ_OS 
  29: OP := _CMP_GE_OQ
  30: OP := _CMP_GT_OQ
  31: OP := _CMP_TRUE_US
ESAC
FOR j := 0 to 15
  i := j*32
  IF k1[j]
	  k[j] := ( a[i+31:i] OP b[i+31:i] ) ? 1 : 0
  ELSE 
	k[j] := 0
  FI
ENDFOR
k[MAX:16] := 0
	</description>
	<mnemonic base="vcmpps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cmp_round_ps_mask / vcmpps -->
<intrinsic tech="AVX-512" rettype="__mmask16" name="_mm512_mask_cmp_round_ps_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="k1" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="imm" type="const int"/>
	<parameter varname="sae" type="const int"/>
	<description>Compare packed single-precision (32-bit) floating-point elements in "a" and "b" based on the comparison operand specified by "imm", and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set). 
	Pass __MM_FROUND_NO_EXC to "sae" to suppress all exceptions.</description>
	<description code="true">
CASE (imm) of
  0: OP := _CMP_EQ_OQ
  1: OP := _CMP_LT_OS
  2: OP := _CMP_LE_OS
  3: OP := _CMP_UNORD_Q 
  4: OP := _CMP_NEQ_UQ
  5: OP := _CMP_NLT_US
  6: OP := _CMP_NLE_US
  7: OP := _CMP_ORD_Q
  8: OP := _CMP_EQ_UQ
  9: OP := _CMP_NGE_US
  10: OP := _CMP_NGT_US
  11: OP := _CMP_FALSE_OQ
  12: OP := _CMP_NEQ_OQ
  13: OP := _CMP_GE_OS
  14: OP := _CMP_GT_OS
  15: OP := _CMP_TRUE_UQ
  16: OP := _CMP_EQ_OS
  17: OP := _CMP_LT_OQ
  18: OP := _CMP_LE_OQ
  19: OP := _CMP_UNORD_S
  20: OP := _CMP_NEQ_US
  21: OP := _CMP_NLT_UQ
  22: OP := _CMP_NLE_UQ
  23: OP := _CMP_ORD_S
  24: OP := _CMP_EQ_US
  25: OP := _CMP_NGE_UQ 
  26: OP := _CMP_NGT_UQ 
  27: OP := _CMP_FALSE_OS 
  28: OP := _CMP_NEQ_OS 
  29: OP := _CMP_GE_OQ
  30: OP := _CMP_GT_OQ
  31: OP := _CMP_TRUE_US
ESAC
FOR j := 0 to 15
  i := j*32
  IF k1[j]
	  k[j] := ( a[i+31:i] OP b[i+31:i] ) ? 1 : 0
  ELSE 
	k[j] := 0
  FI
ENDFOR
k[MAX:16] := 0
	</description>
	<mnemonic base="vcmpps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cmpeq_ps_mask / vcmpps -->
<intrinsic tech="AVX-512" rettype="__mmask16" name="_mm512_mask_cmpeq_ps_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="k1" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<description>Compare packed single-precision (32-bit) floating-point elements in "a" and "b" for equality, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">y
FOR j := 0 to 15
  i := j*32
  IF k1[j]
	  k[j] := (a[i+31:i] == b[i+31:i]) ? 1 : 0
  ELSE 
	k[j] := 0
  FI
ENDFOR		
k[MAX:16] := 0	
	</description>
	<mnemonic base="vcmpps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cmple_ps_mask / vcmpps -->
<intrinsic tech="AVX-512" rettype="__mmask16" name="_mm512_mask_cmple_ps_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="k1" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<description>Compare packed single-precision (32-bit) floating-point elements in "a" and "b" for less-than-or-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
  i := j*32
  IF k1[j]
	k[j] := (a[i+31:i] &lt;= b[i+31:i]) ? 1 : 0
  ELSE 
	k[j] := 0
  FI
ENDFOR
k[MAX:16] := 0
	</description>
	<mnemonic base="vcmpps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cmplt_ps_mask / vcmpps -->
<intrinsic tech="AVX-512" rettype="__mmask16" name="_mm512_mask_cmplt_ps_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="k1" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<description>Compare packed single-precision (32-bit) floating-point elements in "a" and "b" for less-than, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
  i := j*32
  IF k1[j]
	k[j] := (a[i+31:i] &lt; b[i+31:i]) ? 1 : 0
  ELSE 
	k[j] := 0
  FI
ENDFOR
k[MAX:16] := 0
	</description>
	<mnemonic base="vcmpps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cmpneq_ps_mask / vcmpps -->
<intrinsic tech="AVX-512" rettype="__mmask16" name="_mm512_mask_cmpneq_ps_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="k1" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<description>Compare packed single-precision (32-bit) floating-point elements in "a" and "b" for not-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
  i := j*32
  IF k1[j]
	  k[j] := (a[i+31:i] != b[i+31:i]) ? 1 : 0
  ELSE 
	k[j] := 0
  FI
ENDFOR
k[MAX:16] := 0
	</description>
	<mnemonic base="vcmpps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cmpnle_ps_mask / vcmpps -->
<intrinsic tech="AVX-512" rettype="__mmask16" name="_mm512_mask_cmpnle_ps_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="k1" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<description>Compare packed single-precision (32-bit) floating-point elements in "a" and "b" for not-less-than-or-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
  i := j*32
  IF k1[j]
	k[j] := !(a[i+31:i] &lt;= b[i+31:i]) ? 1 : 0
  ELSE 
	k[j] := 0
  FI
ENDFOR
k[MAX:16] := 0
	</description>
	<mnemonic base="vcmpps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cmpnlt_ps_mask / vcmpps -->
<intrinsic tech="AVX-512" rettype="__mmask16" name="_mm512_mask_cmpnlt_ps_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="k1" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<description>Compare packed single-precision (32-bit) floating-point elements in "a" and "b" for not-less-than, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
  i := j*32
  IF k1[j]
	k[j] := !(a[i+31:i] &lt; b[i+31:i]) ? 1 : 0
  ELSE 
	k[j] := 0
  FI
ENDFOR
k[MAX:16] := 0
	</description>
	<mnemonic base="vcmpps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cmpord_ps_mask / vcmpps -->
<intrinsic tech="AVX-512" rettype="__mmask16" name="_mm512_mask_cmpord_ps_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="k1" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<description>Compare packed single-precision (32-bit) floating-point elements in "a" and "b" to see if neither is NaN, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
  i := j*32
  IF k1[j]
	k[j] := (a[i+31:i] != NaN AND b[i+31:i] != NaN) ? 1 : 0 
  ELSE 
	k[j] := 0
  FI
ENDFOR
k[MAX:16] := 0
	</description>
	<mnemonic base="vcmpps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cmpunord_ps_mask / vcmpps -->
<intrinsic tech="AVX-512" rettype="__mmask16" name="_mm512_mask_cmpunord_ps_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="k1" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<description>Compare packed single-precision (32-bit) floating-point elements in "a" and "b" to see if either is NaN, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
  i := j*32
  IF k1[j]
	k[j] := (a[i+31:i] == NaN OR b[i+31:i] == NaN) ? 1 : 0 
  ELSE 
	k[j] := 0
  FI
ENDFOR
k[MAX:16] := 0
	</description>
	<mnemonic base="vcmpps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_cmp_round_sd_mask / vcmpsd -->
<intrinsic tech="AVX-512" rettype="__mmask8" name="_mm_cmp_round_sd_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="imm" type="const int"/>
	<parameter varname="sae" type="const int"/>
	<description>Compare the lower double-precision (64-bit) floating-point element in "a" and "b" based on the comparison operand specified by "imm", and store the result in mask vector "k".
	Pass __MM_FROUND_NO_EXC to "sae" to suppress all exceptions.</description>
	<description code="true">
CASE (imm) of
  0: OP := _CMP_EQ_OQ
  1: OP := _CMP_LT_OS
  2: OP := _CMP_LE_OS
  3: OP := _CMP_UNORD_Q 
  4: OP := _CMP_NEQ_UQ
  5: OP := _CMP_NLT_US
  6: OP := _CMP_NLE_US
  7: OP := _CMP_ORD_Q
  8: OP := _CMP_EQ_UQ
  9: OP := _CMP_NGE_US
  10: OP := _CMP_NGT_US
  11: OP := _CMP_FALSE_OQ
  12: OP := _CMP_NEQ_OQ
  13: OP := _CMP_GE_OS
  14: OP := _CMP_GT_OS
  15: OP := _CMP_TRUE_UQ
  16: OP := _CMP_EQ_OS
  17: OP := _CMP_LT_OQ
  18: OP := _CMP_LE_OQ
  19: OP := _CMP_UNORD_S
  20: OP := _CMP_NEQ_US
  21: OP := _CMP_NLT_UQ
  22: OP := _CMP_NLE_UQ
  23: OP := _CMP_ORD_S
  24: OP := _CMP_EQ_US
  25: OP := _CMP_NGE_UQ 
  26: OP := _CMP_NGT_UQ 
  27: OP := _CMP_FALSE_OS 
  28: OP := _CMP_NEQ_OS 
  29: OP := _CMP_GE_OQ
  30: OP := _CMP_GT_OQ
  31: OP := _CMP_TRUE_US
ESAC

k[0] := ( a[63:0] OP b[63:0] ) ? 1 : 0

k[MAX:1] := 0
	</description>
	<mnemonic base="vcmpsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_cmp_sd_mask / vcmpsd -->
<intrinsic tech="AVX-512" rettype="__mmask8" name="_mm_cmp_sd_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="imm" type="const int"/>
	<description>Compare the lower double-precision (64-bit) floating-point element in "a" and "b" based on the comparison operand specified by "imm", and store the result in mask vector "k".</description>
	<description code="true">
CASE (imm) of
  0: OP := _CMP_EQ_OQ
  1: OP := _CMP_LT_OS
  2: OP := _CMP_LE_OS
  3: OP := _CMP_UNORD_Q 
  4: OP := _CMP_NEQ_UQ
  5: OP := _CMP_NLT_US
  6: OP := _CMP_NLE_US
  7: OP := _CMP_ORD_Q
  8: OP := _CMP_EQ_UQ
  9: OP := _CMP_NGE_US
  10: OP := _CMP_NGT_US
  11: OP := _CMP_FALSE_OQ
  12: OP := _CMP_NEQ_OQ
  13: OP := _CMP_GE_OS
  14: OP := _CMP_GT_OS
  15: OP := _CMP_TRUE_UQ
  16: OP := _CMP_EQ_OS
  17: OP := _CMP_LT_OQ
  18: OP := _CMP_LE_OQ
  19: OP := _CMP_UNORD_S
  20: OP := _CMP_NEQ_US
  21: OP := _CMP_NLT_UQ
  22: OP := _CMP_NLE_UQ
  23: OP := _CMP_ORD_S
  24: OP := _CMP_EQ_US
  25: OP := _CMP_NGE_UQ 
  26: OP := _CMP_NGT_UQ 
  27: OP := _CMP_FALSE_OS 
  28: OP := _CMP_NEQ_OS 
  29: OP := _CMP_GE_OQ
  30: OP := _CMP_GT_OQ
  31: OP := _CMP_TRUE_US
ESAC

k[0] := ( a[63:0] OP b[63:0] ) ? 1 : 0

k[MAX:1] := 0
	</description>
	<mnemonic base="vcmpsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_cmp_round_sd_mask / vcmpsd -->
<intrinsic tech="AVX-512" rettype="__mmask8" name="_mm_mask_cmp_round_sd_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="k1" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="imm" type="const int"/>
	<parameter varname="sae" type="const int"/>
	<description>Compare the lower double-precision (64-bit) floating-point element in "a" and "b" based on the comparison operand specified by "imm", and store the result in mask vector "k" using zeromask "k1" (the element is zeroed out when mask bit 0 is not set).
	Pass __MM_FROUND_NO_EXC to "sae" to suppress all exceptions.</description>
	<description code="true">
CASE (imm) of
  0: OP := _CMP_EQ_OQ
  1: OP := _CMP_LT_OS
  2: OP := _CMP_LE_OS
  3: OP := _CMP_UNORD_Q 
  4: OP := _CMP_NEQ_UQ
  5: OP := _CMP_NLT_US
  6: OP := _CMP_NLE_US
  7: OP := _CMP_ORD_Q
  8: OP := _CMP_EQ_UQ
  9: OP := _CMP_NGE_US
  10: OP := _CMP_NGT_US
  11: OP := _CMP_FALSE_OQ
  12: OP := _CMP_NEQ_OQ
  13: OP := _CMP_GE_OS
  14: OP := _CMP_GT_OS
  15: OP := _CMP_TRUE_UQ
  16: OP := _CMP_EQ_OS
  17: OP := _CMP_LT_OQ
  18: OP := _CMP_LE_OQ
  19: OP := _CMP_UNORD_S
  20: OP := _CMP_NEQ_US
  21: OP := _CMP_NLT_UQ
  22: OP := _CMP_NLE_UQ
  23: OP := _CMP_ORD_S
  24: OP := _CMP_EQ_US
  25: OP := _CMP_NGE_UQ 
  26: OP := _CMP_NGT_UQ 
  27: OP := _CMP_FALSE_OS 
  28: OP := _CMP_NEQ_OS 
  29: OP := _CMP_GE_OQ
  30: OP := _CMP_GT_OQ
  31: OP := _CMP_TRUE_US
ESAC

IF k1[0]
	k[0] := ( a[63:0] OP b[63:0] ) ? 1 : 0
ELSE
	k[0] := 0
FI
k[MAX:1] := 0
	</description>
	<mnemonic base="vcmpsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_cmp_sd_mask / vcmpsd -->
<intrinsic tech="AVX-512" rettype="__mmask8" name="_mm_mask_cmp_sd_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="k1" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="imm" type="const int"/>
	<description>Compare the lower double-precision (64-bit) floating-point element in "a" and "b" based on the comparison operand specified by "imm", and store the result in mask vector "k" using zeromask "k1" (the element is zeroed out when mask bit 0 is not set). </description>
	<description code="true">
CASE (imm) of
  0: OP := _CMP_EQ_OQ
  1: OP := _CMP_LT_OS
  2: OP := _CMP_LE_OS
  3: OP := _CMP_UNORD_Q 
  4: OP := _CMP_NEQ_UQ
  5: OP := _CMP_NLT_US
  6: OP := _CMP_NLE_US
  7: OP := _CMP_ORD_Q
  8: OP := _CMP_EQ_UQ
  9: OP := _CMP_NGE_US
  10: OP := _CMP_NGT_US
  11: OP := _CMP_FALSE_OQ
  12: OP := _CMP_NEQ_OQ
  13: OP := _CMP_GE_OS
  14: OP := _CMP_GT_OS
  15: OP := _CMP_TRUE_UQ
  16: OP := _CMP_EQ_OS
  17: OP := _CMP_LT_OQ
  18: OP := _CMP_LE_OQ
  19: OP := _CMP_UNORD_S
  20: OP := _CMP_NEQ_US
  21: OP := _CMP_NLT_UQ
  22: OP := _CMP_NLE_UQ
  23: OP := _CMP_ORD_S
  24: OP := _CMP_EQ_US
  25: OP := _CMP_NGE_UQ 
  26: OP := _CMP_NGT_UQ 
  27: OP := _CMP_FALSE_OS 
  28: OP := _CMP_NEQ_OS 
  29: OP := _CMP_GE_OQ
  30: OP := _CMP_GT_OQ
  31: OP := _CMP_TRUE_US
ESAC

IF k1[0]
	k[0] := ( a[63:0] OP b[63:0] ) ? 1 : 0
ELSE
	k[0] := 0
FI
k[MAX:1] := 0
	</description>
	<mnemonic base="vcmpsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_cmp_round_ss_mask / vcmpss -->
<intrinsic tech="AVX-512" rettype="__mmask8" name="_mm_cmp_round_ss_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="imm" type="const int"/>
	<parameter varname="sae" type="const int"/>
	<description>Compare the lower single-precision (32-bit) floating-point element in "a" and "b" based on the comparison operand specified by "imm", and store the result in mask vector "k".
	Pass __MM_FROUND_NO_EXC to "sae" to suppress all exceptions.</description>
	<description code="true">
CASE (imm) of
  0: OP := _CMP_EQ_OQ
  1: OP := _CMP_LT_OS
  2: OP := _CMP_LE_OS
  3: OP := _CMP_UNORD_Q 
  4: OP := _CMP_NEQ_UQ
  5: OP := _CMP_NLT_US
  6: OP := _CMP_NLE_US
  7: OP := _CMP_ORD_Q
  8: OP := _CMP_EQ_UQ
  9: OP := _CMP_NGE_US
  10: OP := _CMP_NGT_US
  11: OP := _CMP_FALSE_OQ
  12: OP := _CMP_NEQ_OQ
  13: OP := _CMP_GE_OS
  14: OP := _CMP_GT_OS
  15: OP := _CMP_TRUE_UQ
  16: OP := _CMP_EQ_OS
  17: OP := _CMP_LT_OQ
  18: OP := _CMP_LE_OQ
  19: OP := _CMP_UNORD_S
  20: OP := _CMP_NEQ_US
  21: OP := _CMP_NLT_UQ
  22: OP := _CMP_NLE_UQ
  23: OP := _CMP_ORD_S
  24: OP := _CMP_EQ_US
  25: OP := _CMP_NGE_UQ 
  26: OP := _CMP_NGT_UQ 
  27: OP := _CMP_FALSE_OS 
  28: OP := _CMP_NEQ_OS 
  29: OP := _CMP_GE_OQ
  30: OP := _CMP_GT_OQ
  31: OP := _CMP_TRUE_US
ESAC

k[0] := ( a[31:0] OP b[31:0] ) ? 1 : 0

k[MAX:1] := 0
	</description>
	<mnemonic base="vcmpss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_cmp_ss_mask / vcmpss -->
<intrinsic tech="AVX-512" rettype="__mmask8" name="_mm_cmp_ss_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="imm" type="const int"/>
	<description>Compare the lower single-precision (32-bit) floating-point element in "a" and "b" based on the comparison operand specified by "imm", and store the result in mask vector "k".</description>
	<description code="true">
CASE (imm) of
  0: OP := _CMP_EQ_OQ
  1: OP := _CMP_LT_OS
  2: OP := _CMP_LE_OS
  3: OP := _CMP_UNORD_Q 
  4: OP := _CMP_NEQ_UQ
  5: OP := _CMP_NLT_US
  6: OP := _CMP_NLE_US
  7: OP := _CMP_ORD_Q
  8: OP := _CMP_EQ_UQ
  9: OP := _CMP_NGE_US
  10: OP := _CMP_NGT_US
  11: OP := _CMP_FALSE_OQ
  12: OP := _CMP_NEQ_OQ
  13: OP := _CMP_GE_OS
  14: OP := _CMP_GT_OS
  15: OP := _CMP_TRUE_UQ
  16: OP := _CMP_EQ_OS
  17: OP := _CMP_LT_OQ
  18: OP := _CMP_LE_OQ
  19: OP := _CMP_UNORD_S
  20: OP := _CMP_NEQ_US
  21: OP := _CMP_NLT_UQ
  22: OP := _CMP_NLE_UQ
  23: OP := _CMP_ORD_S
  24: OP := _CMP_EQ_US
  25: OP := _CMP_NGE_UQ 
  26: OP := _CMP_NGT_UQ 
  27: OP := _CMP_FALSE_OS 
  28: OP := _CMP_NEQ_OS 
  29: OP := _CMP_GE_OQ
  30: OP := _CMP_GT_OQ
  31: OP := _CMP_TRUE_US
ESAC

k[0] := ( a[31:0] OP b[31:0] ) ? 1 : 0

k[MAX:1] := 0
	</description>
	<mnemonic base="vcmpss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_cmp_round_ss_mask / vcmpss -->
<intrinsic tech="AVX-512" rettype="__mmask8" name="_mm_mask_cmp_round_ss_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="k1" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="imm" type="const int"/>
	<parameter varname="sae" type="const int"/>
	<description>Compare the lower single-precision (32-bit) floating-point element in "a" and "b" based on the comparison operand specified by "imm", and store the result in mask vector "k" using zeromask "k1" (the element is zeroed out when mask bit 0 is not set). 
	Pass __MM_FROUND_NO_EXC to "sae" to suppress all exceptions.</description>
	<description code="true">
CASE (imm) of
  0: OP := _CMP_EQ_OQ
  1: OP := _CMP_LT_OS
  2: OP := _CMP_LE_OS
  3: OP := _CMP_UNORD_Q 
  4: OP := _CMP_NEQ_UQ
  5: OP := _CMP_NLT_US
  6: OP := _CMP_NLE_US
  7: OP := _CMP_ORD_Q
  8: OP := _CMP_EQ_UQ
  9: OP := _CMP_NGE_US
  10: OP := _CMP_NGT_US
  11: OP := _CMP_FALSE_OQ
  12: OP := _CMP_NEQ_OQ
  13: OP := _CMP_GE_OS
  14: OP := _CMP_GT_OS
  15: OP := _CMP_TRUE_UQ
  16: OP := _CMP_EQ_OS
  17: OP := _CMP_LT_OQ
  18: OP := _CMP_LE_OQ
  19: OP := _CMP_UNORD_S
  20: OP := _CMP_NEQ_US
  21: OP := _CMP_NLT_UQ
  22: OP := _CMP_NLE_UQ
  23: OP := _CMP_ORD_S
  24: OP := _CMP_EQ_US
  25: OP := _CMP_NGE_UQ 
  26: OP := _CMP_NGT_UQ 
  27: OP := _CMP_FALSE_OS 
  28: OP := _CMP_NEQ_OS 
  29: OP := _CMP_GE_OQ
  30: OP := _CMP_GT_OQ
  31: OP := _CMP_TRUE_US
ESAC

IF k1[0]
	k[0] := ( a[31:0] OP b[31:0] ) ? 1 : 0
ELSE
	k[0] := 0
FI
k[MAX:1] := 0
	</description>
	<mnemonic base="vcmpss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_cmp_ss_mask / vcmpss -->
<intrinsic tech="AVX-512" rettype="__mmask8" name="_mm_mask_cmp_ss_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="k1" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="imm" type="const int"/>
	<description>Compare the lower single-precision (32-bit) floating-point element in "a" and "b" based on the comparison operand specified by "imm", and store the result in mask vector "k" using zeromask "k1" (the element is zeroed out when mask bit 0 is not set). </description>
	<description code="true">
CASE (imm) of
  0: OP := _CMP_EQ_OQ
  1: OP := _CMP_LT_OS
  2: OP := _CMP_LE_OS
  3: OP := _CMP_UNORD_Q 
  4: OP := _CMP_NEQ_UQ
  5: OP := _CMP_NLT_US
  6: OP := _CMP_NLE_US
  7: OP := _CMP_ORD_Q
  8: OP := _CMP_EQ_UQ
  9: OP := _CMP_NGE_US
  10: OP := _CMP_NGT_US
  11: OP := _CMP_FALSE_OQ
  12: OP := _CMP_NEQ_OQ
  13: OP := _CMP_GE_OS
  14: OP := _CMP_GT_OS
  15: OP := _CMP_TRUE_UQ
  16: OP := _CMP_EQ_OS
  17: OP := _CMP_LT_OQ
  18: OP := _CMP_LE_OQ
  19: OP := _CMP_UNORD_S
  20: OP := _CMP_NEQ_US
  21: OP := _CMP_NLT_UQ
  22: OP := _CMP_NLE_UQ
  23: OP := _CMP_ORD_S
  24: OP := _CMP_EQ_US
  25: OP := _CMP_NGE_UQ 
  26: OP := _CMP_NGT_UQ 
  27: OP := _CMP_FALSE_OS 
  28: OP := _CMP_NEQ_OS 
  29: OP := _CMP_GE_OQ
  30: OP := _CMP_GT_OQ
  31: OP := _CMP_TRUE_US
ESAC

IF k1[0]
	k[0] := ( a[31:0] OP b[31:0] ) ? 1 : 0
ELSE
	k[0] := 0
FI
k[MAX:1] := 0
	</description>
	<mnemonic base="vcmpss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_comi_round_sd / vcomisd -->
<intrinsic tech="AVX-512" rettype="int" name="_mm_comi_round_sd">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="imm" type="const int"/>
	<parameter varname="sae" type="const int"/>
	<description>Compare the lower double-precision (64-bit) floating-point element in "a" and "b" based on the comparison operand specified by "imm", and return the boolean result (0 or 1).
	Pass __MM_FROUND_NO_EXC to "sae" to suppress all exceptions.</description>
	<description code="true">
CASE (imm) of
  0: OP := _CMP_EQ_OQ
  1: OP := _CMP_LT_OS
  2: OP := _CMP_LE_OS
  3: OP := _CMP_UNORD_Q 
  4: OP := _CMP_NEQ_UQ
  5: OP := _CMP_NLT_US
  6: OP := _CMP_NLE_US
  7: OP := _CMP_ORD_Q
  8: OP := _CMP_EQ_UQ
  9: OP := _CMP_NGE_US
  10: OP := _CMP_NGT_US
  11: OP := _CMP_FALSE_OQ
  12: OP := _CMP_NEQ_OQ
  13: OP := _CMP_GE_OS
  14: OP := _CMP_GT_OS
  15: OP := _CMP_TRUE_UQ
  16: OP := _CMP_EQ_OS
  17: OP := _CMP_LT_OQ
  18: OP := _CMP_LE_OQ
  19: OP := _CMP_UNORD_S
  20: OP := _CMP_NEQ_US
  21: OP := _CMP_NLT_UQ
  22: OP := _CMP_NLE_UQ
  23: OP := _CMP_ORD_S
  24: OP := _CMP_EQ_US
  25: OP := _CMP_NGE_UQ 
  26: OP := _CMP_NGT_UQ 
  27: OP := _CMP_FALSE_OS 
  28: OP := _CMP_NEQ_OS 
  29: OP := _CMP_GE_OQ
  30: OP := _CMP_GT_OQ
  31: OP := _CMP_TRUE_US
ESAC

RETURN ( a[63:0] OP b[63:0] ) ? 1 : 0
	</description>
	<mnemonic base="vcomisd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_comi_round_ss / vcomiss -->
<intrinsic tech="AVX-512" rettype="int" name="_mm_comi_round_ss">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="imm" type="const int"/>
	<parameter varname="sae" type="const int"/>
	<description>Compare the lower single-precision (32-bit) floating-point element in "a" and "b" based on the comparison operand specified by "imm", and return the boolean result (0 or 1).
	Pass __MM_FROUND_NO_EXC to "sae" to suppress all exceptions.</description>
	<description code="true">
CASE (imm) of
  0: OP := _CMP_EQ_OQ
  1: OP := _CMP_LT_OS
  2: OP := _CMP_LE_OS
  3: OP := _CMP_UNORD_Q 
  4: OP := _CMP_NEQ_UQ
  5: OP := _CMP_NLT_US
  6: OP := _CMP_NLE_US
  7: OP := _CMP_ORD_Q
  8: OP := _CMP_EQ_UQ
  9: OP := _CMP_NGE_US
  10: OP := _CMP_NGT_US
  11: OP := _CMP_FALSE_OQ
  12: OP := _CMP_NEQ_OQ
  13: OP := _CMP_GE_OS
  14: OP := _CMP_GT_OS
  15: OP := _CMP_TRUE_UQ
  16: OP := _CMP_EQ_OS
  17: OP := _CMP_LT_OQ
  18: OP := _CMP_LE_OQ
  19: OP := _CMP_UNORD_S
  20: OP := _CMP_NEQ_US
  21: OP := _CMP_NLT_UQ
  22: OP := _CMP_NLE_UQ
  23: OP := _CMP_ORD_S
  24: OP := _CMP_EQ_US
  25: OP := _CMP_NGE_UQ 
  26: OP := _CMP_NGT_UQ 
  27: OP := _CMP_FALSE_OS 
  28: OP := _CMP_NEQ_OS 
  29: OP := _CMP_GE_OQ
  30: OP := _CMP_GT_OQ
  31: OP := _CMP_TRUE_US
ESAC

RETURN ( a[31:0] OP b[31:0] ) ? 1 : 0
	</description>
	<mnemonic base="vcomiss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_compress_pd / vcompresspd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_compress_pd">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="src" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<description>Contiguously store the active double-precision (64-bit) floating-point elements in "a" (those with their respective bit set in writemask "k") to "dst", and pass through the remaining elements from "src".</description>
	<description code="true">
size := 64
m := 0
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[m+size-1:m] := a[i+63:i]
		m := m + size
	FI
ENDFOR
dst[511:m] := src[511:m]
dst[MAX:512] := 0
	</description>
	<mnemonic base="vcompresspd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_compressstoreu_pd / vcompresspd -->
<intrinsic tech="AVX-512" rettype="void" name="_mm512_mask_compressstoreu_pd">
	<CPUID>AVX-512</CPUID>
	<category>Store</category>
	<category>Swizzle</category>
	<parameter varname="base_addr" type="void*"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<description>Contiguously store the active double-precision (64-bit) floating-point elements in "a" (those with their respective bit set in writemask "k") to unaligned memory at "base_addr".</description>
	<description code="true">
size := 64
m := base_addr
FOR j := 0 to 7
	i := j*64
	IF k[j]
		MEM[m+size-1:m] := a[i+63:i]
		m := m + size
	FI
ENDFOR
	</description>
	<mnemonic base="vcompresspd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_compress_pd / vcompresspd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_compress_pd">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<description>Contiguously store the active double-precision (64-bit) floating-point elements in "a" (those with their respective bit set in zeromask "k") to "dst", and set the remaining elements to zero.</description>
	<description code="true">
size := 64
m := 0
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[m+size-1:m] := a[i+63:i]
		m := m + size
	FI
ENDFOR
dst[511:m] := 0
dst[MAX:512] := 0
	</description>
	<mnemonic base="vcompresspd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_compress_ps / vcompressps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_compress_ps">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="src" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<description>Contiguously store the active single-precision (32-bit) floating-point elements in "a" (those with their respective bit set in writemask "k") to "dst", and pass through the remaining elements from "src".</description>
	<description code="true">
size := 32
m := 0
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[m+size-1:m] := a[i+31:i]
		m := m + size
	FI
ENDFOR
dst[511:m] := src[511:m]
dst[MAX:512] := 0
	</description>
	<mnemonic base="vcompressps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_compressstoreu_ps / vcompressps -->
<intrinsic tech="AVX-512" rettype="void" name="_mm512_mask_compressstoreu_ps">
	<CPUID>AVX-512</CPUID>
	<category>Store</category>
	<category>Swizzle</category>
	<parameter varname="base_addr" type="void*"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<description>Contiguously store the active single-precision (32-bit) floating-point elements in "a" (those with their respective bit set in writemask "k") to unaligned memory at "base_addr".</description>
	<description code="true">
size := 32
m := base_addr
FOR j := 0 to 15
	i := j*32
	IF k[j]
		MEM[m+size-1:m] := a[i+31:i]
		m := m + size
	FI
ENDFOR
	</description>
	<mnemonic base="vcompressps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_compress_ps / vcompressps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_compress_ps">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<description>Contiguously store the active single-precision (32-bit) floating-point elements in "a" (those with their respective bit set in zeromask "k") to "dst", and set the remaining elements to zero.</description>
	<description code="true">
size := 32
m := 0
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[m+size-1:m] := a[i+31:i]
		m := m + size
	FI
ENDFOR
dst[511:m] := 0
dst[MAX:512] := 0
	</description>
	<mnemonic base="vcompressps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cvtepi32_pd / vcvtdq2pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_cvtepi32_pd">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m256i"/>
	<description>Convert packed 32-bit integers in "a" to packed double-precision (64-bit) floating-point elements, and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 7
	i := j*32
	m := j*64
	dst[m+63:m] := Convert_Int32_To_FP64(a[i+31:i])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vcvtdq2pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvtepi32_pd / vcvtdq2pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_cvtepi32_pd">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="src" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m256i"/>
	<description>Convert packed 32-bit integers in "a" to packed double-precision (64-bit) floating-point elements, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := j*32
	m := j*64
	IF k[j]
		dst[m+63:m] := Convert_Int32_To_FP64(a[i+31:i])
	ELSE
		dst[m+63:m] := src[m+63:m]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vcvtdq2pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_cvtepi32_pd / vcvtdq2pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_cvtepi32_pd">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m256i"/>
	<description>Convert packed 32-bit integers in "a" to packed double-precision (64-bit) floating-point elements, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 7
	i := j*32
	m := j*64
	IF k[j]
		dst[m+63:m] := Convert_Int32_To_FP64(a[i+31:i])
	ELSE
		dst[m+63:m] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vcvtdq2pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cvt_roundepi32_ps / vcvtdq2ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_cvt_roundepi32_ps">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert packed 32-bit integers in "a" to packed single-precision (32-bit) floating-point elements, and store the results in "dst".
	[round_note]
	</description>
	<description code="true">
FOR j := 0 to 15
	i := 32*j
	dst[i+31:i] := Convert_Int32_To_FP32(a[i+31:i])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vcvtdq2ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cvtepi32_ps / vcvtdq2ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_cvtepi32_ps">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m512i"/>
	<description>Convert packed 32-bit integers in "a" to packed single-precision (32-bit) floating-point elements, and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 15
	i := 32*j
	dst[i+31:i] := Convert_Int32_To_FP32(a[i+31:i])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vcvtdq2ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvt_roundepi32_ps / vcvtdq2ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_cvt_roundepi32_ps">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="src" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert packed 32-bit integers in "a" to packed single-precision (32-bit) floating-point elements, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). 
	[round_note]
	</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := Convert_Int32_To_FP32(a[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vcvtdq2ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvtepi32_ps / vcvtdq2ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_cvtepi32_ps">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="src" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<description>Convert packed 32-bit integers in "a" to packed single-precision (32-bit) floating-point elements, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := Convert_Int32_To_FP32(a[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vcvtdq2ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_cvt_roundepi32_ps / vcvtdq2ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_cvt_roundepi32_ps">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert packed 32-bit integers in "a" to packed single-precision (32-bit) floating-point elements, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).
	[round_note]
	</description>
	<description code="true">
FOR j := 0 to 15
	i := 32*j
	IF k[j]
		dst[i+31:i] := Convert_Int32_To_FP32(a[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vcvtdq2ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_cvtepi32_ps / vcvtdq2ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_cvtepi32_ps">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<description>Convert packed 32-bit integers in "a" to packed single-precision (32-bit) floating-point elements, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 15
	i := 32*j
	IF k[j]
		dst[i+31:i] := Convert_Int32_To_FP32(a[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vcvtdq2ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cvt_roundpd_epi32 / vcvtpd2dq -->
<intrinsic tech="AVX-512" rettype="__m256i" name="_mm512_cvt_roundpd_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert packed double-precision (64-bit) floating-point elements in "a" to packed 32-bit integers, and store the results in "dst".
	[round_note]
	</description>
	<description code="true">
FOR j := 0 to 7
	i := 32*j
	k := 64*j
	dst[i+31:i] := Convert_FP64_To_Int32(a[k+63:k])
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base="vcvtpd2dq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cvtpd_epi32 / vcvtpd2dq -->
<intrinsic tech="AVX-512" rettype="__m256i" name="_mm512_cvtpd_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m512d"/>
	<description>Convert packed double-precision (64-bit) floating-point elements in "a" to packed 32-bit integers, and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 7
	i := 32*j
	k := 64*j
	dst[i+31:i] := Convert_FP64_To_Int32(a[k+63:k])
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base="vcvtpd2dq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvt_roundpd_epi32 / vcvtpd2dq -->
<intrinsic tech="AVX-512" rettype="__m256i" name="_mm512_mask_cvt_roundpd_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="src" type="__m256i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert packed double-precision (64-bit) floating-point elements in "a" to packed 32-bit integers, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). 
	[round_note]
	</description>
	<description code="true">
FOR j := 0 to 7
	i := j*32
	l := j*64
	IF k[j]
		dst[i+31:i] := Convert_FP64_To_Int32(a[l+63:l])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base="vcvtpd2dq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvtpd_epi32 / vcvtpd2dq -->
<intrinsic tech="AVX-512" rettype="__m256i" name="_mm512_mask_cvtpd_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="src" type="__m256i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<description>Convert packed double-precision (64-bit) floating-point elements in "a" to packed 32-bit integers, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := j*32
	l := j*64
	IF k[j]
		dst[i+31:i] := Convert_FP64_To_Int32(a[l+63:l])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base="vcvtpd2dq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_cvt_roundpd_epi32 / vcvtpd2dq -->
<intrinsic tech="AVX-512" rettype="__m256i" name="_mm512_maskz_cvt_roundpd_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert packed double-precision (64-bit) floating-point elements in "a" to packed 32-bit integers, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).
	[round_note]
	</description>
	<description code="true">
FOR j := 0 to 7
	i := 32*j
	l := 64*j
	IF k[j]
		dst[i+31:i] := Convert_FP64_To_Int32(a[l+63:l])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base="vcvtpd2dq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_cvtpd_epi32 / vcvtpd2dq -->
<intrinsic tech="AVX-512" rettype="__m256i" name="_mm512_maskz_cvtpd_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<description>Convert packed double-precision (64-bit) floating-point elements in "a" to packed 32-bit integers, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 7
	i := 32*j
	l := 64*j
	IF k[j]
		dst[i+31:i] := Convert_FP64_To_Int32(a[l+63:l])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base="vcvtpd2dq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cvt_roundpd_ps / vcvtpd2ps -->
<intrinsic tech="AVX-512" rettype="__m256" name="_mm512_cvt_roundpd_ps">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert packed double-precision (64-bit) floating-point elements in "a" to packed single-precision (32-bit) floating-point elements, and store the results in "dst".
	[round_note]
	</description>
	<description code="true">
FOR j := 0 to 7
	i := 32*j
	k := 64*j
	dst[i+31:i] := Convert_FP64_To_FP32(a[k+63:k])
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base="vcvtpd2ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cvtpd_ps / vcvtpd2ps -->
<intrinsic tech="AVX-512" rettype="__m256" name="_mm512_cvtpd_ps">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m512d"/>
	<description>Convert packed double-precision (64-bit) floating-point elements in "a" to packed single-precision (32-bit) floating-point elements, and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 7
	i := 32*j
	k := 64*j
	dst[i+31:i] := Convert_FP64_To_FP32(a[k+63:k])
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base="vcvtpd2ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvt_roundpd_ps / vcvtpd2ps -->
<intrinsic tech="AVX-512" rettype="__m256" name="_mm512_mask_cvt_roundpd_ps">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="src" type="__m256"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert packed double-precision (64-bit) floating-point elements in "a" to packed single-precision (32-bit) floating-point elements, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). 
	[round_note]
	</description>
	<description code="true">
FOR j := 0 to 7
	i := j*32
	l := j*64
	IF k[j]
		dst[i+31:i] := Convert_FP64_To_FP32(a[l+63:l])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base="vcvtpd2ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvtpd_ps / vcvtpd2ps -->
<intrinsic tech="AVX-512" rettype="__m256" name="_mm512_mask_cvtpd_ps">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="src" type="__m256"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<description>Convert packed double-precision (64-bit) floating-point elements in "a" to packed single-precision (32-bit) floating-point elements, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := 32*j
	l := 64*j
	IF k[j]
		dst[i+31:i] := Convert_FP64_To_FP32(a[l+63:l])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base="vcvtpd2ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_cvt_roundpd_ps / vcvtpd2ps -->
<intrinsic tech="AVX-512" rettype="__m256" name="_mm512_maskz_cvt_roundpd_ps">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert packed double-precision (64-bit) floating-point elements in "a" to packed single-precision (32-bit) floating-point elements, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). 
	[round_note]
	</description>
	<description code="true">
FOR j := 0 to 7
	i := j*32
	l := j*64
	IF k[j]
		dst[i+31:i] := Convert_FP64_To_FP32(a[l+63:l])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base="vcvtpd2ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_cvtpd_ps / vcvtpd2ps -->
<intrinsic tech="AVX-512" rettype="__m256" name="_mm512_maskz_cvtpd_ps">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<description>Convert packed double-precision (64-bit) floating-point elements in "a" to packed single-precision (32-bit) floating-point elements, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 7
	i := j*32
	l := j*64
	IF k[j]
		dst[i+31:i] := Convert_FP64_To_FP32(a[l+63:l])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base="vcvtpd2ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cvt_roundpd_epu32 / vcvtpd2udq -->
<intrinsic tech="AVX-512" rettype="__m256i" name="_mm512_cvt_roundpd_epu32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert packed double-precision (64-bit) floating-point elements in "a" to packed unsigned 32-bit integers, and store the results in "dst".
	[round_note]
	</description>
	<description code="true">
FOR j := 0 to 7
	i := 32*j
	k := 64*j
	dst[i+31:i] := Convert_FP64_To_UnsignedInt32(a[k+63:k])
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base="vcvtpd2udq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cvtpd_epu32 / vcvtpd2udq -->
<intrinsic tech="AVX-512" rettype="__m256i" name="_mm512_cvtpd_epu32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m512d"/>
	<description>Convert packed double-precision (64-bit) floating-point elements in "a" to packed unsigned 32-bit integers, and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 7
	i := 32*j
	k := 64*j
	dst[i+31:i] := Convert_FP64_To_UnsignedInt32(a[k+63:k])
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base="vcvtpd2udq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvt_roundpd_epu32 / vcvtpd2udq -->
<intrinsic tech="AVX-512" rettype="__m256i" name="_mm512_mask_cvt_roundpd_epu32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="src" type="__m256i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert packed double-precision (64-bit) floating-point elements in "a" to packed unsigned 32-bit integers, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). 
	[round_note]
	</description>
	<description code="true">
FOR j := 0 to 7
	i := j*32
	l := j*64
	IF k[j]
		dst[i+31:i] := Convert_FP64_To_UnsignedInt32(a[l+63:l])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base="vcvtpd2udq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvtpd_epu32 / vcvtpd2udq -->
<intrinsic tech="AVX-512" rettype="__m256i" name="_mm512_mask_cvtpd_epu32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="src" type="__m256i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<description>Convert packed double-precision (64-bit) floating-point elements in "a" to packed unsigned 32-bit integers, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := j*32
	l := j*64
	IF k[j]
		dst[i+31:i] := Convert_FP64_To_UnsignedInt32(a[l+63:l])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base="vcvtpd2udq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_cvt_roundpd_epu32 / vcvtpd2udq -->
<intrinsic tech="AVX-512" rettype="__m256i" name="_mm512_maskz_cvt_roundpd_epu32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert packed double-precision (64-bit) floating-point elements in "a" to packed unsigned 32-bit integers, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).
	[round_note]
	</description>
	<description code="true">
FOR j := 0 to 7
	i := 32*j
	l := 64*j
	IF k[j]
		dst[i+31:i] := Convert_FP64_To_UnsignedInt32(a[l+63:l])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base="vcvtpd2udq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_cvtpd_epu32 / vcvtpd2udq -->
<intrinsic tech="AVX-512" rettype="__m256i" name="_mm512_maskz_cvtpd_epu32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<description>Convert packed double-precision (64-bit) floating-point elements in "a" to packed unsigned 32-bit integers, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 7
	i := 32*j
	l := 64*j
	IF k[j]
		dst[i+31:i] := Convert_FP64_To_UnsignedInt32(a[l+63:l])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base="vcvtpd2udq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cvt_roundph_ps / vcvtph2ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_cvt_roundph_ps">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m256i"/>
	<parameter varname="sae" type="int"/>
	<description>Convert packed half-precision (16-bit) floating-point elements in "a" to packed single-precision (32-bit) floating-point elements, and store the results in "dst". 
	Pass __MM_FROUND_NO_EXC to "sae" to suppress all exceptions.
	</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	m := j*16
	dst[i+31:i] := Convert_FP16_To_FP32(a[m+15:m])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vcvtph2ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cvtph_ps / vcvtph2ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_cvtph_ps">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m256i"/>
	<description>Convert packed half-precision (16-bit) floating-point elements in "a" to packed single-precision (32-bit) floating-point elements, and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	m := j*16
	dst[i+31:i] := Convert_FP16_To_FP32(a[m+15:m])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vcvtph2ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvt_roundph_ps / vcvtph2ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_cvt_roundph_ps">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="src" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m256i"/>
	<parameter varname="sae" type="int"/>
	<description>Convert packed half-precision (16-bit) floating-point elements in "a" to packed single-precision (32-bit) floating-point elements, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). 
	Pass __MM_FROUND_NO_EXC to "sae" to suppress all exceptions.</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	m := j*16
	IF k[j]
		dst[i+31:i] := Convert_FP16_To_FP32(a[m+15:m])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vcvtph2ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvtph_ps / vcvtph2ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_cvtph_ps">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="src" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m256i"/>
	<description>Convert packed half-precision (16-bit) floating-point elements in "a" to packed single-precision (32-bit) floating-point elements, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	m := j*16
	IF k[j]
		dst[i+31:i] := Convert_FP16_To_FP32(a[m+15:m])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vcvtph2ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_cvt_roundph_ps / vcvtph2ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_cvt_roundph_ps">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m256i"/>
	<parameter varname="sae" type="int"/>
	<description>Convert packed half-precision (16-bit) floating-point elements in "a" to packed single-precision (32-bit) floating-point elements, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). 
	Pass __MM_FROUND_NO_EXC to "sae" to suppress all exceptions.
	</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	m := j*16
	IF k[j]
		dst[i+31:i] := Convert_FP16_To_FP32(a[m+15:m])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vcvtph2ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_cvtph_ps / vcvtph2ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_cvtph_ps">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m256i"/>
	<description>Convert packed half-precision (16-bit) floating-point elements in "a" to packed single-precision (32-bit) floating-point elements, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	m := j*16
	IF k[j]
		dst[i+31:i] := Convert_FP16_To_FP32(a[m+15:m])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vcvtph2ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cvt_roundps_epi32 / vcvtps2dq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_cvt_roundps_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert packed single-precision (32-bit) floating-point elements in "a" to packed 32-bit integers, and store the results in "dst". 
	[round_note]
	</description>
	<description code="true">
FOR j := 0 to 15
	i := 32*j
	dst[i+31:i] := Convert_FP32_To_Int32(a[i+31:i])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vcvtps2dq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cvtps_epi32 / vcvtps2dq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_cvtps_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m512"/>
	<description>Convert packed single-precision (32-bit) floating-point elements in "a" to packed 32-bit integers, and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 15
	i := 32*j
	dst[i+31:i] := Convert_FP32_To_Int32(a[i+31:i])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vcvtps2dq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvt_roundps_epi32 / vcvtps2dq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_cvt_roundps_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert packed single-precision (32-bit) floating-point elements in "a" to packed 32-bit integers, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). 
	[round_note]
	</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := Convert_FP32_To_Int32(a[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vcvtps2dq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvtps_epi32 / vcvtps2dq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_cvtps_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<description>Convert packed single-precision (32-bit) floating-point elements in "a" to packed 32-bit integers, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := Convert_FP32_To_Int32(a[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vcvtps2dq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_cvt_roundps_epi32 / vcvtps2dq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_cvt_roundps_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert packed single-precision (32-bit) floating-point elements in "a" to packed 32-bit integers, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). 
	[round_note]
	</description>
	<description code="true">
FOR j := 0 to 15
	i := 32*j
	IF k[j]
		dst[i+31:i] := Convert_FP32_To_Int32(a[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vcvtps2dq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_cvtps_epi32 / vcvtps2dq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_cvtps_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<description>Convert packed single-precision (32-bit) floating-point elements in "a" to packed 32-bit integers, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := 32*j
	IF k[j]
		dst[i+31:i] := Convert_FP32_To_Int32(a[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vcvtps2dq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cvt_roundps_pd / vcvtps2pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_cvt_roundps_pd">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m256"/>
	<parameter varname="sae" type="int"/>
	<description>Convert packed single-precision (32-bit) floating-point elements in "a" to packed double-precision (64-bit) floating-point elements, and store the results in "dst".
	Pass __MM_FROUND_NO_EXC to "sae" to suppress all exceptions.
	</description>
	<description code="true">
FOR j := 0 to 7
	i := 64*j
	k := 32*j
	dst[i+63:i] := Convert_FP32_To_FP64(a[k+31:k])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vcvtps2pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cvtps_pd / vcvtps2pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_cvtps_pd">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m256"/>
	<description>Convert packed single-precision (32-bit) floating-point elements in "a" to packed double-precision (64-bit) floating-point elements, and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 7
	i := 64*j
	k := 32*j
	dst[i+63:i] := Convert_FP32_To_FP64(a[k+31:k])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vcvtps2pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvt_roundps_pd / vcvtps2pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_cvt_roundps_pd">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="src" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m256"/>
	<parameter varname="sae" type="int"/>
	<description>Convert packed single-precision (32-bit) floating-point elements in "a" to packed double-precision (64-bit) floating-point elements, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). 
	Pass __MM_FROUND_NO_EXC to "sae" to suppress all exceptions.
	</description>
	<description code="true">
FOR j := 0 to 7
	i := 64*j
	l := 32*j
	IF k[j]
		dst[i+63:i] := Convert_FP32_To_FP64(a[l+31:l])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vcvtps2pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvtps_pd / vcvtps2pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_cvtps_pd">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="src" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m256"/>
	<description>Convert packed single-precision (32-bit) floating-point elements in "a" to packed double-precision (64-bit) floating-point elements, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := 64*j
	l := 32*j
	IF k[j]
		dst[i+63:i] := Convert_FP32_To_FP64(a[l+31:l])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vcvtps2pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_cvt_roundps_pd / vcvtps2pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_cvt_roundps_pd">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m256"/>
	<parameter varname="sae" type="int"/>
	<description>Convert packed single-precision (32-bit) floating-point elements in "a" to packed double-precision (64-bit) floating-point elements, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).
	Pass __MM_FROUND_NO_EXC to "sae" to suppress all exceptions.
	</description>
	<description code="true">
FOR j := 0 to 7
	i := 64*j
	l := 32*j
	IF k[j]
		dst[i+63:i] := Convert_FP32_To_FP64(a[l+31:l])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vcvtps2pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_cvtps_pd / vcvtps2pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_cvtps_pd">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m256"/>
	<description>Convert packed single-precision (32-bit) floating-point elements in "a" to packed double-precision (64-bit) floating-point elements, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 7
	i := 64*j
	l := 32*j
	IF k[j]
		dst[i+63:i] := Convert_FP32_To_FP64(a[l+31:l])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vcvtps2pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cvt_roundps_ph / vcvtps2ph -->
<intrinsic tech="AVX-512" rettype="__m256i" name="_mm512_cvt_roundps_ph">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert packed single-precision (32-bit) floating-point elements in "a" to packed half-precision (16-bit) floating-point elements, and store the results in "dst".
	[round_note]
	</description>
	<description code="true">
FOR j := 0 to 15
	i := 16*j
	l := 32*j
	dst[i+15:i] := Convert_FP32_To_FP16FP(a[l+31:l])
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base="vcvtps2ph"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cvtps_ph / vcvtps2ph -->
<intrinsic tech="AVX-512" rettype="__m256i" name="_mm512_cvtps_ph">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert packed single-precision (32-bit) floating-point elements in "a" to packed half-precision (16-bit) floating-point elements, and store the results in "dst".
	[round_note]
	</description>
	<description code="true">
FOR j := 0 to 15
	i := 16*j
	l := 32*j
	dst[i+15:i] := Convert_FP32_To_FP16FP(a[l+31:l])
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base="vcvtps2ph"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvt_roundps_ph / vcvtps2ph -->
<intrinsic tech="AVX-512" rettype="__m256i" name="_mm512_mask_cvt_roundps_ph">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="src" type="__m256i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert packed single-precision (32-bit) floating-point elements in "a" to packed half-precision (16-bit) floating-point elements, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). 
	[round_note]
	</description>
	<description code="true">
FOR j := 0 to 15
	i := 16*j
	l := 32*j
	IF k[j]
		dst[i+15:i] := Convert_FP32_To_FP16FP(a[l+31:l])
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base="vcvtps2ph"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvtps_ph / vcvtps2ph -->
<intrinsic tech="AVX-512" rettype="__m256i" name="_mm512_mask_cvtps_ph">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="src" type="__m256i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert packed single-precision (32-bit) floating-point elements in "a" to packed half-precision (16-bit) floating-point elements, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). 
	[round_note]
	</description>
	<description code="true">
FOR j := 0 to 15
	i := 16*j
	l := 32*j
	IF k[j]
		dst[i+15:i] := Convert_FP32_To_FP16FP(a[l+31:l])
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base="vcvtps2ph"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_cvt_roundps_ph / vcvtps2ph -->
<intrinsic tech="AVX-512" rettype="__m256i" name="_mm512_maskz_cvt_roundps_ph">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert packed single-precision (32-bit) floating-point elements in "a" to packed half-precision (16-bit) floating-point elements, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).
	[round_note]
	</description>
	<description code="true">
FOR j := 0 to 15
	i := 16*j
	l := 32*j
	IF k[j]
		dst[i+15:i] := Convert_FP32_To_FP16FP(a[l+31:l])
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base="vcvtps2ph"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_cvtps_ph / vcvtps2ph -->
<intrinsic tech="AVX-512" rettype="__m256i" name="_mm512_maskz_cvtps_ph">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert packed single-precision (32-bit) floating-point elements in "a" to packed half-precision (16-bit) floating-point elements, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).
	[round_note]
	</description>
	<description code="true">
FOR j := 0 to 15
	i := 16*j
	l := 32*j
	IF k[j]
		dst[i+15:i] := Convert_FP32_To_FP16FP(a[l+31:l])
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base="vcvtps2ph"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cvt_roundps_epu32 / vcvtps2udq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_cvt_roundps_epu32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert packed single-precision (32-bit) floating-point elements in "a" to packed unsigned 32-bit integers, and store the results in "dst". 
	[round_note]
	</description>
	<description code="true">
FOR j := 0 to 15
	i := 32*j
	dst[i+31:i] := Convert_FP32_To_UnsignedInt32(a[i+31:i])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vcvtps2udq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cvtps_epu32 / vcvtps2udq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_cvtps_epu32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m512"/>
	<description>Convert packed single-precision (32-bit) floating-point elements in "a" to packed unsigned 32-bit integers, and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 15
	i := 32*j
	dst[i+31:i] := Convert_FP32_To_UnsignedInt32(a[i+31:i])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vcvtps2udq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvt_roundps_epu32 / vcvtps2udq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_cvt_roundps_epu32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert packed single-precision (32-bit) floating-point elements in "a" to packed unsigned 32-bit integers, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). 
	[round_note]
	</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := Convert_FP32_To_UnsignedInt32(a[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vcvtps2udq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvtps_epu32 / vcvtps2udq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_cvtps_epu32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<description>Convert packed single-precision (32-bit) floating-point elements in "a" to packed unsigned 32-bit integers, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 15
	i := 32*j
	IF k[j]
		dst[i+31:i] := Convert_FP32_To_UnsignedInt32(a[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vcvtps2udq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_cvt_roundps_epu32 / vcvtps2udq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_cvt_roundps_epu32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert packed single-precision (32-bit) floating-point elements in "a" to packed unsigned 32-bit integers, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). 
	[round_note]
	</description>
	<description code="true">
FOR j := 0 to 15
	i := 32*j
	IF k[j]
		dst[i+31:i] := Convert_FP32_To_UnsignedInt32(a[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vcvtps2udq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_cvtps_epu32 / vcvtps2udq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_cvtps_epu32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<description>Convert packed single-precision (32-bit) floating-point elements in "a" to packed unsigned 32-bit integers, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 15
	i := 32*j
	IF k[j]
		dst[i+31:i] := Convert_FP32_To_UnsignedInt32(a[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vcvtps2udq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_cvt_roundsd_i32 / vcvtsd2si -->
<intrinsic tech="AVX-512" rettype="int" name="_mm_cvt_roundsd_i32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert the lower double-precision (64-bit) floating-point element in "a" to a 32-bit integer, and store the result in "dst".
	[round_note]
	</description>
	<description code="true">
dst[31:0] := Convert_FP64_To_Int32(a[63:0])
	</description>
	<mnemonic base="vcvtsd2si"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_cvt_roundsd_i64 / vcvtsd2si -->
<intrinsic tech="AVX-512" rettype="__int64" name="_mm_cvt_roundsd_i64">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert the lower double-precision (64-bit) floating-point element in "a" to a 64-bit integer, and store the result in "dst".
	[round_note]
	</description>
	<description code="true">
dst[63:0] := Convert_FP64_To_Int64(a[63:0])
	</description>
	<mnemonic base="vcvtsd2si"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_cvt_roundsd_si32 / vcvtsd2si -->
<intrinsic tech="AVX-512" rettype="int" name="_mm_cvt_roundsd_si32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert the lower double-precision (64-bit) floating-point element in "a" to a 32-bit integer, and store the result in "dst".
	[round_note]
	</description>
	<description code="true">
dst[31:0] := Convert_FP64_To_Int32(a[63:0])
	</description>
	<mnemonic base="vcvtsd2si"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_cvt_roundsd_si64 / vcvtsd2si -->
<intrinsic tech="AVX-512" rettype="__int64" name="_mm_cvt_roundsd_si64">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert the lower double-precision (64-bit) floating-point element in "a" to a 64-bit integer, and store the result in "dst".
	[round_note]
	</description>
	<description code="true">
dst[63:0] := Convert_FP64_To_Int64(a[63:0])
	</description>
	<mnemonic base="vcvtsd2si"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_cvtsd_i32 / vcvtsd2si -->
<intrinsic tech="AVX-512" rettype="int" name="_mm_cvtsd_i32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m128d"/>
	<description>Convert the lower double-precision (64-bit) floating-point element in "a" to a 32-bit integer, and store the result in "dst".</description>
	<description code="true">
dst[31:0] := Convert_FP64_To_Int32(a[63:0])
	</description>
	<mnemonic base="vcvtsd2si"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_cvtsd_i64 / vcvtsd2si -->
<intrinsic tech="AVX-512" rettype="__int64" name="_mm_cvtsd_i64">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m128d"/>
	<description>Convert the lower double-precision (64-bit) floating-point element in "a" to a 64-bit integer, and store the result in "dst".</description>
	<description code="true">
dst[63:0] := Convert_FP64_To_Int64(a[63:0])
	</description>
	<mnemonic base="vcvtsd2si"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_cvt_roundsd_ss / vcvtsd2ss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_cvt_roundsd_ss">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert the lower double-precision (64-bit) floating-point element in "b" to a single-precision (32-bit) floating-point element, store the result in the lower element of "dst", and copy the upper 3 packed elements from "a" to the upper elements of "dst".
	[round_note]
	</description>
	<description code="true">
dst[31:0] := Convert_FP64_To_FP32(b[63:0])
dst[127:32] := a[127:31]
dst[MAX:64] := 0
	</description>
	<mnemonic base="vcvtsd2ss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_cvt_roundsd_ss / vcvtsd2ss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_mask_cvt_roundsd_ss">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="src" type="__m128"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert the lower double-precision (64-bit) floating-point element in "b" to a single-precision (32-bit) floating-point element, store the result in the lower element of "dst" using writemask "k" (the element is copied from "src" when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst".
	[round_note]
	</description>
	<description code="true">
IF k[0]
	dst[31:0] := Convert_FP64_To_FP32(b[63:0])
ELSE
	dst[31:0] := src[31:0]
FI
dst[127:32] := a[127:31]
dst[MAX:64] := 0
	</description>
	<mnemonic base="vcvtsd2ss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_cvtsd_ss / vcvtsd2ss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_mask_cvtsd_ss">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="src" type="__m128"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128d"/>
	<description>Convert the lower double-precision (64-bit) floating-point element in "b" to a single-precision (32-bit) floating-point element, store the result in the lower element of "dst" using writemask "k" (the element is copied from "src" when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst".
	</description>
	<description code="true">
IF k[0]
	dst[31:0] := Convert_FP64_To_FP32(b[63:0])
ELSE
	dst[31:0] := src[31:0]
FI
dst[127:32] := a[127:31]
dst[MAX:64] := 0
	</description>
	<mnemonic base="vcvtsd2ss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_cvt_roundsd_ss / vcvtsd2ss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_maskz_cvt_roundsd_ss">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert the lower double-precision (64-bit) floating-point element in "b" to a single-precision (32-bit) floating-point element, store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from "a" to the upper elements of "dst". 
	[round_note]
	</description>
	<description code="true">
IF k[0]
	dst[31:0] := Convert_FP64_To_FP32(b[63:0])
ELSE
	dst[31:0] := 0
FI
dst[127:32] := a[127:31]
dst[MAX:64] := 0
	</description>
	<mnemonic base="vcvtsd2ss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_cvtsd_ss / vcvtsd2ss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_maskz_cvtsd_ss">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128d"/>
	<description>Convert the lower double-precision (64-bit) floating-point element in "b" to a single-precision (32-bit) floating-point element, store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from "a" to the upper elements of "dst". 
	</description>
	<description code="true">
IF k[0]
	dst[31:0] := Convert_FP64_To_FP32(b[63:0])
ELSE
	dst[31:0] := 0
FI
dst[127:32] := a[127:31]
dst[MAX:64] := 0
	</description>
	<mnemonic base="vcvtsd2ss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_cvt_roundsd_u32 / vcvtsd2usi -->
<intrinsic tech="AVX-512" rettype="unsigned int" name="_mm_cvt_roundsd_u32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert the lower double-precision (64-bit) floating-point element in "a" to an unsigned 32-bit integer, and store the result in "dst".
	[round_note]
	</description>
	<description code="true">
dst[31:0] := Convert_FP64_To_UnsignedInt32(a[63:0])
	</description>
	<mnemonic base="vcvtsd2usi"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_cvt_roundsd_u64 / vcvtsd2usi -->
<intrinsic tech="AVX-512" rettype="unsigned __int64" name="_mm_cvt_roundsd_u64">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert the lower double-precision (64-bit) floating-point element in "a" to an unsigned 64-bit integer, and store the result in "dst".
	[round_note]
	</description>
	<description code="true">
dst[63:0] := Convert_FP64_To_UnsignedInt64(a[63:0])
	</description>
	<mnemonic base="vcvtsd2usi"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_cvtsd_u32 / vcvtsd2usi -->
<intrinsic tech="AVX-512" rettype="unsigned int" name="_mm_cvtsd_u32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m128d"/>
	<description>Convert the lower double-precision (64-bit) floating-point element in "a" to an unsigned 32-bit integer, and store the result in "dst".</description>
	<description code="true">
dst[31:0] := Convert_FP64_To_UnsignedInt32(a[63:0])
	</description>
	<mnemonic base="vcvtsd2usi"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_cvtsd_u64 / vcvtsd2usi -->
<intrinsic tech="AVX-512" rettype="unsigned __int64" name="_mm_cvtsd_u64">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m128d"/>
	<description>Convert the lower double-precision (64-bit) floating-point element in "a" to an unsigned 64-bit integer, and store the result in "dst".</description>
	<description code="true">
dst[63:0] := Convert_FP64_To_UnsignedInt64(a[63:0])
	</description>
	<mnemonic base="vcvtsd2usi"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_cvt_roundi64_sd / vcvtsi2sd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_cvt_roundi64_sd">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__int64"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert the 64-bit integer "b" to a double-precision (64-bit) floating-point element, store the result in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst". 
	[round_note]
	</description>
	<description code="true">
dst[63:0] := Convert_Int64_To_FP64(b[63:0])
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vcvtsi2sd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_cvt_roundsi64_sd / vcvtsi2sd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_cvt_roundsi64_sd">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__int64"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert the 64-bit integer "b" to a double-precision (64-bit) floating-point element, store the result in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst". 
	[round_note]
	</description>
	<description code="true">
dst[63:0] := Convert_Int64_To_FP64(b[63:0])
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vcvtsi2sd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_cvti32_sd / vcvtsi2sd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_cvti32_sd">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="int"/>
	<description>Convert the 32-bit integer "b" to a double-precision (64-bit) floating-point element, store the result in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst". </description>
	<description code="true">
dst[63:0] := Convert_Int32_To_FP64(b[31:0])
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vcvtsi2sd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_cvti64_sd / vcvtsi2sd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_cvti64_sd">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__int64"/>
	<description>Convert the 64-bit integer "b" to a double-precision (64-bit) floating-point element, store the result in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst". </description>
	<description code="true">
dst[63:0] := Convert_Int64_To_FP64(b[63:0])
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vcvtsi2sd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_cvt_roundi32_ss / vcvtsi2ss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_cvt_roundi32_ss">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="int"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert the 32-bit integer "b" to a single-precision (32-bit) floating-point element, store the result in the lower element of "dst", and copy the upper 3 packed elements from "a" to the upper elements of "dst". 
	[round_note]
	</description>
	<description code="true">
dst[31:0] := Convert_Int32_To_FP32(b[31:0])
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vcvtsi2ss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_cvt_roundi64_ss / vcvtsi2ss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_cvt_roundi64_ss">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__int64"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert the 64-bit integer "b" to a single-precision (32-bit) floating-point element, store the result in the lower element of "dst", and copy the upper 3 packed elements from "a" to the upper elements of "dst". 
	[round_note]
	</description>
	<description code="true">
dst[31:0] := Convert_Int64_To_FP32(b[63:0])
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vcvtsi2ss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_cvt_roundsi32_ss / vcvtsi2ss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_cvt_roundsi32_ss">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="int"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert the 32-bit integer "b" to a single-precision (32-bit) floating-point element, store the result in the lower element of "dst", and copy the upper 3 packed elements from "a" to the upper elements of "dst". 
	[round_note]
	</description>
	<description code="true">
dst[31:0] := Convert_Int32_To_FP32(b[31:0])
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vcvtsi2ss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_cvt_roundsi64_ss / vcvtsi2ss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_cvt_roundsi64_ss">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__int64"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert the 64-bit integer "b" to a single-precision (32-bit) floating-point element, store the result in the lower element of "dst", and copy the upper 3 packed elements from "a" to the upper elements of "dst". 
	[round_note]
	</description>
	<description code="true">
dst[31:0] := Convert_Int64_To_FP32(b[63:0])
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vcvtsi2ss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_cvti32_ss / vcvtsi2ss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_cvti32_ss">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="int"/>
	<description>Convert the 32-bit integer "b" to a single-precision (32-bit) floating-point element, store the result in the lower element of "dst", and copy the upper 3 packed elements from "a" to the upper elements of "dst".</description>
	<description code="true">
dst[31:0] := Convert_Int32_To_FP32(b[31:0])
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vcvtsi2ss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_cvti64_ss / vcvtsi2ss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_cvti64_ss">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__int64"/>
	<description>Convert the 64-bit integer "b" to a single-precision (32-bit) floating-point element, store the result in the lower element of "dst", and copy the upper 3 packed elements from "a" to the upper elements of "dst".</description>
	<description code="true">
dst[31:0] := Convert_Int64_To_FP32(b[63:0])
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vcvtsi2ss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_cvt_roundss_sd / vcvtss2sd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_cvt_roundss_sd">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert the lower single-precision (32-bit) floating-point element in "b" to a double-precision (64-bit) floating-point element, store the result in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst". 
	[round_note]
	</description>
	<description code="true">
dst[63:0] := Convert_FP32_To_FP64(b[31:0])
dst[127:64] := a[127:64]
dst[MAX:64] := 0
	</description>
	<mnemonic base="vcvtss2sd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_cvt_roundss_sd / vcvtss2sd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_mask_cvt_roundss_sd">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="src" type="__m128d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert the lower single-precision (32-bit) floating-point element in "b" to a double-precision (64-bit) floating-point element, store the result in the lower element of "dst" using writemask "k" (the element is copied from "src" when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst".
	[round_note]
	</description>
	<description code="true">
IF k[0]
	dst[63:0] := Convert_FP32_To_FP64(b[31:0])
ELSE
	dst[63:0] := src[63:0]
FI
dst[127:64] := a[127:64]
dst[MAX:64] := 0
	</description>
	<mnemonic base="vcvtss2sd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_cvtss_sd / vcvtss2sd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_mask_cvtss_sd">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="src" type="__m128d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128"/>
	<description>Convert the lower single-precision (32-bit) floating-point element in "b" to a double-precision (64-bit) floating-point element, store the result in the lower element of "dst" using writemask "k" (the element is copied from "src" when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst".
	</description>
	<description code="true">
IF k[0]
	dst[63:0] := Convert_FP32_To_FP64(b[31:0])
ELSE
	dst[63:0] := src[63:0]
FI
dst[127:64] := a[127:64]
dst[MAX:64] := 0
	</description>
	<mnemonic base="vcvtss2sd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_cvt_roundss_sd / vcvtss2sd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_maskz_cvt_roundss_sd">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert the lower single-precision (32-bit) floating-point element in "b" to a double-precision (64-bit) floating-point element, store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst". 
	[round_note]
	</description>
	<description code="true">
IF k[0]
	dst[63:0] := Convert_FP32_To_FP64(b[31:0])
ELSE
	dst[63:0] := 0
FI
dst[127:64] := a[127:64]
dst[MAX:64] := 0
	</description>
	<mnemonic base="vcvtss2sd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_cvtss_sd / vcvtss2sd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_maskz_cvtss_sd">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128"/>
	<description>Convert the lower single-precision (32-bit) floating-point element in "b" to a double-precision (64-bit) floating-point element, store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst".</description>
	<description code="true">
IF k[0]
	dst[63:0] := Convert_FP32_To_FP64(b[31:0])
ELSE
	dst[63:0] := 0
FI
dst[127:64] := a[127:64]
dst[MAX:64] := 0
	</description>
	<mnemonic base="vcvtss2sd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_cvt_roundss_i32 / vcvtss2si -->
<intrinsic tech="AVX-512" rettype="int" name="_mm_cvt_roundss_i32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert the lower single-precision (32-bit) floating-point element in "a" to a 32-bit integer, and store the result in "dst".
	[round_note]
	</description>
	<description code="true">
dst[31:0] := Convert_FP32_To_Int32(a[31:0])
	</description>
	<mnemonic base="vcvtss2si"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_cvt_roundss_i64 / vcvtss2si -->
<intrinsic tech="AVX-512" rettype="__int64" name="_mm_cvt_roundss_i64">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert the lower single-precision (32-bit) floating-point element in "a" to a 64-bit integer, and store the result in "dst".
	[round_note]
	</description>
	<description code="true">
dst[63:0] := Convert_FP32_To_Int64(a[31:0])
	</description>
	<mnemonic base="vcvtss2si"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_cvt_roundss_si32 / vcvtss2si -->
<intrinsic tech="AVX-512" rettype="int" name="_mm_cvt_roundss_si32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert the lower single-precision (32-bit) floating-point element in "a" to a 32-bit integer, and store the result in "dst".
	[round_note]
	</description>
	<description code="true">
dst[31:0] := Convert_FP32_To_Int32(a[31:0])
	</description>
	<mnemonic base="vcvtss2si"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_cvt_roundss_si64 / vcvtss2si -->
<intrinsic tech="AVX-512" rettype="__int64" name="_mm_cvt_roundss_si64">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert the lower single-precision (32-bit) floating-point element in "a" to a 64-bit integer, and store the result in "dst".
	[round_note]
	</description>
	<description code="true">
dst[63:0] := Convert_FP32_To_Int64(a[31:0])
	</description>
	<mnemonic base="vcvtss2si"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_cvtss_i32 / vcvtss2si -->
<intrinsic tech="AVX-512" rettype="int" name="_mm_cvtss_i32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m128"/>
	<description>Convert the lower single-precision (32-bit) floating-point element in "a" to a 32-bit integer, and store the result in "dst".</description>
	<description code="true">
dst[31:0] := Convert_FP32_To_Int32(a[31:0])
	</description>
	<mnemonic base="vcvtss2si"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_cvtss_i64 / vcvtss2si -->
<intrinsic tech="AVX-512" rettype="__int64" name="_mm_cvtss_i64">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m128"/>
	<description>Convert the lower single-precision (32-bit) floating-point element in "a" to a 64-bit integer, and store the result in "dst".</description>
	<description code="true">
dst[63:0] := Convert_FP32_To_Int64(a[31:0])
	</description>
	<mnemonic base="vcvtss2si"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_cvt_roundss_u32 / vcvtss2usi -->
<intrinsic tech="AVX-512" rettype="unsigned int" name="_mm_cvt_roundss_u32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert the lower single-precision (32-bit) floating-point element in "a" to an unsigned 32-bit integer, and store the result in "dst".
	[round_note]
	</description>
	<description code="true">
dst[31:0] := Convert_FP32_To_UnsignedInt32(a[31:0])
	</description>
	<mnemonic base="vcvtss2usi"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_cvt_roundss_u64 / vcvtss2usi -->
<intrinsic tech="AVX-512" rettype="unsigned __int64" name="_mm_cvt_roundss_u64">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert the lower single-precision (32-bit) floating-point element in "a" to an unsigned 64-bit integer, and store the result in "dst".
	[round_note]
	</description>
	<description code="true">
dst[63:0] := Convert_FP32_To_UnsignedInt64(a[31:0])
	</description>
	<mnemonic base="vcvtss2usi"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_cvtss_u32 / vcvtss2usi -->
<intrinsic tech="AVX-512" rettype="unsigned int" name="_mm_cvtss_u32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m128"/>
	<description>Convert the lower single-precision (32-bit) floating-point element in "a" to an unsigned 32-bit integer, and store the result in "dst".</description>
	<description code="true">
dst[31:0] := Convert_FP32_To_UnsignedInt32(a[31:0])
	</description>
	<mnemonic base="vcvtss2usi"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_cvtss_u64 / vcvtss2usi -->
<intrinsic tech="AVX-512" rettype="unsigned __int64" name="_mm_cvtss_u64">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m128"/>
	<description>Convert the lower single-precision (32-bit) floating-point element in "a" to an unsigned 64-bit integer, and store the result in "dst".</description>
	<description code="true">
dst[63:0] := Convert_FP32_To_UnsignedInt64(a[31:0])
	</description>
	<mnemonic base="vcvtss2usi"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cvtt_roundpd_epi32 / vcvttpd2dq -->
<intrinsic tech="AVX-512" rettype="__m256i" name="_mm512_cvtt_roundpd_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="sae" type="int"/>
	<description>Convert packed double-precision (64-bit) floating-point elements in "a" to packed 32-bit integers with truncation, and store the results in "dst". 
	Pass __MM_FROUND_NO_EXC to "sae" to suppress all exceptions.</description>
	<description code="true">
FOR j := 0 to 7
	i := 32*i
	k := 64*j
	dst[i+31:i] := Convert_FP64_To_IntegerTruncate(a[k+63:k])
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base="vcvttpd2dq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cvttpd_epi32 / vcvttpd2dq -->
<intrinsic tech="AVX-512" rettype="__m256i" name="_mm512_cvttpd_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m512d"/>
	<description>Convert packed double-precision (64-bit) floating-point elements in "a" to packed 32-bit integers with truncation, and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 7
	i := 32*j
	k := 64*j
	dst[i+31:i] := Convert_FP64_To_Int32_Truncate(a[k+63:k])
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base="vcvttpd2dq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvtt_roundpd_epi32 / vcvttpd2dq -->
<intrinsic tech="AVX-512" rettype="__m256i" name="_mm512_mask_cvtt_roundpd_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="src" type="__m256i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="sae" type="int"/>
	<description>Convert packed double-precision (64-bit) floating-point elements in "a" to packed 32-bit integers with truncation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).  Pass __MM_FROUND_NO_EXC to "sae" to suppress all exceptions.</description>
	<description code="true">
FOR j := 0 to 7
	i := 32*i
	l := 64*j
	IF k[j]
		dst[i+31:i] := Convert_FP64_To_IntegerTruncate(a[l+63:l])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base="vcvttpd2dq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvttpd_epi32 / vcvttpd2dq -->
<intrinsic tech="AVX-512" rettype="__m256i" name="_mm512_mask_cvttpd_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="src" type="__m256i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<description>Convert packed double-precision (64-bit) floating-point elements in "a" to packed 32-bit integers with truncation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := 32*j
	l := 64*j
	IF k[j]
		dst[i+31:i] := Convert_FP64_To_Int32_Truncate(a[l+63:l])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base="vcvttpd2dq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_cvtt_roundpd_epi32 / vcvttpd2dq -->
<intrinsic tech="AVX-512" rettype="__m256i" name="_mm512_maskz_cvtt_roundpd_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="sae" type="int"/>
	<description>Convert packed double-precision (64-bit) floating-point elements in "a" to packed 32-bit integers with truncation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). 
	Pass __MM_FROUND_NO_EXC to "sae" to suppress all exceptions.</description>
	<description code="true">
FOR j := 0 to 7
	i := 32*i
	l := 64*j
	IF k[j]
		dst[i+31:i] := Convert_FP64_To_IntegerTruncate(a[l+63:l])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</description>

	<mnemonic base="vcvttpd2dq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_cvttpd_epi32 / vcvttpd2dq -->
<intrinsic tech="AVX-512" rettype="__m256i" name="_mm512_maskz_cvttpd_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<description>Convert packed double-precision (64-bit) floating-point elements in "a" to packed 32-bit integers with truncation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 7
	i := 32*j
	l := 64*j
	IF k[j]
		dst[i+31:i] := Convert_FP64_To_Int32_Truncate(a[l+63:l])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base="vcvttpd2dq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cvtt_roundpd_epu32 / vcvttpd2udq -->
<intrinsic tech="AVX-512" rettype="__m256i" name="_mm512_cvtt_roundpd_epu32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="sae" type="int"/>
	<description>Convert packed double-precision (64-bit) floating-point elements in "a" to packed unsigned 32-bit integers with truncation, and store the results in "dst". 
	Pass __MM_FROUND_NO_EXC to "sae" to suppress all exceptions.</description>
	<description code="true">
FOR j := 0 to 7
	i := 32*i
	k := 64*j
	dst[i+31:i] := Convert_FP64_To_UnsignedIntegerTruncate(a[k+63:k])
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base="vcvttpd2udq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cvttpd_epu32 / vcvttpd2udq -->
<intrinsic tech="AVX-512" rettype="__m256i" name="_mm512_cvttpd_epu32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m512d"/>
	<description>Convert packed double-precision (64-bit) floating-point elements in "a" to packed unsigned 32-bit integers with truncation, and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 7
	i := 32*j
	k := 64*j
	dst[i+31:i] := Convert_FP64_To_UnsignedInt32_Truncate(a[k+63:k])
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base="vcvttpd2udq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvtt_roundpd_epu32 / vcvttpd2udq -->
<intrinsic tech="AVX-512" rettype="__m256i" name="_mm512_mask_cvtt_roundpd_epu32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="src" type="__m256i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="sae" type="int"/>
	<description>Convert packed double-precision (64-bit) floating-point elements in "a" to packed unsigned 32-bit integers with truncation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).  
	Pass __MM_FROUND_NO_EXC to "sae" to suppress all exceptions.</description>
	<description code="true">
FOR j := 0 to 7
	i := 32*i
	l := 64*j
	IF k[j]
		dst[i+31:i] := Convert_FP64_To_UnsignedIntegerTruncate(a[l+63:l])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base="vcvttpd2udq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvttpd_epu32 / vcvttpd2udq -->
<intrinsic tech="AVX-512" rettype="__m256i" name="_mm512_mask_cvttpd_epu32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="src" type="__m256i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<description>Convert packed double-precision (64-bit) floating-point elements in "a" to packed unsigned 32-bit integers with truncation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := 32*j
	l := 64*j
	IF k[j]
		dst[i+31:i] := Convert_FP64_To_UnsignedInt32_Truncate(a[l+63:l])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base="vcvttpd2udq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_cvtt_roundpd_epu32 / vcvttpd2udq -->
<intrinsic tech="AVX-512" rettype="__m256i" name="_mm512_maskz_cvtt_roundpd_epu32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="sae" type="int"/>
	<description>Convert packed double-precision (64-bit) floating-point elements in "a" to packed unsigned 32-bit integers with truncation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). 
	Pass __MM_FROUND_NO_EXC to "sae" to suppress all exceptions.</description>
	<description code="true">
FOR j := 0 to 7
	i := 32*i
	l := 64*j
	IF k[j]
		dst[i+31:i] := Convert_FP64_To_UnsignedIntegerTruncate(a[l+63:l])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base="vcvttpd2udq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_cvttpd_epu32 / vcvttpd2udq -->
<intrinsic tech="AVX-512" rettype="__m256i" name="_mm512_maskz_cvttpd_epu32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<description>Convert packed double-precision (64-bit) floating-point elements in "a" to packed unsigned 32-bit integers with truncation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 7
	i := 32*j
	l := 64*j
	IF k[j]
		dst[i+31:i] := Convert_FP64_To_UnsignedInt32_Truncate(a[l+63:l])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base="vcvttpd2udq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cvtt_roundps_epi32 / vcvttps2dq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_cvtt_roundps_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="sae" type="int"/>
	<description>Convert packed single-precision (32-bit) floating-point elements in "a" to packed 32-bit integers with truncation, and store the results in "dst". 
	Pass __MM_FROUND_NO_EXC to "sae" to suppress all exceptions.</description>
	<description code="true">
FOR j := 0 to 15
	i := 32*i
	dst[i+31:i] := Convert_FP32_To_IntegerTruncate(a[i+31:i])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vcvttps2dq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cvttps_epi32 / vcvttps2dq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_cvttps_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m512"/>
	<description>Convert packed single-precision (32-bit) floating-point elements in "a" to packed 32-bit integers with truncation, and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 15
	i := 32*j
	dst[i+31:i] := Convert_FP32_To_Int32_Truncate(a[i+31:i])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vcvttps2dq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvtt_roundps_epi32 / vcvttps2dq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_cvtt_roundps_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="sae" type="int"/>
	<description>Convert packed single-precision (32-bit) floating-point elements in "a" to packed 32-bit integers with truncation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). 
	Pass __MM_FROUND_NO_EXC to "sae" to suppress all exceptions. </description>
	<description code="true">
FOR j := 0 to 15
	i := 32*i
	IF k[j]
		dst[i+31:i] := Convert_FP32_To_IntegerTruncate(a[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vcvttps2dq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvttps_epi32 / vcvttps2dq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_cvttps_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<description>Convert packed single-precision (32-bit) floating-point elements in "a" to packed 32-bit integers with truncation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := 32*j
	IF k[j]
		dst[i+31:i] := Convert_FP32_To_Int32_Truncate(a[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vcvttps2dq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_cvtt_roundps_epi32 / vcvttps2dq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_cvtt_roundps_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="sae" type="int"/>
	<description>Convert packed single-precision (32-bit) floating-point elements in "a" to packed 32-bit integers with truncation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). 
	Pass __MM_FROUND_NO_EXC to "sae" to suppress all exceptions.</description>
	<description code="true">
FOR j := 0 to 15
	i := 32*i
	IF k[j]
		dst[i+31:i] := Convert_FP32_To_IntegerTruncate(a[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vcvttps2dq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_cvttps_epi32 / vcvttps2dq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_cvttps_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<description>Convert packed single-precision (32-bit) floating-point elements in "a" to packed 32-bit integers with truncation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 15
	i := 32*j
	IF k[j]
		dst[i+31:i] := Convert_FP32_To_Int32_Truncate(a[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vcvttps2dq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cvtt_roundps_epu32 / vcvttps2udq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_cvtt_roundps_epu32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="sae" type="int"/>
	<description>Convert packed single-precision (32-bit) floating-point elements in "a" to packed unsigned 32-bit integers with truncation, and store the results in "dst". 
	Pass __MM_FROUND_NO_EXC to "sae" to suppress all exceptions.</description>
	<description code="true">
FOR j := 0 to 15
	i := 32*i
	dst[i+31:i] := Convert_FP32_To_UnsignedIntegerTruncate(a[i+31:i])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vcvttps2udq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cvttps_epu32 / vcvttps2udq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_cvttps_epu32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m512"/>
	<description>Convert packed single-precision (32-bit) floating-point elements in "a" to packed unsigned 32-bit integers with truncation, and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 15
	i := 32*j
	dst[i+31:i] := Convert_FP32_To_UnsignedInt32_Truncate(a[i+31:i])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vcvttps2udq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvtt_roundps_epu32 / vcvttps2udq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_cvtt_roundps_epu32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="sae" type="int"/>
	<description>Convert packed single-precision (32-bit) floating-point elements in "a" to packed unsigned 32-bit integers with truncation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).  
	Pass __MM_FROUND_NO_EXC to "sae" to suppress all exceptions.</description>
	<description code="true">
FOR j := 0 to 15
	i := 32*i
	IF k[j]
		dst[i+31:i] := Convert_FP32_To_UnsignedIntegerTruncate(a[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vcvttps2udq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvttps_epu32 / vcvttps2udq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_cvttps_epu32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<description>Convert packed double-precision (32-bit) floating-point elements in "a" to packed unsigned 32-bit integers with truncation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := 32*j
	IF k[j]
		dst[i+31:i] := Convert_FP64_To_UnsignedInt32_Truncate(a[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vcvttps2udq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_cvtt_roundps_epu32 / vcvttps2udq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_cvtt_roundps_epu32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="sae" type="int"/>
	<description>Convert packed single-precision (32-bit) floating-point elements in "a" to packed unsigned 32-bit integers with truncation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). 
	Pass __MM_FROUND_NO_EXC to "sae" to suppress all exceptions.</description>
	<description code="true">
FOR j := 0 to 15
	i := 32*i
	IF k[j]
		dst[i+31:i] := Convert_FP32_To_UnsignedIntegerTruncate(a[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>

	<mnemonic base="vcvttps2udq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_cvttps_epu32 / vcvttps2udq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_cvttps_epu32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<description>Convert packed double-precision (32-bit) floating-point elements in "a" to packed unsigned 32-bit integers with truncation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 15
	i := 32*j
	IF k[j]
		dst[i+31:i] := Convert_FP64_To_UnsignedInt32_Truncate(a[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vcvttps2udq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_cvtt_roundsd_i32 / vcvttsd2si -->
<intrinsic tech="AVX-512" rettype="int" name="_mm_cvtt_roundsd_i32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert the lower double-precision (64-bit) floating-point element in "a" to a 32-bit integer with truncation, and store the result in "dst".
	[round_note]
	</description>
	<description code="true">
dst[31:0] := Convert_FP64_To_Int32_Truncate(a[63:0])
	</description>
	<mnemonic base="vcvttsd2si"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_cvtt_roundsd_i64 / vcvttsd2si -->
<intrinsic tech="AVX-512" rettype="__int64" name="_mm_cvtt_roundsd_i64">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert the lower double-precision (64-bit) floating-point element in "a" to a 64-bit integer with truncation, and store the result in "dst".
	[round_note]
	</description>
	<description code="true">
dst[63:0] := Convert_FP64_To_Int64_Truncate(a[63:0])
	</description>
	<mnemonic base="vcvttsd2si"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_cvtt_roundsd_si32 / vcvttsd2si -->
<intrinsic tech="AVX-512" rettype="int" name="_mm_cvtt_roundsd_si32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert the lower double-precision (64-bit) floating-point element in "a" to a 32-bit integer with truncation, and store the result in "dst".
	[round_note]
	</description>
	<description code="true">
dst[31:0] := Convert_FP64_To_Int32_Truncate(a[63:0])
	</description>
	<mnemonic base="vcvttsd2si"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_cvtt_roundsd_si64 / vcvttsd2si -->
<intrinsic tech="AVX-512" rettype="__int64" name="_mm_cvtt_roundsd_si64">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert the lower double-precision (64-bit) floating-point element in "a" to a 64-bit integer with truncation, and store the result in "dst".
	[round_note]
	</description>
	<description code="true">
dst[63:0] := Convert_FP64_To_Int64_Truncate(a[63:0])
	</description>
	<mnemonic base="vcvttsd2si"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_cvttsd_i32 / vcvttsd2si -->
<intrinsic tech="AVX-512" rettype="int" name="_mm_cvttsd_i32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m128d"/>
	<description>Convert the lower double-precision (64-bit) floating-point element in "a" to a 32-bit integer with truncation, and store the result in "dst".</description>
	<description code="true">
dst[31:0] := Convert_FP64_To_Int32_Truncate(a[63:0])
	</description>
	<mnemonic base="vcvttsd2si"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_cvttsd_i64 / vcvttsd2si -->
<intrinsic tech="AVX-512" rettype="__int64" name="_mm_cvttsd_i64">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m128d"/>
	<description>Convert the lower double-precision (64-bit) floating-point element in "a" to a 64-bit integer with truncation, and store the result in "dst".</description>
	<description code="true">
dst[63:0] := Convert_FP64_To_Int64_Truncate(a[63:0])
	</description>
	<mnemonic base="vcvttsd2si"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_cvtt_roundsd_u32 / vcvttsd2usi -->
<intrinsic tech="AVX-512" rettype="unsigned int" name="_mm_cvtt_roundsd_u32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert the lower double-precision (64-bit) floating-point element in "a" to an unsigned 32-bit integer with truncation, and store the result in "dst".
	[round_note]
	</description>
	<description code="true">
dst[31:0] := Convert_FP64_To_UnsignedInt32_Truncate(a[63:0])
	</description>
	<mnemonic base="vcvttsd2usi"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_cvtt_roundsd_u64 / vcvttsd2usi -->
<intrinsic tech="AVX-512" rettype="unsigned __int64" name="_mm_cvtt_roundsd_u64">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert the lower double-precision (64-bit) floating-point element in "a" to an unsigned 64-bit integer with truncation, and store the result in "dst".
	[round_note]
	</description>
	<description code="true">
dst[63:0] := Convert_FP64_To_UnsignedInt64_Truncate(a[63:0])
	</description>
	<mnemonic base="vcvttsd2usi"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_cvttsd_u32 / vcvttsd2usi -->
<intrinsic tech="AVX-512" rettype="unsigned int" name="_mm_cvttsd_u32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m128d"/>
	<description>Convert the lower double-precision (64-bit) floating-point element in "a" to an unsigned 32-bit integer with truncation, and store the result in "dst".</description>
	<description code="true">
dst[31:0] := Convert_FP64_To_UnsignedInt32_Truncate(a[63:0])
	</description>
	<mnemonic base="vcvttsd2usi"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_cvttsd_u64 / vcvttsd2usi -->
<intrinsic tech="AVX-512" rettype="unsigned __int64" name="_mm_cvttsd_u64">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m128d"/>
	<description>Convert the lower double-precision (64-bit) floating-point element in "a" to an unsigned 64-bit integer with truncation, and store the result in "dst".</description>
	<description code="true">
dst[63:0] := Convert_FP64_To_UnsignedInt64_Truncate(a[63:0])
	</description>
	<mnemonic base="vcvttsd2usi"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_cvtt_roundss_i32 / vcvttss2si -->
<intrinsic tech="AVX-512" rettype="int" name="_mm_cvtt_roundss_i32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert the lower single-precision (32-bit) floating-point element in "a" to a 32-bit integer with truncation, and store the result in "dst".
	[round_note]
	</description>
	<description code="true">
dst[31:0] := Convert_FP32_To_Int32_Truncate(a[31:0])
	</description>
	<mnemonic base="vcvttss2si"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_cvtt_roundss_i64 / vcvttss2si -->
<intrinsic tech="AVX-512" rettype="__int64" name="_mm_cvtt_roundss_i64">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert the lower single-precision (32-bit) floating-point element in "a" to a 64-bit integer with truncation, and store the result in "dst".
	[round_note]
	</description>
	<description code="true">
dst[63:0] := Convert_FP32_To_Int64_Truncate(a[31:0])
	</description>
	<mnemonic base="vcvttss2si"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_cvtt_roundss_si32 / vcvttss2si -->
<intrinsic tech="AVX-512" rettype="int" name="_mm_cvtt_roundss_si32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert the lower single-precision (32-bit) floating-point element in "a" to a 32-bit integer with truncation, and store the result in "dst".
	[round_note]
	</description>
	<description code="true">
dst[31:0] := Convert_FP32_To_Int32_Truncate(a[31:0])
	</description>
	<mnemonic base="vcvttss2si"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_cvtt_roundss_si64 / vcvttss2si -->
<intrinsic tech="AVX-512" rettype="__int64" name="_mm_cvtt_roundss_si64">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert the lower single-precision (32-bit) floating-point element in "a" to a 64-bit integer with truncation, and store the result in "dst".
	[round_note]
	</description>
	<description code="true">
dst[63:0] := Convert_FP32_To_Int64_Truncate(a[31:0])
	</description>
	<mnemonic base="vcvttss2si"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_cvttss_i32 / vcvttss2si -->
<intrinsic tech="AVX-512" rettype="int" name="_mm_cvttss_i32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m128"/>
	<description>Convert the lower single-precision (32-bit) floating-point element in "a" to a 32-bit integer with truncation, and store the result in "dst".</description>
	<description code="true">
dst[31:0] := Convert_FP32_To_Int32_Truncate(a[31:0])
	</description>
	<mnemonic base="vcvttss2si"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_cvttss_i64 / vcvttss2si -->
<intrinsic tech="AVX-512" rettype="__int64" name="_mm_cvttss_i64">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m128"/>
	<description>Convert the lower single-precision (32-bit) floating-point element in "a" to a 64-bit integer with truncation, and store the result in "dst".</description>
	<description code="true">
dst[63:0] := Convert_FP32_To_Int64_Truncate(a[31:0])
	</description>
	<mnemonic base="vcvttss2si"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_cvtt_roundss_u32 / vcvttss2usi -->
<intrinsic tech="AVX-512" rettype="unsigned int" name="_mm_cvtt_roundss_u32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert the lower single-precision (32-bit) floating-point element in "a" to an unsigned 32-bit integer with truncation, and store the result in "dst".
	[round_note]
	</description>
	<description code="true">
dst[31:0] := Convert_FP32_To_UnsignedInt32_Truncate(a[31:0])
	</description>
	<mnemonic base="vcvttss2usi"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_cvtt_roundss_u64 / vcvttss2usi -->
<intrinsic tech="AVX-512" rettype="unsigned __int64" name="_mm_cvtt_roundss_u64">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert the lower single-precision (32-bit) floating-point element in "a" to an unsigned 64-bit integer with truncation, and store the result in "dst".
	[round_note]
	</description>
	<description code="true">
dst[63:0] := Convert_FP32_To_UnsignedInt64_Truncate(a[31:0])
	</description>
	<mnemonic base="vcvttss2usi"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_cvttss_u32 / vcvttss2usi -->
<intrinsic tech="AVX-512" rettype="unsigned int" name="_mm_cvttss_u32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m128"/>
	<description>Convert the lower single-precision (32-bit) floating-point element in "a" to an unsigned 32-bit integer with truncation, and store the result in "dst".</description>
	<description code="true">
dst[31:0] := Convert_FP32_To_UnsignedInt32_Truncate(a[31:0])
	</description>
	<mnemonic base="vcvttss2usi"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_cvttss_u64 / vcvttss2usi -->
<intrinsic tech="AVX-512" rettype="unsigned __int64" name="_mm_cvttss_u64">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m128"/>
	<description>Convert the lower single-precision (32-bit) floating-point element in "a" to an unsigned 64-bit integer with truncation, and store the result in "dst".</description>
	<description code="true">
dst[63:0] := Convert_FP32_To_UnsignedInt64_Truncate(a[31:0])
	</description>
	<mnemonic base="vcvttss2usi"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cvtepu32_pd / vcvtudq2pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_cvtepu32_pd">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m256i"/>
	<description>Convert packed unsigned 32-bit integers in "a" to packed double-precision (64-bit) floating-point elements, and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	l := j*32
	dst[i+63:i] := ConvertUnsignedIntegerTo_FP64(a[l+31:l])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vcvtudq2pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvtepu32_pd / vcvtudq2pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_cvtepu32_pd">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="src" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m256i"/>
	<description>Convert packed unsigned 32-bit integers in "a" to packed double-precision (64-bit) floating-point elements, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). 
	</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	l := j*32
	IF k[j]
		dst[i+63:i] := ConvertUnsignedIntegerTo_FP64(a[l+31:l])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI	
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vcvtudq2pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_cvtepu32_pd / vcvtudq2pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_cvtepu32_pd">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m256i"/>
	<description>Convert packed unsigned 32-bit integers in "a" to packed double-precision (64-bit) floating-point elements, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	l := j*32
	IF k[j]
		dst[i+63:i] := ConvertUnsignedIntegerTo_FP64(a[l+31:l])
	ELSE
		dst[i+63:i] := 0
	FI	
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vcvtudq2pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cvt_roundepu32_ps / vcvtudq2ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_cvt_roundepu32_ps">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert packed unsigned 32-bit integers in "a" to packed single-precision (32-bit) floating-point elements, and store the results in "dst".
	[round_note]
	</description>
	<description code="true">
FOR j := 0 to 15
	i := 32*j
	dst[i+31:i] := ConvertUnsignedInt32_To_FP32(a[i+31:i])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vcvtudq2ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cvtepu32_ps / vcvtudq2ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_cvtepu32_ps">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m512i"/>
	<description>Convert packed unsigned 32-bit integers in "a" to packed single-precision (32-bit) floating-point elements, and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 15
	i := 32*j
	dst[i+31:i] := ConvertUnsignedInt32_To_FP32(a[i+31:i])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vcvtudq2ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvt_roundepu32_ps / vcvtudq2ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_cvt_roundepu32_ps">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="src" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert packed unsigned 32-bit integers in "a" to packed single-precision (32-bit) floating-point elements, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). 
	[round_note]
	</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := ConvertUnsignedInt32_To_FP32(a[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vcvtudq2ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvtepu32_ps / vcvtudq2ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_cvtepu32_ps">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="src" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<description>Convert packed unsigned 32-bit integers in "a" to packed single-precision (32-bit) floating-point elements, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). 
	</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := ConvertUnsignedInt32_To_FP32(a[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vcvtudq2ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_cvt_roundepu32_ps / vcvtudq2ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_cvt_roundepu32_ps">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert packed unsigned 32-bit integers in "a" to packed single-precision (32-bit) floating-point elements, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).
	[round_note]
	</description>
	<description code="true">
FOR j := 0 to 15
	i := 32*j
	IF k[j]
		dst[i+31:i] := ConvertUnsignedInt32_To_FP32(a[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vcvtudq2ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_cvtepu32_ps / vcvtudq2ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_cvtepu32_ps">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<description>Convert packed unsigned 32-bit integers in "a" to packed single-precision (32-bit) floating-point elements, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).
	</description>
	<description code="true">
FOR j := 0 to 15
	i := 32*j
	IF k[j]
		dst[i+31:i] := ConvertUnsignedInt32_To_FP32(a[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vcvtudq2ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_cvt_roundu64_sd / vcvtusi2sd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_cvt_roundu64_sd">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="unsigned __int64"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert the unsigned 64-bit integer "b" to a double-precision (64-bit) floating-point element, store the result in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst". 
	[round_note]
	</description>
	<description code="true">
dst[63:0] := Convert_UnsignedInt64_To_FP64(b[63:0])
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vcvtusi2sd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_cvtu32_sd / vcvtusi2sd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_cvtu32_sd">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="unsigned int"/>
	<description>Convert the unsigned 32-bit integer "b" to a double-precision (64-bit) floating-point element, store the result in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst".</description>
	<description code="true">
dst[63:0] := Convert_UnsignedInt32_To_FP64(b[31:0])
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vcvtusi2sd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_cvtu64_sd / vcvtusi2sd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_cvtu64_sd">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="unsigned __int64"/>
	<description>Convert the unsigned 64-bit integer "b" to a double-precision (64-bit) floating-point element, store the result in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst".</description>
	<description code="true">
dst[63:0] := Convert_UnsignedInt64_To_FP64(b[63:0])
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vcvtusi2sd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_cvt_roundu32_ss / vcvtusi2ss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_cvt_roundu32_ss">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="unsigned int"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert the unsigned 32-bit integer "b" to a single-precision (32-bit) floating-point element, store the result in the lower element of "dst", and copy the upper 3 packed elements from "a" to the upper elements of "dst". 
	[round_note]
	</description>
	<description code="true">
dst[31:0] := Convert_UnsignedInt32_To_FP32(b[31:0])
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vcvtusi2ss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_cvt_roundu64_ss / vcvtusi2ss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_cvt_roundu64_ss">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="unsigned __int64"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert the unsigned 64-bit integer "b" to a single-precision (32-bit) floating-point element, store the result in the lower element of "dst", and copy the upper 3 packed elements from "a" to the upper elements of "dst". 
	[round_note]
	</description>
	<description code="true">
dst[31:0] := Convert_UnsignedInt64_To_FP32(b[63:0])
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vcvtusi2ss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_cvtu32_ss / vcvtusi2ss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_cvtu32_ss">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="unsigned int"/>
	<description>Convert the unsigned 32-bit integer "b" to a single-precision (32-bit) floating-point element, store the result in the lower element of "dst", and copy the upper 3 packed elements from "a" to the upper elements of "dst".</description>
	<description code="true">
dst[31:0] := Convert_UnsignedInt32_To_FP32(b[31:0])
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vcvtusi2ss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_cvtu64_ss / vcvtusi2ss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_cvtu64_ss">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="unsigned __int64"/>
	<description>Convert the unsigned 64-bit integer "b" to a single-precision (32-bit) floating-point element, store the result in the lower element of "dst", and copy the upper 3 packed elements from "a" to the upper elements of "dst".</description>
	<description code="true">
dst[31:0] := Convert_UnsignedInt64_To_FP32(b[63:0])
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vcvtusi2ss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_div_pd / vdivpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_div_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<description>Divide packed double-precision (64-bit) floating-point elements in "a" by packed elements in "b", and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 7
	i := 64*j
	dst[i+63:i] := a[i+63:i] / b[i+63:i]
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vdivpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_div_round_pd / vdivpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_div_round_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="rounding" type="int"/>
	<description>Divide packed double-precision (64-bit) floating-point elements in "a" by packed elements in "b", =and store the results in "dst".
	[round_note]
	</description>
	<description code="true">
FOR j := 0 to 7
	i := 64*j
	dst[i+63:i] := a[i+63:i] / b[i+63:i]
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vdivpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_div_pd / vdivpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_div_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="src" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<description>Divide packed double-precision (64-bit) floating-point elements in "a" by packed elements in "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := 64*j
	IF k[j]
		dst[i+63:i] := a[i+63:i] / b[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vdivpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_div_round_pd / vdivpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_div_round_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="src" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="rounding" type="int"/>
	<description>
	Divide packed double-precision (64-bit) floating-point elements in "a" by packed elements in "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).
	[round_note]
	</description>
	<description code="true">
FOR j := 0 to 7
	i := 64*j
	IF k[j]
		dst[i+63:i] := a[i+63:i] / b[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vdivpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_div_pd / vdivpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_div_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<description>Divide packed double-precision (64-bit) floating-point elements in "a" by packed elements in "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 7
	i := 64*j
	IF k[j]
		dst[i+63:i] := a[i+63:i] / b[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vdivpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_div_round_pd / vdivpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_div_round_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="rounding" type="int"/>
	<description>Divide packed double-precision (64-bit) floating-point elements in "a" by packed elements in "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).
	[round_note]
	</description>
	<description code="true">
FOR j := 0 to 7
	i := 64*j
	IF k[j]
		dst[i+63:i] := a[i+63:i] / b[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vdivpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_div_ps / vdivps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_div_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<description>Divide packed single-precision (32-bit) floating-point elements in "a" by packed elements in "b", and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 15
	i := 32*j
	dst[i+31:i] := a[i+31:i] / b[i+31:i]
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vdivps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_div_round_ps / vdivps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_div_round_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="rounding" type="int"/>
	<description>Divide packed single-precision (32-bit) floating-point elements in "a" by packed elements in "b", and store the results in "dst".
	[round_note]
	</description>
	<description code="true">
FOR j := 0 to 15
	i := 32*j
	dst[i+31:i] := a[i+31:i] / b[i+31:i]
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vdivps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_div_ps / vdivps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_div_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="src" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<description>Divide packed single-precision (32-bit) floating-point elements in "a" by packed elements in "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := 32*j
	IF k[j]
		dst[i+31:i] := a[i+31:i] / b[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vdivps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_div_round_ps / vdivps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_div_round_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="src" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="rounding" type="int"/>
	<description>
	Divide packed single-precision (32-bit) floating-point elements in "a" by packed elements in "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).
	[round_note]
	</description>
	<description code="true">
FOR j := 0 to 15
	i := 32*j
	IF k[j]
		dst[i+31:i] := a[i+31:i] / b[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vdivps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_div_ps / vdivps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_div_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<description>Divide packed single-precision (32-bit) floating-point elements in "a" by packed elements in "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 15
	i := 32*j
	IF k[j]
		dst[i+31:i] := a[i+31:i] / b[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>

	<mnemonic base="vdivps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_div_round_ps / vdivps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_div_round_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="rounding" type="int"/>
	<description>Divide packed single-precision (32-bit) floating-point elements in "a" by packed elements in "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).
	[round_note]
	</description>
	<description code="true">
FOR j := 0 to 15
	i := 32*j
	IF k[j]
		dst[i+31:i] := a[i+31:i] / b[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vdivps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_div_round_sd / vdivsd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_div_round_sd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="rounding" type="int"/>
	<description>Divide the lower double-precision (64-bit) floating-point element in "a" by the lower double-precision (64-bit) floating-point element in "b", store the result in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst".
		[round_note]
		</description>
	<description code="true">
dst[63:0] := a[63:0] / b[63:0]
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vdivsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_div_round_sd / vdivsd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_mask_div_round_sd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="src" type="__m128d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="rounding" type="int"/>
	<description>Divide the lower double-precision (64-bit) floating-point element in "a" by the lower double-precision (64-bit) floating-point element in "b", store the result in the lower element of "dst" using writemask "k" (the element is copied from "src" when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst". 
		[round_note]
		</description>
	<description code="true">
IF k[0]
	dst[63:0] := a[63:0] / b[63:0]
ELSE
	dst[63:0] := src[63:0]
FI
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vdivsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_div_sd / vdivsd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_mask_div_sd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="src" type="__m128d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<description>Divide the lower double-precision (64-bit) floating-point element in "a" by the lower double-precision (64-bit) floating-point element in "b", store the result in the lower element of "dst" using writemask "k" (the element is copied from "src" when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst". </description>
	<description code="true">
IF k[0]
	dst[63:0] := a[63:0] / b[63:0]
ELSE
	dst[63:0] := src[63:0]
FI
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vdivsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_div_round_sd / vdivsd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_maskz_div_round_sd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="rounding" type="int"/>
	<description>Divide the lower double-precision (64-bit) floating-point element in "a" by the lower double-precision (64-bit) floating-point element in "b", store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst".
		[round_note]
		</description>
	<description code="true">
IF k[0]
	dst[63:0] := a[63:0] / b[63:0]
ELSE
	dst[63:0] := 0
FI
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vdivsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_div_sd / vdivsd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_maskz_div_sd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<description>Divide the lower double-precision (64-bit) floating-point element in "a" by the lower double-precision (64-bit) floating-point element in "b", store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst".</description>
	<description code="true">
IF k[0]
	dst[63:0] := a[63:0] / b[63:0]
ELSE
	dst[63:0] := 0
FI
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vdivsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_div_round_ss / vdivss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_div_round_ss">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="rounding" type="int"/>
	<description>Divide the lower single-precision (32-bit) floating-point element in "a" by the lower single-precision (32-bit) floating-point element in "b", store the result in the lower element of "dst", and copy the upper 3 packed elements from "a" to the upper elements of "dst".
		[round_note]
		</description>
	<description code="true">
dst[31:0] := a[31:0] / b[31:0]
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vdivss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_div_round_ss / vdivss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_mask_div_round_ss">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="src" type="__m128"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="rounding" type="int"/>
	<description>Divide the lower single-precision (32-bit) floating-point element in "a" by the lower single-precision (32-bit) floating-point element in "b", store the result in the lower element of "dst" using writemask "k" (the element is copied from "src" when mask bit 0 is not set), and copy the upper 3 packed elements from "a" to the upper elements of "dst". 
		[round_note]
		</description>
	<description code="true">
IF k[0]
	dst[31:0] := a[31:0] / b[31:0]
ELSE
	dst[31:0] := src[31:0]
FI
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vdivss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_div_ss / vdivss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_mask_div_ss">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="src" type="__m128"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<description>Divide the lower single-precision (32-bit) floating-point element in "a" by the lower single-precision (32-bit) floating-point element in "b", store the result in the lower element of "dst" using writemask "k" (the element is copied from "src" when mask bit 0 is not set), and copy the upper 3 packed elements from "a" to the upper elements of "dst". </description>
	<description code="true">
IF k[0]
	dst[31:0] := a[31:0] / b[31:0]
ELSE
	dst[31:0] := src[31:0]
FI
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vdivss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_div_round_ss / vdivss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_maskz_div_round_ss">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="rounding" type="int"/>
	<description>Divide the lower single-precision (32-bit) floating-point element in "a" by the lower single-precision (32-bit) floating-point element in "b", store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from "a" to the upper elements of "dst".
		[round_note]
		</description>
	<description code="true">
IF k[0]
	dst[31:0] := a[31:0] / b[31:0]
ELSE
	dst[31:0] := 0
FI
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vdivss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_div_ss / vdivss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_maskz_div_ss">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<description>Divide the lower single-precision (32-bit) floating-point element in "a" by the lower single-precision (32-bit) floating-point element in "b", store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from "a" to the upper elements of "dst".</description>
	<description code="true">
IF k[0]
	dst[31:0] := a[31:0] / b[31:0]
ELSE
	dst[31:0] := 0
FI
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vdivss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_expand_pd / vexpandpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_expand_pd">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="src" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<description>Load contiguous active double-precision (64-bit) floating-point elements from "a" (those with their respective bit set in mask "k"), and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<description code="true">
m := 0
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[m+63:m]
		m := m + 64
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vexpandpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_expandloadu_pd / vexpandpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_expandloadu_pd">
	<CPUID>AVX-512</CPUID>
	<category>Load</category>
	<category>Swizzle</category>
	<parameter varname="src" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="mem_addr" type="void const*"/>
	<description>Load contiguous active double-precision (64-bit) floating-point elements from unaligned memory at "mem_addr" (those with their respective bit set in mask "k"), and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<description code="true">
m := 0
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := MEM[mem_addr+m+63:mem_addr+m]
		m := m + 64
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vexpandpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_expand_pd / vexpandpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_expand_pd">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<description>Load contiguous active double-precision (64-bit) floating-point elements from "a" (those with their respective bit set in mask "k"), and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
m := 0
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[m+63:m]
		m := m + 64
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vexpandpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_expandloadu_pd / vexpandpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_expandloadu_pd">
	<CPUID>AVX-512</CPUID>
	<category>Load</category>
	<category>Swizzle</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="mem_addr" type="void const*"/>
	<description>Load contiguous active double-precision (64-bit) floating-point elements from unaligned memory at "mem_addr" (those with their respective bit set in mask "k"), and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
m := 0
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := MEM[mem_addr+m+63:mem_addr+m]
		m := m + 64
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vexpandpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_expand_ps / vexpandps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_expand_ps">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="src" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<description>Load contiguous active single-precision (32-bit) floating-point elements from "a" (those with their respective bit set in mask "k"), and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<description code="true">
m := 0
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := a[m+31:m]
		m := m + 32
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vexpandps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_expandloadu_ps / vexpandps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_expandloadu_ps">
	<CPUID>AVX-512</CPUID>
	<category>Load</category>
	<category>Swizzle</category>
	<parameter varname="src" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="mem_addr" type="void const*"/>
	<description>Load contiguous active single-precision (32-bit) floating-point elements from unaligned memory at "mem_addr" (those with their respective bit set in mask "k"), and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<description code="true">
m := 0
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := MEM[mem_addr+m+31:mem_addr+m]
		m := m + 32
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vexpandps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_expand_ps / vexpandps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_expand_ps">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<description>Load contiguous active single-precision (32-bit) floating-point elements from "a" (those with their respective bit set in mask "k"), and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
m := 0
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := a[m+31:m]
		m := m + 32
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vexpandps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_expandloadu_ps / vexpandps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_expandloadu_ps">
	<CPUID>AVX-512</CPUID>
	<category>Load</category>
	<category>Swizzle</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="mem_addr" type="void const*"/>
	<description>Load contiguous active single-precision (32-bit) floating-point elements from unaligned memory at "mem_addr" (those with their respective bit set in mask "k"), and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
m := 0
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := MEM[mem_addr+m+31:mem_addr+m]
		m := m + 32
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vexpandps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_extractf32x4_ps / vextractf32x4 -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm512_extractf32x4_ps">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="imm" type="int"/>
	<description>Extract 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from "a", selected with "imm", and store the result in "dst".</description>
	<description code="true">
CASE imm of
	0: dst[127:0] := a[127:0]
	1: dst[127:0] := a[255:128]
	2: dst[127:0] := a[383:256]
	3: dst[127:0] := a[511:384]
ESAC
dst[MAX:128] := 0
	</description>	
	<mnemonic base="vextractf32x4"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_extractf32x4_ps / vextractf32x4 -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm512_mask_extractf32x4_ps">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="src" type="__m128"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="imm" type="int"/>
	<description>Extract 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from "a", selected with "imm", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
CASE imm of
	0: tmp[127:0] := a[127:0]
	1: tmp[127:0] := a[255:128]
	2: tmp[127:0] := a[383:256]
	3: tmp[127:0] := a[511:384]
ESAC
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</description>
	<mnemonic base="vextractf32x4"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_extractf32x4_ps / vextractf32x4 -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm512_maskz_extractf32x4_ps">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="imm" type="int"/>
	<description>Extract 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from "a", selected with "imm", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
CASE imm of
	0: tmp[127:0] := a[127:0]
	1: tmp[127:0] := a[255:128]
	2: tmp[127:0] := a[383:256]
	3: tmp[127:0] := a[511:384]
ESAC
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</description>
	<mnemonic base="vextractf32x4"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_extractf64x4_pd / vextractf64x4 -->
<intrinsic tech="AVX-512" rettype="__m256d" name="_mm512_extractf64x4_pd">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="imm" type="int"/>
	<description>Extract 256 bits (composed of 4 packed double-precision (64-bit) floating-point elements) from "a", selected with "imm", and store the result in "dst".</description>
	<description code="true">
CASE imm of
	0: dst[255:0] := a[255:0]
	1: dst[255:0] := a[511:256]
ESAC
dst[MAX:256] := 0
	</description>
	<mnemonic base="vextractf64x4"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_extractf64x4_pd / vextractf64x4 -->
<intrinsic tech="AVX-512" rettype="__m256d" name="_mm512_mask_extractf64x4_pd">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="src" type="__m256d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="imm" type="int"/>
	<description>Extract 256 bits (composed of 4 packed double-precision (64-bit) floating-point elements) from "a", selected with "imm", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
CASE imm of
	0: tmp[255:0] := a[255:0]
	1: tmp[255:0] := a[511:256]
ESAC
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base="vextractf64x4"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_extractf64x4_pd / vextractf64x4 -->
<intrinsic tech="AVX-512" rettype="__m256d" name="_mm512_maskz_extractf64x4_pd">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="imm" type="int"/>
	<description>Extract 256 bits (composed of 4 packed double-precision (64-bit) floating-point elements) from "a", selected with "imm", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
CASE imm of
	0: tmp[255:0] := a[255:0]
	1: tmp[255:0] := a[511:256]
ESAC
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base="vextractf64x4"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_extracti32x4_epi32 / vextracti32x4 -->
<intrinsic tech="AVX-512" rettype="__m128i" name="_mm512_extracti32x4_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="imm" type="int"/>
	<description>Extract 128 bits (composed of 4 packed 32-bit integers) from "a", selected with "imm", and store the result in "dst".</description>
	<description code="true">
CASE imm of
	0: dst[127:0] := a[127:0]
	1: dst[127:0] := a[255:128]
	2: dst[127:0] := a[383:256]
	3: dst[127:0] := a[511:384]
ESAC
dst[MAX:128] := 0
	</description>
	<mnemonic base="vextracti32x4"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_extracti32x4_epi32 / vextracti32x4 -->
<intrinsic tech="AVX-512" rettype="__m128i" name="_mm512_mask_extracti32x4_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="src" type="__m128i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="imm" type="int"/>
	<description>Extract 128 bits (composed of 4 packed 32-bit integers) from "a", selected with "imm", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
CASE imm of
	0: dst[127:0] := a[127:0]
	1: dst[127:0] := a[255:128]
	2: dst[127:0] := a[383:256]
	3: dst[127:0] := a[511:384]
ESAC
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</description>
	<mnemonic base="vextracti32x4"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_extracti32x4_epi32 / vextracti32x4 -->
<intrinsic tech="AVX-512" rettype="__m128i" name="_mm512_maskz_extracti32x4_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="imm" type="int"/>
	<description>Extract 128 bits (composed of 4 packed 32-bit integers) from "a", selected with "imm", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
CASE imm of
	0: dst[127:0] := a[127:0]
	1: dst[127:0] := a[255:128]
	2: dst[127:0] := a[383:256]
	3: dst[127:0] := a[511:384]
ESAC
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</description>
	<mnemonic base="vextracti32x4"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_extracti64x4_epi64 / vextracti64x4 -->
<intrinsic tech="AVX-512" rettype="__m256i" name="_mm512_extracti64x4_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="imm" type="int"/>
	<description>Extract 256 bits (composed of 4 packed 64-bit integers) from "a", selected with "imm", and store the result in "dst".</description>
	<description code="true">
CASE imm of
	0: dst[255:0] := a[255:0]
	1: dst[255:0] := a[511:256]
ESAC
dst[MAX:256] := 0
	</description>
	<mnemonic base="vextracti64x4"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_extracti64x4_epi64 / vextracti64x4 -->
<intrinsic tech="AVX-512" rettype="__m256i" name="_mm512_mask_extracti64x4_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="src" type="__m256i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="imm" type="int"/>
	<description>Extract 256 bits (composed of 4 packed 64-bit integers) from "a", selected with "imm", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
CASE imm of
	0: dst[255:0] := a[255:0]
	1: dst[255:0] := a[511:256]
ESAC
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base="vextracti64x4"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_extracti64x4_epi64 / vextracti64x4 -->
<intrinsic tech="AVX-512" rettype="__m256i" name="_mm512_maskz_extracti64x4_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="imm" type="int"/>
	<description>Extract 256 bits (composed of 4 packed 64-bit integers) from "a", selected with "imm", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
CASE imm of
	0: dst[255:0] := a[255:0]
	1: dst[255:0] := a[511:256]
ESAC
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base="vextracti64x4"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_fixupimm_pd / vfixupimmpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_fixupimm_pd">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="c" type="__m512i"/>
	<parameter varname="imm" type="int"/>
	<description>Fix up packed double-precision (64-bit) floating-point elements in "a" and "b" using packed 64-bit integers in "c", and store the results in "dst". "imm" is used to set the required flags reporting.</description>
	<description code="true">
enum TOKEN_TYPE {
	QNAN_TOKEN := 0, 
	SNAN_TOKEN := 1, 
	ZERO_VALUE_TOKEN := 2, 
	ONE_VALUE_TOKEN := 3, 
	NEG_INF_TOKEN := 4, 
	POS_INF_TOKEN := 5, 
	NEG_VALUE_TOKEN := 6, 
	POS_VALUE_TOKEN := 7
}
FIXUPIMMPD(src1[63:0], src2[63:0], src3[63:0], imm8[7:0]){
	tsrc[63:0] := ((src2[62:52] == 0) AND (MXCSR.DAZ == 1)) ? 0.0 : src2[63:0]
	CASE(tsrc[63:0] of TOKEN_TYPE)
		QNAN_TOKEN:j := 0
		SNAN_TOKEN:j := 1
		ZERO_VALUE_TOKEN: j := 2
		ONE_VALUE_TOKEN: j := 3
		NEG_INF_TOKEN: j := 4
		POS_INF_TOKEN: j := 5
		NEG_VALUE_TOKEN: j := 6
		POS_VALUE_TOKEN: j := 7
	ESAC
	
	token_response[3:0] := src3[3+4*j:4*j]
	
	CASE(token_response[3:0]) of
		0 : dest[63:0] := src1[63:0]
		1 : dest[63:0] := tsrc[63:0]
		2 : dest[63:0] := QNaN(tsrc[63:0])
		3 : dest[63:0] := QNAN_Indefinite
		4 : dest[63:0] := -INF
		5 : dest[63:0] := +INF
		6 : dest[63:0] := tsrc.sign? &#x2013;INF : +INF
		7 : dest[63:0] := -0
		8 : dest[63:0] := +0
		9 : dest[63:0] := -1
		10: dest[63:0] := +1
		11: dest[63:0] := 1&#x2044;2
		12: dest[63:0] := 90.0
		13: dest[63:0] := PI/2
		14: dest[63:0] := MAX_FLOAT
		15: dest[63:0] := -MAX_FLOAT
	ESAC
	
	CASE(tsrc[31:0] of TOKEN_TYPE)
		ZERO_VALUE_TOKEN: if imm8[0] then set #ZE
		ZERO_VALUE_TOKEN: if imm8[1] then set #IE
		ONE_VALUE_TOKEN: if imm8[2] then set #ZE
		ONE_VALUE_TOKEN: if imm8[3] then set #IE
		SNAN_TOKEN: if imm8[4] then set #IE
		NEG_INF_TOKEN: if imm8[5] then set #IE
		NEG_VALUE_TOKEN: if imm8[6] then set #IE
		POS_INF_TOKEN: if imm8[7] then set #IE
	ESAC
	RETURN dest[63:0]
}

FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := FIXUPIMMPD(a[i+63:i], b[i+63:i], c[i+63:i], imm[7:0])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfixupimmpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_fixupimm_round_pd / vfixupimmpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_fixupimm_round_pd">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="c" type="__m512i"/>
	<parameter varname="imm" type="int"/>
	<parameter varname="rounding" type="int"/>
	<description>Fix up packed double-precision (64-bit) floating-point elements in "a" and "b" using packed 64-bit integers in "c", and store the results in "dst". "imm" is used to set the required flags reporting.
	[round_note]
	</description>
	<description code="true">
enum TOKEN_TYPE {
	QNAN_TOKEN := 0, 
	SNAN_TOKEN := 1, 
	ZERO_VALUE_TOKEN := 2, 
	ONE_VALUE_TOKEN := 3, 
	NEG_INF_TOKEN := 4, 
	POS_INF_TOKEN := 5, 
	NEG_VALUE_TOKEN := 6, 
	POS_VALUE_TOKEN := 7
}
FIXUPIMMPD(src1[63:0], src2[63:0], src3[63:0], imm8[7:0]){
	tsrc[63:0] := ((src2[62:52] == 0) AND (MXCSR.DAZ == 1)) ? 0.0 : src2[63:0]
	CASE(tsrc[63:0] of TOKEN_TYPE)
		QNAN_TOKEN:j := 0
		SNAN_TOKEN:j := 1
		ZERO_VALUE_TOKEN: j := 2
		ONE_VALUE_TOKEN: j := 3
		NEG_INF_TOKEN: j := 4
		POS_INF_TOKEN: j := 5
		NEG_VALUE_TOKEN: j := 6
		POS_VALUE_TOKEN: j := 7
	ESAC
	
	token_response[3:0] := src3[3+4*j:4*j]
	
	CASE(token_response[3:0]) of
		0 : dest[63:0] := src1[63:0]
		1 : dest[63:0] := tsrc[63:0]
		2 : dest[63:0] := QNaN(tsrc[63:0])
		3 : dest[63:0] := QNAN_Indefinite
		4 : dest[63:0] := -INF
		5 : dest[63:0] := +INF
		6 : dest[63:0] := tsrc.sign? &#x2013;INF : +INF
		7 : dest[63:0] := -0
		8 : dest[63:0] := +0
		9 : dest[63:0] := -1
		10: dest[63:0] := +1
		11: dest[63:0] := 1&#x2044;2
		12: dest[63:0] := 90.0
		13: dest[63:0] := PI/2
		14: dest[63:0] := MAX_FLOAT
		15: dest[63:0] := -MAX_FLOAT
	ESAC
	
	CASE(tsrc[31:0] of TOKEN_TYPE)
		ZERO_VALUE_TOKEN: if imm8[0] then set #ZE
		ZERO_VALUE_TOKEN: if imm8[1] then set #IE
		ONE_VALUE_TOKEN: if imm8[2] then set #ZE
		ONE_VALUE_TOKEN: if imm8[3] then set #IE
		SNAN_TOKEN: if imm8[4] then set #IE
		NEG_INF_TOKEN: if imm8[5] then set #IE
		NEG_VALUE_TOKEN: if imm8[6] then set #IE
		POS_INF_TOKEN: if imm8[7] then set #IE
	ESAC
	RETURN dest[63:0]
}

FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := FIXUPIMMPD(a[i+63:i], b[i+63:i], c[i+63:i], imm[7:0])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfixupimmpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_fixupimm_pd / vfixupimmpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_fixupimm_pd">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="c" type="__m512i"/>
	<parameter varname="imm" type="int"/>
	<description>Fix up packed double-precision (64-bit) floating-point elements in "a" and "b" using packed 64-bit integers in "c", and store the results in "dst" using writemask "k" (elements are copied from "a" when the corresponding mask bit is not set). "imm" is used to set the required flags reporting.	</description>
	<description code="true">
enum TOKEN_TYPE {
	QNAN_TOKEN := 0, 
	SNAN_TOKEN := 1, 
	ZERO_VALUE_TOKEN := 2, 
	ONE_VALUE_TOKEN := 3, 
	NEG_INF_TOKEN := 4, 
	POS_INF_TOKEN := 5, 
	NEG_VALUE_TOKEN := 6, 
	POS_VALUE_TOKEN := 7
}
FIXUPIMMPD(src1[63:0], src2[63:0], src3[63:0], imm8[7:0]){
	tsrc[63:0] := ((src2[62:52] == 0) AND (MXCSR.DAZ == 1)) ? 0.0 : src2[63:0]
	CASE(tsrc[63:0] of TOKEN_TYPE)
		QNAN_TOKEN:j := 0
		SNAN_TOKEN:j := 1
		ZERO_VALUE_TOKEN: j := 2
		ONE_VALUE_TOKEN: j := 3
		NEG_INF_TOKEN: j := 4
		POS_INF_TOKEN: j := 5
		NEG_VALUE_TOKEN: j := 6
		POS_VALUE_TOKEN: j := 7
	ESAC
	
	token_response[3:0] := src3[3+4*j:4*j]
	
	CASE(token_response[3:0]) of
		0 : dest[63:0] := src1[63:0]
		1 : dest[63:0] := tsrc[63:0]
		2 : dest[63:0] := QNaN(tsrc[63:0])
		3 : dest[63:0] := QNAN_Indefinite
		4 : dest[63:0] := -INF
		5 : dest[63:0] := +INF
		6 : dest[63:0] := tsrc.sign? &#x2013;INF : +INF
		7 : dest[63:0] := -0
		8 : dest[63:0] := +0
		9 : dest[63:0] := -1
		10: dest[63:0] := +1
		11: dest[63:0] := 1&#x2044;2
		12: dest[63:0] := 90.0
		13: dest[63:0] := PI/2
		14: dest[63:0] := MAX_FLOAT
		15: dest[63:0] := -MAX_FLOAT
	ESAC
	
	CASE(tsrc[31:0] of TOKEN_TYPE)
		ZERO_VALUE_TOKEN: if imm8[0] then set #ZE
		ZERO_VALUE_TOKEN: if imm8[1] then set #IE
		ONE_VALUE_TOKEN: if imm8[2] then set #ZE
		ONE_VALUE_TOKEN: if imm8[3] then set #IE
		SNAN_TOKEN: if imm8[4] then set #IE
		NEG_INF_TOKEN: if imm8[5] then set #IE
		NEG_VALUE_TOKEN: if imm8[6] then set #IE
		POS_INF_TOKEN: if imm8[7] then set #IE
	ESAC
	RETURN dest[63:0]
}

FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := FIXUPIMMPD(a[i+63:i], b[i+63:i], c[i+63:i], imm[7:0])
	ELSE
		dst[i+63:i] := a[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfixupimmpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_fixupimm_round_pd / vfixupimmpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_fixupimm_round_pd">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="c" type="__m512i"/>
	<parameter varname="imm" type="int"/>
	<parameter varname="rounding" type="int"/>
	<description>Fix up packed double-precision (64-bit) floating-point elements in "a" and "b" using packed 64-bit integers in "c", and store the results in "dst" using writemask "k" (elements are copied from "a" when the corresponding mask bit is not set). "imm" is used to set the required flags reporting.
	[round_note]
	</description>
	<description code="true">
enum TOKEN_TYPE {
	QNAN_TOKEN := 0, 
	SNAN_TOKEN := 1, 
	ZERO_VALUE_TOKEN := 2, 
	ONE_VALUE_TOKEN := 3, 
	NEG_INF_TOKEN := 4, 
	POS_INF_TOKEN := 5, 
	NEG_VALUE_TOKEN := 6, 
	POS_VALUE_TOKEN := 7
}
FIXUPIMMPD(src1[63:0], src2[63:0], src3[63:0], imm8[7:0]){
	tsrc[63:0] := ((src2[62:52] == 0) AND (MXCSR.DAZ == 1)) ? 0.0 : src2[63:0]
	CASE(tsrc[63:0] of TOKEN_TYPE)
		QNAN_TOKEN:j := 0
		SNAN_TOKEN:j := 1
		ZERO_VALUE_TOKEN: j := 2
		ONE_VALUE_TOKEN: j := 3
		NEG_INF_TOKEN: j := 4
		POS_INF_TOKEN: j := 5
		NEG_VALUE_TOKEN: j := 6
		POS_VALUE_TOKEN: j := 7
	ESAC
	
	token_response[3:0] := src3[3+4*j:4*j]
	
	CASE(token_response[3:0]) of
		0 : dest[63:0] := src1[63:0]
		1 : dest[63:0] := tsrc[63:0]
		2 : dest[63:0] := QNaN(tsrc[63:0])
		3 : dest[63:0] := QNAN_Indefinite
		4 : dest[63:0] := -INF
		5 : dest[63:0] := +INF
		6 : dest[63:0] := tsrc.sign? &#x2013;INF : +INF
		7 : dest[63:0] := -0
		8 : dest[63:0] := +0
		9 : dest[63:0] := -1
		10: dest[63:0] := +1
		11: dest[63:0] := 1&#x2044;2
		12: dest[63:0] := 90.0
		13: dest[63:0] := PI/2
		14: dest[63:0] := MAX_FLOAT
		15: dest[63:0] := -MAX_FLOAT
	ESAC
	
	CASE(tsrc[31:0] of TOKEN_TYPE)
		ZERO_VALUE_TOKEN: if imm8[0] then set #ZE
		ZERO_VALUE_TOKEN: if imm8[1] then set #IE
		ONE_VALUE_TOKEN: if imm8[2] then set #ZE
		ONE_VALUE_TOKEN: if imm8[3] then set #IE
		SNAN_TOKEN: if imm8[4] then set #IE
		NEG_INF_TOKEN: if imm8[5] then set #IE
		NEG_VALUE_TOKEN: if imm8[6] then set #IE
		POS_INF_TOKEN: if imm8[7] then set #IE
	ESAC
	RETURN dest[63:0]
}

FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := FIXUPIMMPD(a[i+63:i], b[i+63:i], c[i+63:i], imm[7:0])
	ELSE
		dst[i+63:i] := a[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfixupimmpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_fixupimm_pd / vfixupimmpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_fixupimm_pd">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="c" type="__m512i"/>
	<parameter varname="imm" type="int"/>
	<description>Fix up packed double-precision (64-bit) floating-point elements in "a" and "b" using packed 64-bit integers in "c", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). "imm" is used to set the required flags reporting.</description>
	<description code="true">
enum TOKEN_TYPE {
	QNAN_TOKEN := 0, 
	SNAN_TOKEN := 1, 
	ZERO_VALUE_TOKEN := 2, 
	ONE_VALUE_TOKEN := 3, 
	NEG_INF_TOKEN := 4, 
	POS_INF_TOKEN := 5, 
	NEG_VALUE_TOKEN := 6, 
	POS_VALUE_TOKEN := 7
}
FIXUPIMMPD(src1[63:0], src2[63:0], src3[63:0], imm8[7:0]){
	tsrc[63:0] := ((src2[62:52] == 0) AND (MXCSR.DAZ == 1)) ? 0.0 : src2[63:0]
	CASE(tsrc[63:0] of TOKEN_TYPE)
		QNAN_TOKEN:j := 0
		SNAN_TOKEN:j := 1
		ZERO_VALUE_TOKEN: j := 2
		ONE_VALUE_TOKEN: j := 3
		NEG_INF_TOKEN: j := 4
		POS_INF_TOKEN: j := 5
		NEG_VALUE_TOKEN: j := 6
		POS_VALUE_TOKEN: j := 7
	ESAC
	
	token_response[3:0] := src3[3+4*j:4*j]
	
	CASE(token_response[3:0]) of
		0 : dest[63:0] := src1[63:0]
		1 : dest[63:0] := tsrc[63:0]
		2 : dest[63:0] := QNaN(tsrc[63:0])
		3 : dest[63:0] := QNAN_Indefinite
		4 : dest[63:0] := -INF
		5 : dest[63:0] := +INF
		6 : dest[63:0] := tsrc.sign? &#x2013;INF : +INF
		7 : dest[63:0] := -0
		8 : dest[63:0] := +0
		9 : dest[63:0] := -1
		10: dest[63:0] := +1
		11: dest[63:0] := 1&#x2044;2
		12: dest[63:0] := 90.0
		13: dest[63:0] := PI/2
		14: dest[63:0] := MAX_FLOAT
		15: dest[63:0] := -MAX_FLOAT
	ESAC
	
	CASE(tsrc[31:0] of TOKEN_TYPE)
		ZERO_VALUE_TOKEN: if imm8[0] then set #ZE
		ZERO_VALUE_TOKEN: if imm8[1] then set #IE
		ONE_VALUE_TOKEN: if imm8[2] then set #ZE
		ONE_VALUE_TOKEN: if imm8[3] then set #IE
		SNAN_TOKEN: if imm8[4] then set #IE
		NEG_INF_TOKEN: if imm8[5] then set #IE
		NEG_VALUE_TOKEN: if imm8[6] then set #IE
		POS_INF_TOKEN: if imm8[7] then set #IE
	ESAC
	RETURN dest[63:0]
}

FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := FIXUPIMMPD(a[i+63:i], b[i+63:i], c[i+63:i], imm[7:0])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfixupimmpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_fixupimm_round_pd / vfixupimmpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_fixupimm_round_pd">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="c" type="__m512i"/>
	<parameter varname="imm" type="int"/>
	<parameter varname="rounding" type="int"/>
	<description>Fix up packed double-precision (64-bit) floating-point elements in "a" and "b" using packed 64-bit integers in "c", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). "imm" is used to set the required flags reporting.
	[round_note]
	</description>
	<description code="true">
enum TOKEN_TYPE {
	QNAN_TOKEN := 0, 
	SNAN_TOKEN := 1, 
	ZERO_VALUE_TOKEN := 2, 
	ONE_VALUE_TOKEN := 3, 
	NEG_INF_TOKEN := 4, 
	POS_INF_TOKEN := 5, 
	NEG_VALUE_TOKEN := 6, 
	POS_VALUE_TOKEN := 7
}
FIXUPIMMPD(src1[63:0], src2[63:0], src3[63:0], imm8[7:0]){
	tsrc[63:0] := ((src2[62:52] == 0) AND (MXCSR.DAZ == 1)) ? 0.0 : src2[63:0]
	CASE(tsrc[63:0] of TOKEN_TYPE)
		QNAN_TOKEN:j := 0
		SNAN_TOKEN:j := 1
		ZERO_VALUE_TOKEN: j := 2
		ONE_VALUE_TOKEN: j := 3
		NEG_INF_TOKEN: j := 4
		POS_INF_TOKEN: j := 5
		NEG_VALUE_TOKEN: j := 6
		POS_VALUE_TOKEN: j := 7
	ESAC
	
	token_response[3:0] := src3[3+4*j:4*j]
	
	CASE(token_response[3:0]) of
		0 : dest[63:0] := src1[63:0]
		1 : dest[63:0] := tsrc[63:0]
		2 : dest[63:0] := QNaN(tsrc[63:0])
		3 : dest[63:0] := QNAN_Indefinite
		4 : dest[63:0] := -INF
		5 : dest[63:0] := +INF
		6 : dest[63:0] := tsrc.sign? &#x2013;INF : +INF
		7 : dest[63:0] := -0
		8 : dest[63:0] := +0
		9 : dest[63:0] := -1
		10: dest[63:0] := +1
		11: dest[63:0] := 1&#x2044;2
		12: dest[63:0] := 90.0
		13: dest[63:0] := PI/2
		14: dest[63:0] := MAX_FLOAT
		15: dest[63:0] := -MAX_FLOAT
	ESAC
	
	CASE(tsrc[31:0] of TOKEN_TYPE)
		ZERO_VALUE_TOKEN: if imm8[0] then set #ZE
		ZERO_VALUE_TOKEN: if imm8[1] then set #IE
		ONE_VALUE_TOKEN: if imm8[2] then set #ZE
		ONE_VALUE_TOKEN: if imm8[3] then set #IE
		SNAN_TOKEN: if imm8[4] then set #IE
		NEG_INF_TOKEN: if imm8[5] then set #IE
		NEG_VALUE_TOKEN: if imm8[6] then set #IE
		POS_INF_TOKEN: if imm8[7] then set #IE
	ESAC
	RETURN dest[63:0]
}

FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := FIXUPIMMPD(a[i+63:i], b[i+63:i], c[i+63:i], imm[7:0])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfixupimmpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_fixupimm_ps / vfixupimmps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_fixupimm_ps">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="c" type="__m512i"/>
	<parameter varname="imm" type="int"/>
	<description>Fix up packed single-precision (32-bit) floating-point elements in "a" and "b" using packed 32-bit integers in "c", and store the results in "dst". "imm" is used to set the required flags reporting.</description>
	<description code="true">
enum TOKEN_TYPE {
	QNAN_TOKEN := 0, 
	SNAN_TOKEN L= 1, 
	ZERO_VALUE_TOKEN := 2, 
	ONE_VALUE_TOKEN := 3, 
	NEG_INF_TOKEN := 4, 
	POS_INF_TOKEN := 5, 
	NEG_VALUE_TOKEN := 6, 
	POS_VALUE_TOKEN := 7
}
FIXUPIMMPD(src1[31:0], src2[31:0], src3[31:0], imm8[7:0]){
	tsrc[31:0] := ((src2[30:23] == 0) AND (MXCSR.DAZ == 1)) ? 0.0 : src2[31:0]
	CASE(tsrc[31:0] of TOKEN_TYPE)
		QNAN_TOKEN:j := 0
		SNAN_TOKEN:j := 1
		ZERO_VALUE_TOKEN: j := 2
		ONE_VALUE_TOKEN: j := 3
		NEG_INF_TOKEN: j := 4
		POS_INF_TOKEN: j := 5
		NEG_VALUE_TOKEN: j := 6
		POS_VALUE_TOKEN: j := 7
	ESAC
	
	token_response[3:0] := src3[3+4*j:4*j]
	
	CASE(token_response[3:0]) of
		0 : dest[31:0] := src1[31:0]
		1 : dest[31:0] := tsrc[31:0]
		2 : dest[31:0] := QNaN(tsrc[31:0])
		3 : dest[31:0] := QNAN_Indefinite
		4 : dest[31:0] := -INF
		5 : dest[31:0] := +INF
		6 : dest[31:0] := tsrc.sign? &#x2013;INF : +INF
		7 : dest[31:0] := -0
		8 : dest[31:0] := +0
		9 : dest[31:0] := -1
		10: dest[31:0] := +1
		11: dest[31:0] := 1&#x2044;2
		12: dest[31:0] := 90.0
		13: dest[31:0] := PI/2
		14: dest[31:0] := MAX_FLOAT
		15: dest[31:0] := -MAX_FLOAT
	ESAC
	
	CASE(tsrc[31:0] of TOKEN_TYPE)
		ZERO_VALUE_TOKEN: if imm8[0] then set #ZE
		ZERO_VALUE_TOKEN: if imm8[1] then set #IE
		ONE_VALUE_TOKEN: if imm8[2] then set #ZE
		ONE_VALUE_TOKEN: if imm8[3] then set #IE
		SNAN_TOKEN: if imm8[4] then set #IE
		NEG_INF_TOKEN: if imm8[5] then set #IE
		NEG_VALUE_TOKEN: if imm8[6] then set #IE
		POS_INF_TOKEN: if imm8[7] then set #IE
	ESAC
	RETURN dest[31:0]
}

FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := FIXUPIMMPD(a[i+31:i], b[i+31:i], c[i+31:i], imm[7:0])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfixupimmps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_fixupimm_round_ps / vfixupimmps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_fixupimm_round_ps">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="c" type="__m512i"/>
	<parameter varname="imm" type="int"/>
	<parameter varname="rounding" type="int"/>
	<description>Fix up packed single-precision (32-bit) floating-point elements in "a" and "b" using packed 32-bit integers in "c", and store the results in "dst". "imm" is used to set the required flags reporting.
	[round_note]
	</description>
	<description code="true">
enum TOKEN_TYPE {
	QNAN_TOKEN := 0, 
	SNAN_TOKEN L= 1, 
	ZERO_VALUE_TOKEN := 2, 
	ONE_VALUE_TOKEN := 3, 
	NEG_INF_TOKEN := 4, 
	POS_INF_TOKEN := 5, 
	NEG_VALUE_TOKEN := 6, 
	POS_VALUE_TOKEN := 7
}
FIXUPIMMPD(src1[31:0], src2[31:0], src3[31:0], imm8[7:0]){
	tsrc[31:0] := ((src2[30:23] == 0) AND (MXCSR.DAZ == 1)) ? 0.0 : src2[31:0]
	CASE(tsrc[31:0] of TOKEN_TYPE)
		QNAN_TOKEN:j := 0
		SNAN_TOKEN:j := 1
		ZERO_VALUE_TOKEN: j := 2
		ONE_VALUE_TOKEN: j := 3
		NEG_INF_TOKEN: j := 4
		POS_INF_TOKEN: j := 5
		NEG_VALUE_TOKEN: j := 6
		POS_VALUE_TOKEN: j := 7
	ESAC
	
	token_response[3:0] := src3[3+4*j:4*j]
	
	CASE(token_response[3:0]) of
		0 : dest[31:0] := src1[31:0]
		1 : dest[31:0] := tsrc[31:0]
		2 : dest[31:0] := QNaN(tsrc[31:0])
		3 : dest[31:0] := QNAN_Indefinite
		4 : dest[31:0] := -INF
		5 : dest[31:0] := +INF
		6 : dest[31:0] := tsrc.sign? &#x2013;INF : +INF
		7 : dest[31:0] := -0
		8 : dest[31:0] := +0
		9 : dest[31:0] := -1
		10: dest[31:0] := +1
		11: dest[31:0] := 1&#x2044;2
		12: dest[31:0] := 90.0
		13: dest[31:0] := PI/2
		14: dest[31:0] := MAX_FLOAT
		15: dest[31:0] := -MAX_FLOAT
	ESAC
	
	CASE(tsrc[31:0] of TOKEN_TYPE)
		ZERO_VALUE_TOKEN: if imm8[0] then set #ZE
		ZERO_VALUE_TOKEN: if imm8[1] then set #IE
		ONE_VALUE_TOKEN: if imm8[2] then set #ZE
		ONE_VALUE_TOKEN: if imm8[3] then set #IE
		SNAN_TOKEN: if imm8[4] then set #IE
		NEG_INF_TOKEN: if imm8[5] then set #IE
		NEG_VALUE_TOKEN: if imm8[6] then set #IE
		POS_INF_TOKEN: if imm8[7] then set #IE
	ESAC
	RETURN dest[31:0]
}

FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := FIXUPIMMPD(a[i+31:i], b[i+31:i], c[i+31:i], imm[7:0])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfixupimmps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_fixupimm_ps / vfixupimmps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_fixupimm_ps">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="c" type="__m512i"/>
	<parameter varname="imm" type="int"/>
	<description>Fix up packed single-precision (32-bit) floating-point elements in "a" and "b" using packed 32-bit integers in "c", and store the results in "dst" using writemask "k" (elements are copied from "a" when the corresponding mask bit is not set). "imm" is used to set the required flags reporting.</description>
	<description code="true">
enum TOKEN_TYPE {
	QNAN_TOKEN := 0, 
	SNAN_TOKEN L= 1, 
	ZERO_VALUE_TOKEN := 2, 
	ONE_VALUE_TOKEN := 3, 
	NEG_INF_TOKEN := 4, 
	POS_INF_TOKEN := 5, 
	NEG_VALUE_TOKEN := 6, 
	POS_VALUE_TOKEN := 7
}
FIXUPIMMPD(src1[31:0], src2[31:0], src3[31:0], imm8[7:0]){
	tsrc[31:0] := ((src2[30:23] == 0) AND (MXCSR.DAZ == 1)) ? 0.0 : src2[31:0]
	CASE(tsrc[31:0] of TOKEN_TYPE)
		QNAN_TOKEN:j := 0
		SNAN_TOKEN:j := 1
		ZERO_VALUE_TOKEN: j := 2
		ONE_VALUE_TOKEN: j := 3
		NEG_INF_TOKEN: j := 4
		POS_INF_TOKEN: j := 5
		NEG_VALUE_TOKEN: j := 6
		POS_VALUE_TOKEN: j := 7
	ESAC
	
	token_response[3:0] := src3[3+4*j:4*j]
	
	CASE(token_response[3:0]) of
		0 : dest[31:0] := src1[31:0]
		1 : dest[31:0] := tsrc[31:0]
		2 : dest[31:0] := QNaN(tsrc[31:0])
		3 : dest[31:0] := QNAN_Indefinite
		4 : dest[31:0] := -INF
		5 : dest[31:0] := +INF
		6 : dest[31:0] := tsrc.sign? &#x2013;INF : +INF
		7 : dest[31:0] := -0
		8 : dest[31:0] := +0
		9 : dest[31:0] := -1
		10: dest[31:0] := +1
		11: dest[31:0] := 1&#x2044;2
		12: dest[31:0] := 90.0
		13: dest[31:0] := PI/2
		14: dest[31:0] := MAX_FLOAT
		15: dest[31:0] := -MAX_FLOAT
	ESAC
	
	CASE(tsrc[31:0] of TOKEN_TYPE)
		ZERO_VALUE_TOKEN: if imm8[0] then set #ZE
		ZERO_VALUE_TOKEN: if imm8[1] then set #IE
		ONE_VALUE_TOKEN: if imm8[2] then set #ZE
		ONE_VALUE_TOKEN: if imm8[3] then set #IE
		SNAN_TOKEN: if imm8[4] then set #IE
		NEG_INF_TOKEN: if imm8[5] then set #IE
		NEG_VALUE_TOKEN: if imm8[6] then set #IE
		POS_INF_TOKEN: if imm8[7] then set #IE
	ESAC
	RETURN dest[31:0]
}

FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := FIXUPIMMPD(a[i+31:i], b[i+31:i], c[i+31:i], imm[7:0])
	ELSE
		dst[i+31:i] := a[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfixupimmps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_fixupimm_round_ps / vfixupimmps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_fixupimm_round_ps">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="c" type="__m512i"/>
	<parameter varname="imm" type="int"/>
	<parameter varname="rounding" type="int"/>
	<description>Fix up packed single-precision (32-bit) floating-point elements in "a" and "b" using packed 32-bit integers in "c", and store the results in "dst" using writemask "k" (elements are copied from "a" when the corresponding mask bit is not set). "imm" is used to set the required flags reporting.
	[round_note]
	</description>
	<description code="true">
enum TOKEN_TYPE {
	QNAN_TOKEN := 0, 
	SNAN_TOKEN L= 1, 
	ZERO_VALUE_TOKEN := 2, 
	ONE_VALUE_TOKEN := 3, 
	NEG_INF_TOKEN := 4, 
	POS_INF_TOKEN := 5, 
	NEG_VALUE_TOKEN := 6, 
	POS_VALUE_TOKEN := 7
}
FIXUPIMMPD(src1[31:0], src2[31:0], src3[31:0], imm8[7:0]){
	tsrc[31:0] := ((src2[30:23] == 0) AND (MXCSR.DAZ == 1)) ? 0.0 : src2[31:0]
	CASE(tsrc[31:0] of TOKEN_TYPE)
		QNAN_TOKEN:j := 0
		SNAN_TOKEN:j := 1
		ZERO_VALUE_TOKEN: j := 2
		ONE_VALUE_TOKEN: j := 3
		NEG_INF_TOKEN: j := 4
		POS_INF_TOKEN: j := 5
		NEG_VALUE_TOKEN: j := 6
		POS_VALUE_TOKEN: j := 7
	ESAC
	
	token_response[3:0] := src3[3+4*j:4*j]
	
	CASE(token_response[3:0]) of
		0 : dest[31:0] := src1[31:0]
		1 : dest[31:0] := tsrc[31:0]
		2 : dest[31:0] := QNaN(tsrc[31:0])
		3 : dest[31:0] := QNAN_Indefinite
		4 : dest[31:0] := -INF
		5 : dest[31:0] := +INF
		6 : dest[31:0] := tsrc.sign? &#x2013;INF : +INF
		7 : dest[31:0] := -0
		8 : dest[31:0] := +0
		9 : dest[31:0] := -1
		10: dest[31:0] := +1
		11: dest[31:0] := 1&#x2044;2
		12: dest[31:0] := 90.0
		13: dest[31:0] := PI/2
		14: dest[31:0] := MAX_FLOAT
		15: dest[31:0] := -MAX_FLOAT
	ESAC
	
	CASE(tsrc[31:0] of TOKEN_TYPE)
		ZERO_VALUE_TOKEN: if imm8[0] then set #ZE
		ZERO_VALUE_TOKEN: if imm8[1] then set #IE
		ONE_VALUE_TOKEN: if imm8[2] then set #ZE
		ONE_VALUE_TOKEN: if imm8[3] then set #IE
		SNAN_TOKEN: if imm8[4] then set #IE
		NEG_INF_TOKEN: if imm8[5] then set #IE
		NEG_VALUE_TOKEN: if imm8[6] then set #IE
		POS_INF_TOKEN: if imm8[7] then set #IE
	ESAC
	RETURN dest[31:0]
}

FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := FIXUPIMMPD(a[i+31:i], b[i+31:i], c[i+31:i], imm[7:0])
	ELSE
		dst[i+31:i] := a[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfixupimmps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_fixupimm_ps / vfixupimmps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_fixupimm_ps">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="c" type="__m512i"/>
	<parameter varname="imm" type="int"/>
	<description>Fix up packed single-precision (32-bit) floating-point elements in "a" and "b" using packed 32-bit integers in "c", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). "imm" is used to set the required flags reporting.</description>
	<description code="true">
enum TOKEN_TYPE {
	QNAN_TOKEN := 0, 
	SNAN_TOKEN L= 1, 
	ZERO_VALUE_TOKEN := 2, 
	ONE_VALUE_TOKEN := 3, 
	NEG_INF_TOKEN := 4, 
	POS_INF_TOKEN := 5, 
	NEG_VALUE_TOKEN := 6, 
	POS_VALUE_TOKEN := 7
}
FIXUPIMMPD(src1[31:0], src2[31:0], src3[31:0], imm8[7:0]){
	tsrc[31:0] := ((src2[30:23] == 0) AND (MXCSR.DAZ == 1)) ? 0.0 : src2[31:0]
	CASE(tsrc[31:0] of TOKEN_TYPE)
		QNAN_TOKEN:j := 0
		SNAN_TOKEN:j := 1
		ZERO_VALUE_TOKEN: j := 2
		ONE_VALUE_TOKEN: j := 3
		NEG_INF_TOKEN: j := 4
		POS_INF_TOKEN: j := 5
		NEG_VALUE_TOKEN: j := 6
		POS_VALUE_TOKEN: j := 7
	ESAC
	
	token_response[3:0] := src3[3+4*j:4*j]
	
	CASE(token_response[3:0]) of
		0 : dest[31:0] := src1[31:0]
		1 : dest[31:0] := tsrc[31:0]
		2 : dest[31:0] := QNaN(tsrc[31:0])
		3 : dest[31:0] := QNAN_Indefinite
		4 : dest[31:0] := -INF
		5 : dest[31:0] := +INF
		6 : dest[31:0] := tsrc.sign? &#x2013;INF : +INF
		7 : dest[31:0] := -0
		8 : dest[31:0] := +0
		9 : dest[31:0] := -1
		10: dest[31:0] := +1
		11: dest[31:0] := 1&#x2044;2
		12: dest[31:0] := 90.0
		13: dest[31:0] := PI/2
		14: dest[31:0] := MAX_FLOAT
		15: dest[31:0] := -MAX_FLOAT
	ESAC
	
	CASE(tsrc[31:0] of TOKEN_TYPE)
		ZERO_VALUE_TOKEN: if imm8[0] then set #ZE
		ZERO_VALUE_TOKEN: if imm8[1] then set #IE
		ONE_VALUE_TOKEN: if imm8[2] then set #ZE
		ONE_VALUE_TOKEN: if imm8[3] then set #IE
		SNAN_TOKEN: if imm8[4] then set #IE
		NEG_INF_TOKEN: if imm8[5] then set #IE
		NEG_VALUE_TOKEN: if imm8[6] then set #IE
		POS_INF_TOKEN: if imm8[7] then set #IE
	ESAC
	RETURN dest[31:0]
}

FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := FIXUPIMMPD(a[i+31:i], b[i+31:i], c[i+31:i], imm[7:0])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfixupimmps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_fixupimm_round_ps / vfixupimmps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_fixupimm_round_ps">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="c" type="__m512i"/>
	<parameter varname="imm" type="int"/>
	<parameter varname="rounding" type="int"/>
	<description>Fix up packed single-precision (32-bit) floating-point elements in "a" and "b" using packed 32-bit integers in "c", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). "imm" is used to set the required flags reporting.
	[round_note]
	</description>
	<description code="true">
enum TOKEN_TYPE {
	QNAN_TOKEN := 0, 
	SNAN_TOKEN L= 1, 
	ZERO_VALUE_TOKEN := 2, 
	ONE_VALUE_TOKEN := 3, 
	NEG_INF_TOKEN := 4, 
	POS_INF_TOKEN := 5, 
	NEG_VALUE_TOKEN := 6, 
	POS_VALUE_TOKEN := 7
}
FIXUPIMMPD(src1[31:0], src2[31:0], src3[31:0], imm8[7:0]){
	tsrc[31:0] := ((src2[30:23] == 0) AND (MXCSR.DAZ == 1)) ? 0.0 : src2[31:0]
	CASE(tsrc[31:0] of TOKEN_TYPE)
		QNAN_TOKEN:j := 0
		SNAN_TOKEN:j := 1
		ZERO_VALUE_TOKEN: j := 2
		ONE_VALUE_TOKEN: j := 3
		NEG_INF_TOKEN: j := 4
		POS_INF_TOKEN: j := 5
		NEG_VALUE_TOKEN: j := 6
		POS_VALUE_TOKEN: j := 7
	ESAC
	
	token_response[3:0] := src3[3+4*j:4*j]
	
	CASE(token_response[3:0]) of
		0 : dest[31:0] := src1[31:0]
		1 : dest[31:0] := tsrc[31:0]
		2 : dest[31:0] := QNaN(tsrc[31:0])
		3 : dest[31:0] := QNAN_Indefinite
		4 : dest[31:0] := -INF
		5 : dest[31:0] := +INF
		6 : dest[31:0] := tsrc.sign? &#x2013;INF : +INF
		7 : dest[31:0] := -0
		8 : dest[31:0] := +0
		9 : dest[31:0] := -1
		10: dest[31:0] := +1
		11: dest[31:0] := 1&#x2044;2
		12: dest[31:0] := 90.0
		13: dest[31:0] := PI/2
		14: dest[31:0] := MAX_FLOAT
		15: dest[31:0] := -MAX_FLOAT
	ESAC
	
	CASE(tsrc[31:0] of TOKEN_TYPE)
		ZERO_VALUE_TOKEN: if imm8[0] then set #ZE
		ZERO_VALUE_TOKEN: if imm8[1] then set #IE
		ONE_VALUE_TOKEN: if imm8[2] then set #ZE
		ONE_VALUE_TOKEN: if imm8[3] then set #IE
		SNAN_TOKEN: if imm8[4] then set #IE
		NEG_INF_TOKEN: if imm8[5] then set #IE
		NEG_VALUE_TOKEN: if imm8[6] then set #IE
		POS_INF_TOKEN: if imm8[7] then set #IE
	ESAC
	RETURN dest[31:0]
}

FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := FIXUPIMMPD(a[i+31:i], b[i+31:i], c[i+31:i], imm[7:0])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfixupimmps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_fixupimm_round_sd / vfixupimmsd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_fixupimm_round_sd">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="c" type="__m128i"/>
	<parameter varname="imm" type="int"/>
	<parameter varname="rounding" type="int"/>
	<description>Fix up the lower double-precision (64-bit) floating-point elements in "a" and "b" using the lower 64-bit integer in "c", store the result in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst". "imm" is used to set the required flags reporting.
	[round_note]
	</description>
	<description code="true">
enum TOKEN_TYPE {
	QNAN_TOKEN := 0, 
	SNAN_TOKEN := 1, 
	ZERO_VALUE_TOKEN := 2, 
	ONE_VALUE_TOKEN := 3, 
	NEG_INF_TOKEN := 4, 
	POS_INF_TOKEN := 5, 
	NEG_VALUE_TOKEN := 6, 
	POS_VALUE_TOKEN := 7
}
FIXUPIMMPD(src1[63:0], src2[63:0], src3[63:0], imm8[7:0]){
	tsrc[63:0] := ((src2[62:52] == 0) AND (MXCSR.DAZ == 1)) ? 0.0 : src2[63:0]
	CASE(tsrc[63:0] of TOKEN_TYPE)
		QNAN_TOKEN:j := 0
		SNAN_TOKEN:j := 1
		ZERO_VALUE_TOKEN: j := 2
		ONE_VALUE_TOKEN: j := 3
		NEG_INF_TOKEN: j := 4
		POS_INF_TOKEN: j := 5
		NEG_VALUE_TOKEN: j := 6
		POS_VALUE_TOKEN: j := 7
	ESAC
	
	token_response[3:0] := src3[3+4*j:4*j]
	
	CASE(token_response[3:0]) of
		0 : dest[63:0] := src1[63:0]
		1 : dest[63:0] := tsrc[63:0]
		2 : dest[63:0] := QNaN(tsrc[63:0])
		3 : dest[63:0] := QNAN_Indefinite
		4 : dest[63:0] := -INF
		5 : dest[63:0] := +INF
		6 : dest[63:0] := tsrc.sign? &#x2013;INF : +INF
		7 : dest[63:0] := -0
		8 : dest[63:0] := +0
		9 : dest[63:0] := -1
		10: dest[63:0] := +1
		11: dest[63:0] := 1&#x2044;2
		12: dest[63:0] := 90.0
		13: dest[63:0] := PI/2
		14: dest[63:0] := MAX_FLOAT
		15: dest[63:0] := -MAX_FLOAT
	ESAC
	
	CASE(tsrc[31:0] of TOKEN_TYPE)
		ZERO_VALUE_TOKEN: if imm8[0] then set #ZE
		ZERO_VALUE_TOKEN: if imm8[1] then set #IE
		ONE_VALUE_TOKEN: if imm8[2] then set #ZE
		ONE_VALUE_TOKEN: if imm8[3] then set #IE
		SNAN_TOKEN: if imm8[4] then set #IE
		NEG_INF_TOKEN: if imm8[5] then set #IE
		NEG_VALUE_TOKEN: if imm8[6] then set #IE
		POS_INF_TOKEN: if imm8[7] then set #IE
	ESAC
	RETURN dest[63:0]
}

dst[63:0] := FIXUPIMMPD(a[63:0], b[63:0], c[63:0], imm[7:0])
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vfixupimmsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_fixupimm_sd / vfixupimmsd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_fixupimm_sd">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="c" type="__m128i"/>
	<parameter varname="imm" type="int"/>
	<description>Fix up the lower double-precision (64-bit) floating-point elements in "a" and "b" using the lower 64-bit integer in "c", store the result in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst". "imm" is used to set the required flags reporting.</description>
	<description code="true">
enum TOKEN_TYPE {
	QNAN_TOKEN := 0, 
	SNAN_TOKEN := 1, 
	ZERO_VALUE_TOKEN := 2, 
	ONE_VALUE_TOKEN := 3, 
	NEG_INF_TOKEN := 4, 
	POS_INF_TOKEN := 5, 
	NEG_VALUE_TOKEN := 6, 
	POS_VALUE_TOKEN := 7
}
FIXUPIMMPD(src1[63:0], src2[63:0], src3[63:0], imm8[7:0]){
	tsrc[63:0] := ((src2[62:52] == 0) AND (MXCSR.DAZ == 1)) ? 0.0 : src2[63:0]
	CASE(tsrc[63:0] of TOKEN_TYPE)
		QNAN_TOKEN:j := 0
		SNAN_TOKEN:j := 1
		ZERO_VALUE_TOKEN: j := 2
		ONE_VALUE_TOKEN: j := 3
		NEG_INF_TOKEN: j := 4
		POS_INF_TOKEN: j := 5
		NEG_VALUE_TOKEN: j := 6
		POS_VALUE_TOKEN: j := 7
	ESAC
	
	token_response[3:0] := src3[3+4*j:4*j]
	
	CASE(token_response[3:0]) of
		0 : dest[63:0] := src1[63:0]
		1 : dest[63:0] := tsrc[63:0]
		2 : dest[63:0] := QNaN(tsrc[63:0])
		3 : dest[63:0] := QNAN_Indefinite
		4 : dest[63:0] := -INF
		5 : dest[63:0] := +INF
		6 : dest[63:0] := tsrc.sign? &#x2013;INF : +INF
		7 : dest[63:0] := -0
		8 : dest[63:0] := +0
		9 : dest[63:0] := -1
		10: dest[63:0] := +1
		11: dest[63:0] := 1&#x2044;2
		12: dest[63:0] := 90.0
		13: dest[63:0] := PI/2
		14: dest[63:0] := MAX_FLOAT
		15: dest[63:0] := -MAX_FLOAT
	ESAC
	
	CASE(tsrc[31:0] of TOKEN_TYPE)
		ZERO_VALUE_TOKEN: if imm8[0] then set #ZE
		ZERO_VALUE_TOKEN: if imm8[1] then set #IE
		ONE_VALUE_TOKEN: if imm8[2] then set #ZE
		ONE_VALUE_TOKEN: if imm8[3] then set #IE
		SNAN_TOKEN: if imm8[4] then set #IE
		NEG_INF_TOKEN: if imm8[5] then set #IE
		NEG_VALUE_TOKEN: if imm8[6] then set #IE
		POS_INF_TOKEN: if imm8[7] then set #IE
	ESAC
	RETURN dest[63:0]
}

dst[63:0] := FIXUPIMMPD(a[63:0], b[63:0], c[63:0], imm[7:0])
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vfixupimmsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_fixupimm_round_sd / vfixupimmsd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_mask_fixupimm_round_sd">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="c" type="__m128i"/>
	<parameter varname="imm" type="int"/>
	<parameter varname="rounding" type="int"/>
	<description>Fix up the lower double-precision (64-bit) floating-point elements in "a" and "b" using the lower 64-bit integer in "c", store the result in the lower element of "dst" using writemask "k" (the element is copied from "a" when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst". "imm" is used to set the required flags reporting.
	[round_note]
	</description>
	<description code="true">
enum TOKEN_TYPE {
	QNAN_TOKEN := 0, 
	SNAN_TOKEN := 1, 
	ZERO_VALUE_TOKEN := 2, 
	ONE_VALUE_TOKEN := 3, 
	NEG_INF_TOKEN := 4, 
	POS_INF_TOKEN := 5, 
	NEG_VALUE_TOKEN := 6, 
	POS_VALUE_TOKEN := 7
}
FIXUPIMMPD(src1[63:0], src2[63:0], src3[63:0], imm8[7:0]){
	tsrc[63:0] := ((src2[62:52] == 0) AND (MXCSR.DAZ == 1)) ? 0.0 : src2[63:0]
	CASE(tsrc[63:0] of TOKEN_TYPE)
		QNAN_TOKEN:j := 0
		SNAN_TOKEN:j := 1
		ZERO_VALUE_TOKEN: j := 2
		ONE_VALUE_TOKEN: j := 3
		NEG_INF_TOKEN: j := 4
		POS_INF_TOKEN: j := 5
		NEG_VALUE_TOKEN: j := 6
		POS_VALUE_TOKEN: j := 7
	ESAC
	
	token_response[3:0] := src3[3+4*j:4*j]
	
	CASE(token_response[3:0]) of
		0 : dest[63:0] := src1[63:0]
		1 : dest[63:0] := tsrc[63:0]
		2 : dest[63:0] := QNaN(tsrc[63:0])
		3 : dest[63:0] := QNAN_Indefinite
		4 : dest[63:0] := -INF
		5 : dest[63:0] := +INF
		6 : dest[63:0] := tsrc.sign? &#x2013;INF : +INF
		7 : dest[63:0] := -0
		8 : dest[63:0] := +0
		9 : dest[63:0] := -1
		10: dest[63:0] := +1
		11: dest[63:0] := 1&#x2044;2
		12: dest[63:0] := 90.0
		13: dest[63:0] := PI/2
		14: dest[63:0] := MAX_FLOAT
		15: dest[63:0] := -MAX_FLOAT
	ESAC
	
	CASE(tsrc[31:0] of TOKEN_TYPE)
		ZERO_VALUE_TOKEN: if imm8[0] then set #ZE
		ZERO_VALUE_TOKEN: if imm8[1] then set #IE
		ONE_VALUE_TOKEN: if imm8[2] then set #ZE
		ONE_VALUE_TOKEN: if imm8[3] then set #IE
		SNAN_TOKEN: if imm8[4] then set #IE
		NEG_INF_TOKEN: if imm8[5] then set #IE
		NEG_VALUE_TOKEN: if imm8[6] then set #IE
		POS_INF_TOKEN: if imm8[7] then set #IE
	ESAC
	RETURN dest[63:0]
}

IF k[0]
	dst[63:0] := FIXUPIMMPD(a[63:0], b[63:0], c[63:0], imm[7:0])
ELSE
	dst[63:0] := a[63:0]
FI
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vfixupimmsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_fixupimm_sd / vfixupimmsd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_mask_fixupimm_sd">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="c" type="__m128i"/>
	<parameter varname="imm" type="int"/>
	<description>Fix up the lower double-precision (64-bit) floating-point elements in "a" and "b" using the lower 64-bit integer in "c", store the result in the lower element of "dst" using writemask "k" (the element is copied from "a" when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst". "imm" is used to set the required flags reporting.</description>
	<description code="true">
enum TOKEN_TYPE {
	QNAN_TOKEN := 0, 
	SNAN_TOKEN := 1, 
	ZERO_VALUE_TOKEN := 2, 
	ONE_VALUE_TOKEN := 3, 
	NEG_INF_TOKEN := 4, 
	POS_INF_TOKEN := 5, 
	NEG_VALUE_TOKEN := 6, 
	POS_VALUE_TOKEN := 7
}
FIXUPIMMPD(src1[63:0], src2[63:0], src3[63:0], imm8[7:0]){
	tsrc[63:0] := ((src2[62:52] == 0) AND (MXCSR.DAZ == 1)) ? 0.0 : src2[63:0]
	CASE(tsrc[63:0] of TOKEN_TYPE)
		QNAN_TOKEN:j := 0
		SNAN_TOKEN:j := 1
		ZERO_VALUE_TOKEN: j := 2
		ONE_VALUE_TOKEN: j := 3
		NEG_INF_TOKEN: j := 4
		POS_INF_TOKEN: j := 5
		NEG_VALUE_TOKEN: j := 6
		POS_VALUE_TOKEN: j := 7
	ESAC
	
	token_response[3:0] := src3[3+4*j:4*j]
	
	CASE(token_response[3:0]) of
		0 : dest[63:0] := src1[63:0]
		1 : dest[63:0] := tsrc[63:0]
		2 : dest[63:0] := QNaN(tsrc[63:0])
		3 : dest[63:0] := QNAN_Indefinite
		4 : dest[63:0] := -INF
		5 : dest[63:0] := +INF
		6 : dest[63:0] := tsrc.sign? &#x2013;INF : +INF
		7 : dest[63:0] := -0
		8 : dest[63:0] := +0
		9 : dest[63:0] := -1
		10: dest[63:0] := +1
		11: dest[63:0] := 1&#x2044;2
		12: dest[63:0] := 90.0
		13: dest[63:0] := PI/2
		14: dest[63:0] := MAX_FLOAT
		15: dest[63:0] := -MAX_FLOAT
	ESAC
	
	CASE(tsrc[31:0] of TOKEN_TYPE)
		ZERO_VALUE_TOKEN: if imm8[0] then set #ZE
		ZERO_VALUE_TOKEN: if imm8[1] then set #IE
		ONE_VALUE_TOKEN: if imm8[2] then set #ZE
		ONE_VALUE_TOKEN: if imm8[3] then set #IE
		SNAN_TOKEN: if imm8[4] then set #IE
		NEG_INF_TOKEN: if imm8[5] then set #IE
		NEG_VALUE_TOKEN: if imm8[6] then set #IE
		POS_INF_TOKEN: if imm8[7] then set #IE
	ESAC
	RETURN dest[63:0]
}

IF k[0]
	dst[63:0] := FIXUPIMMPD(a[63:0], b[63:0], c[63:0], imm[7:0])
ELSE
	dst[63:0] := a[63:0]
FI
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vfixupimmsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_fixupimm_round_sd / vfixupimmsd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_maskz_fixupimm_round_sd">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="c" type="__m128i"/>
	<parameter varname="imm" type="int"/>
	<parameter varname="rounding" type="int"/>
	<description>Fix up the lower double-precision (64-bit) floating-point elements in "a" and "b" using the lower 64-bit integer in "c", store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst". "imm" is used to set the required flags reporting.
	[round_note]
	</description>
	<description code="true">
enum TOKEN_TYPE {
	QNAN_TOKEN := 0, 
	SNAN_TOKEN := 1, 
	ZERO_VALUE_TOKEN := 2, 
	ONE_VALUE_TOKEN := 3, 
	NEG_INF_TOKEN := 4, 
	POS_INF_TOKEN := 5, 
	NEG_VALUE_TOKEN := 6, 
	POS_VALUE_TOKEN := 7
}
FIXUPIMMPD(src1[63:0], src2[63:0], src3[63:0], imm8[7:0]){
	tsrc[63:0] := ((src2[62:52] == 0) AND (MXCSR.DAZ == 1)) ? 0.0 : src2[63:0]
	CASE(tsrc[63:0] of TOKEN_TYPE)
		QNAN_TOKEN:j := 0
		SNAN_TOKEN:j := 1
		ZERO_VALUE_TOKEN: j := 2
		ONE_VALUE_TOKEN: j := 3
		NEG_INF_TOKEN: j := 4
		POS_INF_TOKEN: j := 5
		NEG_VALUE_TOKEN: j := 6
		POS_VALUE_TOKEN: j := 7
	ESAC
	
	token_response[3:0] := src3[3+4*j:4*j]
	
	CASE(token_response[3:0]) of
		0 : dest[63:0] := src1[63:0]
		1 : dest[63:0] := tsrc[63:0]
		2 : dest[63:0] := QNaN(tsrc[63:0])
		3 : dest[63:0] := QNAN_Indefinite
		4 : dest[63:0] := -INF
		5 : dest[63:0] := +INF
		6 : dest[63:0] := tsrc.sign? &#x2013;INF : +INF
		7 : dest[63:0] := -0
		8 : dest[63:0] := +0
		9 : dest[63:0] := -1
		10: dest[63:0] := +1
		11: dest[63:0] := 1&#x2044;2
		12: dest[63:0] := 90.0
		13: dest[63:0] := PI/2
		14: dest[63:0] := MAX_FLOAT
		15: dest[63:0] := -MAX_FLOAT
	ESAC
	
	CASE(tsrc[31:0] of TOKEN_TYPE)
		ZERO_VALUE_TOKEN: if imm8[0] then set #ZE
		ZERO_VALUE_TOKEN: if imm8[1] then set #IE
		ONE_VALUE_TOKEN: if imm8[2] then set #ZE
		ONE_VALUE_TOKEN: if imm8[3] then set #IE
		SNAN_TOKEN: if imm8[4] then set #IE
		NEG_INF_TOKEN: if imm8[5] then set #IE
		NEG_VALUE_TOKEN: if imm8[6] then set #IE
		POS_INF_TOKEN: if imm8[7] then set #IE
	ESAC
	RETURN dest[63:0]
}

IF k[0]
	dst[63:0] := FIXUPIMMPD(a[63:0], b[63:0], c[63:0], imm[7:0])
ELSE
	dst[63:0] := 0
FI
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vfixupimmsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_fixupimm_sd / vfixupimmsd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_maskz_fixupimm_sd">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="c" type="__m128i"/>
	<parameter varname="imm" type="int"/>
	<description>Fix up the lower double-precision (64-bit) floating-point elements in "a" and "b" using the lower 64-bit integer in "c", store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst". "imm" is used to set the required flags reporting.</description>
	<description code="true">
enum TOKEN_TYPE {
	QNAN_TOKEN := 0, 
	SNAN_TOKEN := 1, 
	ZERO_VALUE_TOKEN := 2, 
	ONE_VALUE_TOKEN := 3, 
	NEG_INF_TOKEN := 4, 
	POS_INF_TOKEN := 5, 
	NEG_VALUE_TOKEN := 6, 
	POS_VALUE_TOKEN := 7
}
FIXUPIMMPD(src1[63:0], src2[63:0], src3[63:0], imm8[7:0]){
	tsrc[63:0] := ((src2[62:52] == 0) AND (MXCSR.DAZ == 1)) ? 0.0 : src2[63:0]
	CASE(tsrc[63:0] of TOKEN_TYPE)
		QNAN_TOKEN:j := 0
		SNAN_TOKEN:j := 1
		ZERO_VALUE_TOKEN: j := 2
		ONE_VALUE_TOKEN: j := 3
		NEG_INF_TOKEN: j := 4
		POS_INF_TOKEN: j := 5
		NEG_VALUE_TOKEN: j := 6
		POS_VALUE_TOKEN: j := 7
	ESAC
	
	token_response[3:0] := src3[3+4*j:4*j]
	
	CASE(token_response[3:0]) of
		0 : dest[63:0] := src1[63:0]
		1 : dest[63:0] := tsrc[63:0]
		2 : dest[63:0] := QNaN(tsrc[63:0])
		3 : dest[63:0] := QNAN_Indefinite
		4 : dest[63:0] := -INF
		5 : dest[63:0] := +INF
		6 : dest[63:0] := tsrc.sign? &#x2013;INF : +INF
		7 : dest[63:0] := -0
		8 : dest[63:0] := +0
		9 : dest[63:0] := -1
		10: dest[63:0] := +1
		11: dest[63:0] := 1&#x2044;2
		12: dest[63:0] := 90.0
		13: dest[63:0] := PI/2
		14: dest[63:0] := MAX_FLOAT
		15: dest[63:0] := -MAX_FLOAT
	ESAC
	
	CASE(tsrc[31:0] of TOKEN_TYPE)
		ZERO_VALUE_TOKEN: if imm8[0] then set #ZE
		ZERO_VALUE_TOKEN: if imm8[1] then set #IE
		ONE_VALUE_TOKEN: if imm8[2] then set #ZE
		ONE_VALUE_TOKEN: if imm8[3] then set #IE
		SNAN_TOKEN: if imm8[4] then set #IE
		NEG_INF_TOKEN: if imm8[5] then set #IE
		NEG_VALUE_TOKEN: if imm8[6] then set #IE
		POS_INF_TOKEN: if imm8[7] then set #IE
	ESAC
	RETURN dest[63:0]
}

IF k[0]
	dst[63:0] := FIXUPIMMPD(a[63:0], b[63:0], c[63:0], imm[7:0])
ELSE
	dst[63:0] := 0
FI
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vfixupimmsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_fixupimm_round_ss / vfixupimmss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_fixupimm_round_ss">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="c" type="__m128i"/>
	<parameter varname="imm" type="int"/>
	<parameter varname="rounding" type="int"/>
	<description>Fix up the lower single-precision (32-bit) floating-point elements in "a" and "b" using the lower 32-bit integer in "c", store the result in the lower element of "dst", and copy the upper 3 packed elements from "a" to the upper elements of "dst". "imm" is used to set the required flags reporting.
	[round_note]
	</description>
	<description code="true">
enum TOKEN_TYPE {
	QNAN_TOKEN := 0, 
	SNAN_TOKEN L= 1, 
	ZERO_VALUE_TOKEN := 2, 
	ONE_VALUE_TOKEN := 3, 
	NEG_INF_TOKEN := 4, 
	POS_INF_TOKEN := 5, 
	NEG_VALUE_TOKEN := 6, 
	POS_VALUE_TOKEN := 7
}
FIXUPIMMPD(src1[31:0], src2[31:0], src3[31:0], imm8[7:0]){
	tsrc[31:0] := ((src2[30:23] == 0) AND (MXCSR.DAZ == 1)) ? 0.0 : src2[31:0]
	CASE(tsrc[31:0] of TOKEN_TYPE)
		QNAN_TOKEN:j := 0
		SNAN_TOKEN:j := 1
		ZERO_VALUE_TOKEN: j := 2
		ONE_VALUE_TOKEN: j := 3
		NEG_INF_TOKEN: j := 4
		POS_INF_TOKEN: j := 5
		NEG_VALUE_TOKEN: j := 6
		POS_VALUE_TOKEN: j := 7
	ESAC
	
	token_response[3:0] := src3[3+4*j:4*j]
	
	CASE(token_response[3:0]) of
		0 : dest[31:0] := src1[31:0]
		1 : dest[31:0] := tsrc[31:0]
		2 : dest[31:0] := QNaN(tsrc[31:0])
		3 : dest[31:0] := QNAN_Indefinite
		4 : dest[31:0] := -INF
		5 : dest[31:0] := +INF
		6 : dest[31:0] := tsrc.sign? &#x2013;INF : +INF
		7 : dest[31:0] := -0
		8 : dest[31:0] := +0
		9 : dest[31:0] := -1
		10: dest[31:0] := +1
		11: dest[31:0] := 1&#x2044;2
		12: dest[31:0] := 90.0
		13: dest[31:0] := PI/2
		14: dest[31:0] := MAX_FLOAT
		15: dest[31:0] := -MAX_FLOAT
	ESAC
	
	CASE(tsrc[31:0] of TOKEN_TYPE)
		ZERO_VALUE_TOKEN: if imm8[0] then set #ZE
		ZERO_VALUE_TOKEN: if imm8[1] then set #IE
		ONE_VALUE_TOKEN: if imm8[2] then set #ZE
		ONE_VALUE_TOKEN: if imm8[3] then set #IE
		SNAN_TOKEN: if imm8[4] then set #IE
		NEG_INF_TOKEN: if imm8[5] then set #IE
		NEG_VALUE_TOKEN: if imm8[6] then set #IE
		POS_INF_TOKEN: if imm8[7] then set #IE
	ESAC
	RETURN dest[31:0]
}

dst[31:0] := FIXUPIMMPD(a[31:0], b[31:0], c[31:0], imm[7:0])
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vfixupimmss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_fixupimm_ss / vfixupimmss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_fixupimm_ss">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="c" type="__m128i"/>
	<parameter varname="imm" type="int"/>
	<description>Fix up the lower single-precision (32-bit) floating-point elements in "a" and "b" using the lower 32-bit integer in "c", store the result in the lower element of "dst", and copy the upper 3 packed elements from "a" to the upper elements of "dst". "imm" is used to set the required flags reporting.</description>
	<description code="true">
enum TOKEN_TYPE {
	QNAN_TOKEN := 0, 
	SNAN_TOKEN L= 1, 
	ZERO_VALUE_TOKEN := 2, 
	ONE_VALUE_TOKEN := 3, 
	NEG_INF_TOKEN := 4, 
	POS_INF_TOKEN := 5, 
	NEG_VALUE_TOKEN := 6, 
	POS_VALUE_TOKEN := 7
}
FIXUPIMMPD(src1[31:0], src2[31:0], src3[31:0], imm8[7:0]){
	tsrc[31:0] := ((src2[30:23] == 0) AND (MXCSR.DAZ == 1)) ? 0.0 : src2[31:0]
	CASE(tsrc[31:0] of TOKEN_TYPE)
		QNAN_TOKEN:j := 0
		SNAN_TOKEN:j := 1
		ZERO_VALUE_TOKEN: j := 2
		ONE_VALUE_TOKEN: j := 3
		NEG_INF_TOKEN: j := 4
		POS_INF_TOKEN: j := 5
		NEG_VALUE_TOKEN: j := 6
		POS_VALUE_TOKEN: j := 7
	ESAC
	
	token_response[3:0] := src3[3+4*j:4*j]
	
	CASE(token_response[3:0]) of
		0 : dest[31:0] := src1[31:0]
		1 : dest[31:0] := tsrc[31:0]
		2 : dest[31:0] := QNaN(tsrc[31:0])
		3 : dest[31:0] := QNAN_Indefinite
		4 : dest[31:0] := -INF
		5 : dest[31:0] := +INF
		6 : dest[31:0] := tsrc.sign? &#x2013;INF : +INF
		7 : dest[31:0] := -0
		8 : dest[31:0] := +0
		9 : dest[31:0] := -1
		10: dest[31:0] := +1
		11: dest[31:0] := 1&#x2044;2
		12: dest[31:0] := 90.0
		13: dest[31:0] := PI/2
		14: dest[31:0] := MAX_FLOAT
		15: dest[31:0] := -MAX_FLOAT
	ESAC
	
	CASE(tsrc[31:0] of TOKEN_TYPE)
		ZERO_VALUE_TOKEN: if imm8[0] then set #ZE
		ZERO_VALUE_TOKEN: if imm8[1] then set #IE
		ONE_VALUE_TOKEN: if imm8[2] then set #ZE
		ONE_VALUE_TOKEN: if imm8[3] then set #IE
		SNAN_TOKEN: if imm8[4] then set #IE
		NEG_INF_TOKEN: if imm8[5] then set #IE
		NEG_VALUE_TOKEN: if imm8[6] then set #IE
		POS_INF_TOKEN: if imm8[7] then set #IE
	ESAC
	RETURN dest[31:0]
}

dst[31:0] := FIXUPIMMPD(a[31:0], b[31:0], c[31:0], imm[7:0])
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vfixupimmss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_fixupimm_round_ss / vfixupimmss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_mask_fixupimm_round_ss">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="c" type="__m128i"/>
	<parameter varname="imm" type="int"/>
	<parameter varname="rounding" type="int"/>	
	<description>Fix up the lower single-precision (32-bit) floating-point elements in "a" and "b" using the lower 32-bit integer in "c", store the result in the lower element of "dst" using writemask "k" (the element is copied from "a" when mask bit 0 is not set), and copy the upper 3 packed elements from "a" to the upper elements of "dst". "imm" is used to set the required flags reporting.
	[round_note]
	</description>
	<description code="true">
enum TOKEN_TYPE {
	QNAN_TOKEN := 0, 
	SNAN_TOKEN L= 1, 
	ZERO_VALUE_TOKEN := 2, 
	ONE_VALUE_TOKEN := 3, 
	NEG_INF_TOKEN := 4, 
	POS_INF_TOKEN := 5, 
	NEG_VALUE_TOKEN := 6, 
	POS_VALUE_TOKEN := 7
}
FIXUPIMMPD(src1[31:0], src2[31:0], src3[31:0], imm8[7:0]){
	tsrc[31:0] := ((src2[30:23] == 0) AND (MXCSR.DAZ == 1)) ? 0.0 : src2[31:0]
	CASE(tsrc[31:0] of TOKEN_TYPE)
		QNAN_TOKEN:j := 0
		SNAN_TOKEN:j := 1
		ZERO_VALUE_TOKEN: j := 2
		ONE_VALUE_TOKEN: j := 3
		NEG_INF_TOKEN: j := 4
		POS_INF_TOKEN: j := 5
		NEG_VALUE_TOKEN: j := 6
		POS_VALUE_TOKEN: j := 7
	ESAC
	
	token_response[3:0] := src3[3+4*j:4*j]
	
	CASE(token_response[3:0]) of
		0 : dest[31:0] := src1[31:0]
		1 : dest[31:0] := tsrc[31:0]
		2 : dest[31:0] := QNaN(tsrc[31:0])
		3 : dest[31:0] := QNAN_Indefinite
		4 : dest[31:0] := -INF
		5 : dest[31:0] := +INF
		6 : dest[31:0] := tsrc.sign? &#x2013;INF : +INF
		7 : dest[31:0] := -0
		8 : dest[31:0] := +0
		9 : dest[31:0] := -1
		10: dest[31:0] := +1
		11: dest[31:0] := 1&#x2044;2
		12: dest[31:0] := 90.0
		13: dest[31:0] := PI/2
		14: dest[31:0] := MAX_FLOAT
		15: dest[31:0] := -MAX_FLOAT
	ESAC
	
	CASE(tsrc[31:0] of TOKEN_TYPE)
		ZERO_VALUE_TOKEN: if imm8[0] then set #ZE
		ZERO_VALUE_TOKEN: if imm8[1] then set #IE
		ONE_VALUE_TOKEN: if imm8[2] then set #ZE
		ONE_VALUE_TOKEN: if imm8[3] then set #IE
		SNAN_TOKEN: if imm8[4] then set #IE
		NEG_INF_TOKEN: if imm8[5] then set #IE
		NEG_VALUE_TOKEN: if imm8[6] then set #IE
		POS_INF_TOKEN: if imm8[7] then set #IE
	ESAC
	RETURN dest[31:0]
}

IF k[0]
	dst[31:0] := FIXUPIMMPD(a[31:0], b[31:0], c[31:0], imm[7:0])
ELSE
	dst[31:0] := a[31:0]
FI
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vfixupimmss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_fixupimm_ss / vfixupimmss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_mask_fixupimm_ss">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="c" type="__m128i"/>
	<parameter varname="imm" type="int"/>
	<description>Fix up the lower single-precision (32-bit) floating-point elements in "a" and "b" using the lower 32-bit integer in "c", store the result in the lower element of "dst" using writemask "k" (the element is copied from "a" when mask bit 0 is not set), and copy the upper 3 packed elements from "a" to the upper elements of "dst". "imm" is used to set the required flags reporting.</description>
	<description code="true">
enum TOKEN_TYPE {
	QNAN_TOKEN := 0, 
	SNAN_TOKEN L= 1, 
	ZERO_VALUE_TOKEN := 2, 
	ONE_VALUE_TOKEN := 3, 
	NEG_INF_TOKEN := 4, 
	POS_INF_TOKEN := 5, 
	NEG_VALUE_TOKEN := 6, 
	POS_VALUE_TOKEN := 7
}
FIXUPIMMPD(src1[31:0], src2[31:0], src3[31:0], imm8[7:0]){
	tsrc[31:0] := ((src2[30:23] == 0) AND (MXCSR.DAZ == 1)) ? 0.0 : src2[31:0]
	CASE(tsrc[31:0] of TOKEN_TYPE)
		QNAN_TOKEN:j := 0
		SNAN_TOKEN:j := 1
		ZERO_VALUE_TOKEN: j := 2
		ONE_VALUE_TOKEN: j := 3
		NEG_INF_TOKEN: j := 4
		POS_INF_TOKEN: j := 5
		NEG_VALUE_TOKEN: j := 6
		POS_VALUE_TOKEN: j := 7
	ESAC
	
	token_response[3:0] := src3[3+4*j:4*j]
	
	CASE(token_response[3:0]) of
		0 : dest[31:0] := src1[31:0]
		1 : dest[31:0] := tsrc[31:0]
		2 : dest[31:0] := QNaN(tsrc[31:0])
		3 : dest[31:0] := QNAN_Indefinite
		4 : dest[31:0] := -INF
		5 : dest[31:0] := +INF
		6 : dest[31:0] := tsrc.sign? &#x2013;INF : +INF
		7 : dest[31:0] := -0
		8 : dest[31:0] := +0
		9 : dest[31:0] := -1
		10: dest[31:0] := +1
		11: dest[31:0] := 1&#x2044;2
		12: dest[31:0] := 90.0
		13: dest[31:0] := PI/2
		14: dest[31:0] := MAX_FLOAT
		15: dest[31:0] := -MAX_FLOAT
	ESAC
	
	CASE(tsrc[31:0] of TOKEN_TYPE)
		ZERO_VALUE_TOKEN: if imm8[0] then set #ZE
		ZERO_VALUE_TOKEN: if imm8[1] then set #IE
		ONE_VALUE_TOKEN: if imm8[2] then set #ZE
		ONE_VALUE_TOKEN: if imm8[3] then set #IE
		SNAN_TOKEN: if imm8[4] then set #IE
		NEG_INF_TOKEN: if imm8[5] then set #IE
		NEG_VALUE_TOKEN: if imm8[6] then set #IE
		POS_INF_TOKEN: if imm8[7] then set #IE
	ESAC
	RETURN dest[31:0]
}

IF k[0]
	dst[31:0] := FIXUPIMMPD(a[31:0], b[31:0], c[31:0], imm[7:0])
ELSE
	dst[31:0] := a[31:0]
FI
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vfixupimmss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_fixupimm_round_ss / vfixupimmss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_maskz_fixupimm_round_ss">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="c" type="__m128i"/>
	<parameter varname="imm" type="int"/>
	<parameter varname="rounding" type="int"/>
	<description>Fix up the lower single-precision (32-bit) floating-point elements in "a" and "b" using the lower 32-bit integer in "c", store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from "a" to the upper elements of "dst". "imm" is used to set the required flags reporting.
	[round_note]
	</description>
	<description code="true">
enum TOKEN_TYPE {
	QNAN_TOKEN := 0, 
	SNAN_TOKEN L= 1, 
	ZERO_VALUE_TOKEN := 2, 
	ONE_VALUE_TOKEN := 3, 
	NEG_INF_TOKEN := 4, 
	POS_INF_TOKEN := 5, 
	NEG_VALUE_TOKEN := 6, 
	POS_VALUE_TOKEN := 7
}
FIXUPIMMPD(src1[31:0], src2[31:0], src3[31:0], imm8[7:0]){
	tsrc[31:0] := ((src2[30:23] == 0) AND (MXCSR.DAZ == 1)) ? 0.0 : src2[31:0]
	CASE(tsrc[31:0] of TOKEN_TYPE)
		QNAN_TOKEN:j := 0
		SNAN_TOKEN:j := 1
		ZERO_VALUE_TOKEN: j := 2
		ONE_VALUE_TOKEN: j := 3
		NEG_INF_TOKEN: j := 4
		POS_INF_TOKEN: j := 5
		NEG_VALUE_TOKEN: j := 6
		POS_VALUE_TOKEN: j := 7
	ESAC
	
	token_response[3:0] := src3[3+4*j:4*j]
	
	CASE(token_response[3:0]) of
		0 : dest[31:0] := src1[31:0]
		1 : dest[31:0] := tsrc[31:0]
		2 : dest[31:0] := QNaN(tsrc[31:0])
		3 : dest[31:0] := QNAN_Indefinite
		4 : dest[31:0] := -INF
		5 : dest[31:0] := +INF
		6 : dest[31:0] := tsrc.sign? &#x2013;INF : +INF
		7 : dest[31:0] := -0
		8 : dest[31:0] := +0
		9 : dest[31:0] := -1
		10: dest[31:0] := +1
		11: dest[31:0] := 1&#x2044;2
		12: dest[31:0] := 90.0
		13: dest[31:0] := PI/2
		14: dest[31:0] := MAX_FLOAT
		15: dest[31:0] := -MAX_FLOAT
	ESAC
	
	CASE(tsrc[31:0] of TOKEN_TYPE)
		ZERO_VALUE_TOKEN: if imm8[0] then set #ZE
		ZERO_VALUE_TOKEN: if imm8[1] then set #IE
		ONE_VALUE_TOKEN: if imm8[2] then set #ZE
		ONE_VALUE_TOKEN: if imm8[3] then set #IE
		SNAN_TOKEN: if imm8[4] then set #IE
		NEG_INF_TOKEN: if imm8[5] then set #IE
		NEG_VALUE_TOKEN: if imm8[6] then set #IE
		POS_INF_TOKEN: if imm8[7] then set #IE
	ESAC
	RETURN dest[31:0]
}

IF k[0]
	dst[31:0] := FIXUPIMMPD(a[31:0], b[31:0], c[31:0], imm[7:0])
ELSE
	dst[31:0] := 0
FI
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vfixupimmss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_fixupimm_ss / vfixupimmss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_maskz_fixupimm_ss">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="c" type="__m128i"/>
	<parameter varname="imm" type="int"/>
	<description>Fix up the lower single-precision (32-bit) floating-point elements in "a" and "b" using the lower 32-bit integer in "c", store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from "a" to the upper elements of "dst". "imm" is used to set the required flags reporting.</description>
	<description code="true">
enum TOKEN_TYPE {
	QNAN_TOKEN := 0, 
	SNAN_TOKEN L= 1, 
	ZERO_VALUE_TOKEN := 2, 
	ONE_VALUE_TOKEN := 3, 
	NEG_INF_TOKEN := 4, 
	POS_INF_TOKEN := 5, 
	NEG_VALUE_TOKEN := 6, 
	POS_VALUE_TOKEN := 7
}
FIXUPIMMPD(src1[31:0], src2[31:0], src3[31:0], imm8[7:0]){
	tsrc[31:0] := ((src2[30:23] == 0) AND (MXCSR.DAZ == 1)) ? 0.0 : src2[31:0]
	CASE(tsrc[31:0] of TOKEN_TYPE)
		QNAN_TOKEN:j := 0
		SNAN_TOKEN:j := 1
		ZERO_VALUE_TOKEN: j := 2
		ONE_VALUE_TOKEN: j := 3
		NEG_INF_TOKEN: j := 4
		POS_INF_TOKEN: j := 5
		NEG_VALUE_TOKEN: j := 6
		POS_VALUE_TOKEN: j := 7
	ESAC
	
	token_response[3:0] := src3[3+4*j:4*j]
	
	CASE(token_response[3:0]) of
		0 : dest[31:0] := src1[31:0]
		1 : dest[31:0] := tsrc[31:0]
		2 : dest[31:0] := QNaN(tsrc[31:0])
		3 : dest[31:0] := QNAN_Indefinite
		4 : dest[31:0] := -INF
		5 : dest[31:0] := +INF
		6 : dest[31:0] := tsrc.sign? &#x2013;INF : +INF
		7 : dest[31:0] := -0
		8 : dest[31:0] := +0
		9 : dest[31:0] := -1
		10: dest[31:0] := +1
		11: dest[31:0] := 1&#x2044;2
		12: dest[31:0] := 90.0
		13: dest[31:0] := PI/2
		14: dest[31:0] := MAX_FLOAT
		15: dest[31:0] := -MAX_FLOAT
	ESAC
	
	CASE(tsrc[31:0] of TOKEN_TYPE)
		ZERO_VALUE_TOKEN: if imm8[0] then set #ZE
		ZERO_VALUE_TOKEN: if imm8[1] then set #IE
		ONE_VALUE_TOKEN: if imm8[2] then set #ZE
		ONE_VALUE_TOKEN: if imm8[3] then set #IE
		SNAN_TOKEN: if imm8[4] then set #IE
		NEG_INF_TOKEN: if imm8[5] then set #IE
		NEG_VALUE_TOKEN: if imm8[6] then set #IE
		POS_INF_TOKEN: if imm8[7] then set #IE
	ESAC
	RETURN dest[31:0]
}

IF k[0]
	dst[31:0] := FIXUPIMMPD(a[31:0], b[31:0], c[31:0], imm[7:0])
ELSE
	dst[31:0] := 0
FI
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vfixupimmss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_fmadd_pd / vfmadd231pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_fmadd_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="c" type="__m512d"/>
	<description>Multiply packed double-precision (64-bit) floating-point elements in "a" and "b", add the intermediate result to packed elements in "c", and store the results in "dst". 
	</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := (a[i+63:i] * b[i+63:i]) + c[i+63:i]
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfmadd132pd"/>
	<mnemonic base="vfmadd213pd"/>
	<mnemonic base="vfmadd231pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_fmadd_round_pd / vfmadd231pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_fmadd_round_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="c" type="__m512d"/>
	<parameter varname="rounding" type="int"/>
	<description>Multiply packed double-precision (64-bit) floating-point elements in "a" and "b", add the intermediate result to packed elements in "c", and store the results in "dst". 
	[round_note]
	</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := (a[i+63:i] * b[i+63:i]) + c[i+63:i]
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfmadd132pd"/>
	<mnemonic base="vfmadd213pd"/>
	<mnemonic base="vfmadd231pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask3_fmadd_pd / vfmadd231pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask3_fmadd_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="c" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<description>Multiply packed double-precision (64-bit) floating-point elements in "a" and "b", add the intermediate result to packed elements in "c", and store the results in "dst" using writemask "k" (elements are copied from "c" when the corresponding mask bit is not set). 
	</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := (a[i+63:i] * b[i+63:i]) + c[i+63:i]
	ELSE
		dst[i+63:i] := c[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfmadd132pd"/>
	<mnemonic base="vfmadd213pd"/>
	<mnemonic base="vfmadd231pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask3_fmadd_round_pd / vfmadd231pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask3_fmadd_round_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="c" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="rounding" type="int"/>
	<description>Multiply packed double-precision (64-bit) floating-point elements in "a" and "b", add the intermediate result to packed elements in "c", and store the results in "dst" using writemask "k" (elements are copied from "c" when the corresponding mask bit is not set). 
	[round_note]
	</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := (a[i+63:i] * b[i+63:i]) + c[i+63:i]
	ELSE 
		dst[i+63:i] := c[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfmadd132pd"/>
	<mnemonic base="vfmadd213pd"/>
	<mnemonic base="vfmadd231pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_fmadd_pd / vfmadd231pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_fmadd_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="c" type="__m512d"/>
	<description>Multiply packed double-precision (64-bit) floating-point elements in "a" and "b", add the intermediate result to packed elements in "c", and store the results in "dst" using writemask "k" (elements are copied from "a" when the corresponding mask bit is not set). 
	</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := (a[i+63:i] * b[i+63:i]) + c[i+63:i]
	ELSE
		dst[i+63:i] := a[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfmadd132pd"/>
	<mnemonic base="vfmadd213pd"/>
	<mnemonic base="vfmadd231pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_fmadd_round_pd / vfmadd231pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_fmadd_round_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="c" type="__m512d"/>
	<parameter varname="rounding" type="int"/>
	<description>Multiply packed double-precision (64-bit) floating-point elements in "a" and "b", add the intermediate result to packed elements in "c", and store the results in "dst" using writemask "k" (elements are copied from "a" when the corresponding mask bit is not set).
	[round_note]</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := (a[i+63:i] * b[i+63:i]) + c[i+63:i]
	ELSE
		dst[i+63:i] := a[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfmadd132pd"/>
	<mnemonic base="vfmadd213pd"/>
	<mnemonic base="vfmadd231pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_fmadd_pd / vfmadd231pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_fmadd_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="c" type="__m512d"/>
	<description>Multiply packed double-precision (64-bit) floating-point elements in "a" and "b", add the intermediate result to packed elements in "c", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). 
	</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := (a[i+63:i] * b[i+63:i]) + c[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfmadd132pd"/>
	<mnemonic base="vfmadd213pd"/>
	<mnemonic base="vfmadd231pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_fmadd_round_pd / vfmadd231pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_fmadd_round_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="c" type="__m512d"/>
	<parameter varname="rounding" type="const int"/>
	<description>Multiply packed double-precision (64-bit) floating-point elements in "a" and "b", add the intermediate result to packed elements in "c", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). 
	[round_note]</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := (a[i+63:i] * b[i+63:i]) + c[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfmadd132pd"/>
	<mnemonic base="vfmadd213pd"/>
	<mnemonic base="vfmadd231pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_fmadd_ps / vfmadd231ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_fmadd_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="c" type="__m512"/>
	<description>Multiply packed single-precision (32-bit) floating-point elements in "a" and "b", add the intermediate result to packed elements in "c", and store the results in "dst". 
	</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := (a[i+31:i] * b[i+31:i]) + c[i+31:i]
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfmadd132ps"/>
	<mnemonic base="vfmadd213ps"/>
	<mnemonic base="vfmadd231ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_fmadd_round_ps / vfmadd231ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_fmadd_round_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="c" type="__m512"/>
	<parameter varname="rounding" type="int"/>
	<description>Multiply packed single-precision (32-bit) floating-point elements in "a" and "b", add the intermediate result to packed elements in "c", and store the results in "dst". 
	[round_note]</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := (a[i+31:i] * b[i+31:i]) + c[i+31:i]
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfmadd132ps"/>
	<mnemonic base="vfmadd213ps"/>
	<mnemonic base="vfmadd231ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask3_fmadd_ps / vfmadd231ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask3_fmadd_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="c" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<description>Multiply packed single-precision (32-bit) floating-point elements in "a" and "b", add the intermediate result to packed elements in "c", and store the results in "dst" using writemask "k" (elements are copied from "c" when the corresponding mask bit is not set). 
	</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := (a[i+31:i] * b[i+31:i]) + c[i+31:i]
	ELSE
		dst[i+31:i] := c[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfmadd132ps"/>
	<mnemonic base="vfmadd213ps"/>
	<mnemonic base="vfmadd231ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask3_fmadd_round_ps / vfmadd231ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask3_fmadd_round_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="c" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="rounding" type="int"/>
	<description>Multiply packed single-precision (32-bit) floating-point elements in "a" and "b", add the intermediate result to packed elements in "c", and store the results in "dst" using writemask "k" (elements are copied from "c" when the corresponding mask bit is not set). 
	[round_note]</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := (a[i+31:i] * b[i+31:i]) + c[i+31:i]
	ELSE
		dst[i+31:i] := c[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfmadd132ps"/>
	<mnemonic base="vfmadd213ps"/>
	<mnemonic base="vfmadd231ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_fmadd_ps / vfmadd231ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_fmadd_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="c" type="__m512"/>
	<description>Multiply packed single-precision (32-bit) floating-point elements in "a" and "b", add the intermediate result to packed elements in "c", and store the results in "dst" using writemask "k" (elements are copied from "a" when the corresponding mask bit is not set). 
	</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := (a[i+31:i] * b[i+31:i]) + c[i+31:i]
	ELSE
		dst[i+31:i] := a[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfmadd132ps"/>
	<mnemonic base="vfmadd213ps"/>
	<mnemonic base="vfmadd231ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_fmadd_round_ps / vfmadd231ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_fmadd_round_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="c" type="__m512"/>
	<parameter varname="rounding" type="int"/>
	<description>Multiply packed single-precision (32-bit) floating-point elements in "a" and "b", add the intermediate result to packed elements in "c", and store the results in "dst" using writemask "k" (elements are copied from "a" when the corresponding mask bit is not set). 
	[round_note]</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := (a[i+31:i] * b[i+31:i]) + c[i+31:i]
	ELSE
		dst[i+31:i] := a[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfmadd132ps"/>
	<mnemonic base="vfmadd213ps"/>
	<mnemonic base="vfmadd231ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_fmadd_ps / vfmadd231ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_fmadd_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="c" type="__m512"/>
	<description>Multiply packed single-precision (32-bit) floating-point elements in "a" and "b", add the intermediate result to packed elements in "c", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). 
	</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := (a[i+31:i] * b[i+31:i]) + c[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>	
	<mnemonic base="vfmadd132ps"/>
	<mnemonic base="vfmadd213ps"/>
	<mnemonic base="vfmadd231ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_fmadd_round_ps / vfmadd231ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_fmadd_round_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="c" type="__m512"/>
	<parameter varname="rounding" type="const int"/>
	<description>Multiply packed single-precision (32-bit) floating-point elements in "a" and "b", add the intermediate result to packed elements in "c", and store the results in "a" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). 
	[round_note]</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		a[i+31:i] := (a[i+31:i] * b[i+31:i]) + c[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfmadd132ps"/>
	<mnemonic base="vfmadd213ps"/>
	<mnemonic base="vfmadd231ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask3_fmadd_round_sd / vfmadd231sd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_mask3_fmadd_round_sd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="c" type="__m128d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="rounding" type="int"/>
	<description>Multiply the lower double-precision (64-bit) floating-point elements in "a" and "b", and add the intermediate result to the lower element in "c". Store the result in the lower element of "dst" using writemask "k" (the element is copied from "c" when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst".
	[round_note]</description>
	<description code="true">
IF k[0]
	dst[63:0] := (a[63:0] * b[63:0]) + c[63:0]
ELSE
	dst[63:0] := c[63:0]
FI
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vfmadd132sd"/>
	<mnemonic base="vfmadd213sd"/>
	<mnemonic base="vfmadd231sd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask3_fmadd_sd / vfmadd231sd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_mask3_fmadd_sd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="c" type="__m128d"/>
	<parameter varname="k" type="__mmask8"/>
	<description>Multiply the lower double-precision (64-bit) floating-point elements in "a" and "b", and add the intermediate result to the lower element in "c". Store the result in the lower element of "dst" using writemask "k" (the element is copied from "c" when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst".
	</description>
	<description code="true">
IF k[0]
	dst[63:0] := (a[63:0] * b[63:0]) + c[63:0]
ELSE
	dst[63:0] := c[63:0]
FI
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vfmadd132sd"/>
	<mnemonic base="vfmadd213sd"/>
	<mnemonic base="vfmadd231sd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_fmadd_round_sd / vfmadd231sd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_mask_fmadd_round_sd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="c" type="__m128d"/>
	<parameter varname="rounding" type="int"/>
	<description>Multiply the lower double-precision (64-bit) floating-point elements in "a" and "b", and add the intermediate result to the lower element in "c". Store the result in the lower element of "dst" using writemask "k" (the element is copied from "a" when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst".
	[round_note]</description>
	<description code="true">
IF k[0]
	dst[63:0] := (a[63:0] * b[63:0]) + c[63:0]
ELSE
	dst[63:0] := a[63:0]
FI
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vfmadd132sd"/>
	<mnemonic base="vfmadd213sd"/>
	<mnemonic base="vfmadd231sd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_fmadd_sd / vfmadd231sd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_mask_fmadd_sd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="c" type="__m128d"/>
	<description>Multiply the lower double-precision (64-bit) floating-point elements in "a" and "b", and add the intermediate result to the lower element in "c". Store the result in the lower element of "dst" using writemask "k" (the element is copied from "a" when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst".
	</description>
	<description code="true">
IF k[0]
	dst[63:0] := (a[63:0] * b[63:0]) + c[63:0]
ELSE
	dst[63:0] := a[63:0]
FI
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vfmadd132sd"/>
	<mnemonic base="vfmadd213sd"/>
	<mnemonic base="vfmadd231sd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_fmadd_round_sd / vfmadd231sd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_maskz_fmadd_round_sd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="c" type="__m128d"/>
	<parameter varname="rounding" type="int"/>
	<description>Multiply the lower double-precision (64-bit) floating-point elements in "a" and "b", and add the intermediate result to the lower element in "c". Store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst".
	[round_note]</description>
	<description code="true">
IF k[0]
	dst[63:0] := (a[63:0] * b[63:0]) + c[63:0]
ELSE
	dst[63:0] := 0
FI
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vfmadd132sd"/>
	<mnemonic base="vfmadd213sd"/>
	<mnemonic base="vfmadd231sd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_fmadd_sd / vfmadd231sd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_maskz_fmadd_sd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="c" type="__m128d"/>
	<description>Multiply the lower double-precision (64-bit) floating-point elements in "a" and "b", and add the intermediate result to the lower element in "c". Store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst".
	</description>
	<description code="true">
IF k[0]
	dst[63:0] := (a[63:0] * b[63:0]) + c[63:0]
ELSE
	dst[63:0] := 0
FI
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vfmadd132sd"/>
	<mnemonic base="vfmadd213sd"/>
	<mnemonic base="vfmadd231sd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask3_fmadd_round_ss / vfmadd231ss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_mask3_fmadd_round_ss">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="c" type="__m128"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="rounding" type="int"/>
	<description>Multiply the lower single-precision (32-bit) floating-point elements in "a" and "b", and add the intermediate result to the lower element in "c". Store the result in the lower element of "dst" using writemask "k" (the element is copied from "c" when mask bit 0 is not set), and copy the upper 3 packed elements from "a" to the upper elements of "dst".
	[round_note]</description>
	<description code="true">
IF k[0]
	dst[31:0] := (a[31:0] * b[31:0]) + c[31:0]
ELSE
	dst[31:0] := c[31:0]
FI
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vfmadd132ss"/>
	<mnemonic base="vfmadd213ss"/>
	<mnemonic base="vfmadd231ss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask3_fmadd_ss / vfmadd231ss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_mask3_fmadd_ss">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="c" type="__m128"/>
	<parameter varname="k" type="__mmask8"/>
	<description>Multiply the lower single-precision (32-bit) floating-point elements in "a" and "b", and add the intermediate result to the lower element in "c". Store the result in the lower element of "dst" using writemask "k" (the element is copied from "c" when mask bit 0 is not set), and copy the upper 3 packed elements from "a" to the upper elements of "dst".
	</description>
	<description code="true">
IF k[0]
	dst[31:0] := (a[31:0] * b[31:0]) + c[31:0]
ELSE
	dst[31:0] := c[31:0]
FI
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vfmadd132ss"/>
	<mnemonic base="vfmadd213ss"/>
	<mnemonic base="vfmadd231ss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_fmadd_round_ss / vfmadd231ss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_mask_fmadd_round_ss">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="c" type="__m128"/>
	<parameter varname="rounding" type="int"/>
	<description>Multiply the lower single-precision (32-bit) floating-point elements in "a" and "b", and add the intermediate result to the lower element in "c". Store the result in the lower element of "dst" using writemask "k" (the element is copied from "a" when mask bit 0 is not set), and copy the upper 3 packed elements from "a" to the upper elements of "dst".
	[round_note]</description>
	<description code="true">
IF k[0]
	dst[31:0] := (a[31:0] * b[31:0]) + c[31:0]
ELSE
	dst[31:0] := a[31:0]
FI
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vfmadd132ss"/>
	<mnemonic base="vfmadd213ss"/>
	<mnemonic base="vfmadd231ss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_fmadd_ss / vfmadd231ss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_mask_fmadd_ss">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="c" type="__m128"/>
	<description>Multiply the lower single-precision (32-bit) floating-point elements in "a" and "b", and add the intermediate result to the lower element in "c". Store the result in the lower element of "dst" using writemask "k" (the element is copied from "a" when mask bit 0 is not set), and copy the upper 3 packed elements from "a" to the upper elements of "dst".
	</description>
	<description code="true">
IF k[0]
	dst[31:0] := (a[31:0] * b[31:0]) + c[31:0]
ELSE
	dst[31:0] := a[31:0]
FI
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vfmadd132ss"/>
	<mnemonic base="vfmadd213ss"/>
	<mnemonic base="vfmadd231ss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_fmadd_round_ss / vfmadd231ss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_maskz_fmadd_round_ss">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="c" type="__m128"/>
	<parameter varname="rounding" type="int"/>
	<description>Multiply the lower single-precision (32-bit) floating-point elements in "a" and "b", and add the intermediate result to the lower element in "c". Store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from "a" to the upper elements of "dst".
	[round_note]</description>
	<description code="true">
IF k[0]
	dst[31:0] := (a[31:0] * b[31:0]) + c[31:0]
ELSE
	dst[31:0] := 0
FI
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vfmadd132ss"/>
	<mnemonic base="vfmadd213ss"/>
	<mnemonic base="vfmadd231ss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_fmadd_ss / vfmadd231ss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_maskz_fmadd_ss">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="c" type="__m128"/>
	<description>Multiply the lower single-precision (32-bit) floating-point elements in "a" and "b", and add the intermediate result to the lower element in "c". Store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from "a" to the upper elements of "dst".
	</description>
	<description code="true">
IF k[0]
	dst[31:0] := (a[31:0] * b[31:0]) + c[31:0]
ELSE
	dst[31:0] := 0
FI
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vfmadd132ss"/>
	<mnemonic base="vfmadd213ss"/>
	<mnemonic base="vfmadd231ss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_fmaddsub_pd / vfmaddsub231pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_fmaddsub_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="c" type="__m512d"/>
	<description>Multiply packed double-precision (64-bit) floating-point elements in "a" and "b", alternatively add and subtract packed elements in "c" to/from the intermediate result, and store the results in "dst". 
	</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF (j is even) 
		dst[i+63:i] := (a[i+63:i] * b[i+63:i]) - c[i+63:i]
	ELSE
		dst[i+63:i] := (a[i+63:i] * b[i+63:i]) + c[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfmaddsub132pd"/>
	<mnemonic base="vfmaddsub213pd"/>
	<mnemonic base="vfmaddsub231pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_fmaddsub_round_pd / vfmaddsub231pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_fmaddsub_round_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="c" type="__m512d"/>
	<parameter varname="rounding" type="const int"/>
	<description>Multiply packed double-precision (64-bit) floating-point elements in "a" and "b", alternatively add and subtract packed elements in "c" to/from the intermediate result, and store the results in "dst". 
	[round_note]</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF (j is even) 
		dst[i+63:i] := (a[i+63:i] * b[i+63:i]) - c[i+63:i]
	ELSE
		dst[i+63:i] := (a[i+63:i] * b[i+63:i]) + c[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfmaddsub132pd"/>
	<mnemonic base="vfmaddsub213pd"/>
	<mnemonic base="vfmaddsub231pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask3_fmaddsub_pd / vfmaddsub231pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask3_fmaddsub_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="c" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<description>Multiply packed double-precision (64-bit) floating-point elements in "a" and "b", alternatively add and subtract packed elements in "c" to/from the intermediate result, and store the results in "dst" using writemask "k" (elements are copied from "c" when the corresponding mask bit is not set).  </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF (j is even) 
			dst[i+63:i] := (a[i+63:i] * b[i+63:i]) - c[i+63:i]
		ELSE
			dst[i+63:i] := (a[i+63:i] * b[i+63:i]) + c[i+63:i]
		FI
	ELSE
		dst[i+63:i] := c[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfmaddsub132pd"/>
	<mnemonic base="vfmaddsub213pd"/>
	<mnemonic base="vfmaddsub231pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask3_fmaddsub_round_pd / vfmaddsub231pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask3_fmaddsub_round_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="c" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="rounding" type="const int"/>
	<description>Multiply packed double-precision (64-bit) floating-point elements in "a" and "b", alternatively add and subtract packed elements in "c" to/from the intermediate result, and store the results in "dst" using writemask "k" (elements are copied from "c" when the corresponding mask bit is not set).  [round_note]</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF (j is even) 
			dst[i+63:i] := (a[i+63:i] * b[i+63:i]) - c[i+63:i]
		ELSE
			dst[i+63:i] := (a[i+63:i] * b[i+63:i]) + c[i+63:i]
		FI
	ELSE 
		dst[i+63:i] := c[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfmaddsub132pd"/>
	<mnemonic base="vfmaddsub213pd"/>
	<mnemonic base="vfmaddsub231pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_fmaddsub_pd / vfmaddsub231pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_fmaddsub_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="c" type="__m512d"/>
	<description>Multiply packed double-precision (64-bit) floating-point elements in "a" and "b", alternatively add and subtract packed elements in "c" to/from the intermediate result, and store the results in "dst" using writemask "k" (elements are copied from "a" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF (j is even) 
			dst[i+63:i] := (a[i+63:i] * b[i+63:i]) - c[i+63:i]
		ELSE
			dst[i+63:i] := (a[i+63:i] * b[i+63:i]) + c[i+63:i]
		FI
	ELSE
		dst[i+63:i] := a[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfmaddsub132pd"/>
	<mnemonic base="vfmaddsub213pd"/>
	<mnemonic base="vfmaddsub231pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_fmaddsub_round_pd / vfmaddsub231pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_fmaddsub_round_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="c" type="__m512d"/>
	<parameter varname="rounding" type="const int"/>
	<description>Multiply packed double-precision (64-bit) floating-point elements in "a" and "b", alternatively add and subtract packed elements in "c" to/from the intermediate result, and store the results in "dst" using writemask "k" (elements are copied from "a" when the corresponding mask bit is not set). [round_note]</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF (j is even) 
			dst[i+63:i] := (a[i+63:i] * b[i+63:i]) - c[i+63:i]
		ELSE
			dst[i+63:i] := (a[i+63:i] * b[i+63:i]) + c[i+63:i]
		FI
	ELSE
		dst[i+63:i] := a[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfmaddsub132pd"/>
	<mnemonic base="vfmaddsub213pd"/>
	<mnemonic base="vfmaddsub231pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_fmaddsub_pd / vfmaddsub231pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_fmaddsub_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="c" type="__m512d"/>
	<description>Multiply packed double-precision (64-bit) floating-point elements in "a" and "b", alternatively add and subtract packed elements in "c" to/from the intermediate result, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). 
	</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF (j is even) 
			dst[i+63:i] := (a[i+63:i] * b[i+63:i]) - c[i+63:i]
		ELSE
			dst[i+63:i] := (a[i+63:i] * b[i+63:i]) + c[i+63:i]
		FI
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfmaddsub132pd"/>
	<mnemonic base="vfmaddsub213pd"/>
	<mnemonic base="vfmaddsub231pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_fmaddsub_round_pd / vfmaddsub231pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_fmaddsub_round_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="c" type="__m512d"/>
	<parameter varname="rounding" type="const int"/>
	<description>Multiply packed double-precision (64-bit) floating-point elements in "a" and "b", alternatively add and subtract packed elements in "c" to/from the intermediate result, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). 
	[round_note]</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF (j is even) 
			dst[i+63:i] := (a[i+63:i] * b[i+63:i]) - c[i+63:i]
		ELSE
			dst[i+63:i] := (a[i+63:i] * b[i+63:i]) + c[i+63:i]
		FI
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfmaddsub132pd"/>
	<mnemonic base="vfmaddsub213pd"/>
	<mnemonic base="vfmaddsub231pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_fmaddsub_ps / vfmaddsub231ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_fmaddsub_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="c" type="__m512"/>
	<description>Multiply packed single-precision (32-bit) floating-point elements in "a" and "b", alternatively add and subtract packed elements in "c" to/from the intermediate result, and store the results in "dst". 
	</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF (j is even) 
		dst[i+31:i] := (a[i+31:i] * b[i+31:i]) - c[i+31:i]
	ELSE
		dst[i+31:i] := (a[i+31:i] * b[i+31:i]) + c[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfmaddsub132ps"/>
	<mnemonic base="vfmaddsub213ps"/>
	<mnemonic base="vfmaddsub231ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_fmaddsub_round_ps / vfmaddsub231ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_fmaddsub_round_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="c" type="__m512"/>
	<parameter varname="rounding" type="const int"/>
	<description>Multiply packed single-precision (32-bit) floating-point elements in "a" and "b", alternatively add and subtract packed elements in "c" to/from the intermediate result, and store the results in "dst". 
	[round_note]</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF (j is even) 
		dst[i+31:i] := (a[i+31:i] * b[i+31:i]) - c[i+31:i]
	ELSE
		dst[i+31:i] := (a[i+31:i] * b[i+31:i]) + c[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfmaddsub132ps"/>
	<mnemonic base="vfmaddsub213ps"/>
	<mnemonic base="vfmaddsub231ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask3_fmaddsub_ps / vfmaddsub231ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask3_fmaddsub_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="c" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<description>Multiply packed single-precision (32-bit) floating-point elements in "a" and "b", alternatively add and subtract packed elements in "c" to/from the intermediate result, and store the results in "dst" using writemask "k" (elements are copied from "c" when the corresponding mask bit is not set).  </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF (j is even) 
			dst[i+31:i] := (a[i+31:i] * b[i+31:i]) - c[i+31:i]
		ELSE
			dst[i+31:i] := (a[i+31:i] * b[i+31:i]) + c[i+31:i]
		FI
	ELSE
		dst[i+31:i] := c[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfmaddsub132ps"/>
	<mnemonic base="vfmaddsub213ps"/>
	<mnemonic base="vfmaddsub231ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask3_fmaddsub_round_ps / vfmaddsub231ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask3_fmaddsub_round_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="c" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="rounding" type="const int"/>
	<description>Multiply packed single-precision (32-bit) floating-point elements in "a" and "b", alternatively add and subtract packed elements in "c" to/from the intermediate result, and store the results in "dst" using writemask "k" (elements are copied from "c" when the corresponding mask bit is not set).  [round_note]</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF (j is even) 
			dst[i+31:i] := (a[i+31:i] * b[i+31:i]) - c[i+31:i]
		ELSE
			dst[i+31:i] := (a[i+31:i] * b[i+31:i]) + c[i+31:i]
		FI
	ELSE
		dst[i+31:i] := c[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfmaddsub132ps"/>
	<mnemonic base="vfmaddsub213ps"/>
	<mnemonic base="vfmaddsub231ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_fmaddsub_ps / vfmaddsub231ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_fmaddsub_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="c" type="__m512"/>
	<description>Multiply packed single-precision (32-bit) floating-point elements in "a" and "b", alternatively add and subtract packed elements in "c" to/from the intermediate result, and store the results in "dst" using writemask "k" (elements are copied from "a" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF (j is even) 
			dst[i+31:i] := (a[i+31:i] * b[i+31:i]) - c[i+31:i]
		ELSE
			dst[i+31:i] := (a[i+31:i] * b[i+31:i]) + c[i+31:i]
		FI
	ELSE
		dst[i+31:i] := a[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfmaddsub132ps"/>
	<mnemonic base="vfmaddsub213ps"/>
	<mnemonic base="vfmaddsub231ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_fmaddsub_round_ps / vfmaddsub231ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_fmaddsub_round_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="c" type="__m512"/>
	<parameter varname="rounding" type="const int"/>
	<description>Multiply packed single-precision (32-bit) floating-point elements in "a" and "b", alternatively add and subtract packed elements in "c" to/from the intermediate result, and store the results in "dst" using writemask "k" (elements are copied from "a" when the corresponding mask bit is not set). [round_note]</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF (j is even) 
			dst[i+31:i] := (a[i+31:i] * b[i+31:i]) - c[i+31:i]
		ELSE
			dst[i+31:i] := (a[i+31:i] * b[i+31:i]) + c[i+31:i]
		FI
	ELSE
		dst[i+31:i] := a[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfmaddsub132ps"/>
	<mnemonic base="vfmaddsub213ps"/>
	<mnemonic base="vfmaddsub231ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_fmaddsub_ps / vfmaddsub231ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_fmaddsub_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="c" type="__m512"/>
	<description>Multiply packed single-precision (32-bit) floating-point elements in "a" and "b", alternatively add and subtract packed elements in "c" to/from the intermediate result, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). 
	</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF (j is even) 
			dst[i+31:i] := (a[i+31:i] * b[i+31:i]) - c[i+31:i]
		ELSE
			dst[i+31:i] := (a[i+31:i] * b[i+31:i]) + c[i+31:i]
		FI
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfmaddsub132ps"/>
	<mnemonic base="vfmaddsub213ps"/>
	<mnemonic base="vfmaddsub231ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_fmaddsub_round_ps / vfmaddsub231ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_fmaddsub_round_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="c" type="__m512"/>
	<parameter varname="rounding" type="const int"/>
	<description>Multiply packed single-precision (32-bit) floating-point elements in "a" and "b", alternatively add and subtract packed elements in "c" to/from the intermediate result, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). 
	[round_note]</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF (j is even) 
			dst[i+31:i] := (a[i+31:i] * b[i+31:i]) - c[i+31:i]
		ELSE
			dst[i+31:i] := (a[i+31:i] * b[i+31:i]) + c[i+31:i]
		FI
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfmaddsub132ps"/>
	<mnemonic base="vfmaddsub213ps"/>
	<mnemonic base="vfmaddsub231ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_fmsub_pd / vfmsub231pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_fmsub_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="c" type="__m512d"/>
	<description>Multiply packed double-precision (64-bit) floating-point elements in "a" and "b", subtract packed elements in "c" from the intermediate result, and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := (a[i+63:i] * b[i+63:i]) - c[i+63:i]
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfmsub132pd"/>
	<mnemonic base="vfmsub213pd"/>
	<mnemonic base="vfmsub231pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_fmsub_round_pd / vfmsub231pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_fmsub_round_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="c" type="__m512d"/>
	<parameter varname="rounding" type="int"/>
	<description>Multiply packed double-precision (64-bit) floating-point elements in "a" and "b", subtract packed elements in "c" from the intermediate result, and store the results in "dst". 
	[round_note]</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := (a[i+63:i] * b[i+63:i]) - c[i+63:i]
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfmsub132pd"/>
	<mnemonic base="vfmsub213pd"/>
	<mnemonic base="vfmsub231pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask3_fmsub_pd / vfmsub231pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask3_fmsub_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="c" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<description>Multiply packed double-precision (64-bit) floating-point elements in "a" and "b", subtract packed elements in "c" from the intermediate result, and store the results in "dst" using writemask "k" (elements are copied from "c" when the corresponding mask bit is not set).  </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := (a[i+63:i] * b[i+63:i]) - c[i+63:i]
	ELSE
		dst[i+63:i] := c[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfmsub132pd"/>
	<mnemonic base="vfmsub213pd"/>
	<mnemonic base="vfmsub231pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask3_fmsub_round_pd / vfmsub231pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask3_fmsub_round_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="c" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="rounding" type="int"/>
	<description>Multiply packed double-precision (64-bit) floating-point elements in "a" and "b", subtract packed elements in "c" from the intermediate result, and store the results in "dst" using writemask "k" (elements are copied from "c" when the corresponding mask bit is not set).  [round_note]</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := (a[i+63:i] * b[i+63:i]) - c[i+63:i]
	ELSE
		dst[i+63:i] := c[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfmsub132pd"/>
	<mnemonic base="vfmsub213pd"/>
	<mnemonic base="vfmsub231pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_fmsub_pd / vfmsub231pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_fmsub_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="c" type="__m512d"/>
	<description>Multiply packed double-precision (64-bit) floating-point elements in "a" and "b", subtract packed elements in "c" from the intermediate result, and store the results in "dst" using writemask "k" (elements are copied from "a" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := (a[i+63:i] * b[i+63:i]) - c[i+63:i]
	ELSE
		dst[i+63:i] := a[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfmsub132pd"/>
	<mnemonic base="vfmsub213pd"/>
	<mnemonic base="vfmsub231pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_fmsub_round_pd / vfmsub231pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_fmsub_round_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="c" type="__m512d"/>
	<parameter varname="rounding" type="int"/>
	<description>Multiply packed double-precision (64-bit) floating-point elements in "a" and "b", subtract packed elements in "c" from the intermediate result, and store the results in "dst" using writemask "k" (elements are copied from "a" when the corresponding mask bit is not set). [round_note]</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := (a[i+63:i] * b[i+63:i]) - c[i+63:i]
	ELSE
		dst[i+63:i] := a[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfmsub132pd"/>
	<mnemonic base="vfmsub213pd"/>
	<mnemonic base="vfmsub231pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_fmsub_pd / vfmsub231pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_fmsub_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="c" type="__m512d"/>
	<description>Multiply packed double-precision (64-bit) floating-point elements in "a" and "b", subtract packed elements in "c" from the intermediate result, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). 
	</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := (a[i+63:i] * b[i+63:i]) - c[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfmsub132pd"/>
	<mnemonic base="vfmsub213pd"/>
	<mnemonic base="vfmsub231pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_fmsub_round_pd / vfmsub231pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_fmsub_round_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="c" type="__m512d"/>
	<parameter varname="rounding" type="const int"/>
	<description>Multiply packed double-precision (64-bit) floating-point elements in "a" and "b", subtract packed elements in "c" from the intermediate result, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). 
	[round_note]</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := (a[i+63:i] * b[i+63:i]) - c[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfmsub132pd"/>
	<mnemonic base="vfmsub213pd"/>
	<mnemonic base="vfmsub231pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_fmsub_ps / vfmsub231ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_fmsub_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="c" type="__m512"/>
	<description>Multiply packed single-precision (32-bit) floating-point elements in "a" and "b", subtract packed elements in "c" from the intermediate result, and store the results in "dst". 
	</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := (a[i+31:i] * b[i+31:i]) - c[i+31:i]
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfmsub132ps"/>
	<mnemonic base="vfmsub213ps"/>
	<mnemonic base="vfmsub231ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_fmsub_round_ps / vfmsub231ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_fmsub_round_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="c" type="__m512"/>
	<parameter varname="rounding" type="int"/>
	<description>Multiply packed single-precision (32-bit) floating-point elements in "a" and "b", subtract packed elements in "c" from the intermediate result, and store the results in "dst". 
	[round_note]</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := (a[i+31:i] * b[i+31:i]) - c[i+31:i]
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfmsub132ps"/>
	<mnemonic base="vfmsub213ps"/>
	<mnemonic base="vfmsub231ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask3_fmsub_ps / vfmsub231ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask3_fmsub_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="c" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<description>Multiply packed single-precision (32-bit) floating-point elements in "a" and "b", subtract packed elements in "c" from the intermediate result, and store the results in "dst" using writemask "k" (elements are copied from "c" when the corresponding mask bit is not set).  </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := (a[i+31:i] * b[i+31:i]) - c[i+31:i]
	ELSE
		dst[i+31:i] := c[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfmsub132ps"/>
	<mnemonic base="vfmsub213ps"/>
	<mnemonic base="vfmsub231ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask3_fmsub_round_ps / vfmsub231ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask3_fmsub_round_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="c" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="rounding" type="int"/>
	<description>Multiply packed single-precision (32-bit) floating-point elements in "a" and "b", subtract packed elements in "c" from the intermediate result, and store the results in "dst" using writemask "k" (elements are copied from "c" when the corresponding mask bit is not set).  [round_note]</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := (a[i+31:i] * b[i+31:i]) - c[i+31:i]
	ELSE
		dst[i+31:i] := c[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfmsub132ps"/>
	<mnemonic base="vfmsub213ps"/>
	<mnemonic base="vfmsub231ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_fmsub_ps / vfmsub231ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_fmsub_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="c" type="__m512"/>
	<description>Multiply packed single-precision (32-bit) floating-point elements in "a" and "b", subtract packed elements in "c" from the intermediate result, and store the results in "dst" using writemask "k" (elements are copied from "a" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := (a[i+31:i] * b[i+31:i]) - c[i+31:i]
	ELSE
		dst[i+31:i] := a[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfmsub132ps"/>
	<mnemonic base="vfmsub213ps"/>
	<mnemonic base="vfmsub231ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_fmsub_round_ps / vfmsub231ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_fmsub_round_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="c" type="__m512"/>
	<parameter varname="rounding" type="int"/>
	<description>Multiply packed single-precision (32-bit) floating-point elements in "a" and "b", subtract packed elements in "c" from the intermediate result, and store the results in "dst" using writemask "k" (elements are copied from "a" when the corresponding mask bit is not set). [round_note]</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := (a[i+31:i] * b[i+31:i]) - c[i+31:i]
	ELSE
		dst[i+31:i] := a[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfmsub132ps"/>
	<mnemonic base="vfmsub213ps"/>
	<mnemonic base="vfmsub231ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_fmsub_ps / vfmsub231ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_fmsub_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="c" type="__m512"/>
	<description>Multiply packed single-precision (32-bit) floating-point elements in "a" and "b", subtract packed elements in "c" from the intermediate result, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). 
	</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := (a[i+31:i] * b[i+31:i]) - c[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfmsub132ps"/>
	<mnemonic base="vfmsub213ps"/>
	<mnemonic base="vfmsub231ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_fmsub_round_ps / vfmsub231ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_fmsub_round_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="c" type="__m512"/>
	<parameter varname="rounding" type="const int"/>
	<description>Multiply packed single-precision (32-bit) floating-point elements in "a" and "b", subtract packed elements in "c" from the intermediate result, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). 
	[round_note]</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := (a[i+31:i] * b[i+31:i]) - c[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfmsub132ps"/>
	<mnemonic base="vfmsub213ps"/>
	<mnemonic base="vfmsub231ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask3_fmsub_round_sd / vfmsub231sd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_mask3_fmsub_round_sd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="c" type="__m128d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="rounding" type="int"/>
	<description>Multiply the lower double-precision (64-bit) floating-point elements in "a" and "b", and subtract the lower element in "c" from the intermediate result. Store the result in the lower element of "dst" using writemask "k" (the element is copied from "c" when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst".
	[round_note]</description>
	<description code="true">
IF k[0]
	dst[63:0] := (a[63:0] * b[63:0]) - c[63:0]
ELSE
	dst[63:0] := c[63:0]
FI
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vfmsub132sd"/>
	<mnemonic base="vfmsub213sd"/>
	<mnemonic base="vfmsub231sd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask3_fmsub_sd / vfmsub231sd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_mask3_fmsub_sd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="c" type="__m128d"/>
	<parameter varname="k" type="__mmask8"/>
	<description>Multiply the lower double-precision (64-bit) floating-point elements in "a" and "b", and subtract the lower element in "c" from the intermediate result. Store the result in the lower element of "dst" using writemask "k" (the element is copied from "c" when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst".</description>
	<description code="true">
IF k[0]
	dst[63:0] := (a[63:0] * b[63:0]) - c[63:0]
ELSE
	dst[63:0] := c[63:0]
FI
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vfmsub132sd"/>
	<mnemonic base="vfmsub213sd"/>
	<mnemonic base="vfmsub231sd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_fmsub_round_sd / vfmsub231sd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_mask_fmsub_round_sd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="c" type="__m128d"/>
	<parameter varname="rounding" type="int"/>
	<description>Multiply the lower double-precision (64-bit) floating-point elements in "a" and "b", and subtract the lower element in "c" from the intermediate result. Store the result in the lower element of "dst" using writemask "k" (the element is copied from "a" when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst".
	[round_note]</description>
	<description code="true">
IF k[0]
	dst[63:0] := (a[63:0] * b[63:0]) - c[63:0]
ELSE
	dst[63:0] := a[63:0]
FI
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vfmsub132sd"/>
	<mnemonic base="vfmsub213sd"/>
	<mnemonic base="vfmsub231sd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_fmsub_sd / vfmsub231sd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_mask_fmsub_sd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="c" type="__m128d"/>
	<description>Multiply the lower double-precision (64-bit) floating-point elements in "a" and "b", and subtract the lower element in "c" from the intermediate result. Store the result in the lower element of "dst" using writemask "k" (the element is copied from "a" when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst".</description>
	<description code="true">
IF k[0]
	dst[63:0] := (a[63:0] * b[63:0]) - c[63:0]
ELSE
	dst[63:0] := a[63:0]
FI
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vfmsub132sd"/>
	<mnemonic base="vfmsub213sd"/>
	<mnemonic base="vfmsub231sd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_fmsub_round_sd / vfmsub231sd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_maskz_fmsub_round_sd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="c" type="__m128d"/>
	<parameter varname="rounding" type="int"/>
	<description>Multiply the lower double-precision (64-bit) floating-point elements in "a" and "b", and subtract the lower element in "c" from the intermediate result. Store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst". 
	[round_note]</description>
	<description code="true">
IF k[0]
	dst[63:0] := (a[63:0] * b[63:0]) - c[63:0]
ELSE
	dst[63:0] := 0
FI
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vfmsub132sd"/>
	<mnemonic base="vfmsub213sd"/>
	<mnemonic base="vfmsub231sd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_fmsub_sd / vfmsub231sd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_maskz_fmsub_sd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="c" type="__m128d"/>
	<description>Multiply the lower double-precision (64-bit) floating-point elements in "a" and "b", and subtract the lower element in "c" from the intermediate result. Store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst".</description>
	<description code="true">
IF k[0]
	dst[63:0] := (a[63:0] * b[63:0]) - c[63:0]
ELSE
	dst[63:0] := 0
FI
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vfmsub132sd"/>
	<mnemonic base="vfmsub213sd"/>
	<mnemonic base="vfmsub231sd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask3_fmsub_round_ss / vfmsub231ss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_mask3_fmsub_round_ss">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="c" type="__m128"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="rounding" type="int"/>
	<description>Multiply the lower single-precision (32-bit) floating-point elements in "a" and "b", and subtract the lower element in "c" from the intermediate result. Store the result in the lower element of "dst" using writemask "k" (the element is copied from "c" when mask bit 0 is not set), and copy the upper 3 packed elements from "a" to the upper elements of "dst". 
	[round_note]</description>
	<description code="true">
IF k[0]
	dst[31:0] := (a[31:0] * b[31:0]) - c[31:0]
ELSE
	dst[31:0] := c[31:0]
FI
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vfmsub132ss"/>
	<mnemonic base="vfmsub213ss"/>
	<mnemonic base="vfmsub231ss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask3_fmsub_ss / vfmsub231ss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_mask3_fmsub_ss">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="c" type="__m128"/>
	<parameter varname="k" type="__mmask8"/>
	<description>Multiply the lower single-precision (32-bit) floating-point elements in "a" and "b", and subtract the lower element in "c" from the intermediate result. Store the result in the lower element of "dst" using writemask "k" (the element is copied from "c" when mask bit 0 is not set), and copy the upper 3 packed elements from "a" to the upper elements of "dst".
	</description>
	<description code="true">
IF k[0]
	dst[31:0] := (a[31:0] * b[31:0]) - c[31:0]
ELSE
	dst[31:0] := c[31:0]
FI
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vfmsub132ss"/>
	<mnemonic base="vfmsub213ss"/>
	<mnemonic base="vfmsub231ss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_fmsub_round_ss / vfmsub231ss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_mask_fmsub_round_ss">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="c" type="__m128"/>
	<parameter varname="rounding" type="int"/>
	<description>Multiply the lower single-precision (32-bit) floating-point elements in "a" and "b", and subtract the lower element in "c" from the intermediate result. Store the result in the lower element of "dst" using writemask "k" (the element is copied from "a" when mask bit 0 is not set), and copy the upper 3 packed elements from "a" to the upper elements of "dst". 
	[round_note]</description>
	<description code="true">
IF k[0]
	dst[31:0] := (a[31:0] * b[31:0]) - c[31:0]
ELSE
	dst[31:0] := a[31:0]
FI
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vfmsub132ss"/>
	<mnemonic base="vfmsub213ss"/>
	<mnemonic base="vfmsub231ss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_fmsub_ss / vfmsub231ss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_mask_fmsub_ss">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="c" type="__m128"/>
	<description>Multiply the lower single-precision (32-bit) floating-point elements in "a" and "b", and subtract the lower element in "c" from the intermediate result. Store the result in the lower element of "dst" using writemask "k" (the element is copied from "a" when mask bit 0 is not set), and copy the upper 3 packed elements from "a" to the upper elements of "dst".</description>
	<description code="true">
IF k[0]
	dst[31:0] := (a[31:0] * b[31:0]) - c[31:0]
ELSE
	dst[31:0] := a[31:0]
FI
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vfmsub132ss"/>
	<mnemonic base="vfmsub213ss"/>
	<mnemonic base="vfmsub231ss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_fmsub_round_ss / vfmsub231ss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_maskz_fmsub_round_ss">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="c" type="__m128"/>
	<parameter varname="rounding" type="int"/>
	<description>Multiply the lower single-precision (32-bit) floating-point elements in "a" and "b", and subtract the lower element in "c" from the intermediate result. Store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from "a" to the upper elements of "dst". 
	[round_note]</description>
	<description code="true">
IF k[0]
	dst[31:0] := (a[31:0] * b[31:0]) - c[31:0]
ELSE
	dst[31:0] := 0
FI
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vfmsub132ss"/>
	<mnemonic base="vfmsub213ss"/>
	<mnemonic base="vfmsub231ss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_fmsub_ss / vfmsub231ss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_maskz_fmsub_ss">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="c" type="__m128"/>
	<description>Multiply the lower single-precision (32-bit) floating-point elements in "a" and "b", and subtract the lower element in "c" from the intermediate result. Store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from "a" to the upper elements of "dst".</description>
	<description code="true">
IF k[0]
	dst[31:0] := (a[31:0] * b[31:0]) - c[31:0]
ELSE
	dst[31:0] := 0
FI
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vfmsub132ss"/>
	<mnemonic base="vfmsub213ss"/>
	<mnemonic base="vfmsub231ss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_fmsubadd_pd / vfmsubadd231pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_fmsubadd_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="c" type="__m512d"/>
	<description>Multiply packed double-precision (64-bit) floating-point elements in "a" and "b", alternatively subtract and add packed elements in "c" from/to the intermediate result, and store the results in "dst". 
	</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF (j is even) 
		dst[i+63:i] := (a[i+63:i] * b[i+63:i]) - c[i+63:i]
	ELSE
		dst[i+63:i] := (a[i+63:i] * b[i+63:i]) + c[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfmsubadd132pd"/>
	<mnemonic base="vfmsubadd213pd"/>
	<mnemonic base="vfmsubadd231pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_fmsubadd_round_pd / vfmsubadd231pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_fmsubadd_round_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="c" type="__m512d"/>
	<parameter varname="rounding" type="const int"/>
	<description>Multiply packed double-precision (64-bit) floating-point elements in "a" and "b", alternatively subtract and add packed elements in "c" from/to the intermediate result, and store the results in "dst". 
	[round_note]</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF (j is even) 
		dst[i+63:i] := (a[i+63:i] * b[i+63:i]) - c[i+63:i]
	ELSE
		dst[i+63:i] := (a[i+63:i] * b[i+63:i]) + c[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfmsubadd132pd"/>
	<mnemonic base="vfmsubadd213pd"/>
	<mnemonic base="vfmsubadd231pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask3_fmsubadd_pd / vfmsubadd231pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask3_fmsubadd_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="c" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<description>Multiply packed double-precision (64-bit) floating-point elements in "a" and "b", alternatively subtract and add packed elements in "c" from/to the intermediate result, and store the results in "dst" using writemask "k" (elements are copied from "c" when the corresponding mask bit is not set).  </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF (j is even) 
			dst[i+63:i] := (a[i+63:i] * b[i+63:i]) - c[i+63:i]
		ELSE
			dst[i+63:i] := (a[i+63:i] * b[i+63:i]) + c[i+63:i]
		FI
	ELSE
		dst[i+63:i] := c[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfmsubadd132pd"/>
	<mnemonic base="vfmsubadd213pd"/>
	<mnemonic base="vfmsubadd231pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask3_fmsubadd_round_pd / vfmsubadd231pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask3_fmsubadd_round_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="c" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="rounding" type="const int"/>
	<description>Multiply packed double-precision (64-bit) floating-point elements in "a" and "b", alternatively subtract and add packed elements in "c" from/to the intermediate result, and store the results in "dst" using writemask "k" (elements are copied from "c" when the corresponding mask bit is not set).  [round_note]</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF (j is even) 
			dst[i+63:i] := (a[i+63:i] * b[i+63:i]) - c[i+63:i]
		ELSE
			dst[i+63:i] := (a[i+63:i] * b[i+63:i]) + c[i+63:i]
		FI
	ELSE
		dst[i+63:i] := c[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfmsubadd132pd"/>
	<mnemonic base="vfmsubadd213pd"/>
	<mnemonic base="vfmsubadd231pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_fmsubadd_pd / vfmsubadd231pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_fmsubadd_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="c" type="__m512d"/>
	<description>Multiply packed double-precision (64-bit) floating-point elements in "a" and "b", alternatively subtract and add packed elements in "c" from/to the intermediate result, and store the results in "dst" using writemask "k" (elements are copied from "a" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF (j is even) 
			dst[i+63:i] := (a[i+63:i] * b[i+63:i]) - c[i+63:i]
		ELSE
			dst[i+63:i] := (a[i+63:i] * b[i+63:i]) + c[i+63:i]
		FI
	ELSE
		dst[i+63:i] := a[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfmsubadd132pd"/>
	<mnemonic base="vfmsubadd213pd"/>
	<mnemonic base="vfmsubadd231pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_fmsubadd_round_pd / vfmsubadd231pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_fmsubadd_round_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="c" type="__m512d"/>
	<parameter varname="rounding" type="const int"/>
	<description>Multiply packed double-precision (64-bit) floating-point elements in "a" and "b", alternatively subtract and add packed elements in "c" from/to the intermediate result, and store the results in "dst" using writemask "k" (elements are copied from "a" when the corresponding mask bit is not set). [round_note]</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF (j is even) 
			dst[i+63:i] := (a[i+63:i] * b[i+63:i]) - c[i+63:i]
		ELSE
			dst[i+63:i] := (a[i+63:i] * b[i+63:i]) + c[i+63:i]
		FI
	ELSE
		dst[i+63:i] := a[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfmsubadd132pd"/>
	<mnemonic base="vfmsubadd213pd"/>
	<mnemonic base="vfmsubadd231pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_fmsubadd_pd / vfmsubadd231pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_fmsubadd_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="c" type="__m512d"/>
	<description>Multiply packed double-precision (64-bit) floating-point elements in "a" and "b", alternatively subtract and add packed elements in "c" from/to the intermediate result, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). 
	</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF (j is even) 
			dst[i+63:i] := (a[i+63:i] * b[i+63:i]) - c[i+63:i]
		ELSE
			dst[i+63:i] := (a[i+63:i] * b[i+63:i]) + c[i+63:i]
		FI
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfmsubadd132pd"/>
	<mnemonic base="vfmsubadd213pd"/>
	<mnemonic base="vfmsubadd231pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_fmsubadd_round_pd / vfmsubadd231pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_fmsubadd_round_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="c" type="__m512d"/>
	<parameter varname="rounding" type="const int"/>
	<description>Multiply packed double-precision (64-bit) floating-point elements in "a" and "b", alternatively subtract and add packed elements in "c" from/to the intermediate result, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). 
	[round_note]</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF (j is even) 
			dst[i+63:i] := (a[i+63:i] * b[i+63:i]) - c[i+63:i]
		ELSE
			dst[i+63:i] := (a[i+63:i] * b[i+63:i]) + c[i+63:i]
		FI
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfmsubadd132pd"/>
	<mnemonic base="vfmsubadd213pd"/>
	<mnemonic base="vfmsubadd231pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_fmsubadd_ps / vfmsubadd231ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_fmsubadd_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="c" type="__m512"/>
	<description>Multiply packed single-precision (32-bit) floating-point elements in "a" and "b", alternatively subtract and add packed elements in "c" from/to the intermediate result, and store the results in "dst". 
	</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF (j is even) 
		dst[i+31:i] := (a[i+31:i] * b[i+31:i]) - c[i+31:i]
	ELSE
		dst[i+31:i] := (a[i+31:i] * b[i+31:i]) + c[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfmsubadd132ps"/>
	<mnemonic base="vfmsubadd213ps"/>
	<mnemonic base="vfmsubadd231ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_fmsubadd_round_ps / vfmsubadd231ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_fmsubadd_round_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="c" type="__m512"/>
	<parameter varname="rounding" type="const int"/>
	<description>Multiply packed single-precision (32-bit) floating-point elements in "a" and "b", alternatively subtract and add packed elements in "c" from/to the intermediate result, and store the results in "dst". 
	[round_note]</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF (j is even) 
		dst[i+31:i] := (a[i+31:i] * b[i+31:i]) - c[i+31:i]
	ELSE
		dst[i+31:i] := (a[i+31:i] * b[i+31:i]) + c[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfmsubadd132ps"/>
	<mnemonic base="vfmsubadd213ps"/>
	<mnemonic base="vfmsubadd231ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask3_fmsubadd_ps / vfmsubadd231ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask3_fmsubadd_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="c" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<description>Multiply packed single-precision (32-bit) floating-point elements in "a" and "b", alternatively subtract and add packed elements in "c" from/to the intermediate result, and store the results in "dst" using writemask "k" (elements are copied from "c" when the corresponding mask bit is not set).  </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF (j is even) 
			dst[i+31:i] := (a[i+31:i] * b[i+31:i]) - c[i+31:i]
		ELSE
			dst[i+31:i] := (a[i+31:i] * b[i+31:i]) + c[i+31:i]
		FI
	ELSE
		dst[i+31:i] := c[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfmsubadd132ps"/>
	<mnemonic base="vfmsubadd213ps"/>
	<mnemonic base="vfmsubadd231ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask3_fmsubadd_round_ps / vfmsubadd231ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask3_fmsubadd_round_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="c" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="rounding" type="const int"/>
	<description>Multiply packed single-precision (32-bit) floating-point elements in "a" and "b", alternatively subtract and add packed elements in "c" from/to the intermediate result, and store the results in "dst" using writemask "k" (elements are copied from "c" when the corresponding mask bit is not set).  [round_note]</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF (j is even) 
			dst[i+31:i] := (a[i+31:i] * b[i+31:i]) - c[i+31:i]
		ELSE
			dst[i+31:i] := (a[i+31:i] * b[i+31:i]) + c[i+31:i]
		FI
	ELSE
		dst[i+31:i] := c[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfmsubadd132ps"/>
	<mnemonic base="vfmsubadd213ps"/>
	<mnemonic base="vfmsubadd231ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_fmsubadd_ps / vfmsubadd231ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_fmsubadd_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="c" type="__m512"/>
	<description>Multiply packed single-precision (32-bit) floating-point elements in "a" and "b", alternatively subtract and add packed elements in "c" from/to the intermediate result, and store the results in "dst" using writemask "k" (elements are copied from "a" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF (j is even) 
			dst[i+31:i] := (a[i+31:i] * b[i+31:i]) - c[i+31:i]
		ELSE
			dst[i+31:i] := (a[i+31:i] * b[i+31:i]) + c[i+31:i]
		FI
	ELSE
		dst[i+31:i] := a[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfmsubadd132ps"/>
	<mnemonic base="vfmsubadd213ps"/>
	<mnemonic base="vfmsubadd231ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_fmsubadd_round_ps / vfmsubadd231ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_fmsubadd_round_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="c" type="__m512"/>
	<parameter varname="rounding" type="const int"/>
	<description>Multiply packed single-precision (32-bit) floating-point elements in "a" and "b", alternatively subtract and add packed elements in "c" from/to the intermediate result, and store the results in "dst" using writemask "k" (elements are copied from "a" when the corresponding mask bit is not set).
	[round_note]</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF (j is even) 
			dst[i+31:i] := (a[i+31:i] * b[i+31:i]) - c[i+31:i]
		ELSE
			dst[i+31:i] := (a[i+31:i] * b[i+31:i]) + c[i+31:i]
		FI
	ELSE
		dst[i+31:i] := a[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfmsubadd132ps"/>
	<mnemonic base="vfmsubadd213ps"/>
	<mnemonic base="vfmsubadd231ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_fmsubadd_ps / vfmsubadd231ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_fmsubadd_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="c" type="__m512"/>
	<description>Multiply packed single-precision (32-bit) floating-point elements in "a" and "b", alternatively subtract and add packed elements in "c" from/to the intermediate result, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). 
	</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF (j is even) 
			dst[i+31:i] := (a[i+31:i] * b[i+31:i]) - c[i+31:i]
		ELSE
			dst[i+31:i] := (a[i+31:i] * b[i+31:i]) + c[i+31:i]
		FI
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfmsubadd132ps"/>
	<mnemonic base="vfmsubadd213ps"/>
	<mnemonic base="vfmsubadd231ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_fmsubadd_round_ps / vfmsubadd231ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_fmsubadd_round_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="c" type="__m512"/>
	<parameter varname="rounding" type="const int"/>
	<description>Multiply packed single-precision (32-bit) floating-point elements in "a" and "b", alternatively subtract and add packed elements in "c" from/to the intermediate result, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). 
	[round_note]</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF (j is even) 
			dst[i+31:i] := (a[i+31:i] * b[i+31:i]) - c[i+31:i]
		ELSE
			dst[i+31:i] := (a[i+31:i] * b[i+31:i]) + c[i+31:i]
		FI
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfmsubadd132ps"/>
	<mnemonic base="vfmsubadd213ps"/>
	<mnemonic base="vfmsubadd231ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_fnmadd_pd / vfnmadd231pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_fnmadd_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="c" type="__m512d"/>
	<description>Multiply packed double-precision (64-bit) floating-point elements in "a" and "b", add the negated intermediate result to packed elements in "c", and store the results in "dst". 
	</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := -(a[i+63:i] * b[i+63:i]) + c[i+63:i]
ENDFOR	
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfnmadd132pd"/>
	<mnemonic base="vfnmadd213pd"/>
	<mnemonic base="vfnmadd231pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_fnmadd_round_pd / vfnmadd231pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_fnmadd_round_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="c" type="__m512d"/>
	<parameter varname="rounding" type="int"/>
	<description>Multiply packed double-precision (64-bit) floating-point elements in "a" and "b", add the negated intermediate result to packed elements in "c", and store the results in "dst".
	 [round_note]</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := -(a[i+63:i] * b[i+63:i]) + c[i+63:i]
ENDFOR	
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfnmadd132pd"/>
	<mnemonic base="vfnmadd213pd"/>
	<mnemonic base="vfnmadd231pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask3_fnmadd_pd / vfnmadd231pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask3_fnmadd_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="c" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<description>Multiply packed double-precision (64-bit) floating-point elements in "a" and "b", add the negated intermediate result to packed elements in "c", and store the results in "dst" using writemask "k" (elements are copied from "c" when the corresponding mask bit is not set).  </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := -(a[i+63:i] * b[i+63:i]) + c[i+63:i]
	ELSE
		dst[i+63:i] := c[i+63:i]
	FI
ENDFOR	
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfnmadd132pd"/>
	<mnemonic base="vfnmadd213pd"/>
	<mnemonic base="vfnmadd231pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask3_fnmadd_round_pd / vfnmadd231pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask3_fnmadd_round_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="c" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="rounding" type="int"/>
	<description>Multiply packed double-precision (64-bit) floating-point elements in "a" and "b", add the negated intermediate result to packed elements in "c", and store the results in "dst" using writemask "k" (elements are copied from "c" when the corresponding mask bit is not set).  [round_note]</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := -(a[i+63:i] * b[i+63:i]) + c[i+63:i]
	ELSE
		dst[i+63:i] := c[i+63:i]
	FI
ENDFOR	
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfnmadd132pd"/>
	<mnemonic base="vfnmadd213pd"/>
	<mnemonic base="vfnmadd231pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_fnmadd_pd / vfnmadd231pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_fnmadd_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="c" type="__m512d"/>
	<description>Multiply packed double-precision (64-bit) floating-point elements in "a" and "b", add the negated intermediate result to packed elements in "c", and store the results in "dst" using writemask "k" (elements are copied from "a" when the corresponding mask bit is not set).  </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := -(a[i+63:i] * b[i+63:i]) + c[i+63:i]
	ELSE
		dst[i+63:i] := a[i+63:i]
	FI
ENDFOR	
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfnmadd132pd"/>
	<mnemonic base="vfnmadd213pd"/>
	<mnemonic base="vfnmadd231pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_fnmadd_round_pd / vfnmadd231pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_fnmadd_round_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="c" type="__m512d"/>
	<parameter varname="rounding" type="int"/>
	<description>Multiply packed double-precision (64-bit) floating-point elements in "a" and "b", add the negated intermediate result to packed elements in "c", and store the results in "dst" using writemask "k" (elements are copied from "a" when the corresponding mask bit is not set). [round_note]</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := -(a[i+63:i] * b[i+63:i]) + c[i+63:i]
	ELSE
		dst[i+63:i] := a[i+63:i]
	FI
ENDFOR	
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfnmadd132pd"/>
	<mnemonic base="vfnmadd213pd"/>
	<mnemonic base="vfnmadd231pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_fnmadd_pd / vfnmadd231pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_fnmadd_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="c" type="__m512d"/>
	<description>Multiply packed double-precision (64-bit) floating-point elements in "a" and "b", add the negated intermediate result to packed elements in "c", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := -(a[i+63:i] * b[i+63:i]) + c[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR	
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfnmadd132pd"/>
	<mnemonic base="vfnmadd213pd"/>
	<mnemonic base="vfnmadd231pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_fnmadd_round_pd / vfnmadd231pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_fnmadd_round_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="c" type="__m512d"/>
	<parameter varname="rounding" type="const int"/>
	<description>Multiply packed double-precision (64-bit) floating-point elements in "a" and "b", add the negated intermediate result to packed elements in "c", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). [round_note]</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := -(a[i+63:i] * b[i+63:i]) + c[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR	
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfnmadd132pd"/>
	<mnemonic base="vfnmadd213pd"/>
	<mnemonic base="vfnmadd231pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_fnmadd_ps / vfnmadd231ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_fnmadd_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="c" type="__m512"/>
	<description>Multiply packed single-precision (32-bit) floating-point elements in "a" and "b", add the negated intermediate result to packed elements in "c", and store the results in "dst". 
	</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	a[i+31:i] := -(a[i+31:i] * b[i+31:i]) + c[i+31:i]
ENDFOR	
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfnmadd132ps"/>
	<mnemonic base="vfnmadd213ps"/>
	<mnemonic base="vfnmadd231ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_fnmadd_round_ps / vfnmadd231ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_fnmadd_round_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="c" type="__m512"/>
	<parameter varname="rounding" type="int"/>
	<description>Multiply packed single-precision (32-bit) floating-point elements in "a" and "b", add the negated intermediate result to packed elements in "c", and store the results in "dst".  
	[round_note]</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := -(a[i+31:i] * b[i+31:i]) + c[i+31:i]
ENDFOR	
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfnmadd132ps"/>
	<mnemonic base="vfnmadd213ps"/>
	<mnemonic base="vfnmadd231ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask3_fnmadd_ps / vfnmadd231ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask3_fnmadd_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="c" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<description>Multiply packed single-precision (32-bit) floating-point elements in "a" and "b", add the negated intermediate result to packed elements in "c", and store the results in "dst" using writemask "k" (elements are copied from "c" when the corresponding mask bit is not set).  </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := -(a[i+31:i] * b[i+31:i]) + c[i+31:i]
	ELSE
		dst[i+31:i] := c[i+31:i]
	FI
ENDFOR	
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfnmadd132ps"/>
	<mnemonic base="vfnmadd213ps"/>
	<mnemonic base="vfnmadd231ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask3_fnmadd_round_ps / vfnmadd231ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask3_fnmadd_round_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="c" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="rounding" type="int"/>
	<description>Multiply packed single-precision (32-bit) floating-point elements in "a" and "b", add the negated intermediate result to packed elements in "c", and store the results in "dst" using writemask "k" (elements are copied from "c" when the corresponding mask bit is not set).  [round_note]</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := -(a[i+31:i] * b[i+31:i]) + c[i+31:i]
	ELSE
		dst[i+31:i] := c[i+31:i]
	FI
ENDFOR	
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfnmadd132ps"/>
	<mnemonic base="vfnmadd213ps"/>
	<mnemonic base="vfnmadd231ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_fnmadd_ps / vfnmadd231ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_fnmadd_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="c" type="__m512"/>
	<description>Multiply packed single-precision (32-bit) floating-point elements in "a" and "b", add the negated intermediate result to packed elements in "c", and store the results in "dst" using writemask "k" (elements are copied from "a" when the corresponding mask bit is not set).  </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := -(a[i+31:i] * b[i+31:i]) + c[i+31:i]
	ELSE
		dst[i+31:i] := a[i+31:i]
	FI
ENDFOR	
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfnmadd132ps"/>
	<mnemonic base="vfnmadd213ps"/>
	<mnemonic base="vfnmadd231ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_fnmadd_round_ps / vfnmadd231ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_fnmadd_round_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="c" type="__m512"/>
	<parameter varname="rounding" type="int"/>
	<description>Multiply packed single-precision (32-bit) floating-point elements in "a" and "b", add the negated intermediate result to packed elements in "c", and store the results in "dst" using writemask "k" (elements are copied from "a" when the corresponding mask bit is not set). [round_note]</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := -(a[i+31:i] * b[i+31:i]) + c[i+31:i]
	ELSE
		dst[i+31:i] := a[i+31:i]
	FI
ENDFOR	
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfnmadd132ps"/>
	<mnemonic base="vfnmadd213ps"/>
	<mnemonic base="vfnmadd231ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_fnmadd_ps / vfnmadd231ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_fnmadd_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="c" type="__m512"/>
	<description>Multiply packed single-precision (32-bit) floating-point elements in "a" and "b", add the negated intermediate result to packed elements in "c", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := -(a[i+31:i] * b[i+31:i]) + c[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR	
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfnmadd132ps"/>
	<mnemonic base="vfnmadd213ps"/>
	<mnemonic base="vfnmadd231ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_fnmadd_round_ps / vfnmadd231ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_fnmadd_round_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="c" type="__m512"/>
	<parameter varname="rounding" type="const int"/>
	<description>Multiply packed single-precision (32-bit) floating-point elements in "a" and "b", add the negated intermediate result to packed elements in "c", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). [round_note]</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := -(a[i+31:i] * b[i+31:i]) + c[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR	
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfnmadd132ps"/>
	<mnemonic base="vfnmadd213ps"/>
	<mnemonic base="vfnmadd231ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask3_fnmadd_round_sd / vfnmadd231sd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_mask3_fnmadd_round_sd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="c" type="__m128d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="rounding" type="int"/>
	<description>Multiply the lower double-precision (64-bit) floating-point elements in "a" and "b", and add the negated intermediate result to the lower element in "c". Store the result in the lower element of "dst" using writemask "k" (the element is copied from "c" when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst".
	[round_note]</description>
	<description code="true">
IF k[0]
	dst[63:0] := -(a[63:0] * b[63:0]) + c[63:0]
ELSE
	dst[63:0] := c[63:0]
FI
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vfnmadd132sd"/>
	<mnemonic base="vfnmadd213sd"/>
	<mnemonic base="vfnmadd231sd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask3_fnmadd_sd / vfnmadd231sd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_mask3_fnmadd_sd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="c" type="__m128d"/>
	<parameter varname="k" type="__mmask8"/>
	<description>Multiply the lower double-precision (64-bit) floating-point elements in "a" and "b", and add the negated intermediate result to the lower element in "c". Store the result in the lower element of "dst" using writemask "k" (the element is copied from "c" when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst".</description>
	<description code="true">
IF k[0]
	dst[63:0] := -(a[63:0] * b[63:0]) + c[63:0]
ELSE
	dst[63:0] := c[63:0]
FI
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vfnmadd132sd"/>
	<mnemonic base="vfnmadd213sd"/>
	<mnemonic base="vfnmadd231sd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_fnmadd_round_sd / vfnmadd231sd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_mask_fnmadd_round_sd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="c" type="__m128d"/>
	<parameter varname="rounding" type="int"/>
	<description>Multiply the lower double-precision (64-bit) floating-point elements in "a" and "b", and add the negated intermediate result to the lower element in "c". Store the result in the lower element of "dst" using writemask "k" (the element is copied from "a" when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst".
	[round_note]</description>
	<description code="true">
IF k[0]
	dst[63:0] := -(a[63:0] * b[63:0]) + c[63:0]
ELSE
	dst[63:0] := a[63:0]
FI
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vfnmadd132sd"/>
	<mnemonic base="vfnmadd213sd"/>
	<mnemonic base="vfnmadd231sd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_fnmadd_sd / vfnmadd231sd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_mask_fnmadd_sd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="c" type="__m128d"/>
	<description>Multiply the lower double-precision (64-bit) floating-point elements in "a" and "b", and add the negated intermediate result to the lower element in "c". Store the result in the lower element of "dst" using writemask "k" (the element is copied from "a" when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst".</description>
	<description code="true">
IF k[0]
	dst[63:0] := -(a[63:0] * b[63:0]) + c[63:0]
ELSE
	dst[63:0] := a[63:0]
FI
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vfnmadd132sd"/>
	<mnemonic base="vfnmadd213sd"/>
	<mnemonic base="vfnmadd231sd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_fnmadd_round_sd / vfnmadd231sd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_maskz_fnmadd_round_sd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="c" type="__m128d"/>
	<parameter varname="rounding" type="int"/>
	<description>Multiply the lower double-precision (64-bit) floating-point elements in "a" and "b", and add the negated intermediate result to the lower element in "c". Store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst".
	[round_note]</description>
	<description code="true">
IF k[0]
	dst[63:0] := -(a[63:0] * b[63:0]) + c[63:0]
ELSE
	dst[63:0] := 0
FI
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vfnmadd132sd"/>
	<mnemonic base="vfnmadd213sd"/>
	<mnemonic base="vfnmadd231sd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_fnmadd_sd / vfnmadd132sd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_maskz_fnmadd_sd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="c" type="__m128d"/>
	<description>Multiply the lower double-precision (64-bit) floating-point elements in "a" and "b", and add the negated intermediate result to the lower element in "c". Store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst".</description>
	<description code="true">
IF k[0]
	dst[63:0] := -(a[63:0] * b[63:0]) + c[63:0]
ELSE
	dst[63:0] := 0
FI
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vfnmadd213sd"/>
	<mnemonic base="vfnmadd231sd"/>
	<mnemonic base="vfnmadd132sd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask3_fnmadd_round_ss / vfnmadd231ss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_mask3_fnmadd_round_ss">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="c" type="__m128"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="rounding" type="int"/>
	<description>Multiply the lower single-precision (32-bit) floating-point elements in "a" and "b", and add the negated intermediate result to the lower element in "c". Store the result in the lower element of "dst" using writemask "k" (the element is copied from "c" when mask bit 0 is not set), and copy the upper 3 packed elements from "a" to the upper elements of "dst".
	[round_note]</description>
	<description code="true">
IF k[0]
	dst[31:0] := -(a[31:0] * b[31:0]) + c[31:0]
ELSE
	dst[31:0] := c[31:0]
FI
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vfnmadd132ss"/>
	<mnemonic base="vfnmadd213ss"/>
	<mnemonic base="vfnmadd231ss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask3_fnmadd_ss / vfnmadd231ss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_mask3_fnmadd_ss">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="c" type="__m128"/>
	<parameter varname="k" type="__mmask8"/>
	<description>Multiply the lower single-precision (32-bit) floating-point elements in "a" and "b", and add the negated intermediate result to the lower element in "c". Store the result in the lower element of "dst" using writemask "k" (the element is copied from "c" when mask bit 0 is not set), and copy the upper 3 packed elements from "a" to the upper elements of "dst".</description>
	<description code="true">
IF k[0]
	dst[31:0] := -(a[31:0] * b[31:0]) + c[31:0]
ELSE
	dst[31:0] := c[31:0]
FI
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vfnmadd132ss"/>
	<mnemonic base="vfnmadd213ss"/>
	<mnemonic base="vfnmadd231ss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_fnmadd_round_ss / vfnmadd231ss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_mask_fnmadd_round_ss">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="c" type="__m128"/>
	<parameter varname="rounding" type="int"/>
	<description>Multiply the lower single-precision (32-bit) floating-point elements in "a" and "b", and add the negated intermediate result to the lower element in "c". Store the result in the lower element of "dst" using writemask "k" (the element is copied from "a" when mask bit 0 is not set), and copy the upper 3 packed elements from "a" to the upper elements of "dst". 
	[round_note]</description>
	<description code="true">
IF k[0]
	dst[31:0] := -(a[31:0] * b[31:0]) + c[31:0]
ELSE
	dst[31:0] := a[31:0]
FI
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vfnmadd132ss"/>
	<mnemonic base="vfnmadd213ss"/>
	<mnemonic base="vfnmadd231ss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_fnmadd_ss / vfnmadd231ss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_mask_fnmadd_ss">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="c" type="__m128"/>
	<description>Multiply the lower single-precision (32-bit) floating-point elements in "a" and "b", and add the negated intermediate result to the lower element in "c". Store the result in the lower element of "dst" using writemask "k" (the element is copied from "a" when mask bit 0 is not set), and copy the upper 3 packed elements from "a" to the upper elements of "dst".</description>
	<description code="true">
IF k[0]
	dst[31:0] := -(a[31:0] * b[31:0]) + c[31:0]
ELSE
	dst[31:0] := a[31:0]
FI
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vfnmadd132ss"/>
	<mnemonic base="vfnmadd213ss"/>
	<mnemonic base="vfnmadd231ss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_fnmadd_round_ss / vfnmadd231ss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_maskz_fnmadd_round_ss">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="c" type="__m128"/>
	<parameter varname="rounding" type="int"/>
	<description>Multiply the lower single-precision (32-bit) floating-point elements in "a" and "b", and add the negated intermediate result to the lower element in "c". Store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from "a" to the upper elements of "dst". 
	[round_note]</description>
	<description code="true">
IF k[0]
	dst[31:0] := -(a[31:0] * b[31:0]) + c[31:0]
ELSE
	dst[31:0] := 0
FI
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vfnmadd132ss"/>
	<mnemonic base="vfnmadd213ss"/>
	<mnemonic base="vfnmadd231ss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_fnmadd_ss / vfnmadd231ss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_maskz_fnmadd_ss">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="c" type="__m128"/>
	<description>Multiply the lower single-precision (32-bit) floating-point elements in "a" and "b", and add the negated intermediate result to the lower element in "c". Store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from "a" to the upper elements of "dst".</description>
	<description code="true">
IF k[0]
	dst[31:0] := -(a[31:0] * b[31:0]) + c[31:0]
ELSE
	dst[31:0] := 0
FI
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vfnmadd132ss"/>
	<mnemonic base="vfnmadd213ss"/>
	<mnemonic base="vfnmadd231ss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_fnmsub_pd / vfnmsub231pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_fnmsub_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="c" type="__m512d"/>
	<description>Multiply packed double-precision (64-bit) floating-point elements in "a" and "b", subtract packed elements in "c" from the negated intermediate result, and store the results in "dst". </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := -(a[i+63:i] * b[i+63:i]) - c[i+63:i]
ENDFOR	
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfnmsub132pd"/>
	<mnemonic base="vfnmsub213pd"/>
	<mnemonic base="vfnmsub231pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_fnmsub_round_pd / vfnmsub231pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_fnmsub_round_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="c" type="__m512d"/>
	<parameter varname="rounding" type="int"/>
	<description>Multiply packed double-precision (64-bit) floating-point elements in "a" and "b", subtract packed elements in "c" from the negated intermediate result, and store the results in "dst".  
	[round_note]</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := -(a[i+63:i] * b[i+63:i]) - c[i+63:i]
ENDFOR	
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfnmsub132pd"/>
	<mnemonic base="vfnmsub213pd"/>
	<mnemonic base="vfnmsub231pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask3_fnmsub_pd / vfnmsub231pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask3_fnmsub_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="c" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<description>Multiply packed double-precision (64-bit) floating-point elements in "a" and "b", subtract packed elements in "c" from the negated intermediate result, and store the results in "dst" using writemask "k" (elements are copied from "c" when the corresponding mask bit is not set).  </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := -(a[i+63:i] * b[i+63:i]) - c[i+63:i]
	ELSE
		dst[i+63:i] := c[i+63:i]
	FI
ENDFOR	
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfnmsub132pd"/>
	<mnemonic base="vfnmsub213pd"/>
	<mnemonic base="vfnmsub231pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask3_fnmsub_round_pd / vfnmsub231pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask3_fnmsub_round_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="c" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="rounding" type="int"/>
	<description>Multiply packed double-precision (64-bit) floating-point elements in "a" and "b", subtract packed elements in "c" from the negated intermediate result, and store the results in "dst" using writemask "k" (elements are copied from "c" when the corresponding mask bit is not set). [round_note]</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := -(a[i+63:i] * b[i+63:i]) - c[i+63:i]
	ELSE
		dst[i+63:i] := c[i+63:i]
	FI
ENDFOR	
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfnmsub132pd"/>
	<mnemonic base="vfnmsub213pd"/>
	<mnemonic base="vfnmsub231pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_fnmsub_pd / vfnmsub231pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_fnmsub_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="c" type="__m512d"/>
	<description>Multiply packed double-precision (64-bit) floating-point elements in "a" and "b", subtract packed elements in "c" from the negated intermediate result, and store the results in "dst" using writemask "k" (elements are copied from "a" when the corresponding mask bit is not set).  </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := -(a[i+63:i] * b[i+63:i]) - c[i+63:i]
	ELSE
		dst[i+63:i] := a[i+63:i]
	FI
ENDFOR	
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfnmsub132pd"/>
	<mnemonic base="vfnmsub213pd"/>
	<mnemonic base="vfnmsub231pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_fnmsub_round_pd / vfnmsub231pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_fnmsub_round_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="c" type="__m512d"/>
	<parameter varname="rounding" type="int"/>
	<description>Multiply packed double-precision (64-bit) floating-point elements in "a" and "b", subtract packed elements in "c" from the negated intermediate result, and store the results in "dst" using writemask "k" (elements are copied from "a" when the corresponding mask bit is not set).
	[round_note]</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := -(a[i+63:i] * b[i+63:i]) - c[i+63:i]
	ELSE
		dst[i+63:i] := a[i+63:i]
	FI
ENDFOR	
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfnmsub132pd"/>
	<mnemonic base="vfnmsub213pd"/>
	<mnemonic base="vfnmsub231pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_fnmsub_pd / vfnmsub231pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_fnmsub_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="c" type="__m512d"/>
	<description>Multiply packed double-precision (64-bit) floating-point elements in "a" and "b", subtract packed elements in "c" from the negated intermediate result, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := -(a[i+63:i] * b[i+63:i]) - c[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR	
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfnmsub132pd"/>
	<mnemonic base="vfnmsub213pd"/>
	<mnemonic base="vfnmsub231pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_fnmsub_round_pd / vfnmsub231pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_fnmsub_round_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="c" type="__m512d"/>
	<parameter varname="rounding" type="const int"/>
	<description>Multiply packed double-precision (64-bit) floating-point elements in "a" and "b", subtract packed elements in "c" from the negated intermediate result, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). [round_note]</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := -(a[i+63:i] * b[i+63:i]) - c[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR	
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfnmsub132pd"/>
	<mnemonic base="vfnmsub213pd"/>
	<mnemonic base="vfnmsub231pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_fnmsub_ps / vfnmsub231ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_fnmsub_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="c" type="__m512"/>
	<description>Multiply packed single-precision (32-bit) floating-point elements in "a" and "b", subtract packed elements in "c" from the negated intermediate result, and store the results in "dst". </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := -(a[i+31:i] * b[i+31:i]) - c[i+31:i]
ENDFOR	
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfnmsub132ps"/>
	<mnemonic base="vfnmsub213ps"/>
	<mnemonic base="vfnmsub231ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_fnmsub_round_ps / vfnmsub231ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_fnmsub_round_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="c" type="__m512"/>
	<parameter varname="rounding" type="int"/>
	<description>Multiply packed single-precision (32-bit) floating-point elements in "a" and "b", subtract packed elements in "c" from the negated intermediate result, and store the results in "dst". 
	[round_note]</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := -(a[i+31:i] * b[i+31:i]) - c[i+31:i]
ENDFOR	
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfnmsub132ps"/>
	<mnemonic base="vfnmsub213ps"/>
	<mnemonic base="vfnmsub231ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask3_fnmsub_ps / vfnmsub231ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask3_fnmsub_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="c" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<description>Multiply packed single-precision (32-bit) floating-point elements in "a" and "b", subtract packed elements in "c" from the negated intermediate result, and store the results in "dst" using writemask "k" (elements are copied from "c" when the corresponding mask bit is not set).  </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := -(a[i+31:i] * b[i+31:i]) - c[i+31:i]
	ELSE
		dst[i+31:i] := c[i+31:i]
	FI
ENDFOR	
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfnmsub132ps"/>
	<mnemonic base="vfnmsub213ps"/>
	<mnemonic base="vfnmsub231ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask3_fnmsub_round_ps / vfnmsub231ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask3_fnmsub_round_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="c" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="rounding" type="int"/>
	<description>Multiply packed single-precision (32-bit) floating-point elements in "a" and "b", subtract packed elements in "c" from the negated intermediate result, and store the results in "dst" using writemask "k" (elements are copied from "c" when the corresponding mask bit is not set).  [round_note]</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := -(a[i+31:i] * b[i+31:i]) - c[i+31:i]
	ELSE
		dst[i+31:i] := c[i+31:i]
	FI
ENDFOR	
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfnmsub132ps"/>
	<mnemonic base="vfnmsub213ps"/>
	<mnemonic base="vfnmsub231ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_fnmsub_ps / vfnmsub231ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_fnmsub_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="c" type="__m512"/>
	<description>Multiply packed single-precision (32-bit) floating-point elements in "a" and "b", subtract packed elements in "c" from the negated intermediate result, and store the results in "dst" using writemask "k" (elements are copied from "a" when the corresponding mask bit is not set).  </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := -(a[i+31:i] * b[i+31:i]) - c[i+31:i]
	ELSE
		dst[i+31:i] := a[i+31:i]
	FI
ENDFOR	
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfnmsub132ps"/>
	<mnemonic base="vfnmsub213ps"/>
	<mnemonic base="vfnmsub231ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_fnmsub_round_ps / vfnmsub231ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_fnmsub_round_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="c" type="__m512"/>
	<parameter varname="rounding" type="int"/>
	<description>Multiply packed single-precision (32-bit) floating-point elements in "a" and "b", subtract packed elements in "c" from the negated intermediate result, and store the results in "dst" using writemask "k" (elements are copied from "a" when the corresponding mask bit is not set). 
	[round_note]
	</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := -(a[i+31:i] * b[i+31:i]) - c[i+31:i]
	ELSE
		dst[i+31:i] := a[i+31:i]
	FI
ENDFOR	
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfnmsub132ps"/>
	<mnemonic base="vfnmsub213ps"/>
	<mnemonic base="vfnmsub231ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_fnmsub_ps / vfnmsub231ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_fnmsub_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="c" type="__m512"/>
	<description>Multiply packed single-precision (32-bit) floating-point elements in "a" and "b", subtract packed elements in "c" from the negated intermediate result, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := -(a[i+31:i] * b[i+31:i]) - c[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR	
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfnmsub132ps"/>
	<mnemonic base="vfnmsub213ps"/>
	<mnemonic base="vfnmsub231ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_fnmsub_round_ps / vfnmsub231ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_fnmsub_round_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="c" type="__m512"/>
	<parameter varname="rounding" type="const int"/>
	<description>Multiply packed single-precision (32-bit) floating-point elements in "a" and "b", subtract packed elements in "c" from the negated intermediate result, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). 
	[round_note]
	</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := -(a[i+31:i] * b[i+31:i]) - c[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR	
dst[MAX:512] := 0
	</description>
	<mnemonic base="vfnmsub132ps"/>
	<mnemonic base="vfnmsub213ps"/>
	<mnemonic base="vfnmsub231ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask3_fnmsub_round_sd / vfnmsub231sd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_mask3_fnmsub_round_sd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="c" type="__m128d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="rounding" type="int"/>
	<description>Multiply the lower double-precision (64-bit) floating-point elements in "a" and "b", and subtract the lower element in "c" from the negated intermediate result. Store the result in the lower element of "dst" using writemask "k" (the element is copied from "c" when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst".
	[round_note]</description>
	<description code="true">
IF k[0]
	dst[63:0] := -(a[63:0] * b[63:0]) - c[63:0]
ELSE
	dst[63:0] := c[63:0]
FI
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vfnmsub132sd"/>
	<mnemonic base="vfnmsub213sd"/>
	<mnemonic base="vfnmsub231sd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask3_fnmsub_sd / vfnmsub231sd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_mask3_fnmsub_sd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="c" type="__m128d"/>
	<parameter varname="k" type="__mmask8"/>
	<description>Multiply the lower double-precision (64-bit) floating-point elements in "a" and "b", and subtract the lower element in "c" from the negated intermediate result. Store the result in the lower element of "dst" using writemask "k" (the element is copied from "c" when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst".</description>
	<description code="true">
IF k[0]
	dst[63:0] := -(a[63:0] * b[63:0]) - c[63:0]
ELSE
	dst[63:0] := c[63:0]
FI
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vfnmsub132sd"/>
	<mnemonic base="vfnmsub213sd"/>
	<mnemonic base="vfnmsub231sd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_fnmsub_round_sd / vfnmsub231sd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_mask_fnmsub_round_sd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="c" type="__m128d"/>
	<parameter varname="rounding" type="int"/>
	<description>Multiply the lower double-precision (64-bit) floating-point elements in "a" and "b", and subtract the lower element in "c" from the negated intermediate result. Store the result in the lower element of "dst" using writemask "k" (the element is copied from "c" when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst".
	[round_note]</description>
	<description code="true">
IF k[0]
	dst[63:0] := -(a[63:0] * b[63:0]) - c[63:0]
ELSE
	dst[63:0] := a[63:0]
FI
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vfnmsub132sd"/>
	<mnemonic base="vfnmsub213sd"/>
	<mnemonic base="vfnmsub231sd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_fnmsub_sd / vfnmsub231sd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_mask_fnmsub_sd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="c" type="__m128d"/>
	<description>Multiply the lower double-precision (64-bit) floating-point elements in "a" and "b", and subtract the lower element in "c" from the negated intermediate result. Store the result in the lower element of "dst" using writemask "k" (the element is copied from "c" when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst".</description>
	<description code="true">
IF k[0]
	dst[63:0] := -(a[63:0] * b[63:0]) - c[63:0]
ELSE
	dst[63:0] := a[63:0]
FI
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vfnmsub132sd"/>
	<mnemonic base="vfnmsub213sd"/>
	<mnemonic base="vfnmsub231sd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_fnmsub_round_sd / vfnmsub231sd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_maskz_fnmsub_round_sd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="c" type="__m128d"/>
	<parameter varname="rounding" type="int"/>
	<description>Multiply the lower double-precision (64-bit) floating-point elements in "a" and "b", and subtract the lower element in "c" from the negated intermediate result. Store the result in "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst".
	[round_note]</description>
	<description code="true">
IF k[0]
	dst[63:0] := -(a[63:0] * b[63:0]) - c[63:0]
ELSE
	dst[63:0] := 0
FI
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vfnmsub132sd"/>
	<mnemonic base="vfnmsub213sd"/>
	<mnemonic base="vfnmsub231sd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_fnmsub_sd / vfnmsub231sd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_maskz_fnmsub_sd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="c" type="__m128d"/>
	<description>Multiply the lower double-precision (64-bit) floating-point elements in "a" and "b", and subtract the lower element in "c" from the negated intermediate result. Store the result in "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst".</description>
	<description code="true">
IF k[0]
	dst[63:0] := -(a[63:0] * b[63:0]) - c[63:0]
ELSE
	dst[63:0] := 0
FI
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vfnmsub132sd"/>
	<mnemonic base="vfnmsub213sd"/>
	<mnemonic base="vfnmsub231sd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask3_fnmsub_round_ss / vfnmsub231ss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_mask3_fnmsub_round_ss">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="c" type="__m128"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="rounding" type="int"/>
	<description>Multiply the lower single-precision (32-bit) floating-point elements in "a" and "b", subtract the lower element in "c" from the negated intermediate result, store the result in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst" using writemask "k" (elements are copied from "c" when the corresponding mask bit is not set). 
	[round_note]</description>
	<description code="true">
IF k[0]
	dst[31:0] := -(a[31:0] * b[31:0]) - c[31:0]
ELSE
	dst[31:0] := c[31:0]
FI
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vfnmsub132ss"/>
	<mnemonic base="vfnmsub213ss"/>
	<mnemonic base="vfnmsub231ss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask3_fnmsub_ss / vfnmsub231ss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_mask3_fnmsub_ss">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="c" type="__m128"/>
	<parameter varname="k" type="__mmask8"/>
	<description>Multiply the lower single-precision (32-bit) floating-point elements in "a" and "b", and subtract the lower element in "c" from the negated intermediate result. Store the result in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst" using writemask "k" (elements are copied from "c" when the corresponding mask bit is not set).</description>
	<description code="true">
IF k[0]
	dst[31:0] := -(a[31:0] * b[31:0]) - c[31:0]
ELSE
	dst[31:0] := c[31:0]
FI
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vfnmsub132ss"/>
	<mnemonic base="vfnmsub213ss"/>
	<mnemonic base="vfnmsub231ss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_fnmsub_round_ss / vfnmsub231ss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_mask_fnmsub_round_ss">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="c" type="__m128"/>
	<parameter varname="rounding" type="int"/>
	<description>Multiply the lower single-precision (32-bit) floating-point elements in "a" and "b", and subtract the lower element in "c" from the negated intermediate result. Store the result in the lower element of "dst" using writemask "k" (the element is copied from "c" when mask bit 0 is not set), and copy the upper 3 packed elements from "a" to the upper elements of "dst".
	[round_note]</description>
	<description code="true">
IF k[0]
	dst[31:0] := -(a[31:0] * b[31:0]) - c[31:0]
ELSE
	dst[31:0] := a[31:0]
FI
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vfnmsub132ss"/>
	<mnemonic base="vfnmsub213ss"/>
	<mnemonic base="vfnmsub231ss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_fnmsub_ss / vfnmsub231ss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_mask_fnmsub_ss">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="c" type="__m128"/>
	<description>Multiply the lower single-precision (32-bit) floating-point elements in "a" and "b", and subtract the lower element in "c" from the negated intermediate result. Store the result in the lower element of "dst" using writemask "k" (the element is copied from "c" when mask bit 0 is not set), and copy the upper 3 packed elements from "a" to the upper elements of "dst".</description>
	<description code="true">
IF k[0]
	dst[31:0] := -(a[31:0] * b[31:0]) - c[31:0]
ELSE
	dst[31:0] := a[31:0]
FI
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vfnmsub132ss"/>
	<mnemonic base="vfnmsub213ss"/>
	<mnemonic base="vfnmsub231ss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_fnmsub_round_ss / vfnmsub231ss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_maskz_fnmsub_round_ss">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="c" type="__m128"/>
	<parameter varname="rounding" type="int"/>
	<description>Multiply the lower single-precision (32-bit) floating-point elements in "a" and "b", and subtract the lower element in "c" from the negated intermediate result. Store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from "a" to the upper elements of "dst".
	[round_note]</description>
	<description code="true">
IF k[0]
	dst[31:0] := -(a[31:0] * b[31:0]) - c[31:0]
ELSE
	dst[31:0] := 0
FI
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vfnmsub132ss"/>
	<mnemonic base="vfnmsub213ss"/>
	<mnemonic base="vfnmsub231ss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_fnmsub_ss / vfnmsub231ss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_maskz_fnmsub_ss">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="c" type="__m128"/>
	<description>Multiply the lower single-precision (32-bit) floating-point elements in "a" and "b", and subtract the lower element in "c" from the negated intermediate result. Store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from "a" to the upper elements of "dst".</description>
	<description code="true">
IF k[0]
	dst[31:0] := -(a[31:0] * b[31:0]) - c[31:0]
ELSE
	dst[31:0] := 0
FI
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vfnmsub132ss"/>
	<mnemonic base="vfnmsub213ss"/>
	<mnemonic base="vfnmsub231ss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_i32gather_pd / vgatherdpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_i32gather_pd">
	<CPUID>AVX-512</CPUID>
	<category>Load</category>
	<parameter varname="vindex" type="__m256i"/>
	<parameter varname="base_addr" type="void const*"/>
	<parameter varname="scale" type="int"/>
	<description>
	Gather double-precision (64-bit) floating-point elements from memory using 32-bit indices. 64-bit elements are loaded from addresses starting at "base_addr" and offset by each 32-bit element in "vindex" (each index is scaled by the factor in "scale"). Gathered elements are merged into "dst". "scale" should be 1, 2, 4 or 8.
	</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	m := j*32
	dst[i+63:i] := MEM[base_addr + SignExtend(vindex[m+31:m])*scale]
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vgatherdpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_i32gather_pd / vgatherdpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_i32gather_pd">
	<CPUID>AVX-512</CPUID>
	<category>Load</category>
	<parameter varname="src" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="vindex" type="__m256i"/>
	<parameter varname="base_addr" type="void const*"/>
	<parameter varname="scale" type="int"/>
	<description>
	Gather double-precision (64-bit) floating-point elements from memory using 32-bit indices. 64-bit elements are loaded from addresses starting at "base_addr" and offset by each 32-bit element in "vindex" (each index is scaled by the factor in "scale"). Gathered elements are merged into "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). "scale" should be 1, 2, 4 or 8.
	</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	m := j*32
	IF k[j]
		dst[i+63:i] := MEM[base_addr + SignExtend(vindex[m+31:m])*scale]
		k[j] := 0
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
k[MAX:8] := 0
dst[MAX:512] := 0
	</description>
	<mnemonic base="vgatherdpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_i32gather_ps / vgatherdps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_i32gather_ps">
	<CPUID>AVX-512</CPUID>
	<category>Load</category>
	<parameter varname="vindex" type="__m512i"/>
	<parameter varname="base_addr" type="void const*"/>
	<parameter varname="scale" type="int"/>
	<description>Gather single-precision (32-bit) floating-point elements from memory using 32-bit indices. 32-bit elements are loaded from addresses starting at "base_addr" and offset by each 32-bit element in "vindex" (each index is scaled by the factor in "scale"). Gathered elements are merged into "dst". "scale" should be 1, 2, 4 or 8.</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := MEM[base_addr + SignExtend(vindex[i+31:i])*scale]
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vgatherdps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_i32gather_ps / vgatherdps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_i32gather_ps">
	<CPUID>AVX-512</CPUID>
	<category>Load</category>
	<parameter varname="src" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="vindex" type="__m512i"/>
	<parameter varname="base_addr" type="void const*"/>
	<parameter varname="scale" type="int"/>
	<description>
	Gather single-precision (32-bit) floating-point elements from memory using 32-bit indices. 32-bit elements are loaded from addresses starting at "base_addr" and offset by each 32-bit element in "vindex" (each index is scaled by the factor in "scale"). Gathered elements are merged into "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). "scale" should be 1, 2, 4 or 8.
	</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := MEM[base_addr + SignExtend(vindex[i+31:i])*scale]
		k[j] := 0
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
k[MAX:16] := 0
dst[MAX:512] := 0
	</description>
	<mnemonic base="vgatherdps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_i64gather_pd / vgatherqpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_i64gather_pd">
	<CPUID>AVX-512</CPUID>
	<category>Load</category>
	<parameter varname="vindex" type="__m512i"/>
	<parameter varname="base_addr" type="void const*"/>
	<parameter varname="scale" type="int"/>
	<description>
	Gather double-precision (64-bit) floating-point elements from memory using 64-bit indices. 64-bit elements are loaded from addresses starting at "base_addr" and offset by each 64-bit element in "vindex" (each index is scaled by the factor in "scale"). Gathered elements are merged into "dst". "scale" should be 1, 2, 4 or 8.
	</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := MEM[base_addr + SignExtend(vindex[i+63:i])*scale]
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vgatherqpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_i64gather_pd / vgatherqpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_i64gather_pd">
	<CPUID>AVX-512</CPUID>
	<category>Load</category>
	<parameter varname="src" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="vindex" type="__m512i"/>
	<parameter varname="base_addr" type="void const*"/>
	<parameter varname="scale" type="int"/>
	<description>
	Gather double-precision (64-bit) floating-point elements from memory using 64-bit indices. 64-bit elements are loaded from addresses starting at "base_addr" and offset by each 64-bit element in "vindex" (each index is scaled by the factor in "scale"). Gathered elements are merged into "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). "scale" should be 1, 2, 4 or 8.
	</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := MEM[base_addr + SignExtend(vindex[i+63:i])*scale]
		k[j] := 0
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
k[MAX:8] := 0
dst[MAX:512] := 0
	</description>
	<mnemonic base="vgatherqpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_i64gather_ps / vgatherqps -->
<intrinsic tech="AVX-512" rettype="__m256" name="_mm512_i64gather_ps">
	<CPUID>AVX-512</CPUID>
		<category>Load</category>
	<parameter varname="vindex" type="__m512i"/>
	<parameter varname="base_addr" type="void const*"/>
	<parameter varname="scale" type="int"/>
	<description>
	Gather single-precision (32-bit) floating-point elements from memory using 64-bit indices. 32-bit elements are loaded from addresses starting at "base_addr" and offset by each 64-bit element in "vindex" (each index is scaled by the factor in "scale"). Gathered elements are merged into "dst". "scale" should be 1, 2, 4 or 8.
	</description>
	<description code="true">
FOR j := 0 to 7
	i := j*32
	m := j*64
	dst[i+31:i] := MEM[base_addr + SignExtend(vindex[i+63:i])*scale]
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base="vgatherqps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_i64gather_ps / vgatherqps -->
<intrinsic tech="AVX-512" rettype="__m256" name="_mm512_mask_i64gather_ps">
	<CPUID>AVX-512</CPUID>
	<category>Load</category>
	<parameter varname="src" type="__m256"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="vindex" type="__m512i"/>
	<parameter varname="base_addr" type="void const*"/>
	<parameter varname="scale" type="int"/>
	<description>
	Gather single-precision (32-bit) floating-point elements from memory using 64-bit indices. 32-bit elements are loaded from addresses starting at "base_addr" and offset by each 64-bit element in "vindex" (each index is scaled by the factor in "scale"). Gathered elements are merged into "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). "scale" should be 1, 2, 4 or 8.
	</description>
	<description code="true">
FOR j := 0 to 7
	i := j*32
	m := j*64
	IF k[j]
		dst[i+31:i] := MEM[base_addr + SignExtend(vindex[i+63:i])*scale]
		k[j] := 0
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
k[MAX:8] := 0
dst[MAX:256] := 0
	</description>
	<mnemonic base="vgatherqps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_getexp_pd / vgetexppd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_getexp_pd">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="a" type="__m512d"/>
	<description>Convert the exponent of each packed double-precision (64-bit) floating-point element in "a" to a double-precision (64-bit) floating-point number representing the integer exponent, and store the results in "dst". This intrinsic essentially calculates "floor(log2(x))" for each element.</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := ConvertExpFP64(a[i+63:i])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vgetexppd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_getexp_round_pd / vgetexppd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_getexp_round_pd">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert the exponent of each packed double-precision (64-bit) floating-point element in "a" to a double-precision (64-bit) floating-point number representing the integer exponent, and store the results in "dst". This intrinsic essentially calculates "floor(log2(x))" for each element.
	[round_note]
	</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := ConvertExpFP64(a[i+63:i])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vgetexppd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_getexp_pd / vgetexppd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_getexp_pd">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="src" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<description>Convert the exponent of each packed double-precision (64-bit) floating-point element in "a" to a double-precision (64-bit) floating-point number representing the integer exponent, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). This intrinsic essentially calculates "floor(log2(x))" for each element.</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := ConvertExpFP64(a[i+63:i])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vgetexppd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_getexp_round_pd / vgetexppd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_getexp_round_pd">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="src" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert the exponent of each packed double-precision (64-bit) floating-point element in "a" to a double-precision (64-bit) floating-point number representing the integer exponent, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). This intrinsic essentially calculates "floor(log2(x))" for each element.
	[round_note]
	</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := ConvertExpFP64(a[i+63:i])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vgetexppd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_getexp_pd / vgetexppd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_getexp_pd">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<description>Convert the exponent of each packed double-precision (64-bit) floating-point element in "a" to a double-precision (64-bit) floating-point number representing the integer exponent, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates "floor(log2(x))" for each element.</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := ConvertExpFP64(a[i+63:i])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vgetexppd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_getexp_round_pd / vgetexppd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_getexp_round_pd">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert the exponent of each packed double-precision (64-bit) floating-point element in "a" to a double-precision (64-bit) floating-point number representing the integer exponent, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates "floor(log2(x))" for each element.
	[round_note]
	</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := ConvertExpFP64(a[i+63:i])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vgetexppd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_getexp_ps / vgetexpps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_getexp_ps">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="a" type="__m512"/>
	<description>Convert the exponent of each packed single-precision (32-bit) floating-point element in "a" to a single-precision (32-bit) floating-point number representing the integer exponent, and store the results in "dst". This intrinsic essentially calculates "floor(log2(x))" for each element.</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := ConvertExpFP32(a[i+31:i])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vgetexpps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_getexp_round_ps / vgetexpps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_getexp_round_ps">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert the exponent of each packed single-precision (32-bit) floating-point element in "a" to a single-precision (32-bit) floating-point number representing the integer exponent, and store the results in "dst". This intrinsic essentially calculates "floor(log2(x))" for each element.
	[round_note]
	</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := ConvertExpFP32(a[i+31:i])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vgetexpps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_getexp_ps / vgetexpps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_getexp_ps">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="src" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<description>Convert the exponent of each packed single-precision (32-bit) floating-point element in "a" to a single-precision (32-bit) floating-point number representing the integer exponent, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). This intrinsic essentially calculates "floor(log2(x))" for each element.</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := ConvertExpFP32(a[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vgetexpps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_getexp_round_ps / vgetexpps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_getexp_round_ps">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="src" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert the exponent of each packed single-precision (32-bit) floating-point element in "a" to a single-precision (32-bit) floating-point number representing the integer exponent, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). This intrinsic essentially calculates "floor(log2(x))" for each element.
	[round_note]
	</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := ConvertExpFP32(a[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vgetexpps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_getexp_ps / vgetexpps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_getexp_ps">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<description>Convert the exponent of each packed single-precision (32-bit) floating-point element in "a" to a single-precision (32-bit) floating-point number representing the integer exponent, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates "floor(log2(x))" for each element.</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := ConvertExpFP32(a[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vgetexpps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_getexp_round_ps / vgetexpps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_getexp_round_ps">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert the exponent of each packed single-precision (32-bit) floating-point element in "a" to a single-precision (32-bit) floating-point number representing the integer exponent, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates "floor(log2(x))" for each element.
	[round_note]
	</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := ConvertExpFP32(a[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vgetexpps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_getexp_round_sd / vgetexpsd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_getexp_round_sd">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert the exponent of the lower double-precision (64-bit) floating-point element in "b" to a double-precision (64-bit) floating-point number representing the integer exponent, store the result in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst". This intrinsic essentially calculates "floor(log2(x))" for the lower element.
	[round_note]
	</description>
	<description code="true">
dst[63:0] := ConvertExpFP64(b[63:0])
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vgetexpsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_getexp_sd / vgetexpsd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_getexp_sd">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<description>Convert the exponent of the lower double-precision (64-bit) floating-point element in "b" to a double-precision (64-bit) floating-point number representing the integer exponent, store the result in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst". This intrinsic essentially calculates "floor(log2(x))" for the lower element.</description>
	<description code="true">
dst[63:0] := ConvertExpFP64(b[63:0])
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vgetexpsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_getexp_round_sd / vgetexpsd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_mask_getexp_round_sd">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="src" type="__m128d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert the exponent of the lower double-precision (64-bit) floating-point element in "b" to a double-precision (64-bit) floating-point number representing the integer exponent, store the result in the lower element of "dst" using writemask "k" (the element is copied from "src" when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst". This intrinsic essentially calculates "floor(log2(x))" for the lower element.
	[round_note]
	</description>
	<description code="true">
IF k[0]
	dst[63:0] := ConvertExpFP64(b[63:0])
ELSE
	dst[63:0] := src[63:0]
FI
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vgetexpsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_getexp_sd / vgetexpsd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_mask_getexp_sd">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="src" type="__m128d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<description>Convert the exponent of the lower double-precision (64-bit) floating-point element in "b" to a double-precision (64-bit) floating-point number representing the integer exponent, store the result in the lower element of "dst" using writemask "k" (the element is copied from "src" when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst". This intrinsic essentially calculates "floor(log2(x))" for the lower element.</description>
	<description code="true">
IF k[0]
	dst[63:0] := ConvertExpFP64(b[63:0])
ELSE
	dst[63:0] := src[63:0]
FI
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vgetexpsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_getexp_round_sd / vgetexpsd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_maskz_getexp_round_sd">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert the exponent of the lower double-precision (64-bit) floating-point element in "b" to a double-precision (64-bit) floating-point number representing the integer exponent, store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst". This intrinsic essentially calculates "floor(log2(x))" for the lower element.
	[round_note]
	</description>
	<description code="true">
IF k[0]
	dst[63:0] := ConvertExpFP64(b[63:0])
ELSE
	dst[63:0] := 0
FI
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vgetexpsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_getexp_sd / vgetexpsd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_maskz_getexp_sd">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<description>Convert the exponent of the lower double-precision (64-bit) floating-point element in "b" to a double-precision (64-bit) floating-point number representing the integer exponent, store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst". This intrinsic essentially calculates "floor(log2(x))" for the lower element.</description>
	<description code="true">
IF k[0]
	dst[63:0] := ConvertExpFP64(b[63:0])
ELSE
	dst[63:0] := 0
FI
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vgetexpsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_getexp_round_ss / vgetexpss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_getexp_round_ss">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert the exponent of the lower single-precision (32-bit) floating-point element in "b" to a single-precision (32-bit) floating-point number representing the integer exponent, store the result in the lower element of "dst", and copy the upper 3 packed elements from "a" to the upper elements of "dst". This intrinsic essentially calculates "floor(log2(x))" for the lower element.
	[round_note]
	</description>
	<description code="true">
dst[31:0] := ConvertExpFP32(b[31:0])
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vgetexpss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_getexp_ss / vgetexpss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_getexp_ss">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<description>Convert the exponent of the lower single-precision (32-bit) floating-point element in "b" to a single-precision (32-bit) floating-point number representing the integer exponent, store the result in the lower element of "dst", and copy the upper 3 packed elements from "a" to the upper elements of "dst". This intrinsic essentially calculates "floor(log2(x))" for the lower element.</description>
	<description code="true">
dst[31:0] := ConvertExpFP32(b[31:0])
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vgetexpss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_getexp_round_ss / vgetexpss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_mask_getexp_round_ss">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="src" type="__m128"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert the exponent of the lower single-precision (32-bit) floating-point element in "b" to a single-precision (32-bit) floating-point number representing the integer exponent, store the result in the lower element of "dst" using writemask "k" (the element is copied from "src" when mask bit 0 is not set), and copy the upper 3 packed elements from "a" to the upper elements of "dst". This intrinsic essentially calculates "floor(log2(x))" for the lower element.
	[round_note]
	</description>
	<description code="true">
IF k[0]
	dst[31:0] := ConvertExpFP32(b[31:0])
ELSE
	dst[31:0] := src[31:0]
FI
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vgetexpss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_getexp_ss / vgetexpss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_mask_getexp_ss">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="src" type="__m128"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<description>Convert the exponent of the lower single-precision (32-bit) floating-point element in "b" to a single-precision (32-bit) floating-point number representing the integer exponent, store the result in the lower element of "dst" using writemask "k" (the element is copied from "src" when mask bit 0 is not set), and copy the upper 3 packed elements from "a" to the upper elements of "dst". This intrinsic essentially calculates "floor(log2(x))" for the lower element.</description>
	<description code="true">
IF k[0]
	dst[31:0] := ConvertExpFP32(b[31:0])
ELSE
	dst[31:0] := src[31:0]
FI
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vgetexpss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_getexp_round_ss / vgetexpss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_maskz_getexp_round_ss">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="rounding" type="int"/>
	<description>Convert the exponent of the lower single-precision (32-bit) floating-point element in "b" to a single-precision (32-bit) floating-point number representing the integer exponent, store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from "a" to the upper elements of "dst". This intrinsic essentially calculates "floor(log2(x))" for the lower element.
	[round_note]
	</description>
	<description code="true">
IF k[0]
	dst[31:0] := ConvertExpFP32(b[31:0])
ELSE
	dst[31:0] := 0
FI
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vgetexpss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_getexp_ss / vgetexpss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_maskz_getexp_ss">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<description>Convert the exponent of the lower single-precision (32-bit) floating-point element in "b" to a single-precision (32-bit) floating-point number representing the integer exponent, store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from "a" to the upper elements of "dst". This intrinsic essentially calculates "floor(log2(x))" for the lower element.</description>
	<description code="true">
IF k[0]
	dst[31:0] := ConvertExpFP32(b[31:0])
ELSE
	dst[31:0] := 0
FI
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vgetexpss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_getmant_pd / vgetmantpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_getmant_pd">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="interv" type="_MM_MANTISSA_NORM_ENUM"/>
	<parameter varname="sc" type="_MM_MANTISSA_SIGN_ENUM"/>
	<description>Normalize the mantissas of packed double-precision (64-bit) floating-point elements in "a", and store the results in "dst". This intrinsic essentially calculates "&#xB1;(2^k)*|x.significand|", where "k" depends on the interval range defined by "interv" and the sign depends on "sc" and the source sign.
	[getmant_note]</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := GetNormalizedMantissa(a[i+63:i], sc, interv)
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vgetmantpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_getmant_round_pd / vgetmantpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_getmant_round_pd">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="interv" type="_MM_MANTISSA_NORM_ENUM"/>
	<parameter varname="sc" type="_MM_MANTISSA_SIGN_ENUM"/>
	<parameter varname="rounding" type="int"/>
	<description>Normalize the mantissas of packed double-precision (64-bit) floating-point elements in "a", and store the results in "dst". This intrinsic essentially calculates "&#xB1;(2^k)*|x.significand|", where "k" depends on the interval range defined by "interv" and the sign depends on "sc" and the source sign.
	[getmant_note][round_note]</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := GetNormalizedMantissa(a[i+63:i], sc, interv)
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vgetmantpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_getmant_pd / vgetmantpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_getmant_pd">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="src" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="interv" type="_MM_MANTISSA_NORM_ENUM"/>
	<parameter varname="sc" type="_MM_MANTISSA_SIGN_ENUM"/>
	<description>Normalize the mantissas of packed double-precision (64-bit) floating-point elements in "a", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). This intrinsic essentially calculates "&#xB1;(2^k)*|x.significand|", where "k" depends on the interval range defined by "interv" and the sign depends on "sc" and the source sign.
	[getmant_note]</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := GetNormalizedMantissa(a[i+63:i], sc, interv)
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vgetmantpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_getmant_round_pd / vgetmantpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_getmant_round_pd">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="src" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="interv" type="_MM_MANTISSA_NORM_ENUM"/>
	<parameter varname="sc" type="_MM_MANTISSA_SIGN_ENUM"/>
	<parameter varname="rounding" type="int"/>
	<description>Normalize the mantissas of packed double-precision (64-bit) floating-point elements in "a", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). This intrinsic essentially calculates "&#xB1;(2^k)*|x.significand|", where "k" depends on the interval range defined by "interv" and the sign depends on "sc" and the source sign.
	[getmant_note][round_note]</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := GetNormalizedMantissa(a[i+63:i], sc, interv)
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vgetmantpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_getmant_pd / vgetmantpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_getmant_pd">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="interv" type="_MM_MANTISSA_NORM_ENUM"/>
	<parameter varname="sc" type="_MM_MANTISSA_SIGN_ENUM"/>
	<description>Normalize the mantissas of packed double-precision (64-bit) floating-point elements in "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates "&#xB1;(2^k)*|x.significand|", where "k" depends on the interval range defined by "interv" and the sign depends on "sc" and the source sign.
	[getmant_note]</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := GetNormalizedMantissa(a[i+63:i], sc, interv)
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vgetmantpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_getmant_round_pd / vgetmantpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_getmant_round_pd">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="interv" type="_MM_MANTISSA_NORM_ENUM"/>
	<parameter varname="sc" type="_MM_MANTISSA_SIGN_ENUM"/>
	<parameter varname="rounding" type="int"/>
	<description>Normalize the mantissas of packed double-precision (64-bit) floating-point elements in "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates "&#xB1;(2^k)*|x.significand|", where "k" depends on the interval range defined by "interv" and the sign depends on "sc" and the source sign.
	[getmant_note][round_note]</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := GetNormalizedMantissa(a[i+63:i], sc, interv)
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vgetmantpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_getmant_ps / vgetmantps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_getmant_ps">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="interv" type="_MM_MANTISSA_NORM_ENUM"/>
	<parameter varname="sc" type="_MM_MANTISSA_SIGN_ENUM"/>
	<description>Normalize the mantissas of packed single-precision (32-bit) floating-point elements in "a", and store the results in "dst". This intrinsic essentially calculates "&#xB1;(2^k)*|x.significand|", where "k" depends on the interval range defined by "interv" and the sign depends on "sc" and the source sign.
	[getmant_note]</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := GetNormalizedMantissa(a[i+31:i], sc, interv)
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vgetmantps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_getmant_round_ps / vgetmantps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_getmant_round_ps">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="interv" type="_MM_MANTISSA_NORM_ENUM"/>
	<parameter varname="sc" type="_MM_MANTISSA_SIGN_ENUM"/>
	<parameter varname="rounding" type="int"/>
	<description>Normalize the mantissas of packed single-precision (32-bit) floating-point elements in "a", and store the results in "dst". This intrinsic essentially calculates "&#xB1;(2^k)*|x.significand|", where "k" depends on the interval range defined by "interv" and the sign depends on "sc" and the source sign.
	[getmant_note][round_note]</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := GetNormalizedMantissa(a[i+31:i], sc, interv)
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vgetmantps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_getmant_ps / vgetmantps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_getmant_ps">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="src" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="interv" type="_MM_MANTISSA_NORM_ENUM"/>
	<parameter varname="sc" type="_MM_MANTISSA_SIGN_ENUM"/>
	<description>Normalize the mantissas of packed single-precision (32-bit) floating-point elements in "a", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). This intrinsic essentially calculates "&#xB1;(2^k)*|x.significand|", where "k" depends on the interval range defined by "interv" and the sign depends on "sc" and the source sign.
	[getmant_note]</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := GetNormalizedMantissa(a[i+31:i], sc, interv)
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vgetmantps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_getmant_round_ps / vgetmantps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_getmant_round_ps">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="src" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="interv" type="_MM_MANTISSA_NORM_ENUM"/>
	<parameter varname="sc" type="_MM_MANTISSA_SIGN_ENUM"/>
	<parameter varname="rounding" type="int"/>
	<description>Normalize the mantissas of packed single-precision (32-bit) floating-point elements in "a", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). This intrinsic essentially calculates "&#xB1;(2^k)*|x.significand|", where "k" depends on the interval range defined by "interv" and the sign depends on "sc" and the source sign.
	[getmant_note][round_note]</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := GetNormalizedMantissa(a[i+31:i], sc, interv)
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vgetmantps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_getmant_ps / vgetmantps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_getmant_ps">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="interv" type="_MM_MANTISSA_NORM_ENUM"/>
	<parameter varname="sc" type="_MM_MANTISSA_SIGN_ENUM"/>
	<description>Normalize the mantissas of packed single-precision (32-bit) floating-point elements in "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates "&#xB1;(2^k)*|x.significand|", where "k" depends on the interval range defined by "interv" and the sign depends on "sc" and the source sign.
	[getmant_note]</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := GetNormalizedMantissa(a[i+31:i], sc, interv)
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vgetmantps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_getmant_round_ps / vgetmantps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_getmant_round_ps">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="interv" type="_MM_MANTISSA_NORM_ENUM"/>
	<parameter varname="sc" type="_MM_MANTISSA_SIGN_ENUM"/>
	<parameter varname="rounding" type="int"/>
	<description>Normalize the mantissas of packed single-precision (32-bit) floating-point elements in "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates "&#xB1;(2^k)*|x.significand|", where "k" depends on the interval range defined by "interv" and the sign depends on "sc" and the source sign.
	[getmant_note][round_note]</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := GetNormalizedMantissa(a[i+31:i], sc, interv)
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vgetmantps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_getmant_round_sd / vgetmantsd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_getmant_round_sd">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="interv" type="_MM_MANTISSA_NORM_ENUM"/>
	<parameter varname="sc" type="_MM_MANTISSA_SIGN_ENUM"/>
	<parameter varname="rounding" type="int"/>
	<description>Normalize the mantissas of the lower double-precision (64-bit) floating-point element in "a", store the result in the lower element of "dst", and copy the upper element from "b" to the upper element of "dst". This intrinsic essentially calculates "&#xB1;(2^k)*|x.significand|", where "k" depends on the interval range defined by "interv" and the sign depends on "sc" and the source sign.
	[getmant_note][round_note]</description>
	<description code="true">
dst[63:0] := GetNormalizedMantissa(a[63:0], sc, interv)
dst[127:64] := b[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vgetmantsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_getmant_sd / vgetmantsd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_getmant_sd">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="interv" type="_MM_MANTISSA_NORM_ENUM"/>
	<parameter varname="sc" type="_MM_MANTISSA_SIGN_ENUM"/>
	<description>Normalize the mantissas of the lower double-precision (64-bit) floating-point element in "a", store the result in the lower element of "dst", and copy the upper element from "b" to the upper element of "dst". This intrinsic essentially calculates "&#xB1;(2^k)*|x.significand|", where "k" depends on the interval range defined by "interv" and the sign depends on "sc" and the source sign.
	[getmant_note]</description>
	<description code="true">
dst[63:0] := GetNormalizedMantissa(a[63:0], sc, interv)
dst[127:64] := b[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vgetmantsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_getmant_round_sd / vgetmantsd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_mask_getmant_round_sd">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="src" type="__m128d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="interv" type="_MM_MANTISSA_NORM_ENUM"/>
	<parameter varname="sc" type="_MM_MANTISSA_SIGN_ENUM"/>
	<parameter varname="rounding" type="int"/>
	<description>Normalize the mantissas of the lower double-precision (64-bit) floating-point element in "a", store the result in the lower element of "dst" using writemask "k" (the element is copied from "src" when mask bit 0 is not set), and copy the upper element from "b" to the upper element of "dst". This intrinsic essentially calculates "&#xB1;(2^k)*|x.significand|", where "k" depends on the interval range defined by "interv" and the sign depends on "sc" and the source sign.
	[getmant_note][round_note]</description>
	<description code="true">
IF k[0]
	dst[63:0] := GetNormalizedMantissa(a[63:0], sc, interv)
ELSE
	dst[63:0] := src[63:0]
FI
dst[127:64] := b[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vgetmantsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_getmant_sd / vgetmantsd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_mask_getmant_sd">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="src" type="__m128d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="interv" type="_MM_MANTISSA_NORM_ENUM"/>
	<parameter varname="sc" type="_MM_MANTISSA_SIGN_ENUM"/>
	<description>Normalize the mantissas of the lower double-precision (64-bit) floating-point element in "a", store the result in the lower element of "dst" using writemask "k" (the element is copied from "src" when mask bit 0 is not set), and copy the upper element from "b" to the upper element of "dst". This intrinsic essentially calculates "&#xB1;(2^k)*|x.significand|", where "k" depends on the interval range defined by "interv" and the sign depends on "sc" and the source sign.
	[getmant_note]</description>
	<description code="true">
IF k[0]
	dst[63:0] := GetNormalizedMantissa(a[63:0], sc, interv)
ELSE
	dst[63:0] := src[63:0]
FI
dst[127:64] := b[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vgetmantsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_getmant_round_sd / vgetmantsd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_maskz_getmant_round_sd">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="interv" type="_MM_MANTISSA_NORM_ENUM"/>
	<parameter varname="sc" type="_MM_MANTISSA_SIGN_ENUM"/>
	<parameter varname="rounding" type="int"/>
	<description>Normalize the mantissas of the lower double-precision (64-bit) floating-point element in "a", store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper element from "b" to the upper element of "dst". This intrinsic essentially calculates "&#xB1;(2^k)*|x.significand|", where "k" depends on the interval range defined by "interv" and the sign depends on "sc" and the source sign.
	[getmant_note][round_note]</description>
	<description code="true">
IF k[0]
	dst[63:0] := GetNormalizedMantissa(a[63:0], sc, interv)
ELSE
	dst[63:0] := 0
FI
dst[127:64] := b[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vgetmantsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_getmant_sd / vgetmantsd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_maskz_getmant_sd">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="interv" type="_MM_MANTISSA_NORM_ENUM"/>
	<parameter varname="sc" type="_MM_MANTISSA_SIGN_ENUM"/>
	<description>Normalize the mantissas of the lower double-precision (64-bit) floating-point element in "a", store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper element from "b" to the upper element of "dst". This intrinsic essentially calculates "&#xB1;(2^k)*|x.significand|", where "k" depends on the interval range defined by "interv" and the sign depends on "sc" and the source sign.
	[getmant_note]</description>
	<description code="true">
IF k[0]
	dst[63:0] := GetNormalizedMantissa(a[63:0], sc, interv)
ELSE
	dst[63:0] := 0
FI
dst[127:64] := b[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vgetmantsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_getmant_round_ss / vgetmantss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_getmant_round_ss">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="interv" type="_MM_MANTISSA_NORM_ENUM"/>
	<parameter varname="sc" type="_MM_MANTISSA_SIGN_ENUM"/>
	<parameter varname="rounding" type="int"/>
	<description>Normalize the mantissas of the lower single-precision (32-bit) floating-point element in "a", store the result in the lower element of "dst", and copy the upper 3 packed elements from "b" to the upper elements of "dst". This intrinsic essentially calculates "&#xB1;(2^k)*|x.significand|", where "k" depends on the interval range defined by "interv" and the sign depends on "sc" and the source sign.
	[getmant_note][round_note]</description>
	<description code="true">
dst[31:0] := GetNormalizedMantissa(a[31:0], sc, interv)
dst[127:32] := b[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vgetmantss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_getmant_ss / vgetmantss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_getmant_ss">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="interv" type="_MM_MANTISSA_NORM_ENUM"/>
	<parameter varname="sc" type="_MM_MANTISSA_SIGN_ENUM"/>
	<description>Normalize the mantissas of the lower single-precision (32-bit) floating-point element in "a", store the result in the lower element of "dst", and copy the upper 3 packed elements from "b" to the upper elements of "dst". This intrinsic essentially calculates "&#xB1;(2^k)*|x.significand|", where "k" depends on the interval range defined by "interv" and the sign depends on "sc" and the source sign.
	[getmant_note]</description>
	<description code="true">
dst[31:0] := GetNormalizedMantissa(a[31:0], sc, interv)
dst[127:32] := b[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vgetmantss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_getmant_round_ss / vgetmantss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_mask_getmant_round_ss">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="src" type="__m128"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="interv" type="_MM_MANTISSA_NORM_ENUM"/>
	<parameter varname="sc" type="_MM_MANTISSA_SIGN_ENUM"/>
	<parameter varname="rounding" type="int"/>	
	<description>Normalize the mantissas of the lower single-precision (32-bit) floating-point element in "a", store the result in the lower element of "dst" using writemask "k" (the element is copied from "src" when mask bit 0 is not set), and copy the upper 3 packed elements from "b" to the upper elements of "dst". This intrinsic essentially calculates "&#xB1;(2^k)*|x.significand|", where "k" depends on the interval range defined by "interv" and the sign depends on "sc" and the source sign.
	[getmant_note][round_note]</description>
	<description code="true">
IF k[0]
	dst[31:0] := GetNormalizedMantissa(a[31:0], sc, interv)
ELSE
	dst[31:0] := src[31:0]
FI
dst[127:32] := b[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vgetmantss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_getmant_ss / vgetmantss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_mask_getmant_ss">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="src" type="__m128"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="interv" type="_MM_MANTISSA_NORM_ENUM"/>
	<parameter varname="sc" type="_MM_MANTISSA_SIGN_ENUM"/>
	<description>Normalize the mantissas of the lower single-precision (32-bit) floating-point element in "a", store the result in the lower element of "dst" using writemask "k" (the element is copied from "src" when mask bit 0 is not set), and copy the upper 3 packed elements from "b" to the upper elements of "dst". This intrinsic essentially calculates "&#xB1;(2^k)*|x.significand|", where "k" depends on the interval range defined by "interv" and the sign depends on "sc" and the source sign.
	[getmant_note]</description>
	<description code="true">
IF k[0]
	dst[31:0] := GetNormalizedMantissa(a[31:0], sc, interv)
ELSE
	dst[31:0] := src[31:0]
FI
dst[127:32] := b[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vgetmantss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_getmant_round_ss / vgetmantss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_maskz_getmant_round_ss">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="interv" type="_MM_MANTISSA_NORM_ENUM"/>
	<parameter varname="sc" type="_MM_MANTISSA_SIGN_ENUM"/>
	<parameter varname="rounding" type="int"/>
	<description>Normalize the mantissas of the lower single-precision (32-bit) floating-point element in "a", store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from "b" to the upper elements of "dst". This intrinsic essentially calculates "&#xB1;(2^k)*|x.significand|", where "k" depends on the interval range defined by "interv" and the sign depends on "sc" and the source sign.
	[getmant_note][round_note]</description>
	<description code="true">
IF k[0]
	dst[31:0] := GetNormalizedMantissa(a[31:0], sc, interv)
ELSE
	dst[31:0] := 0
FI
dst[127:32] := b[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vgetmantss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_getmant_ss / vgetmantss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_maskz_getmant_ss">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="interv" type="_MM_MANTISSA_NORM_ENUM"/>
	<parameter varname="sc" type="_MM_MANTISSA_SIGN_ENUM"/>
	<description>Normalize the mantissas of the lower single-precision (32-bit) floating-point element in "a", store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from "b" to the upper elements of "dst". This intrinsic essentially calculates "&#xB1;(2^k)*|x.significand|", where "k" depends on the interval range defined by "interv" and the sign depends on "sc" and the source sign.
	[getmant_note]</description>
	<description code="true">
IF k[0]
	dst[31:0] := GetNormalizedMantissa(a[31:0], sc, interv)
ELSE
	dst[31:0] := 0
FI
dst[127:32] := b[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vgetmantss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_insertf32x4 / vinsertf32x4 -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_insertf32x4">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="imm" type="int"/>
	<description>Copy "a" to "dst", then insert 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from "b" into "dst" at the location specified by "imm".</description>
	<description code="true">
dst[511:0] := a[511:0]
CASE (imm[1:0]) of
	0: dst[127:0] := b[127:0]
	1: dst[255:128] := b[127:0]
	2: dst[383:256] := b[127:0]
	3: dst[511:384] := b[127:0]
ESAC
dst[MAX:512] := 0
	</description>	
	<mnemonic base="vinsertf32x4"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_insertf32x4 / vinsertf32x4 -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_insertf32x4">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="src" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="imm" type="int"/>
	<description>Copy "a" to "tmp", then insert 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from "b" into "tmp" at the location specified by "imm".  Store "tmp" to "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). 
	</description>
	<description code="true">
tmp[511:0] := a[511:0]
CASE (imm[1:0]) of
	0: tmp[127:0] := b[127:0]
	1: tmp[255:128] := b[127:0]
	2: tmp[383:256] := b[127:0]
	3: tmp[511:384] := b[127:0]
ESAC
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>	
	<mnemonic base="vinsertf32x4"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_insertf32x4 / vinsertf32x4 -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_insertf32x4">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="imm" type="int"/>
	<description>Copy "a" to "tmp", then insert 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from "b" into "tmp" at the location specified by "imm".  Store "tmp" to "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). 
	</description>
	<description code="true">
tmp[511:0] := a[511:0]
CASE (imm[1:0]) of
	0: tmp[127:0] := b[127:0]
	1: tmp[255:128] := b[127:0]
	2: tmp[383:256] := b[127:0]
	3: tmp[511:384] := b[127:0]
ESAC
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vinsertf32x4"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_insertf64x4 / vinsertf64x4 -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_insertf64x4">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m256d"/>
	<parameter varname="imm" type="int"/>
	<description>Copy "a" to "dst", then insert 256 bits (composed of 4 packed double-precision (64-bit) floating-point elements) from "b" into "dst" at the location specified by "imm".</description>
	<description code="true">
dst[511:0] := a[511:0]
CASE (imm[0]) of
	0: dst[255:0] := b[255:0]
	1: dst[511:256] := b[255:0]
ESAC
dst[MAX:512] := 0
	</description>
	<mnemonic base="vinsertf64x4"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_insertf64x4 / vinsertf64x4 -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_insertf64x4">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="src" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m256d"/>
	<parameter varname="imm" type="int"/>
	<description>Copy "a" to "tmp", then insert 256 bits (composed of 4 packed double-precision (64-bit) floating-point elements) from "b" into "tmp" at the location specified by "imm".  Store "tmp" to "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). 
	</description>
	<description code="true">
tmp[511:0] := a[511:0]
CASE (imm[0]) of
	0: tmp[255:0] := b[255:0]
	1: tmp[511:256] := b[255:0]
ESAC
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vinsertf64x4"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_insertf64x4 / vinsertf64x4 -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_insertf64x4">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m256d"/>
	<parameter varname="imm" type="int"/>
	<description>Copy "a" to "tmp", then insert 256 bits (composed of 4 packed double-precision (64-bit) floating-point elements) from "b" into "tmp" at the location specified by "imm".  Store "tmp" to "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). 
	</description>
	<description code="true">
tmp[511:0] := a[511:0]
CASE (imm[0]) of
	0: tmp[255:0] := b[255:0]
	1: tmp[511:256] := b[255:0]
ESAC
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vinsertf64x4"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_inserti32x4 / vinserti32x4 -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_inserti32x4">
	<type>Integer</type>
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m128i"/>
	<parameter varname="imm" type="int"/>
	<description>Copy "a" to "dst", then insert 128 bits (composed of 4 packed 32-bit integers) from "b" into "dst" at the location specified by "imm".</description>
	<description code="true">
dst[511:0] := a[511:0]
CASE (imm[1:0]) of
	0: dst[127:0] := b[127:0]
	1: dst[255:128] := b[127:0]
	2: dst[383:256] := b[127:0]
	3: dst[511:384] := b[127:0]
ESAC
dst[MAX:512] := 0
	</description>
	<mnemonic base="vinserti32x4"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_inserti32x4 / vinserti32x4 -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_inserti32x4">
	<type>Integer</type>
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m128i"/>
	<parameter varname="imm" type="int"/>
	<description>Copy "a" to "tmp", then insert 128 bits (composed of 4 packed 32-bit integers) from "b" into "tmp" at the location specified by "imm".  Store "tmp" to "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). 
	</description>
	<description code="true">
tmp[511:0] := a[511:0]
CASE (imm[1:0]) of
	0: tmp[127:0] := b[127:0]
	1: tmp[255:128] := b[127:0]
	2: tmp[383:256] := b[127:0]
	3: tmp[511:384] := b[127:0]
ESAC
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vinserti32x4"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_inserti32x4 / vinserti32x4 -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_inserti32x4">
	<type>Integer</type>
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m128i"/>
	<parameter varname="imm" type="int"/>
	<description>Copy "a" to "tmp", then insert 128 bits (composed of 4 packed 32-bit integers) from "b" into "tmp" at the location specified by "imm".  Store "tmp" to "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). 
	</description>
	<description code="true">
tmp[511:0] := a[511:0]
CASE (imm[1:0]) of
	0: tmp[127:0] := b[127:0]
	1: tmp[255:128] := b[127:0]
	2: tmp[383:256] := b[127:0]
	3: tmp[511:384] := b[127:0]
ESAC
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vinserti32x4"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_inserti64x4 / vinserti64x4 -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_inserti64x4">
	<type>Integer</type>
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m256i"/>
	<parameter varname="imm" type="int"/>
	<description>Copy "a" to "dst", then insert 256 bits (composed of 4 packed 64-bit integers) from "b" into "dst" at the location specified by "imm".</description>
	<description code="true">
dst[511:0] := a[511:0]
CASE (imm) of
	0: dst[255:0] := b[255:0]
	1: dst[511:256] := b[255:0]
ESAC
dst[MAX:512] := 0
	</description>
	<mnemonic base="vinserti64x4"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_inserti64x4 / vinserti64x4 -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_inserti64x4">
	<type>Integer</type>
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m256i"/>
	<parameter varname="imm" type="int"/>
	<description>Copy "a" to "tmp", then insert 256 bits (composed of 4 packed 64-bit integers) from "b" into "tmp" at the location specified by "imm".  Store "tmp" to "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). 
	</description>
	<description code="true">
tmp[511:0] := a[511:0]
CASE (imm[0]) of
	0: tmp[255:0] := b[255:0]
	1: tmp[511:256] := b[255:0]
ESAC
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vinserti64x4"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_inserti64x4 / vinserti64x4 -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_inserti64x4">
	<type>Integer</type>
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m256i"/>
	<parameter varname="imm" type="int"/>
	<description>Copy "a" to "tmp", then insert 256 bits (composed of 4 packed 64-bit integers) from "b" into "tmp" at the location specified by "imm".  Store "tmp" to "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). 
	</description>
	<description code="true">
tmp[511:0] := a[511:0]
CASE (imm[0]) of
	0: tmp[255:0] := b[255:0]
	1: tmp[511:256] := b[255:0]
ESAC
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vinserti64x4"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_max_pd / vmaxpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_max_pd">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="src" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<description>Compare packed double-precision (64-bit) floating-point elements in "a" and "b", and store packed maximum values in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := MAX(a[i+63:i], b[i+63:i])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vmaxpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_max_round_pd / vmaxpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_max_round_pd">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="src" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="sae" type="int"/>
	<description>Compare packed double-precision (64-bit) floating-point elements in "a" and "b", and store packed maximum values in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).  
	Pass __MM_FROUND_NO_EXC to "sae" to suppress all exceptions.</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := MAX(a[i+63:i], b[i+63:i])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vmaxpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_max_pd / vmaxpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_max_pd">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<description>Compare packed double-precision (64-bit) floating-point elements in "a" and "b", and store packed maximum values in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := MAX(a[i+63:i], b[i+63:i])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vmaxpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_max_round_pd / vmaxpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_max_round_pd">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="sae" type="int"/>
	<description>Compare packed double-precision (64-bit) floating-point elements in "a" and "b", and store packed maximum values in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). 
	Pass __MM_FROUND_NO_EXC to "sae" to suppress all exceptions.</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := MAX(a[i+63:i], b[i+63:i])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vmaxpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_max_pd / vmaxpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_max_pd">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<description>Compare packed double-precision (64-bit) floating-point elements in "a" and "b", and store packed maximum values in "dst".</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := MAX(a[i+63:i], b[i+63:i])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vmaxpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_max_round_pd / vmaxpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_max_round_pd">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="sae" type="int"/>
	<description>Compare packed double-precision (64-bit) floating-point elements in "a" and "b", and store packed maximum values in "dst". 
	Pass __MM_FROUND_NO_EXC to "sae" to suppress all exceptions.</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := MAX(a[i+63:i], b[i+63:i])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vmaxpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_max_ps / vmaxps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_max_ps">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="src" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<description>Compare packed single-precision (32-bit) floating-point elements in "a" and "b", and store packed maximum values in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := MAX(a[i+31:i], b[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vmaxps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_max_round_ps / vmaxps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_max_round_ps">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="src" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="sae" type="int"/>
	<description>Compare packed single-precision (32-bit) floating-point elements in "a" and "b", and store packed maximum values in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).  
	Pass __MM_FROUND_NO_EXC to "sae" to suppress all exceptions.</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := MAX(a[i+31:i], b[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vmaxps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_max_ps / vmaxps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_max_ps">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<description>Compare packed single-precision (32-bit) floating-point elements in "a" and "b", and store packed maximum values in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := MAX(a[i+31:i], b[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vmaxps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_max_round_ps / vmaxps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_max_round_ps">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="sae" type="int"/>
	<description>Compare packed single-precision (32-bit) floating-point elements in "a" and "b", and store packed maximum values in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). 
	Pass __MM_FROUND_NO_EXC to "sae" to suppress all exceptions.</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := MAX(a[i+31:i], b[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vmaxps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_max_ps / vmaxps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_max_ps">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<description>Compare packed single-precision (32-bit) floating-point elements in "a" and "b", and store packed maximum values in "dst".</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := MAX(a[i+31:i], b[i+31:i])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vmaxps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_max_round_ps / vmaxps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_max_round_ps">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="sae" type="int"/>
	<description>Compare packed single-precision (32-bit) floating-point elements in "a" and "b", and store packed maximum values in "dst". 
	Pass __MM_FROUND_NO_EXC to "sae" to suppress all exceptions.</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := MAX(a[i+31:i], b[i+31:i])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vmaxps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_max_round_sd / vmaxsd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_mask_max_round_sd">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="src" type="__m128d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="sae" type="int"/>
	<description>Compare the lower double-precision (64-bit) floating-point elements in "a" and "b", store the maximum value in the lower element of "dst" using writemask "k" (the element is copied from "src" when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst".
	Pass __MM_FROUND_NO_EXC to "sae" to suppress all exceptions.</description>
	<description code="true">
IF k[0]
	dst[63:0] := MAX(a[63:0], b[63:0])
ELSE
	dst[63:0] := src[63:0]
FI
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vmaxsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_max_sd / vmaxsd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_mask_max_sd">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="src" type="__m128d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<description>Compare the lower double-precision (64-bit) floating-point elements in "a" and "b", store the maximum value in the lower element of "dst" using writemask "k" (the element is copied from "src" when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst".</description>
	<description code="true">
IF k[0]
	dst[63:0] := MAX(a[63:0], b[63:0])
ELSE
	dst[63:0] := src[63:0]
FI
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vmaxsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_max_round_sd / vmaxsd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_maskz_max_round_sd">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="sae" type="int"/>
	<description>Compare the lower double-precision (64-bit) floating-point elements in "a" and "b", store the maximum value in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst".
	Pass __MM_FROUND_NO_EXC to "sae" to suppress all exceptions.</description>
	<description code="true">
IF k[0]
	dst[63:0] := MAX(a[63:0], b[63:0])
ELSE
	dst[63:0] := 0
FI
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vmaxsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_max_sd / vmaxsd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_maskz_max_sd">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<description>Compare the lower double-precision (64-bit) floating-point elements in "a" and "b", store the maximum value in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst".</description>
	<description code="true">
IF k[0]
	dst[63:0] := MAX(a[63:0], b[63:0])
ELSE
	dst[63:0] := 0
FI
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vmaxsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_max_round_sd / vmaxsd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_max_round_sd">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="sae" type="int"/>
	<description>Compare the lower double-precision (64-bit) floating-point elements in "a" and "b", store the maximum value in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst".
	Pass __MM_FROUND_NO_EXC to "sae" to suppress all exceptions.</description>
	<description code="true">
dst[63:0] := MAX(a[63:0], b[63:0])
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vmaxsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_max_round_ss / vmaxss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_mask_max_round_ss">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="src" type="__m128"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="sae" type="int"/>
	<description>Compare the lower single-precision (32-bit) floating-point elements in "a" and "b", store the maximum value in the lower element of "dst" using writemask "k" (the element is copied from "src" when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst".
	Pass __MM_FROUND_NO_EXC to "sae" to suppress all exceptions.</description>
	<description code="true">
IF k[0]
	dst[31:0] := MAX(a[31:0], b[31:0])
ELSE
	dst[31:0] := src[31:0]
FI
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vmaxss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_max_ss / vmaxss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_mask_max_ss">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="src" type="__m128"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<description>Compare the lower single-precision (32-bit) floating-point elements in "a" and "b", store the maximum value in the lower element of "dst" using writemask "k" (the element is copied from "src" when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst".</description>
	<description code="true">
IF k[0]
	dst[31:0] := MAX(a[31:0], b[31:0])
ELSE
	dst[31:0] := src[31:0]
FI
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vmaxss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_max_round_ss / vmaxss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_maskz_max_round_ss">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="sae" type="int"/>
	<description>Compare the lower single-precision (32-bit) floating-point elements in "a" and "b", store the maximum value in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst".
	Pass __MM_FROUND_NO_EXC to "sae" to suppress all exceptions.</description>
	<description code="true">
IF k[0]
	dst[31:0] := MAX(a[31:0], b[31:0])
ELSE
	dst[31:0] := 0
FI
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vmaxss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_max_ss / vmaxss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_maskz_max_ss">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<description>Compare the lower single-precision (32-bit) floating-point elements in "a" and "b", store the maximum value in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst".</description>
	<description code="true">
IF k[0]
	dst[31:0] := MAX(a[31:0], b[31:0])
ELSE
	dst[31:0] := 0
FI
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vmaxss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_max_round_ss / vmaxss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_max_round_ss">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="sae" type="int"/>
	<description>Compare the lower single-precision (32-bit) floating-point elements in "a" and "b", store the maximum value in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst".
	Pass __MM_FROUND_NO_EXC to "sae" to suppress all exceptions.</description>
	<description code="true">
dst[31:0] := MAX(a[31:0], b[31:0])
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vmaxss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_min_pd / vminpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_min_pd">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="src" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<description>Compare packed double-precision (64-bit) floating-point elements in "a" and "b", and store packed minimum values in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := MIN(a[i+63:i], b[i+63:i])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vminpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_min_round_pd / vminpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_min_round_pd">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="src" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="sae" type="int"/>
	<description>Compare packed double-precision (64-bit) floating-point elements in "a" and "b", and store packed minimum values in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).  
	Pass __MM_FROUND_NO_EXC to "sae" to suppress all exceptions.</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := MIN(a[i+63:i], b[i+63:i])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vminpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_min_pd / vminpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_min_pd">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<description>Compare packed double-precision (64-bit) floating-point elements in "a" and "b", and store packed minimum values in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := MIN(a[i+63:i], b[i+63:i])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vminpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_min_round_pd / vminpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_min_round_pd">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="sae" type="int"/>
	<description>Compare packed double-precision (64-bit) floating-point elements in "a" and "b", and store packed minimum values in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). 
	Pass __MM_FROUND_NO_EXC to "sae" to suppress all exceptions.</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := MIN(a[i+63:i], b[i+63:i])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vminpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_min_pd / vminpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_min_pd">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<description>Compare packed double-precision (64-bit) floating-point elements in "a" and "b", and store packed minimum values in "dst".
	</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := MIN(a[i+63:i], b[i+63:i])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vminpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_min_round_pd / vminpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_min_round_pd">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="sae" type="int"/>
	<description>Compare packed double-precision (64-bit) floating-point elements in "a" and "b", and store packed minimum values in "dst". 
	Pass __MM_FROUND_NO_EXC to "sae" to suppress all exceptions.</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := MIN(a[i+63:i], b[i+63:i])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vminpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_min_ps / vminps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_min_ps">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="src" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<description>Compare packed single-precision (32-bit) floating-point elements in "a" and "b", and store packed minimum values in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := MIN(a[i+31:i], b[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>

	<mnemonic base="vminps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_min_round_ps / vminps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_min_round_ps">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="src" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="sae" type="int"/>
	<description>Compare packed single-precision (32-bit) floating-point elements in "a" and "b", and store packed minimum values in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).  
	Pass __MM_FROUND_NO_EXC to "sae" to suppress all exceptions.</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := MIN(a[i+31:i], b[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vminps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_min_ps / vminps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_min_ps">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<description>Compare packed single-precision (32-bit) floating-point elements in "a" and "b", and store packed minimum values in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := MIN(a[i+31:i], b[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vminps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_min_round_ps / vminps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_min_round_ps">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="sae" type="int"/>
	<description>Compare packed single-precision (32-bit) floating-point elements in "a" and "b", and store packed minimum values in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). 
	Pass __MM_FROUND_NO_EXC to "sae" to suppress all exceptions.</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := MIN(a[i+31:i], b[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vminps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_min_ps / vminps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_min_ps">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<description>Compare packed single-precision (32-bit) floating-point elements in "a" and "b", and store packed minimum values in "dst".
	</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := MIN(a[i+31:i], b[i+31:i])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vminps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_min_round_ps / vminps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_min_round_ps">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="sae" type="int"/>
	<description>Compare packed single-precision (32-bit) floating-point elements in "a" and "b", and store packed minimum values in "dst". 
	Pass __MM_FROUND_NO_EXC to "sae" to suppress all exceptions.</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := MIN(a[i+31:i], b[i+31:i])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vminps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_min_round_sd / vminsd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_mask_min_round_sd">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="src" type="__m128d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="sae" type="int"/>
	<description>Compare the lower double-precision (64-bit) floating-point elements in "a" and "b", store the minimum value in the lower element of "dst" using writemask "k" (the element is copied from "src" when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst".
	Pass __MM_FROUND_NO_EXC to "sae" to suppress all exceptions.</description>
	<description code="true">
IF k[0]
	dst[63:0] := MIN(a[63:0], b[63:0])
ELSE
	dst[63:0] := src[63:0]
FI
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vminsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_min_sd / vminsd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_mask_min_sd">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="src" type="__m128d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<description>Compare the lower double-precision (64-bit) floating-point elements in "a" and "b", store the minimum value in the lower element of "dst" using writemask "k" (the element is copied from "src" when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst".</description>
	<description code="true">
IF k[0]
	dst[63:0] := MIN(a[63:0], b[63:0])
ELSE
	dst[63:0] := src[63:0]
FI
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vminsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_min_round_sd / vminsd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_maskz_min_round_sd">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="sae" type="int"/>
	<description>Compare the lower double-precision (64-bit) floating-point elements in "a" and "b", store the minimum value in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst".
	Pass __MM_FROUND_NO_EXC to "sae" to suppress all exceptions.</description>
	<description code="true">
IF k[0]
	dst[63:0] := MIN(a[63:0], b[63:0])
ELSE
	dst[63:0] := 0
FI
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vminsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_min_sd / vminsd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_maskz_min_sd">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<description>Compare the lower double-precision (64-bit) floating-point elements in "a" and "b", store the minimum value in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst".</description>
	<description code="true">
IF k[0]
	dst[63:0] := MIN(a[63:0], b[63:0])
ELSE
	dst[63:0] := 0
FI
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vminsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_min_round_sd / vminsd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_min_round_sd">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="sae" type="int"/>
	<description>Compare the lower double-precision (64-bit) floating-point elements in "a" and "b", store the minimum value in the lower element of "dst" , and copy the upper element from "a" to the upper element of "dst".
	Pass __MM_FROUND_NO_EXC to "sae" to suppress all exceptions.</description>
	<description code="true">
dst[63:0] := MIN(a[63:0], b[63:0])
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vminsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_min_round_ss / vminss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_mask_min_round_ss">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="src" type="__m128"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="sae" type="int"/>
	<description>Compare the lower single-precision (32-bit) floating-point elements in "a" and "b", store the minimum value in the lower element of "dst" using writemask "k" (the element is copied from "src" when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst".
	Pass __MM_FROUND_NO_EXC to "sae" to suppress all exceptions.</description>
	<description code="true">
IF k[0]
	dst[31:0] := MIN(a[31:0], b[31:0])
ELSE
	dst[31:0] := src[31:0]
FI
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vminss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_min_ss / vminss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_mask_min_ss">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="src" type="__m128"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<description>Compare the lower single-precision (32-bit) floating-point elements in "a" and "b", store the minimum value in the lower element of "dst" using writemask "k" (the element is copied from "src" when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst".</description>
	<description code="true">
IF k[0]
	dst[31:0] := MIN(a[31:0], b[31:0])
ELSE
	dst[31:0] := src[31:0]
FI
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vminss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_min_round_ss / vminss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_maskz_min_round_ss">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="sae" type="int"/>
	<description>Compare the lower single-precision (32-bit) floating-point elements in "a" and "b", store the minimum value in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst".
	Pass __MM_FROUND_NO_EXC to "sae" to suppress all exceptions.</description>
	<description code="true">
IF k[0]
	dst[31:0] := MIN(a[31:0], b[31:0])
ELSE
	dst[31:0] := 0
FI
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vminss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_min_ss / vminss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_maskz_min_ss">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<description>Compare the lower single-precision (32-bit) floating-point elements in "a" and "b", store the minimum value in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst".</description>
	<description code="true">
IF k[0]
	dst[31:0] := MIN(a[31:0], b[31:0])
ELSE
	dst[31:0] := 0
FI
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vminss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_min_round_ss / vminss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_min_round_ss">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="sae" type="int"/>
	<description>Compare the lower single-precision (32-bit) floating-point elements in "a" and "b", store the minimum value in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst".
	Pass __MM_FROUND_NO_EXC to "sae" to suppress all exceptions.</description>
	<description code="true">
dst[31:0] := MIN(a[31:0], b[31:0])
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vminss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_load_pd / vmovapd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_load_pd">
	<CPUID>AVX-512</CPUID>
	<category>Load</category>
	<parameter varname="mem_addr" type="void const*"/>
	<description>Load 512-bits (composed of 8 packed double-precision (64-bit) floating-point elements) from memory into "dst". 
	"mem_addr" must be aligned on a 64-byte boundary or a general-protection exception will be generated.</description>
	<description code="true">
dst[511:0] := MEM[mem_addr+511:mem_addr]
dst[MAX:512] := 0
	</description>
	<mnemonic base="vmovapd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_load_pd / vmovapd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_load_pd">
	<CPUID>AVX-512</CPUID>
	<category>Load</category>
	<parameter varname="src" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="mem_addr" type="void const*"/>
	<description>Load packed double-precision (64-bit) floating-point elements from memory into "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). "mem_addr" must be aligned on a 64-byte boundary or a general-protection exception will be generated.</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := MEM[mem_addr+i+63:mem_addr+i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vmovapd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_mov_pd / vmovapd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_mov_pd">
	<CPUID>AVX-512</CPUID>
	<category>Move</category>
	<parameter varname="src" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<description>Move packed double-precision (64-bit) floating-point elements from "a" to "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vmovapd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_store_pd / vmovapd -->
<intrinsic tech="AVX-512" rettype="void" name="_mm512_mask_store_pd">
	<CPUID>AVX-512</CPUID>
	<category>Store</category>
	<parameter varname="mem_addr" type="void*"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<description>Store packed double-precision (64-bit) floating-point elements from "a" into memory using writemask "k".
	"mem_addr" must be aligned on a 64-byte boundary or a general-protection exception will be generated.</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		MEM[mem_addr+i+63:mem_addr+i] := a[i+63:i]
	FI
ENDFOR
	</description>
	<mnemonic base="vmovapd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_load_pd / vmovapd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_load_pd">
	<CPUID>AVX-512</CPUID>
	<category>Load</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="mem_addr" type="void const*"/>
	<description>Load packed double-precision (64-bit) floating-point elements from memory into "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). "mem_addr" must be aligned on a 64-byte boundary or a general-protection exception will be generated.</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := MEM[mem_addr+i+63:mem_addr+i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vmovapd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_mov_pd / vmovapd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_mov_pd">
	<CPUID>AVX-512</CPUID>
	<category>Move</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<description>Move packed double-precision (64-bit) floating-point elements from "a" into "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vmovapd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_store_pd / vmovapd -->
<intrinsic tech="AVX-512" rettype="void" name="_mm512_store_pd">
	<CPUID>AVX-512</CPUID>
	<category>Store</category>
	<parameter varname="mem_addr" type="void*"/>
	<parameter varname="a" type="__m512d"/>
	<description>Store 512-bits (composed of 8 packed double-precision (64-bit) floating-point elements) from "a" into memory.
	"mem_addr" must be aligned on a 64-byte boundary or a general-protection exception will be generated.</description>
	<description code="true">
MEM[mem_addr+511:mem_addr] := a[511:0]
	</description>
	<mnemonic base="vmovapd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_load_ps / vmovaps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_load_ps">
	<CPUID>AVX-512</CPUID>
	<category>Load</category>
	<parameter varname="mem_addr" type="void const*"/>
	<description>Load 512-bits (composed of 16 packed single-precision (32-bit) floating-point elements) from memory into "dst". 
	"mem_addr" must be aligned on a 64-byte boundary or a general-protection exception will be generated.</description>
	<description code="true">
dst[511:0] := MEM[mem_addr+511:mem_addr]
dst[MAX:512] := 0
	</description>
	<mnemonic base="vmovaps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_load_ps / vmovaps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_load_ps">
	<CPUID>AVX-512</CPUID>
	<category>Load</category>
	<parameter varname="src" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="mem_addr" type="void const*"/>
	<description>Load packed single-precision (32-bit) floating-point elements from memory into "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). "mem_addr" must be aligned on a 64-byte boundary or a general-protection exception will be generated.</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := MEM[mem_addr+i+31:mem_addr+i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vmovaps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_mov_ps / vmovaps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_mov_ps">
	<CPUID>AVX-512</CPUID>
	<category>Move</category>
	<parameter varname="src" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<description>Move packed single-precision (32-bit) floating-point elements from "a" to "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vmovaps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_store_ps / vmovaps -->
<intrinsic tech="AVX-512" rettype="void" name="_mm512_mask_store_ps">
	<CPUID>AVX-512</CPUID>
	<category>Store</category>
	<parameter varname="mem_addr" type="void*"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<description>Store packed single-precision (32-bit) floating-point elements from "a" into memory using writemask "k".
	"mem_addr" must be aligned on a 64-byte boundary or a general-protection exception will be generated.</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		MEM[mem_addr+i+31:mem_addr+i] := a[i+31:i]
	FI
ENDFOR
	</description>
	<mnemonic base="vmovaps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_load_ps / vmovaps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_load_ps">
	<CPUID>AVX-512</CPUID>
	<category>Load</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="mem_addr" type="void const*"/>
	<description>Load packed single-precision (32-bit) floating-point elements from memory into "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). "mem_addr" must be aligned on a 64-byte boundary or a general-protection exception will be generated.</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := MEM[mem_addr+i+31:mem_addr+i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>	
	<mnemonic base="vmovaps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_mov_ps / vmovaps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_mov_ps">
	<CPUID>AVX-512</CPUID>
	<category>Move</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<description>Move packed single-precision (32-bit) floating-point elements from "a" into "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vmovaps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_store_ps / vmovaps -->
<intrinsic tech="AVX-512" rettype="void" name="_mm512_store_ps">
	<CPUID>AVX-512</CPUID>
	<category>Store</category>
	<parameter varname="mem_addr" type="void*"/>
	<parameter varname="a" type="__m512"/>
	<description>Store 512-bits (composed of 16 packed single-precision (32-bit) floating-point elements) from "a" into memory. 
	"mem_addr" must be aligned on a 64-byte boundary or a general-protection exception will be generated.</description>
	<description code="true">
MEM[mem_addr+511:mem_addr] := a[511:0]
	</description>
	<mnemonic base="vmovaps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_movedup_pd / vmovddup -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_movedup_pd">
	<CPUID>AVX-512</CPUID>
	<category>Move</category>
	<parameter varname="src" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<description>Duplicate even-indexed double-precision (64-bit) floating-point elements from "a", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<description code="true">
tmp[63:0] := a[63:0]
tmp[127:64] := a[63:0]
tmp[191:128] := a[191:128]
tmp[255:192] := a[191:128]
tmp[319:256] := a[319:256] 
tmp[383:320] := a[319:256] 
tmp[447:384] := a[447:384]
tmp[511:448] := a[447:384]
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vmovddup"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_movedup_pd / vmovddup -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_movedup_pd">
	<CPUID>AVX-512</CPUID>
	<category>Move</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<description>Duplicate even-indexed double-precision (64-bit) floating-point elements from "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
tmp[63:0] := a[63:0]
tmp[127:64] := a[63:0]
tmp[191:128] := a[191:128]
tmp[255:192] := a[191:128]
tmp[319:256] := a[319:256] 
tmp[383:320] := a[319:256] 
tmp[447:384] := a[447:384]
tmp[511:448] := a[447:384]
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vmovddup"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_movedup_pd / vmovddup -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_movedup_pd">
	<CPUID>AVX-512</CPUID>
	<category>Move</category>
	<parameter varname="a" type="__m512d"/>
	<description>Duplicate even-indexed double-precision (64-bit) floating-point elements from "a", and store the results in "dst".
	</description>
	<description code="true">
tmp[63:0] := a[63:0]
tmp[127:64] := a[63:0]
tmp[191:128] := a[191:128]
tmp[255:192] := a[191:128]
tmp[319:256] := a[319:256] 
tmp[383:320] := a[319:256] 
tmp[447:384] := a[447:384]
tmp[511:448] := a[447:384]
dst[MAX:512] := 0
	</description>
	<mnemonic base="vmovddup"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_load_epi32 / vmovdqa32 -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_load_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Load</category>
	<parameter varname="mem_addr" type="void const*"/>
	<description>Load 512-bits (composed of 16 packed 32-bit integers) from memory into "dst". 
	"mem_addr" must be aligned on a 64-byte boundary or a general-protection exception will be generated.</description>
	<description code="true">
dst[511:0] := MEM[mem_addr+511:mem_addr]
dst[MAX:512] := 0
	</description>
	<mnemonic base="vmovdqa32"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_load_si512 / vmovdqa32 -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_load_si512">
	<CPUID>AVX-512</CPUID>
	<category>Load</category>
	<parameter varname="mem_addr" type="void const*"/>
	<description>Load 512-bits of integer data from memory into "dst". 
	"mem_addr" must be aligned on a 64-byte boundary or a general-protection exception will be generated.</description>
	<description code="true">
dst[511:0] := MEM[mem_addr+511:mem_addr]
dst[MAX:512] := 0
	</description>
	<mnemonic base="vmovdqa32"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_load_epi32 / vmovdqa32 -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_load_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Load</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="mem_addr" type="void const*"/>
	<description>Load packed 32-bit integers from memory into "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).
	"mem_addr" must be aligned on a 64-byte boundary or a general-protection exception will be generated.</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := MEM[mem_addr+i+31:mem_addr+i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vmovdqa32"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_mov_epi32 / vmovdqa32 -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_mov_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Move</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<description>Move packed 32-bit integers from "a" to "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vmovdqa32"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_store_epi32 / vmovdqa32 -->
<intrinsic tech="AVX-512" rettype="void" name="_mm512_mask_store_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Store</category>
	<parameter varname="mem_addr" type="void*"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<description>Store packed 32-bit integers from "a" into memory using writemask "k".
	"mem_addr" must be aligned on a 64-byte boundary or a general-protection exception will be generated.
	</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		MEM[mem_addr+i+31:mem_addr+i] := a[i+31:i]
	FI
ENDFOR
	</description>
	<mnemonic base="vmovdqa32"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_load_epi32 / vmovdqa32 -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_load_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Load</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="mem_addr" type="void const*"/>
	<description>Load packed 32-bit integers from memory into "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). 
	"mem_addr" must be aligned on a 64-byte boundary or a general-protection exception will be generated.</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := MEM[mem_addr+i+31:mem_addr+i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vmovdqa32"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_mov_epi32 / vmovdqa32 -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_mov_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Move</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<description>Move packed 32-bit integers from "a" into "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vmovdqa32"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_store_epi32 / vmovdqa32 -->
<intrinsic tech="AVX-512" rettype="void" name="_mm512_store_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Store</category>
	<parameter varname="mem_addr" type="void*"/>
	<parameter varname="a" type="__m512i"/>
	<description>Store 512-bits (composed of 16 packed 32-bit integers) from "a" into memory. 
	"mem_addr" must be aligned on a 64-byte boundary or a general-protection exception will be generated.</description>
	<description code="true">
MEM[mem_addr+511:mem_addr] := a[511:0]
	</description>
	<mnemonic base="vmovdqa32"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_store_si512 / vmovdqa32 -->
<intrinsic tech="AVX-512" rettype="void" name="_mm512_store_si512">
	<CPUID>AVX-512</CPUID>
	<category>Store</category>
	<parameter varname="mem_addr" type="void*"/>
	<parameter varname="a" type="__m512i"/>
	<description>Store 512-bits of integer data from "a" into memory. 
	"mem_addr" must be aligned on a 64-byte boundary or a general-protection exception will be generated.</description>
	<description code="true">
MEM[mem_addr+511:mem_addr] := a[511:0]
	</description>
	<mnemonic base="vmovdqa32"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_load_epi64 / vmovdqa64 -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_load_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Load</category>
	<parameter varname="mem_addr" type="void const*"/>
	<description>Load 512-bits (composed of 8 packed 64-bit integers) from memory into "dst". 
	"mem_addr" must be aligned on a 64-byte boundary or a general-protection exception will be generated.</description>
	<description code="true">
dst[511:0] := MEM[mem_addr+511:mem_addr]
dst[MAX:512] := 0
	</description>
	<mnemonic base="vmovdqa64"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_load_epi64 / vmovdqa64 -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_load_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Load</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="mem_addr" type="void const*"/>
	<description>Load packed 64-bit integers from memory into "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). 
	"mem_addr" must be aligned on a 64-byte boundary or a general-protection exception will be generated.</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := MEM[mem_addr+i+63:mem_addr+i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vmovdqa64"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_mov_epi64 / vmovdqa64 -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_mov_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Move</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<description>Move packed 64-bit integers from "a" to "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vmovdqa64"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_store_epi64 / vmovdqa64 -->
<intrinsic tech="AVX-512" rettype="void" name="_mm512_mask_store_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Store</category>
	<parameter varname="mem_addr" type="void*"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<description>Store packed 64-bit integers from "a" into memory using writemask "k".
	"mem_addr" must be aligned on a 64-byte boundary or a general-protection exception will be generated.
	</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		MEM[mem_addr+i+63:mem_addr+i] := a[i+63:i]
	FI
ENDFOR
	</description>
	<mnemonic base="vmovdqa64"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_load_epi64 / vmovdqa64 -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_load_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Load</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="mem_addr" type="void const*"/>
	<description>Load packed 64-bit integers from memory into "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). 
	"mem_addr" must be aligned on a 64-byte boundary or a general-protection exception will be generated.
	</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := MEM[mem_addr+i+63:mem_addr+i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vmovdqa64"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_mov_epi64 / vmovdqa64 -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_mov_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Move</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<description>Move packed 64-bit integers from "a" into "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vmovdqa64"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_store_epi64 / vmovdqa64 -->
<intrinsic tech="AVX-512" rettype="void" name="_mm512_store_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Store</category>
	<parameter varname="mem_addr" type="void*"/>
	<parameter varname="a" type="__m512i"/>
	<description>Store 512-bits (composed of 8 packed 64-bit integers) from "a" into memory. 
	"mem_addr" must be aligned on a 64-byte boundary or a general-protection exception will be generated.</description>
	<description code="true">
MEM[mem_addr+511:mem_addr] := a[511:0]
	</description>
	<mnemonic base="vmovdqa64"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_loadu_si512 / vmovdqu32 -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_loadu_si512">
	<CPUID>AVX-512</CPUID>
	<category>Load</category>
	<parameter varname="mem_addr" type="void const*"/>
	<description>Load 512-bits of integer data from memory into "dst".
	"mem_addr" does not need to be aligned on any particular boundary.
	</description>
	<description code="true">
dst[511:0] := MEM[mem_addr+511:mem_addr]
dst[MAX:512] := 0
	</description>
	<mnemonic base="vmovdqu32"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_loadu_epi32 / vmovdqu32 -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_loadu_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Load</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="mem_addr" type="void const*"/>
	<description>Load packed 32-bit integers from memory into "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). 
	"mem_addr" does not need to be aligned on any particular boundary.
	</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := MEM[mem_addr+i+31:mem_addr+i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vmovdqu32"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_storeu_epi32 / vmovdqu32 -->
<intrinsic tech="AVX-512" rettype="void" name="_mm512_mask_storeu_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Store</category>
	<parameter varname="mem_addr" type="void*"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<description>Store packed 32-bit integers from "a" into memory using writemask "k".
	"mem_addr" does not need to be aligned on any particular boundary.
	</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		MEM[mem_addr+i+31:mem_addr+i] := a[i+31:i]
	FI
ENDFOR
	</description>
	<mnemonic base="vmovdqu32"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_loadu_epi32 / vmovdqu32 -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_loadu_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Load</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="mem_addr" type="void const*"/>
	<description>Load packed 32-bit integers from memory into "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).
	"mem_addr" does not need to be aligned on any particular boundary.
	</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := MEM[mem_addr+i+31:mem_addr+i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vmovdqu32"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_storeu_si512 / vmovdqu32 -->
<intrinsic tech="AVX-512" rettype="void" name="_mm512_storeu_si512">
	<CPUID>AVX-512</CPUID>
	<category>Store</category>
	<parameter varname="mem_addr" type="void*"/>
	<parameter varname="a" type="__m512i"/>
	<description>Store 512-bits of integer data from "a" into memory.
	"mem_addr" does not need to be aligned on any particular boundary.
	</description>
	<description code="true">
MEM[mem_addr+511:mem_addr] := a[511:0]
	</description>
	<mnemonic base="vmovdqu32"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_loadu_epi64 / vmovdqu64 -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_loadu_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Load</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="mem_addr" type="void const*"/>
	<description>Load packed 64-bit integers from memory into "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). 
	"mem_addr" does not need to be aligned on any particular boundary.
	</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := MEM[mem_addr+i+63:mem_addr+i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vmovdqu64"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_storeu_epi64 / vmovdqu64 -->
<intrinsic tech="AVX-512" rettype="void" name="_mm512_mask_storeu_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Store</category>
	<parameter varname="mem_addr" type="void*"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<description>Store packed 64-bit integers from "a" into memory using writemask "k".
	"mem_addr" does not need to be aligned on any particular boundary.
	</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		MEM[mem_addr+i+63:mem_addr+i] := a[i+63:i]
	FI
ENDFOR
	</description>
	<mnemonic base="vmovdqu64"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_loadu_epi64 / vmovdqu64 -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_loadu_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Load</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="mem_addr" type="void const*"/>
	<description>Load packed 64-bit integers from memory into "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).
	"mem_addr" does not need to be aligned on any particular boundary.
	</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := MEM[mem_addr+i+63:mem_addr+i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vmovdqu64"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_stream_load_si512 / vmovntdqa -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_stream_load_si512">
	<CPUID>AVX-512</CPUID>
	<category>Load</category>
	<parameter varname="mem_addr" type="void const*"/>
	<description>Load 512-bits of integer data from memory into "dst" using a non-temporal memory hint. 
	"mem_addr" must be aligned on a 64-byte boundary or a general-protection exception will be generated.</description>
	<description code="true">
dst[511:0] := MEM[mem_addr+511:mem_addr]
dst[MAX:512] := 0
	</description>
	<mnemonic base="vmovntdqa"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_stream_si512 / vmovntdqa -->
<intrinsic tech="AVX-512" rettype="void" name="_mm512_stream_si512">
	<CPUID>AVX-512</CPUID>
	<category>Store</category>
	<parameter varname="mem_addr" type="void*"/>
	<parameter varname="a" type="__m512i"/>
	<description>Store 512-bits of integer data from "a" into memory using a non-temporal memory hint. 
	"mem_addr" must be aligned on a 64-byte boundary or a general-protection exception will be generated.</description>
	<description code="true">
MEM[mem_addr+511:mem_addr] := a[511:0]
	</description>
	<mnemonic base="vmovntdqa"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_stream_pd / vmovntpd -->
<intrinsic tech="AVX-512" rettype="void" name="_mm512_stream_pd">
	<CPUID>AVX-512</CPUID>
	<category>Store</category>
	<parameter varname="mem_addr" type="void*"/>
	<parameter varname="a" type="__m512d"/>
	<description>Store 512-bits (composed of 8 packed double-precision (64-bit) floating-point elements) from "a" into memory using a non-temporal memory hint. 
	"mem_addr" must be aligned on a 64-byte boundary or a general-protection exception will be generated.</description>
	<description code="true">
MEM[mem_addr+511:mem_addr] := a[511:0]
	</description>
	<mnemonic base="vmovntpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_stream_ps / vmovntps -->
<intrinsic tech="AVX-512" rettype="void" name="_mm512_stream_ps">
	<CPUID>AVX-512</CPUID>
	<category>Store</category>
	<parameter varname="mem_addr" type="void*"/>
	<parameter varname="a" type="__m512"/>
	<description>Store 512-bits (composed of 16 packed single-precision (32-bit) floating-point elements) from "a" into memory using a non-temporal memory hint. 
	"mem_addr" must be aligned on a 64-byte boundary or a general-protection exception will be generated.</description>
	<description code="true">
MEM[mem_addr+511:mem_addr] := a[511:0]
	</description>
	<mnemonic base="vmovntps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_load_sd / vmovsd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_mask_load_sd">
	<CPUID>AVX-512</CPUID>
	<category>Load</category>
	<parameter varname="src" type="__m128d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="mem_addr" type="const double*"/>
	<description>Load a double-precision (64-bit) floating-point element from memory into the lower element of "dst" using writemask "k" (the element is copied from "src" when mask bit 0 is not set), and set the upper element of "dst" to zero. "mem_addr" must be aligned on a 16-byte boundary or a general-protection exception will be generated.</description>
	<description code="true">
IF k[0]
	dst[63:0] := MEM[mem_addr+63:mem_addr]
ELSE
	dst[63:0] := src[63:0]
FI
dst[MAX:64] := 0
	</description>
	<mnemonic base="vmovsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_move_sd / vmovsd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_mask_move_sd">
	<CPUID>AVX-512</CPUID>
	<category>Move</category>
	<parameter varname="src" type="__m128d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<description>Move the lower double-precision (64-bit) floating-point element from "b" to the lower element of "dst" using writemask "k" (the element is copied from "src" when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst".</description>
	<description code="true">
IF k[0]
	dst[63:0] := b[63:0]
ELSE
	dst[63:0] := src[63:0]
FI
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vmovsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_store_sd / vmovsd -->
<intrinsic tech="AVX-512" rettype="void" name="_mm_mask_store_sd">
	<CPUID>AVX-512</CPUID>
	<category>Store</category>
	<parameter varname="mem_addr" type="double*"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<description>Store the lower double-precision (64-bit) floating-point element from "a" into memory using writemask "k".
	"mem_addr" must be aligned on a 16-byte boundary or a general-protection exception will be generated.</description>
	<description code="true">
IF k[0]
	MEM[mem_addr+63:mem_addr] := a[63:0]
FI
	</description>
	<mnemonic base="vmovsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_load_sd / vmovsd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_maskz_load_sd">
	<CPUID>AVX-512</CPUID>
	<category>Load</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="mem_addr" type="const double*"/>
	<description>Load a double-precision (64-bit) floating-point element from memory into the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and set the upper element of "dst" to zero. "mem_addr" must be aligned on a 16-byte boundary or a general-protection exception will be generated.</description>
	<description code="true">
IF k[0]
	dst[63:0] := MEM[mem_addr+63:mem_addr]
ELSE
	dst[63:0] := 0
FI
dst[MAX:64] := 0
	</description>
	<mnemonic base="vmovsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_move_sd / vmovsd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_maskz_move_sd">
	<CPUID>AVX-512</CPUID>
	<category>Move</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<description>Move the lower double-precision (64-bit) floating-point element from "b" to the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst".</description>
	<description code="true">
IF k[0]
	dst[63:0] := b[63:0]
ELSE
	dst[63:0] := 0
FI
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vmovsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_movehdup_ps / vmovshdup -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_movehdup_ps">
	<CPUID>AVX-512</CPUID>
	<category>Move</category>
	<parameter varname="src" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<description>Duplicate odd-indexed single-precision (32-bit) floating-point elements from "a", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<description code="true">
tmp[31:0] := a[63:32] 
tmp[63:32] := a[63:32] 
tmp[95:64] := a[127:96] 
tmp[127:96] := a[127:96]
tmp[159:128] := a[191:160] 
tmp[191:160] := a[191:160] 
tmp[223:192] := a[255:224] 
tmp[255:224] := a[255:224]
tmp[287:256] := a[319:288] 
tmp[319:288] := a[319:288] 
tmp[351:320] := a[383:352] 
tmp[383:352] := a[383:352] 
tmp[415:384] := a[447:416] 
tmp[447:416] := a[447:416] 
tmp[479:448] := a[511:480]
tmp[511:480] := a[511:480]
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vmovshdup"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_movehdup_ps / vmovshdup -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_movehdup_ps">
	<CPUID>AVX-512</CPUID>
	<category>Move</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<description>Duplicate odd-indexed single-precision (32-bit) floating-point elements from "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
tmp[31:0] := a[63:32] 
tmp[63:32] := a[63:32] 
tmp[95:64] := a[127:96] 
tmp[127:96] := a[127:96]
tmp[159:128] := a[191:160] 
tmp[191:160] := a[191:160] 
tmp[223:192] := a[255:224] 
tmp[255:224] := a[255:224]
tmp[287:256] := a[319:288] 
tmp[319:288] := a[319:288] 
tmp[351:320] := a[383:352] 
tmp[383:352] := a[383:352] 
tmp[415:384] := a[447:416] 
tmp[447:416] := a[447:416] 
tmp[479:448] := a[511:480]
tmp[511:480] := a[511:480]
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vmovshdup"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_movehdup_ps / vmovshdup -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_movehdup_ps">
	<CPUID>AVX-512</CPUID>
	<category>Move</category>
	<parameter varname="a" type="__m512"/>
	<description>Duplicate odd-indexed single-precision (32-bit) floating-point elements from "a", and store the results in "dst".
	</description>
	<description code="true">
dst[31:0] := a[63:32] 
dst[63:32] := a[63:32] 
dst[95:64] := a[127:96] 
dst[127:96] := a[127:96]
dst[159:128] := a[191:160] 
dst[191:160] := a[191:160] 
dst[223:192] := a[255:224] 
dst[255:224] := a[255:224]
dst[287:256] := a[319:288] 
dst[319:288] := a[319:288] 
dst[351:320] := a[383:352] 
dst[383:352] := a[383:352] 
dst[415:384] := a[447:416] 
dst[447:416] := a[447:416] 
dst[479:448] := a[511:480]
dst[511:480] := a[511:480]
dst[MAX:512] := 0
	</description>
	<mnemonic base="vmovshdup"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_moveldup_ps / vmovsldup -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_moveldup_ps">
	<CPUID>AVX-512</CPUID>
	<category>Move</category>
	<parameter varname="src" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<description>Duplicate even-indexed single-precision (32-bit) floating-point elements from "a", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<description code="true">
tmp[31:0] := a[31:0] 
tmp[63:32] := a[31:0] 
tmp[95:64] := a[95:64] 
tmp[127:96] := a[95:64]
tmp[159:128] := a[159:128] 
tmp[191:160] := a[159:128] 
tmp[223:192] := a[223:192] 
tmp[255:224] := a[223:192]
tmp[287:256] := a[287:256] 
tmp[319:288] := a[287:256] 
tmp[351:320] := a[351:320] 
tmp[383:352] := a[351:320] 
tmp[415:384] := a[415:384] 
tmp[447:416] := a[415:384] 
tmp[479:448] := a[479:448]
tmp[511:480] := a[479:448]
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR	
dst[MAX:512] := 0
	</description>
	<mnemonic base="vmovsldup"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_moveldup_ps / vmovsldup -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_moveldup_ps">
	<CPUID>AVX-512</CPUID>
	<category>Move</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<description>Duplicate even-indexed single-precision (32-bit) floating-point elements from "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
tmp[31:0] := a[31:0] 
tmp[63:32] := a[31:0] 
tmp[95:64] := a[95:64] 
tmp[127:96] := a[95:64]
tmp[159:128] := a[159:128] 
tmp[191:160] := a[159:128] 
tmp[223:192] := a[223:192] 
tmp[255:224] := a[223:192]
tmp[287:256] := a[287:256] 
tmp[319:288] := a[287:256] 
tmp[351:320] := a[351:320] 
tmp[383:352] := a[351:320] 
tmp[415:384] := a[415:384] 
tmp[447:416] := a[415:384] 
tmp[479:448] := a[479:448]
tmp[511:480] := a[479:448]
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0	
	</description>
	<mnemonic base="vmovsldup"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_moveldup_ps / vmovsldup -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_moveldup_ps">
	<CPUID>AVX-512</CPUID>
	<category>Move</category>
	<parameter varname="a" type="__m512"/>
	<description>Duplicate even-indexed single-precision (32-bit) floating-point elements from "a", and store the results in "dst".
	</description>
	<description code="true">
dst[31:0] := a[31:0] 
dst[63:32] := a[31:0] 
dst[95:64] := a[95:64] 
dst[127:96] := a[95:64]
dst[159:128] := a[159:128] 
dst[191:160] := a[159:128] 
dst[223:192] := a[223:192] 
dst[255:224] := a[223:192]
dst[287:256] := a[287:256] 
dst[319:288] := a[287:256] 
dst[351:320] := a[351:320] 
dst[383:352] := a[351:320] 
dst[415:384] := a[415:384] 
dst[447:416] := a[415:384] 
dst[479:448] := a[479:448]
dst[511:480] := a[479:448]
dst[MAX:512] := 0
	</description>
	<mnemonic base="vmovsldup"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_load_ss / vmovss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_mask_load_ss">
	<CPUID>AVX-512</CPUID>
	<category>Load</category>
	<parameter varname="src" type="__m128"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="mem_addr" type="const float*"/>
	<description>Load a single-precision (32-bit) floating-point element from memory into the lower element of "dst" using writemask "k" (the element is copied from "src" when mask bit 0 is not set), and set the upper elements of "dst" to zero. "mem_addr" must be aligned on a 16-byte boundary or a general-protection exception will be generated.</description>
	<description code="true">
IF k[0]
	dst[31:0] := MEM[mem_addr+31:mem_addr]
ELSE
	dst[31:0] := src[31:0]
FI
dst[MAX:32] := 0
	</description>
	<mnemonic base="vmovss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_move_ss / vmovss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_mask_move_ss">
	<CPUID>AVX-512</CPUID>
	<category>Move</category>
	<parameter varname="src" type="__m128"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<description>Move the lower single-precision (32-bit) floating-point element from "b" to the lower element of "dst" using writemask "k" (the element is copied from "src" when mask bit 0 is not set), and copy the upper 3 packed elements from "a" to the upper elements of "dst".</description>
	<description code="true">
IF k[0]
	dst[31:0] := b[31:0]
ELSE
	dst[31:0] := src[31:0]
FI
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vmovss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_store_ss / vmovss -->
<intrinsic tech="AVX-512" rettype="void" name="_mm_mask_store_ss">
	<CPUID>AVX-512</CPUID>
	<category>Store</category>
	<parameter varname="mem_addr" type="float*"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<description>Store the lower single-precision (32-bit) floating-point element from "a" into memory using writemask "k".
	"mem_addr" must be aligned on a 16-byte boundary or a general-protection exception will be generated.</description>
	<description code="true">
IF k[0]
	MEM[mem_addr+31:mem_addr] := a[31:0]
FI
	</description>
	<mnemonic base="vmovss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_load_ss / vmovss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_maskz_load_ss">
	<CPUID>AVX-512</CPUID>
	<category>Load</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="mem_addr" type="const float*"/>
	<description>Load a single-precision (32-bit) floating-point element from memory into the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and set the upper elements of "dst" to zero. "mem_addr" must be aligned on a 16-byte boundary or a general-protection exception will be generated.</description>
	<description code="true">
IF k[0]
	dst[31:0] := MEM[mem_addr+31:mem_addr]
ELSE
	dst[31:0] := 0
FI
dst[MAX:32] := 0
	</description>
	<mnemonic base="vmovss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_move_ss / vmovss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_maskz_move_ss">
	<CPUID>AVX-512</CPUID>
	<category>Move</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<description>Move the lower single-precision (32-bit) floating-point element from "b" to the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from "a" to the upper elements of "dst".</description>
	<description code="true">
IF k[0]
	dst[31:0] := b[31:0]
ELSE
	dst[31:0] := 0
FI
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vmovss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_loadu_pd / vmovupd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_loadu_pd">
	<CPUID>AVX-512</CPUID>
	<category>Load</category>
	<parameter varname="mem_addr" type="void const*"/>
	<description>Load 512-bits (composed of 8 packed double-precision (64-bit) floating-point elements) from memory into "dst". 
	"mem_addr" does not need to be aligned on any particular boundary.</description>
	<description code="true">
dst[511:0] := MEM[mem_addr+511:mem_addr]
dst[MAX:512] := 0
	</description>
	<mnemonic base="vmovupd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_loadu_pd / vmovupd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_loadu_pd">
	<CPUID>AVX-512</CPUID>
	<category>Load</category>
	<parameter varname="src" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="mem_addr" type="void const*"/>
	<description>Load packed double-precision (64-bit) floating-point elements from memoy into "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).
	"mem_addr" does not need to be aligned on any particular boundary. </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := MEM[mem_addr+i+63:mem_addr+i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vmovupd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_storeu_pd / vmovupd -->
<intrinsic tech="AVX-512" rettype="void" name="_mm512_mask_storeu_pd">
	<CPUID>AVX-512</CPUID>
	<category>Store</category>
	<parameter varname="mem_addr" type="void*"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<description>Store packed double-precision (64-bit) floating-point elements from "a" into memory using writemask "k".
	"mem_addr" does not need to be aligned on any particular boundary.</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		MEM[mem_addr+i+63:mem_addr+i] := a[i+63:i]
	FI
ENDFOR
	</description>
	<mnemonic base="vmovupd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_loadu_pd / vmovupd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_loadu_pd">
	<CPUID>AVX-512</CPUID>
	<category>Load</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="mem_addr" type="void const*"/>
	<description>Load packed double-precision (64-bit) floating-point elements from memoy into "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).
	"mem_addr" does not need to be aligned on any particular boundary.
	</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := MEM[mem_addr+i+63:mem_addr+i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vmovupd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_storeu_pd / vmovupd -->
<intrinsic tech="AVX-512" rettype="void" name="_mm512_storeu_pd">
	<CPUID>AVX-512</CPUID>
	<category>Store</category>
	<parameter varname="mem_addr" type="void*"/>
	<parameter varname="a" type="__m512d"/>
	<description>Store 512-bits (composed of 8 packed double-precision (64-bit) floating-point elements) from "a" into memory. 
	"mem_addr" does not need to be aligned on any particular boundary.</description>
	<description code="true">
MEM[mem_addr+511:mem_addr] := a[511:0]
	</description>
	<mnemonic base="vmovupd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_loadu_ps / vmovups -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_loadu_ps">
	<CPUID>AVX-512</CPUID>
	<category>Load</category>
	<parameter varname="mem_addr" type="void const*"/>
	<description>Load 512-bits (composed of 16 packed single-precision (32-bit) floating-point elements) from memory into "dst". 
	"mem_addr" does not need to be aligned on any particular boundary.</description>
	<description code="true">
dst[511:0] := MEM[mem_addr+511:mem_addr]
dst[MAX:512] := 0
	</description>
	<mnemonic base="vmovups"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_loadu_ps / vmovups -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_loadu_ps">
	<CPUID>AVX-512</CPUID>
	<category>Load</category>
	<parameter varname="src" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="mem_addr" type="void const*"/>
	<description>Load packed single-precision (32-bit) floating-point elements from memory into "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).
	"mem_addr" does not need to be aligned on any particular boundary.
	</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := MEM[mem_addr+i+31:mem_addr+i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vmovups"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_storeu_ps / vmovups -->
<intrinsic tech="AVX-512" rettype="void" name="_mm512_mask_storeu_ps">
	<CPUID>AVX-512</CPUID>
	<category>Store</category>
	<parameter varname="mem_addr" type="void*"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<description>Store packed single-precision (32-bit) floating-point elements from "a" into memory using writemask "k".
	"mem_addr" does not need to be aligned on any particular boundary.
	</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		MEM[mem_addr+i+31:mem_addr+i] := a[i+31:i]
	FI
ENDFOR
	</description>
	<mnemonic base="vmovups"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_loadu_ps / vmovups -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_loadu_ps">
	<CPUID>AVX-512</CPUID>
	<category>Load</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="mem_addr" type="void const*"/>
	<description>Load packed single-precision (32-bit) floating-point elements from memory into "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).
	"mem_addr" does not need to be aligned on any particular boundary.
	</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := MEM[mem_addr+i+31:mem_addr+i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vmovups"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_storeu_ps / vmovups -->
<intrinsic tech="AVX-512" rettype="void" name="_mm512_storeu_ps">
	<CPUID>AVX-512</CPUID>
	<category>Store</category>
	<parameter varname="mem_addr" type="void*"/>
	<parameter varname="a" type="__m512"/>
	<description>Store 512-bits (composed of 16 packed single-precision (32-bit) floating-point elements) from "a" into memory. 
	"mem_addr" does not need to be aligned on any particular boundary.</description>
	<description code="true">
MEM[mem_addr+511:mem_addr] := a[511:0]
	</description>
	<mnemonic base="vmovups"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_mul_pd / vmulpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_mul_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="src" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<description>Multiply packed double-precision (64-bit) floating-point elements in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).  RM.</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] * b[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vmulpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_mul_round_pd / vmulpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_mul_round_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="src" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="rounding" type="int"/>
	<description>Multiply packed double-precision (64-bit) floating-point elements in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).  
	[round_note]</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] * b[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vmulpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_mul_pd / vmulpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_mul_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<description>Multiply packed double-precision (64-bit) floating-point elements in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] * b[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vmulpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_mul_round_pd / vmulpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_mul_round_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="rounding" type="int"/>
	<description>Multiply packed double-precision (64-bit) floating-point elements in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). 
	[round_note]</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] * b[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vmulpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mul_pd / vmulpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mul_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<description>Multiply packed double-precision (64-bit) floating-point elements in "a" and "b", and store the results in "dst".
	</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := a[i+63:i] * b[i+63:i]
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vmulpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mul_round_pd / vmulpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mul_round_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="rounding" type="int"/>
	<description>Multiply packed double-precision (64-bit) floating-point elements in "a" and "b", and store the results in "dst". 
	[round_note]
	 </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := a[i+63:i] * b[i+63:i]
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vmulpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_mul_ps / vmulps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_mul_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="src" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<description>Multiply packed single-precision (32-bit) floating-point elements in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).  RM.</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i] * b[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vmulps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_mul_round_ps / vmulps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_mul_round_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="src" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="rounding" type="int"/>
	<description>Multiply packed single-precision (32-bit) floating-point elements in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).
	 [round_note]</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i] * b[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vmulps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_mul_ps / vmulps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_mul_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<description>Multiply packed single-precision (32-bit) floating-point elements in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i] * b[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vmulps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_mul_round_ps / vmulps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_mul_round_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="rounding" type="int"/>
	<description>Multiply packed single-precision (32-bit) floating-point elements in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). 
	[round_note]</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i] * b[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vmulps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mul_ps / vmulps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mul_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<description>Multiply packed single-precision (32-bit) floating-point elements in "a" and "b", and store the results in "dst".
	</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := a[i+31:i] * b[i+31:i]
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vmulps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mul_round_ps / vmulps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mul_round_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="rounding" type="int"/>
	<description>Multiply packed single-precision (32-bit) floating-point elements in "a" and "b", and store the results in "dst". 
	[round_note]
	 </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := a[i+31:i] * b[i+31:i]
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vmulps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_mul_round_sd / vmulsd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_mask_mul_round_sd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="src" type="__m128d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="rounding" type="int"/>
	<description>Multiply the lower double-precision (64-bit) floating-point element in "a" and "b", store the result in the lower element of "dst" using writemask "k" (the element is copied from "src" when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst".
		[round_note]
		</description>
	<description code="true">
IF k[0]
	dst[63:0] := a[63:0] * b[63:0]
ELSE
	dst[63:0] := src[63:0]
FI
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vmulsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_mul_sd / vmulsd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_mask_mul_sd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="src" type="__m128d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<description>Multiply the lower double-precision (64-bit) floating-point element in "a" and "b", store the result in the lower element of "dst" using writemask "k" (the element is copied from "src" when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst".</description>
	<description code="true">
IF k[0]
	dst[63:0] := a[63:0] * b[63:0]
ELSE
	dst[63:0] := src[63:0]
FI
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vmulsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_mul_round_sd / vmulsd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_maskz_mul_round_sd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="rounding" type="int"/>
	<description>Multiply the lower double-precision (64-bit) floating-point element in "a" and "b", store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst".
		[round_note]
		</description>
	<description code="true">
IF k[0]
	dst[63:0] := a[63:0] * b[63:0]
ELSE
	dst[63:0] := 0
FI
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vmulsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_mul_sd / vmulsd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_maskz_mul_sd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<description>Multiply the lower double-precision (64-bit) floating-point element in "a" and "b", store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst".</description>
	<description code="true">
IF k[0]
	dst[63:0] := a[63:0] * b[63:0]
ELSE
	dst[63:0] := 0
FI
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vmulsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mul_round_sd / vmulsd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_mul_round_sd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="rounding" type="int"/>
	<description>Multiply the lower double-precision (64-bit) floating-point element in "a" and "b", store the result in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst".
		[round_note]
		</description>
	<description code="true">
dst[63:0] := a[63:0] * b[63:0]
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vmulsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_mul_round_ss / vmulss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_mask_mul_round_ss">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="src" type="__m128"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="rounding" type="int"/>
	<description>Multiply the lower single-precision (32-bit) floating-point element in "a" and "b", store the result in the lower element of "dst" using writemask "k" (the element is copied from "src" when mask bit 0 is not set), and copy the upper 3 packed elements from "a" to the upper elements of "dst".
		[round_note]
		</description>
	<description code="true">
IF k[0]
	dst[31:0] := a[31:0] * b[31:0]
ELSE
	dst[31:0] := src[31:0]
FI
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vmulss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_mul_ss / vmulss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_mask_mul_ss">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="src" type="__m128"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<description>Multiply the lower single-precision (32-bit) floating-point element in "a" and "b", store the result in the lower element of "dst" using writemask "k" (the element is copied from "src" when mask bit 0 is not set), and copy the upper 3 packed elements from "a" to the upper elements of "dst".</description>
	<description code="true">
IF k[0]
	dst[31:0] := a[31:0] * b[31:0]
ELSE
	dst[31:0] := src[31:0]
FI
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vmulss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_mul_round_ss / vmulss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_maskz_mul_round_ss">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="rounding" type="int"/>
	<description>Multiply the lower single-precision (32-bit) floating-point element in "a" and "b", store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from "a" to the upper elements of "dst".
		[round_note]
		</description>
	<description code="true">
IF k[0]
	dst[31:0] := a[31:0] * b[31:0]
ELSE
	dst[31:0] := 0
FI
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vmulss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_mul_ss / vmulss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_maskz_mul_ss">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<description>Multiply the lower single-precision (32-bit) floating-point element in "a" and "b", store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from "a" to the upper elements of "dst".</description>
	<description code="true">
IF k[0]
	dst[31:0] := a[31:0] * b[31:0]
ELSE
	dst[31:0] := 0
FI
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vmulss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mul_round_ss / vmulss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_mul_round_ss">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="rounding" type="int"/>
	<description>Multiply the lower single-precision (32-bit) floating-point element in "a" and "b", store the result in the lower element of "dst", and copy the upper 3 packed elements from "a" to the upper elements of "dst".
		[round_note]
		</description>
	<description code="true">
dst[31:0] := a[31:0] * b[31:0]
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vmulss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_abs_epi32 / vpabsd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_abs_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="a" type="__m512i"/>
	<description>Compute the absolute value of packed 32-bit integers in "a", and store the unsigned results in "dst". </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := ABS(a[i+31:i])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpabsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_abs_epi32 / vpabsd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_abs_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<description>Compute the absolute value of packed 32-bit integers in "a", and store the unsigned results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := ABS(a[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>	
	<mnemonic base="vpabsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_abs_epi32 / vpabsd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_abs_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<description>Compute the absolute value of packed 32-bit integers in "a", and store the unsigned results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := ABS(a[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpabsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_abs_epi64 / vpabsq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_abs_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="a" type="__m512i"/>
	<description>Compute the absolute value of packed 64-bit integers in "a", and store the unsigned results in "dst". </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := ABS(a[i+63:i])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpabsq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_abs_epi64 / vpabsq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_abs_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<description>Compute the absolute value of packed 64-bit integers in "a", and store the unsigned results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := ABS(a[i+63:i])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpabsq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_abs_epi64 / vpabsq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_abs_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<description>Compute the absolute value of packed 64-bit integers in "a", and store the unsigned results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := ABS(a[i+63:i])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpabsq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_add_epi32 / vpaddd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_add_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Add packed 32-bit integers in "a" and "b", and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := a[i+31:i] + b[i+31:i]
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpaddd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_add_epi32 / vpaddd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_add_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Add packed 32-bit integers in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i] + b[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpaddd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_add_epi32 / vpaddd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_add_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Add packed 32-bit integers in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i] + b[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpaddd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_add_epi64 / vpaddq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_add_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Add packed 64-bit integers in "a" and "b", and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := a[i+63:i] + b[i+63:i]
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpaddq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_add_epi64 / vpaddq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_add_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Add packed 64-bit integers in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] + b[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpaddq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_add_epi64 / vpaddq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_add_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Add packed 64-bit integers in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] + b[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpaddq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_and_epi32 / vpandd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_and_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Logical</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compute the bitwise AND of packed 32-bit integers in "a" and "b", and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := a[i+31:i] BITWISE AND b[i+31:i]
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpandd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_and_si512 / vpandd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_and_si512">
	<CPUID>AVX-512</CPUID>
	<category>Logical</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compute the bitwise AND of 512 bits (representing integer data) in "a" and "b", and store the result in "dst".</description>
	<description code="true">
dst[511:0] := (a[511:0] AND b[511:0])
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpandd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_and_epi32 / vpandd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_and_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Logical</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compute the bitwise AND of packed 32-bit integers in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i] AND b[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpandd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_andnot_epi32 / vpandnd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_andnot_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Logical</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compute the bitwise AND NOT of packed 32-bit integers in "a" and "b", and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := (NOT a[i+31:i]) AND b[i+31:i]
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpandnd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_andnot_si512 / vpandnd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_andnot_si512">
	<CPUID>AVX-512</CPUID>
	<category>Logical</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compute the bitwise AND NOT of 512 bits (representing integer data) in "a" and "b", and store the result in "dst".</description>
	<description code="true">
dst[511:0] := ((NOT a[511:0]) AND b[511:0])
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpandnd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_andnot_epi32 / vpandnd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_andnot_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Logical</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compute the bitwise AND NOT of packed 32-bit integers in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := ((NOT a[i+31:i]) AND b[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpandnd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_andnot_epi32 / vpandnd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_andnot_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Logical</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compute the bitwise AND NOT of packed 32-bit integers in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := (NOT a[i+31:i]) AND b[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpandnd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_andnot_epi64 / vpandnq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_andnot_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Logical</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compute the bitwise AND NOT of 512 bits (composed of packed 64-bit integers) in "a" and "b", and store the results in "dst".</description>
	<description code="true">
dst[511:0] := ((NOT a[511:0]) AND b[511:0])
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpandnq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_andnot_epi64 / vpandnq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_andnot_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Logical</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compute the bitwise AND NOT of packed 64-bit integers in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := ((NOT a[i+63:i]) AND b[i+63:i])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpandnq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_andnot_epi64 / vpandnq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_andnot_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Logical</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compute the bitwise AND NOT of packed 64-bit integers in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := (NOT a[i+63:i]) AND b[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpandnq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_and_epi64 / vpandq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_and_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Logical</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compute the bitwise AND of 512 bits (composed of packed 64-bit integers) in "a" and "b", and store the results in "dst".</description>
	<description code="true">
dst[511:0] := (a[511:0] AND b[511:0])
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpandq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_and_epi64 / vpandq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_and_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Logical</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compute the bitwise AND of packed 64-bit integers in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] AND b[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpandq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_and_epi64 / vpandq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_and_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Logical</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compute the bitwise AND of packed 64-bit integers in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] AND b[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpandq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_blend_epi32 / vpblendmd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_blend_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Blend packed 32-bit integers from "a" and "b" using control mask "k", and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := b[i+31:i]
	ELSE
		dst[i+31:i] := a[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpblendmd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_blend_epi64 / vpblendmq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_blend_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Blend packed 64-bit integers from "a" and "b" using control mask "k", and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := b[i+63:i]
	ELSE
		dst[i+63:i] := a[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpblendmq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_set1_epi8 / vpbroadcastb -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_set1_epi8">
	<CPUID>AVX-512</CPUID>
	<category>Set</category>
	<parameter varname="a" type="char"/>
	<description>Broadcast 8-bit integer "a" to all elements of "dst".</description>
	<description code="true">
FOR j := 0 to 63
	i := j*8
	dst[i+7:i] := a[7:0]
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpbroadcastb"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_broadcastd_epi32 / vpbroadcastd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_broadcastd_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="a" type="__m128i"/>
	<description>Broadcast the low packed 32-bit integer from "a" to all elements of "dst".</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := a[31:0]
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpbroadcastd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_broadcastd_epi32 / vpbroadcastd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_broadcastd_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m128i"/>
	<description>Broadcast the low packed 32-bit integer from "a" to all elements of "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := a[31:0]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpbroadcastd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_set1_epi32 / vpbroadcastd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_set1_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Set</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="int"/>
	<description>Broadcast 32-bit integer "a" to all elements of "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := a[31:0]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpbroadcastd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_broadcastd_epi32 / vpbroadcastd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_broadcastd_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m128i"/>
	<description>Broadcast the low packed 32-bit integer from "a" to all elements of "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := a[31:0]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpbroadcastd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_set1_epi32 / vpbroadcastd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_set1_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Set</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="int"/>
	<description>Broadcast 32-bit integer "a" to all elements of "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := a[31:0]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpbroadcastd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_set1_epi32 / vpbroadcastd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_set1_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Set</category>
	<parameter varname="a" type="int"/>
	<description>Broadcast 32-bit integer "a" to all elements of "dst".</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := a[31:0]
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpbroadcastd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_broadcastmb_epi64 / vpbroadcastmb2q -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_broadcastmb_epi64">
	<CPUID>AVX-512.CDI</CPUID>
	<category>Swizzle</category>
	<parameter varname="k" type="__mmask8"/>
	<description>Broadcst the low 8-bits from input mask "k" to all 64-bit elements of "dst".</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := ZeroExtend(k[7:0])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpbroadcastmb2q"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_broadcastmw_epi32 / vpbroadcastmd2w -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_broadcastmw_epi32">
	<CPUID>AVX-512.CDI</CPUID>
	<category>Swizzle</category>
	<parameter varname="k" type="__mmask16"/>
	<description>Broadcst the low 16-bits from input mask "k" to all 32-bit elements of "dst".</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := ZeroExtend(k[15:0])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpbroadcastmd2w"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_broadcastq_epi64 / vpbroadcastq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_broadcastq_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="a" type="__m128i"/>
	<description>Broadcast the low packed 64-bit integer from "a" to all elements of "dst". </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := a[63:0]
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpbroadcastq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_broadcastq_epi64 / vpbroadcastq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_broadcastq_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128i"/>
	<description>Broadcast the low packed 64-bit integer from "a" to all elements of "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[63:0]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpbroadcastq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_set1_epi64 / vpbroadcastq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_set1_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Set</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__int64"/>
	<description>Broadcast 64-bit integer "a" to all elements of "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[63:0]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpbroadcastq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_broadcastq_epi64 / vpbroadcastq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_broadcastq_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128i"/>
	<description>Broadcast the low packed 64-bit integer from "a" to all elements of "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[63:0]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpbroadcastq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_set1_epi64 / vpbroadcastq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_set1_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Set</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__int64"/>
	<description>Broadcast 64-bit integer "a" to all elements of "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[63:0]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpbroadcastq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_set1_epi64 / vpbroadcastq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_set1_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Set</category>
	<parameter varname="a" type="__int64"/>
	<description>Broadcast 64-bit integer "a" to all elements of "dst".</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := a[63:0]
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpbroadcastq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_set1_epi16 / vpbroadcastw -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_set1_epi16">
	<CPUID>AVX-512</CPUID>
	<category>Set</category>
	<parameter varname="a" type="short"/>
	<description>Broadcast 16-bit integer "a" to all all elements of "dst".
	</description>
	<description code="true">
FOR j := 0 to 31
	i := j*16
	dst[i+15:i] := a[15:0]
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpbroadcastw"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cmp_epi32_mask / vpcmpd -->
<intrinsic tech="AVX-512" rettype="__mmask16" name="_mm512_cmp_epi32_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<parameter varname="imm" type="const _MM_CMPINT_ENUM"/>
	<description>Compare packed 32-bit integers in "a" and "b" based on the comparison operand specified by "imm", and store the results in mask vector "k".</description>
	<description code="true">
CASE(imm) of
  0: OP := _MM_CMPINT_EQ
  1: OP := _MM_CMPINT_LT
  2: OP := _MM_CMPINT_LE
  3: OP := _MM_CMPINT_FALSE
  4: OP := _MM_CMPINT_NEQ
  5: OP := _MM_CMPINT_NLT
  6: OP := _MM_CMPINT_NLE
  7: OP := _MM_CMPINT_TRUE
ESAC
FOR j := 0 to 15
	i := j*32
	k[j] := ( a[i+31:i] OP b[i+31:i] ) ? 1 : 0
ENDFOR
k[MAX:16] := 0
	</description>
	<mnemonic base="vpcmpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cmpeq_epi32_mask / vpcmpd -->
<intrinsic tech="AVX-512" rettype="__mmask16" name="_mm512_cmpeq_epi32_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed 32-bit integers in "a" and "b" for equality, and store the results in mask vector "k".</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	k[j] := ( a[i+31:i] == b[i+31:i] ) ? 1 : 0
ENDFOR
k[MAX:16] := 0
	</description>
	<mnemonic base="vpcmpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cmpge_epi32_mask / vpcmpd -->
<intrinsic tech="AVX-512" rettype="__mmask16" name="_mm512_cmpge_epi32_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed 32-bit integers in "a" and "b" for greater-than-or-equal, and store the results in mask vector "k".</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	k[j] := ( a[i+31:i] &gt;= b[i+31:i] ) ? 1 : 0
ENDFOR
k[MAX:16] := 0
	</description>
	<mnemonic base="vpcmpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cmpgt_epi32_mask / vpcmpd -->
<intrinsic tech="AVX-512" rettype="__mmask16" name="_mm512_cmpgt_epi32_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed 32-bit integers in "a" and "b" for greater-than, and store the results in mask vector "k".</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	k[j] := ( a[i+31:i] &gt; b[i+31:i] ) ? 1 : 0
ENDFOR
k[MAX:16] := 0
	</description>
	<mnemonic base="vpcmpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cmple_epi32_mask / vpcmpd -->
<intrinsic tech="AVX-512" rettype="__mmask16" name="_mm512_cmple_epi32_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed 32-bit integers in "a" and "b" for less-than-or-equal, and store the results in mask vector "k".</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	k[j] := ( a[i+31:i] &lt;= b[i+31:i] ) ? 1 : 0
ENDFOR
k[MAX:16] := 0
	</description>
	<mnemonic base="vpcmpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cmplt_epi32_mask / vpcmpd -->
<intrinsic tech="AVX-512" rettype="__mmask16" name="_mm512_cmplt_epi32_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed 32-bit integers in "a" and "b" for less-than, and store the results in mask vector "k".</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	k[j] := ( a[i+31:i] &lt; b[i+31:i] ) ? 1 : 0
ENDFOR
k[MAX:16] := 0
	</description>
	<mnemonic base="vpcmpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cmpneq_epi32_mask / vpcmpd -->
<intrinsic tech="AVX-512" rettype="__mmask16" name="_mm512_cmpneq_epi32_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed 32-bit integers in "a" and "b" for not-equal, and store the results in mask vector "k".</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	k[j] := ( a[i+31:i] != b[i+31:i] ) ? 1 : 0
ENDFOR
k[MAX:16] := 0
	</description>
	<mnemonic base="vpcmpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cmp_epi32_mask / vpcmpd -->
<intrinsic tech="AVX-512" rettype="__mmask16" name="_mm512_mask_cmp_epi32_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="k1" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<parameter varname="imm" type="const _MM_CMPINT_ENUM"/>
	<description>Compare packed 32-bit integers in "a" and "b" based on the comparison operand specified by "imm", and store the results in mask vector "k1" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
CASE(imm) of
  0: OP := _MM_CMPINT_EQ
  1: OP := _MM_CMPINT_LT
  2: OP := _MM_CMPINT_LE
  3: OP := _MM_CMPINT_FALSE
  4: OP := _MM_CMPINT_NEQ
  5: OP := _MM_CMPINT_NLT
  6: OP := _MM_CMPINT_NLE
  7: OP := _MM_CMPINT_TRUE
ESAC
FOR j := 0 to 15
	i := j*32
	IF k1[j]
		k[j] := ( a[i+31:i] OP b[i+31:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:16] := 0
	</description>
	<mnemonic base="vpcmpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cmpeq_epi32_mask / vpcmpd -->
<intrinsic tech="AVX-512" rettype="__mmask16" name="_mm512_mask_cmpeq_epi32_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="k1" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed 32-bit integers in "a" and "b" for equality, and store the results in mask vector "k1" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k1[j]
		k[j] := ( a[i+31:i] == b[i+31:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:16] := 0
	</description>
	<mnemonic base="vpcmpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cmpge_epi32_mask / vpcmpd -->
<intrinsic tech="AVX-512" rettype="__mmask16" name="_mm512_mask_cmpge_epi32_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="k1" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed 32-bit integers in "a" and "b" for greater-than-or-equal, and store the results in mask vector "k1" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k1[j]
		k[j] := ( a[i+31:i] &gt;= b[i+31:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:16] := 0
	</description>
	<mnemonic base="vpcmpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cmpgt_epi32_mask / vpcmpd -->
<intrinsic tech="AVX-512" rettype="__mmask16" name="_mm512_mask_cmpgt_epi32_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="k1" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed 32-bit integers in "a" and "b" for greater-than, and store the results in mask vector "k1" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k1[j]
		k[j] := ( a[i+31:i] &gt; b[i+31:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:16] := 0
	</description>
	<mnemonic base="vpcmpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cmple_epi32_mask / vpcmpd -->
<intrinsic tech="AVX-512" rettype="__mmask16" name="_mm512_mask_cmple_epi32_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="k1" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed 32-bit integers in "a" and "b" for less-than, and store the results in mask vector "k1" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k1[j]
		k[j] := ( a[i+31:i] &lt; b[i+31:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:16] := 0
	</description>
	<mnemonic base="vpcmpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cmplt_epi32_mask / vpcmpd -->
<intrinsic tech="AVX-512" rettype="__mmask16" name="_mm512_mask_cmplt_epi32_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="k1" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed 32-bit integers in "a" and "b" for less-than-or-equal, and store the results in mask vector "k1" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k1[j]
		k[j] := ( a[i+31:i] &lt;= b[i+31:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:16] := 0
	</description>
	<mnemonic base="vpcmpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cmpneq_epi32_mask / vpcmpd -->
<intrinsic tech="AVX-512" rettype="__mmask16" name="_mm512_mask_cmpneq_epi32_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="k1" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed 32-bit integers in "a" and "b" for not-equal, and store the results in mask vector "k1" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k1[j]
		k[j] := ( a[i+31:i] != b[i+31:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:16] := 0
	</description>
	<mnemonic base="vpcmpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cmp_epi64_mask / vpcmpq -->
<intrinsic tech="AVX-512" rettype="__mmask8" name="_mm512_cmp_epi64_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<parameter varname="imm" type="const _MM_CMPINT_ENUM"/>
	<description>Compare packed 64-bit integers in "a" and "b" based on the comparison operand specified by "imm", and store the results in mask vector "k".</description>
	<description code="true">
CASE(imm) of
  0: OP := _MM_CMPINT_EQ
  1: OP := _MM_CMPINT_LT
  2: OP := _MM_CMPINT_LE
  3: OP := _MM_CMPINT_FALSE
  4: OP := _MM_CMPINT_NEQ
  5: OP := _MM_CMPINT_NLT
  6: OP := _MM_CMPINT_NLE
  7: OP := _MM_CMPINT_TRUE
ESAC
FOR j := 0 to 7
	i := j*64
	k[j] := ( a[i+63:i] OP b[i+63:i] ) ? 1 : 0
ENDFOR
k[MAX:8] := 0
	</description>
	<mnemonic base="vpcmpq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cmpeq_epi64_mask / vpcmpq -->
<intrinsic tech="AVX-512" rettype="__mmask8" name="_mm512_cmpeq_epi64_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed 64-bit integers in "a" and "b" for equality, and store the results in mask vector "k".</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	k[j] := ( a[i+63:i] == b[i+63:i] ) ? 1 : 0
ENDFOR
k[MAX:8] := 0
	</description>
	<mnemonic base="vpcmpq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cmpge_epi64_mask / vpcmpq -->
<intrinsic tech="AVX-512" rettype="__mmask8" name="_mm512_cmpge_epi64_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed 64-bit integers in "a" and "b" for greater-than-or-equal, and store the results in mask vector "k".</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	k[j] := ( a[i+63:i] &gt;= b[i+63:i] ) ? 1 : 0
ENDFOR
k[MAX:8] := 0
	</description>
	<mnemonic base="vpcmpq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cmpgt_epi64_mask / vpcmpq -->
<intrinsic tech="AVX-512" rettype="__mmask8" name="_mm512_cmpgt_epi64_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed 64-bit integers in "a" and "b" for greater-than, and store the results in mask vector "k".</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	k[j] := ( a[i+63:i] &gt; b[i+63:i] ) ? 1 : 0
ENDFOR
k[MAX:8] := 0
	</description>
	<mnemonic base="vpcmpq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cmple_epi64_mask / vpcmpq -->
<intrinsic tech="AVX-512" rettype="__mmask8" name="_mm512_cmple_epi64_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed 64-bit integers in "a" and "b" for less-than-or-equal, and store the results in mask vector "k".</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	k[j] := ( a[i+63:i] &lt;= b[i+63:i] ) ? 1 : 0
ENDFOR
k[MAX:8] := 0
	</description>
	<mnemonic base="vpcmpq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cmplt_epi64_mask / vpcmpq -->
<intrinsic tech="AVX-512" rettype="__mmask8" name="_mm512_cmplt_epi64_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed 64-bit integers in "a" and "b" for less-than, and store the results in mask vector "k".</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	k[j] := ( a[i+63:i] &lt; b[i+63:i] ) ? 1 : 0
ENDFOR
k[MAX:8] := 0
	</description>
	<mnemonic base="vpcmpq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cmpneq_epi64_mask / vpcmpq -->
<intrinsic tech="AVX-512" rettype="__mmask8" name="_mm512_cmpneq_epi64_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed 64-bit integers in "a" and "b" for not-equal, and store the results in mask vector "k".</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	k[j] := ( a[i+63:i] != b[i+63:i] ) ? 1 : 0
ENDFOR
k[MAX:8] := 0
	</description>
	<mnemonic base="vpcmpq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cmp_epi64_mask / vpcmpq -->
<intrinsic tech="AVX-512" rettype="__mmask8" name="_mm512_mask_cmp_epi64_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="k1" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<parameter varname="imm" type="const _MM_CMPINT_ENUM"/>
	<description>Compare packed 64-bit integers in "a" and "b" based on the comparison operand specified by "imm", and store the results in mask vector "k1" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
CASE(imm) of
  0: OP := _MM_CMPINT_EQ
  1: OP := _MM_CMPINT_LT
  2: OP := _MM_CMPINT_LE
  3: OP := _MM_CMPINT_FALSE
  4: OP := _MM_CMPINT_NEQ
  5: OP := _MM_CMPINT_NLT
  6: OP := _MM_CMPINT_NLE
  7: OP := _MM_CMPINT_TRUE
ESAC
FOR j := 0 to 7
	i := j*64
	IF k1[j]
		k[j] := ( a[i+63:i] OP b[i+63:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</description>
	<mnemonic base="vpcmpq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cmpeq_epi64_mask / vpcmpq -->
<intrinsic tech="AVX-512" rettype="__mmask8" name="_mm512_mask_cmpeq_epi64_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="k1" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed 64-bit integers in "a" and "b" for equality, and store the results in mask vector "k1" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k1[j]
		k[j] := ( a[i+63:i] == b[i+63:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</description>
	<mnemonic base="vpcmpq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cmpge_epi64_mask / vpcmpq -->
<intrinsic tech="AVX-512" rettype="__mmask8" name="_mm512_mask_cmpge_epi64_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="k1" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed 64-bit integers in "a" and "b" for greater-than-or-equal, and store the results in mask vector "k1" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k1[j]
		k[j] := ( a[i+63:i] &gt;= b[i+63:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</description>
	<mnemonic base="vpcmpq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cmpgt_epi64_mask / vpcmpq -->
<intrinsic tech="AVX-512" rettype="__mmask8" name="_mm512_mask_cmpgt_epi64_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="k1" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed 64-bit integers in "a" and "b" for greater-than, and store the results in mask vector "k1" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k1[j]
		k[j] := ( a[i+63:i] &gt; b[i+63:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</description>
	<mnemonic base="vpcmpq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cmple_epi64_mask / vpcmpq -->
<intrinsic tech="AVX-512" rettype="__mmask8" name="_mm512_mask_cmple_epi64_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="k1" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed 64-bit integers in "a" and "b" for less-than-or-equal, and store the results in mask vector "k1" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k1[j]
		k[j] := ( a[i+63:i] &lt;= b[i+63:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</description>
	<mnemonic base="vpcmpq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cmplt_epi64_mask / vpcmpq -->
<intrinsic tech="AVX-512" rettype="__mmask8" name="_mm512_mask_cmplt_epi64_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="k1" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed 64-bit integers in "a" and "b" for less-than, and store the results in mask vector "k1" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k1[j]
		k[j] := ( a[i+63:i] &lt; b[i+63:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</description>
	<mnemonic base="vpcmpq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cmpneq_epi64_mask / vpcmpq -->
<intrinsic tech="AVX-512" rettype="__mmask8" name="_mm512_mask_cmpneq_epi64_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="k1" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed 64-bit integers in "a" and "b" for not-equal, and store the results in mask vector "k1" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k1[j]
		k[j] := ( a[i+63:i] != b[i+63:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</description>
	<mnemonic base="vpcmpq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cmp_epu32_mask / vpcmpud -->
<intrinsic tech="AVX-512" rettype="__mmask16" name="_mm512_cmp_epu32_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<parameter varname="imm" type="const _MM_CMPINT_ENUM"/>
	<description>Compare packed unsigned 32-bit integers in "a" and "b" based on the comparison operand specified by "imm", and store the results in mask vector "k".</description>
	<description code="true">
CASE(imm) of
  0: OP := _MM_CMPINT_EQ
  1: OP := _MM_CMPINT_LT
  2: OP := _MM_CMPINT_LE
  3: OP := _MM_CMPINT_FALSE
  4: OP := _MM_CMPINT_NEQ
  5: OP := _MM_CMPINT_NLT
  6: OP := _MM_CMPINT_NLE
  7: OP := _MM_CMPINT_TRUE
ESAC
FOR j := 0 to 15
	i := j*32
	k[j] := ( a[i+31:i] OP b[i+31:i] ) ? 1 : 0
ENDFOR
k[MAX:16] := 0
	</description>
	<mnemonic base="vpcmpud"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cmpeq_epu32_mask / vpcmpud -->
<intrinsic tech="AVX-512" rettype="__mmask16" name="_mm512_cmpeq_epu32_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed unsigned 32-bit integers in "a" and "b" for equality, and store the results in mask vector "k".</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	k[j] := ( a[i+31:i] == b[i+31:i] ) ? 1 : 0
ENDFOR
k[MAX:16] := 0
	</description>
	<mnemonic base="vpcmpud"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cmpge_epu32_mask / vpcmpud -->
<intrinsic tech="AVX-512" rettype="__mmask16" name="_mm512_cmpge_epu32_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed unsigned 32-bit integers in "a" and "b" for greater-than-or-equal, and store the results in mask vector "k".</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	k[j] := ( a[i+31:i] &gt;= b[i+31:i] ) ? 1 : 0
ENDFOR
k[MAX:16] := 0
	</description>
	<mnemonic base="vpcmpud"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cmpgt_epu32_mask / vpcmpud -->
<intrinsic tech="AVX-512" rettype="__mmask16" name="_mm512_cmpgt_epu32_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed unsigned 32-bit integers in "a" and "b" for greater-than, and store the results in mask vector "k".</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	k[j] := ( a[i+31:i] &gt; b[i+31:i] ) ? 1 : 0
ENDFOR
k[MAX:16] := 0
	</description>
	<mnemonic base="vpcmpud"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cmple_epu32_mask / vpcmpud -->
<intrinsic tech="AVX-512" rettype="__mmask16" name="_mm512_cmple_epu32_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed unsigned 32-bit integers in "a" and "b" for less-than-or-equal, and store the results in mask vector "k".</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	k[j] := ( a[i+31:i] &lt;= b[i+31:i] ) ? 1 : 0
ENDFOR
k[MAX:16] := 0
	</description>
	<mnemonic base="vpcmpud"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cmplt_epu32_mask / vpcmpud -->
<intrinsic tech="AVX-512" rettype="__mmask16" name="_mm512_cmplt_epu32_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed unsigned 32-bit integers in "a" and "b" for less-than, and store the results in mask vector "k".</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	k[j] := ( a[i+31:i] &lt; b[i+31:i] ) ? 1 : 0
ENDFOR
k[MAX:16] := 0
	</description>
	<mnemonic base="vpcmpud"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cmpneq_epu32_mask / vpcmpud -->
<intrinsic tech="AVX-512" rettype="__mmask16" name="_mm512_cmpneq_epu32_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed unsigned 32-bit integers in "a" and "b" for not-equal, and store the results in mask vector "k".</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	k[j] := ( a[i+31:i] != b[i+31:i] ) ? 1 : 0
ENDFOR
k[MAX:16] := 0
	</description>
	<mnemonic base="vpcmpud"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cmp_epu32_mask / vpcmpud -->
<intrinsic tech="AVX-512" rettype="__mmask16" name="_mm512_mask_cmp_epu32_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="k1" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<parameter varname="imm" type="const _MM_CMPINT_ENUM"/>
	<description>Compare packed unsigned 32-bit integers in "a" and "b" based on the comparison operand specified by "imm", and store the results in mask vector "k1" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
CASE(imm) of
  0: OP := _MM_CMPINT_EQ
  1: OP := _MM_CMPINT_LT
  2: OP := _MM_CMPINT_LE
  3: OP := _MM_CMPINT_FALSE
  4: OP := _MM_CMPINT_NEQ
  5: OP := _MM_CMPINT_NLT
  6: OP := _MM_CMPINT_NLE
  7: OP := _MM_CMPINT_TRUE
ESAC
FOR j := 0 to 15
	i := j*32
	IF k1[j]
		k[j] := ( a[i+31:i] OP b[i+31:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:16] := 0
	</description>
	<mnemonic base="vpcmpud"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cmpeq_epu32_mask / vpcmpud -->
<intrinsic tech="AVX-512" rettype="__mmask16" name="_mm512_mask_cmpeq_epu32_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="k1" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed unsigned 32-bit integers in "a" and "b" for equality, and store the results in mask vector "k1" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k1[j]
		k[j] := ( a[i+31:i] == b[i+31:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:16] := 0
	</description>
	<mnemonic base="vpcmpud"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cmpge_epu32_mask / vpcmpud -->
<intrinsic tech="AVX-512" rettype="__mmask16" name="_mm512_mask_cmpge_epu32_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="k1" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed unsigned 32-bit integers in "a" and "b" for greater-than-or-equal, and store the results in mask vector "k1" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k1[j]
		k[j] := ( a[i+31:i] &gt;= b[i+31:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:16] := 0
	</description>
	<mnemonic base="vpcmpud"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cmpgt_epu32_mask / vpcmpud -->
<intrinsic tech="AVX-512" rettype="__mmask16" name="_mm512_mask_cmpgt_epu32_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="k1" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed unsigned 32-bit integers in "a" and "b" for greater-than, and store the results in mask vector "k1" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k1[j]
		k[j] := ( a[i+31:i] &gt; b[i+31:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:16] := 0
	</description>
	<mnemonic base="vpcmpud"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cmple_epu32_mask / vpcmpud -->
<intrinsic tech="AVX-512" rettype="__mmask16" name="_mm512_mask_cmple_epu32_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="k1" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed unsigned 32-bit integers in "a" and "b" for less-than, and store the results in mask vector "k1" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k1[j]
		k[j] := ( a[i+31:i] &lt; b[i+31:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:16] := 0
	</description>
	<mnemonic base="vpcmpud"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cmplt_epu32_mask / vpcmpud -->
<intrinsic tech="AVX-512" rettype="__mmask16" name="_mm512_mask_cmplt_epu32_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="k1" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed unsigned 32-bit integers in "a" and "b" for less-than-or-equal, and store the results in mask vector "k1" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k1[j]
		k[j] := ( a[i+31:i] &lt;= b[i+31:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:16] := 0
	</description>
	<mnemonic base="vpcmpud"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cmpneq_epu32_mask / vpcmpud -->
<intrinsic tech="AVX-512" rettype="__mmask16" name="_mm512_mask_cmpneq_epu32_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="k1" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed unsigned 32-bit integers in "a" and "b" for not-equal, and store the results in mask vector "k1" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k1[j]
		k[j] := ( a[i+31:i] != b[i+31:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:16] := 0
	</description>
	<mnemonic base="vpcmpud"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cmp_epu64_mask / vpcmpuq -->
<intrinsic tech="AVX-512" rettype="__mmask8" name="_mm512_cmp_epu64_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<parameter varname="imm" type="const _MM_CMPINT_ENUM"/>
	<description>Compare packed unsigned 64-bit integers in "a" and "b" based on the comparison operand specified by "imm", and store the results in mask vector "k".</description>
	<description code="true">
CASE(imm) of
  0: OP := _MM_CMPINT_EQ
  1: OP := _MM_CMPINT_LT
  2: OP := _MM_CMPINT_LE
  3: OP := _MM_CMPINT_FALSE
  4: OP := _MM_CMPINT_NEQ
  5: OP := _MM_CMPINT_NLT
  6: OP := _MM_CMPINT_NLE
  7: OP := _MM_CMPINT_TRUE
ESAC
FOR j := 0 to 7
	i := j*64
	k[j] := ( a[i+63:i] OP b[i+63:i] ) ? 1 : 0
ENDFOR
k[MAX:8] := 0
	</description>
	<mnemonic base="vpcmpuq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cmpeq_epu64_mask / vpcmpuq -->
<intrinsic tech="AVX-512" rettype="__mmask8" name="_mm512_cmpeq_epu64_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed unsigned 64-bit integers in "a" and "b" for equality, and store the results in mask vector "k".</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	k[j] := ( a[i+63:i] == b[i+63:i] ) ? 1 : 0
ENDFOR
k[MAX:8] := 0
	</description>
	<mnemonic base="vpcmpuq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cmpge_epu64_mask / vpcmpuq -->
<intrinsic tech="AVX-512" rettype="__mmask8" name="_mm512_cmpge_epu64_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed unsigned 64-bit integers in "a" and "b" for greater-than-or-equal, and store the results in mask vector "k".</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	k[j] := ( a[i+63:i] &gt;= b[i+63:i] ) ? 1 : 0
ENDFOR
k[MAX:8] := 0
	</description>
	<mnemonic base="vpcmpuq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cmpgt_epu64_mask / vpcmpuq -->
<intrinsic tech="AVX-512" rettype="__mmask8" name="_mm512_cmpgt_epu64_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed unsigned 64-bit integers in "a" and "b" for greater-than, and store the results in mask vector "k".</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	k[j] := ( a[i+63:i] &gt; b[i+63:i] ) ? 1 : 0
ENDFOR
k[MAX:8] := 0
	</description>
	<mnemonic base="vpcmpuq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cmple_epu64_mask / vpcmpuq -->
<intrinsic tech="AVX-512" rettype="__mmask8" name="_mm512_cmple_epu64_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed unsigned 64-bit integers in "a" and "b" for less-than-or-equal, and store the results in mask vector "k".</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	k[j] := ( a[i+63:i] &lt;= b[i+63:i] ) ? 1 : 0
ENDFOR
k[MAX:8] := 0
	</description>
	<mnemonic base="vpcmpuq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cmplt_epu64_mask / vpcmpuq -->
<intrinsic tech="AVX-512" rettype="__mmask8" name="_mm512_cmplt_epu64_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed unsigned 64-bit integers in "a" and "b" for less-than, and store the results in mask vector "k".</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	k[j] := ( a[i+63:i] &lt; b[i+63:i] ) ? 1 : 0
ENDFOR
k[MAX:8] := 0
	</description>
	<mnemonic base="vpcmpuq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cmpneq_epu64_mask / vpcmpuq -->
<intrinsic tech="AVX-512" rettype="__mmask8" name="_mm512_cmpneq_epu64_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed unsigned 64-bit integers in "a" and "b" for not-equal, and store the results in mask vector "k".</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	k[j] := ( a[i+63:i] != b[i+63:i] ) ? 1 : 0
ENDFOR
k[MAX:8] := 0
	</description>
	<mnemonic base="vpcmpuq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cmp_epu64_mask / vpcmpuq -->
<intrinsic tech="AVX-512" rettype="__mmask8" name="_mm512_mask_cmp_epu64_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="k1" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<parameter varname="imm" type="const _MM_CMPINT_ENUM"/>
	<description>Compare packed unsigned 64-bit integers in "a" and "b" based on the comparison operand specified by "imm", and store the results in mask vector "k1" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
CASE(imm) of
  0: OP := _MM_CMPINT_EQ
  1: OP := _MM_CMPINT_LT
  2: OP := _MM_CMPINT_LE
  3: OP := _MM_CMPINT_FALSE
  4: OP := _MM_CMPINT_NEQ
  5: OP := _MM_CMPINT_NLT
  6: OP := _MM_CMPINT_NLE
  7: OP := _MM_CMPINT_TRUE
ESAC
FOR j := 0 to 7
	i := j*64
	IF k1[j]
		k[j] := ( a[i+63:i] OP b[i+63:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</description>
	<mnemonic base="vpcmpuq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cmpeq_epu64_mask / vpcmpuq -->
<intrinsic tech="AVX-512" rettype="__mmask8" name="_mm512_mask_cmpeq_epu64_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="k1" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed unsigned 64-bit integers in "a" and "b" for equality, and store the results in mask vector "k1" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k1[j]
		k[j] := ( a[i+63:i] == b[i+63:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</description>
	<mnemonic base="vpcmpuq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cmpge_epu64_mask / vpcmpuq -->
<intrinsic tech="AVX-512" rettype="__mmask8" name="_mm512_mask_cmpge_epu64_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="k1" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed unsigned 64-bit integers in "a" and "b" for greater-than-or-equal, and store the results in mask vector "k1" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k1[j]
		k[j] := ( a[i+63:i] &gt;= b[i+63:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</description>
	<mnemonic base="vpcmpuq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cmpgt_epu64_mask / vpcmpuq -->
<intrinsic tech="AVX-512" rettype="__mmask8" name="_mm512_mask_cmpgt_epu64_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="k1" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed unsigned 64-bit integers in "a" and "b" for greater-than, and store the results in mask vector "k1" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k1[j]
		k[j] := ( a[i+63:i] &gt; b[i+63:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</description>
	<mnemonic base="vpcmpuq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cmple_epu64_mask / vpcmpuq -->
<intrinsic tech="AVX-512" rettype="__mmask8" name="_mm512_mask_cmple_epu64_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="k1" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed unsigned 64-bit integers in "a" and "b" for less-than-or-equal, and store the results in mask vector "k1" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k1[j]
		k[j] := ( a[i+63:i] &lt;= b[i+63:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</description>
	<mnemonic base="vpcmpuq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cmplt_epu64_mask / vpcmpuq -->
<intrinsic tech="AVX-512" rettype="__mmask8" name="_mm512_mask_cmplt_epu64_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="k1" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed unsigned 64-bit integers in "a" and "b" for less-than, and store the results in mask vector "k1" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k1[j]
		k[j] := ( a[i+63:i] &lt; b[i+63:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</description>
	<mnemonic base="vpcmpuq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cmpneq_epu64_mask / vpcmpuq -->
<intrinsic tech="AVX-512" rettype="__mmask8" name="_mm512_mask_cmpneq_epu64_mask">
	<CPUID>AVX-512</CPUID>
	<category>Compare</category>
	<parameter varname="k1" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed unsigned 64-bit integers in "a" and "b" for not-equal, and store the results in mask vector "k1" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k1[j]
		k[j] := ( a[i+63:i] != b[i+63:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</description>
	<mnemonic base="vpcmpuq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_compress_epi32 / vpcompressd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_compress_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<description>Contiguously store the active 32-bit integers in "a" (those with their respective bit set in writemask "k") to "dst", and pass through the remaining elements from "src".</description>
	<description code="true">
size := 32
m := 0
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[m+size-1:m] := a[i+31:i]
		m := m + size
	FI
ENDFOR
dst[511:m] := src[511:m]
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpcompressd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_compressstoreu_epi32 / vpcompressd -->
<intrinsic tech="AVX-512" rettype="void" name="_mm512_mask_compressstoreu_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Store</category>
	<category>Swizzle</category>
	<parameter varname="base_addr" type="void*"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<description>Contiguously store the active 32-bit integers in "a" (those with their respective bit set in writemask "k") to unaligned memory at "base_addr".</description>
	<description code="true">
size := 32
m := base_addr
FOR j := 0 to 15
	i := j*32
	IF k[j]
		MEM[m+size-1:m] := a[i+31:i]
		m := m + size
	FI
ENDFOR
	</description>
	<mnemonic base="vpcompressd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_compress_epi32 / vpcompressd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_compress_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<description>Contiguously store the active 32-bit integers in "a" (those with their respective bit set in zeromask "k") to "dst", and set the remaining elements to zero.</description>
	<description code="true">
size := 32
m := 0
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[m+size-1:m] := a[i+31:i]
		m := m + size
	FI
ENDFOR
dst[511:m] := 0
dst[MAX:512] := 0
	</description>	
	<mnemonic base="vpcompressd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_compress_epi64 / vpcompressq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_compress_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<description>Contiguously store the active 64-bit integers in "a" (those with their respective bit set in writemask "k") to "dst", and pass through the remaining elements from "src".</description>
	<description code="true">
size := 64
m := 0
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[m+size-1:m] := a[i+63:i]
		m := m + size
	FI
ENDFOR
dst[511:m] := src[511:m]
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpcompressq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_compressstoreu_epi64 / vpcompressq -->
<intrinsic tech="AVX-512" rettype="void" name="_mm512_mask_compressstoreu_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Store</category>
	<category>Swizzle</category>
	<parameter varname="base_addr" type="void*"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<description>Contiguously store the active 64-bit integers in "a" (those with their respective bit set in writemask "k") to unaligned memory at "base_addr".</description>
	<description code="true">
size := 64
m := base_addr
FOR j := 0 to 7
	i := j*64
	IF k[j]
		MEM[m+size-1:m] := a[i+63:i]
		m := m + size
	FI
ENDFOR
	</description>
	<mnemonic base="vpcompressq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_compress_epi64 / vpcompressq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_compress_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<description>Contiguously store the active 64-bit integers in "a" (those with their respective bit set in zeromask "k") to "dst", and set the remaining elements to zero.</description>
	<description code="true">
size := 64
m := 0
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[m+size-1:m] := a[i+63:i]
		m := m + size
	FI
ENDFOR
dst[511:m] := 0
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpcompressq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_conflict_epi32 / vpconflictd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_conflict_epi32">
	<CPUID>AVX-512.CDI</CPUID>
	<category>Compare</category>
	<parameter varname="a" type="__m512i"/>
	<description>Test each 32-bit element of "a" for equality with all other elements in "a" closer to the least significant bit. Each element's comparison forms a zero extended bit vector in "dst".</description>
	<description code="true">
FOR j := 0 to 15
  i := j*32
  FOR k := 0 to j-1
	m := k*32
	dst[i+k] := (a[i+31:i] == a[m+31:m]) ? 1 : 0
  ENDFOR
  dst[i+31:i+j] := 0
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpconflictd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_conflict_epi32 / vpconflictd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_conflict_epi32">
	<CPUID>AVX-512.CDI</CPUID>
	<category>Compare</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<description>Test each 32-bit element of "a" for equality with all other elements in "a" closer to the least significant bit using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). Each element's comparison forms a zero extended bit vector in "dst".</description>	
	<description code="true">
FOR j := 0 to 15
  i := j*32
  IF k[i]
	FOR l := 0 to j-1
	  m := l*32
	  dst[i+l] := (a[i+31:i] == a[m+31:m]) ? 1 : 0
	ENDFOR
	dst[i+31:i+j] := 0
  ELSE
	  dst[i+31:i] := src[i+31:i]
  FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpconflictd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_conflict_epi32 / vpconflictd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_conflict_epi32">
	<CPUID>AVX-512.CDI</CPUID>
	<category>Compare</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<description>Test each 32-bit element of "a" for equality with all other elements in "a" closer to the least significant bit using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). Each element's comparison forms a zero extended bit vector in "dst".</description>
	<description code="true">
FOR j := 0 to 15
  i := j*32
  IF k[i]
	FOR l := 0 to j-1
	  m := l*32
	  dst[i+l] := (a[i+31:i] == a[m+31:m]) ? 1 : 0
	ENDFOR
	dst[i+31:i+j] := 0
  ELSE
	  dst[i+31:i] := 0
  FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpconflictd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_conflict_epi64 / vpconflictq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_conflict_epi64">
	<CPUID>AVX-512.CDI</CPUID>
	<category>Compare</category>
	<parameter varname="a" type="__m512i"/>
	<description>Test each 64-bit element of "a" for equality with all other elements in "a" closer to the least significant bit. Each element's comparison forms a zero extended bit vector in "dst".</description>
	<description code="true">
FOR j := 0 to 7
  i := j*64
  FOR k := 0 to j-1
	m := k*64
	dst[i+k] := (a[i+63:i] == a[m+63:m]) ? 1 : 0
  ENDFOR
  dst[i+63:i+j] := 0
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpconflictq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_conflict_epi64 / vpconflictq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_conflict_epi64">
	<CPUID>AVX-512.CDI</CPUID>
	<category>Compare</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<description>Test each 64-bit element of "a" for equality with all other elements in "a" closer to the least significant bit using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). Each element's comparison forms a zero extended bit vector in "dst".</description>
	<description code="true">
FOR j := 0 to 7
  i := j*64
  IF k[j]
	FOR l := 0 to j-1
	  m := l*64
	  dst[i+l] := (a[i+63:i] == a[m+63:m]) ? 1 : 0
	ENDFOR
	dst[i+63:i+j] := 0
  ELSE
	  dst[i+63:i] := src[i+63:i]
  FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpconflictq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_conflict_epi64 / vpconflictq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_conflict_epi64">
	<CPUID>AVX-512.CDI</CPUID>
	<category>Compare</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<description>Test each 64-bit element of "a" for equality with all other elements in "a" closer to the least significant bit using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). Each element's comparison forms a zero extended bit vector in "dst".</description>
	<description code="true">
FOR j := 0 to 7
  i := j*64
  IF k[j]
	FOR l := 0 to j-1
	  m := l*64
	  dst[i+l] := (a[i+63:i] == a[m+63:m]) ? 1 : 0
	ENDFOR
	dst[i+63:i+j] := 0
  ELSE
	  dst[i+63:i] := 0
  FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpconflictq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_permutevar_epi32 / vpermd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_permutevar_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="idx" type="__m512i"/>
	<parameter varname="a" type="__m512i"/>
	<description>Shuffle 32-bit integers in "a" across lanes using the corresponding index in "idx", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). Note that this intrinsic shuffles across 128-bit lanes, unlike past intrinsics that use the "permutevar" name. This intrinsic is identical to "_mm512_mask_permutexvar_epi32", and it is recommended that you use that intrinsic name.</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	id := idx[i+3:i]*32
	IF k[j]
		dst[i+31:i] := a[id+31:id]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpermd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_permutexvar_epi32 / vpermd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_permutexvar_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="idx" type="__m512i"/>
	<parameter varname="a" type="__m512i"/>
	<description>Shuffle 32-bit integers in "a" across lanes using the corresponding index in "idx", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	id := idx[i+3:i]*32
	IF k[j]
		dst[i+31:i] := a[id+31:id]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpermd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_permutexvar_epi32 / vpermd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_permutexvar_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="idx" type="__m512i"/>
	<parameter varname="a" type="__m512i"/>
	<description>Shuffle 32-bit integers in "a" across lanes using the corresponding index in "idx", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	id := idx[i+3:i]*32
	IF k[j]
		dst[i+31:i] := a[id+31:id]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpermd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_permutevar_epi32 / vpermd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_permutevar_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="idx" type="__m512i"/>
	<parameter varname="a" type="__m512i"/>
	<description>Shuffle 32-bit integers in "a" across lanes using the corresponding index in "idx", and store the results in "dst". Note that this intrinsic shuffles across 128-bit lanes, unlike past intrinsics that use the "permutevar" name. This intrinsic is identical to "_mm512_permutexvar_epi32", and it is recommended that you use that intrinsic name.
	</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	id := idx[i+3:i]*32
	dst[i+31:i] := a[id+31:id]
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpermd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_permutexvar_epi32 / vpermd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_permutexvar_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="idx" type="__m512i"/>
	<parameter varname="a" type="__m512i"/>
	<description>Shuffle 32-bit integers in "a" across lanes using the corresponding index in "idx", and store the results in "dst".
	</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	id := idx[i+3:i]*32
	dst[i+31:i] := a[id+31:id]
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpermd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask2_permutex2var_epi32 / vpermt2d -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask2_permutex2var_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="idx" type="__m512i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="b" type="__m512i"/>
	<description>Shuffle 32-bit integers in "a" and "b" across lanes using the corresponding selector and index in "idx", and store the results in "dst" using writemask "k" (elements are copied from "idx" when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	off := idx[i+3:i]*32
	IF k[j]
		dst[i+31:i] := idx[i+4] ? b[off+31:off] : a[off+31:off]
	ELSE
		dst[i+31:i] := idx[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpermi2d"/>
	<mnemonic base="vpermt2d"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_permutex2var_epi32 / vpermt2d -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_permutex2var_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="idx" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Shuffle 32-bit integers in "a" and "b" across lanes using the corresponding selector and index in "idx", and store the results in "dst" using writemask "k" (elements are copied from "a" when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	off := idx[i+3:i]*32
	IF k[j]
		dst[i+31:i] := idx[i+4] ? b[off+31:off] : a[off+31:off]
	ELSE
		dst[i+31:i] := a[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpermi2d"/>
	<mnemonic base="vpermt2d"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_permutex2var_epi32 / vpermt2d -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_permutex2var_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="idx" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Shuffle 32-bit integers in "a" and "b" across lanes using the corresponding selector and index in "idx", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	off := idx[i+3:i]*32
	IF k[j]
		dst[i+31:i] := (idx[i+4]) ? b[off+31:off] : a[off+31:off]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpermi2d"/>
	<mnemonic base="vpermt2d"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_permutex2var_epi32 / vpermt2d -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_permutex2var_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="idx" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Shuffle 32-bit integers in "a" and "b" across lanes using the corresponding selector and index in "idx", and store the results in "dst".
	</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	off := idx[i+3:i]*32
	dst[i+31:i] := idx[i+4] ? b[off+31:off] : a[off+31:off]
ENDFOR
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpermi2d"/>
	<mnemonic base="vpermt2d"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask2_permutex2var_pd / vpermt2pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask2_permutex2var_pd">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="idx" type="__m512i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="b" type="__m512d"/>
	<description>Shuffle double-precision (64-bit) floating-point elements in "a" and "b" across lanes using the corresponding selector and index in "idx", and store the results in "dst" using writemask "k" (elements are copied from "idx" when the corresponding mask bit is not set)</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	off := idx[i+2:i]*64
	IF k[j]
		dst[i+63:i] := idx[i+3] ? b[off+63:off] : a[off+63:off]
	ELSE
		dst[i+63:i] := idx[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpermi2pd"/>
	<mnemonic base="vpermt2pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_permutex2var_pd / vpermt2pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_permutex2var_pd">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="idx" type="__m512i"/>
	<parameter varname="b" type="__m512d"/>
	<description>Shuffle double-precision (64-bit) floating-point elements in "a" and "b" across lanes using the corresponding selector and index in "idx", and store the results in "dst" using writemask "k" (elements are copied from "a" when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	off := idx[i+2:i]*64
	IF k[j]
		dst[i+63:i] := idx[i+3] ? b[off+63:off] : a[off+63:off]
	ELSE
		dst[i+63:i] := a[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpermi2pd"/>
	<mnemonic base="vpermt2pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_permutex2var_pd / vpermt2pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_permutex2var_pd">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="idx" type="__m512i"/>
	<parameter varname="b" type="__m512d"/>
	<description>Shuffle double-precision (64-bit) floating-point elements in "a" and "b" across lanes using the corresponding selector and index in "idx", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	off := idx[i+2:i]*64
	IF k[j]
		dst[i+63:i] := (idx[i+3]) ? b[off+63:off] : a[off+63:off]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpermi2pd"/>
	<mnemonic base="vpermt2pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_permutex2var_pd / vpermt2pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_permutex2var_pd">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="idx" type="__m512i"/>
	<parameter varname="b" type="__m512d"/>
	<description>Shuffle double-precision (64-bit) floating-point elements in "a" and "b" across lanes using the corresponding selector and index in "idx", and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	off := idx[i+2:i]*64
	dst[i+63:i] := idx[i+3] ? b[off+63:off] : a[off+63:off]
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpermi2pd"/>
	<mnemonic base="vpermt2pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask2_permutex2var_ps / vpermt2ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask2_permutex2var_ps">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="idx" type="__m512i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="b" type="__m512"/>
	<description>Shuffle single-precision (32-bit) floating-point elements in "a" and "b" across lanes using the corresponding selector and index in "idx", and store the results in "dst" using writemask "k" (elements are copied from "idx" when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	off := idx[i+3:i]*32
	IF k[j]
		dst[i+31:i] := idx[i+4] ? b[off+31:off] : a[off+31:off]
	ELSE
		dst[i+31:i] := idx[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpermi2ps"/>
	<mnemonic base="vpermt2ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_permutex2var_ps / vpermt2ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_permutex2var_ps">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="idx" type="__m512i"/>
	<parameter varname="b" type="__m512"/>
	<description>Shuffle single-precision (32-bit) floating-point elements in "a" and "b" across lanes using the corresponding selector and index in "idx", and store the results in "dst" using writemask "k" (elements are copied from "a" when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	off := idx[i+3:i]*32
	IF k[j]
		dst[i+31:i] := idx[i+4] ? b[off+31:off] : a[off+31:off]
	ELSE
		dst[i+31:i] := a[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpermi2ps"/>
	<mnemonic base="vpermt2ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_permutex2var_ps / vpermt2ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_permutex2var_ps">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="idx" type="__m512i"/>
	<parameter varname="b" type="__m512"/>
	<description>Shuffle single-precision (32-bit) floating-point elements in "a" and "b" across lanes using the corresponding selector and index in "idx", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	off := idx[i+3:i]*32
	IF k[j]
		dst[i+31:i] := (idx[i+4]) ? b[off+31:off] : a[off+31:off]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpermi2ps"/>
	<mnemonic base="vpermt2ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_permutex2var_ps / vpermt2ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_permutex2var_ps">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="idx" type="__m512i"/>
	<parameter varname="b" type="__m512"/>
	<description>Shuffle single-precision (32-bit) floating-point elements in "a" and "b" across lanes using the corresponding selector and index in "idx", and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	off := idx[i+3:i]*32
	dst[i+31:i] := idx[i+4] ? b[off+31:off] : a[off+31:off]
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpermi2ps"/>
	<mnemonic base="vpermt2ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask2_permutex2var_epi64 / vpermt2q -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask2_permutex2var_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="idx" type="__m512i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="b" type="__m512i"/>
	<description>Shuffle 64-bit integers in "a" and "b" across lanes using the corresponding selector and index in "idx", and store the results in "dst" using writemask "k" (elements are copied from "idx" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	off := idx[i+2:i]*64
	IF k[j]
		dst[i+63:i] := idx[i+3] ? b[off+63:off] : a[off+63:off]
	ELSE
		dst[i+63:i] := idx[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpermi2q"/>
	<mnemonic base="vpermt2q"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_permutex2var_epi64 / vpermt2q -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_permutex2var_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="idx" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Shuffle 64-bit integers in "a" and "b" across lanes using the corresponding selector and index in "idx", and store the results in "dst" using writemask "k" (elements are copied from "a" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	off := idx[i+2:i]*64
	IF k[j]
		dst[i+63:i] := idx[i+3] ? b[off+63:off] : a[off+63:off]
	ELSE
		dst[i+63:i] := a[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpermi2q"/>
	<mnemonic base="vpermt2q"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_permutex2var_epi64 / vpermt2q -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_permutex2var_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="idx" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Shuffle 64-bit integers in "a" and "b" across lanes using the corresponding selector and index in "idx", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	off := idx[i+2:i]*64
	IF k[j]
		dst[i+63:i] := (idx[i+3]) ? b[off+63:off] : a[off+63:off]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpermi2q"/>
	<mnemonic base="vpermt2q"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_permutex2var_epi64 / vpermt2q -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_permutex2var_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="idx" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Shuffle 64-bit integers in "a" and "b" across lanes using the corresponding selector and index in "idx", and store the results in "dst".
	</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	off := idx[i+2:i]*64
	dst[i+63:i] := idx[i+3] ? b[off+63:off] : a[off+63:off]
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpermi2q"/>
	<mnemonic base="vpermt2q"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_permute_pd / vpermilpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_permute_pd">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="src" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="imm" type="const int"/>
	<description>Shuffle double-precision (64-bit) floating-point elements in "a" within 128-bit lanes using the control in "imm", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<description code="true">
IF (imm[0] == 0) tmp_dst[63:0] := a[63:0]
IF (imm[0] == 1) tmp_dst[63:0] := a[127:64]
IF (imm[1] == 0) tmp_dst[127:64] := a[63:0]
IF (imm[1] == 1) tmp_dst[127:64] := a[127:64]
IF (imm[2] == 0) tmp_dst[191:128] := a[191:128]
IF (imm[2] == 1) tmp_dst[191:128] := a[255:192]
IF (imm[3] == 0) tmp_dst[255:192] := a[191:128]
IF (imm[3] == 1) tmp_dst[255:192] := a[255:192]
IF (imm[4] == 0) tmp_dst[319:256] := a[319:256]
IF (imm[4] == 1) tmp_dst[319:256] := a[383:320]
IF (imm[5] == 0) tmp_dst[383:320] := a[319:256]
IF (imm[5] == 1) tmp_dst[383:320] := a[383:320]
IF (imm[6] == 0) tmp_dst[447:384] := a[447:384]
IF (imm[6] == 1) tmp_dst[447:384] := a[511:448]
IF (imm[7] == 0) tmp_dst[511:448] := a[447:384]
IF (imm[7] == 1) tmp_dst[511:448] := a[511:448]
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp_dst[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpermilpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_permutevar_pd / vpermilpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_permutevar_pd">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="src" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512i"/>
	<description>Shuffle double-precision (64-bit) floating-point elements in "a" within 128-bit lanes using the control in "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<description code="true">
IF (b[1] == 0) tmp_dst[63:0] := a[63:0]
IF (b[1] == 1) tmp_dst[63:0] := a[127:64]
IF (b[65] == 0) tmp_dst[127:64] := a[63:0]
IF (b[65] == 1) tmp_dst[127:64] := a[127:64]
IF (b[129] == 0) tmp_dst[191:128] := a[191:128]
IF (b[129] == 1) tmp_dst[191:128] := a[255:192]
IF (b[193] == 0) tmp_dst[255:192] := a[191:128]
IF (b[193] == 1) tmp_dst[255:192] := a[255:192]
IF (b[257] == 0) tmp_dst[319:256] := a[319:256]
IF (b[257] == 1) tmp_dst[319:256] := a[383:320]
IF (b[321] == 0) tmp_dst[383:320] := a[319:256]
IF (b[321] == 1) tmp_dst[383:320] := a[383:320]
IF (b[385] == 0) tmp_dst[447:384] := a[447:384]
IF (b[385] == 1) tmp_dst[447:384] := a[511:448]
IF (b[449] == 0) tmp_dst[511:448] := a[447:384]
IF (b[449] == 1) tmp_dst[511:448] := a[511:448]
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp_dst[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpermilpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_permute_pd / vpermilpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_permute_pd">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="imm" type="const int"/>
	<description>Shuffle double-precision (64-bit) floating-point elements in "a" within 128-bit lanes using the control in "imm", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
IF (imm[0] == 0) tmp_dst[63:0] := a[63:0]
IF (imm[0] == 1) tmp_dst[63:0] := a[127:64]
IF (imm[1] == 0) tmp_dst[127:64] := a[63:0]
IF (imm[1] == 1) tmp_dst[127:64] := a[127:64]
IF (imm[2] == 0) tmp_dst[191:128] := a[191:128]
IF (imm[2] == 1) tmp_dst[191:128] := a[255:192]
IF (imm[3] == 0) tmp_dst[255:192] := a[191:128]
IF (imm[3] == 1) tmp_dst[255:192] := a[255:192]
IF (imm[4] == 0) tmp_dst[319:256] := a[319:256]
IF (imm[4] == 1) tmp_dst[319:256] := a[383:320]
IF (imm[5] == 0) tmp_dst[383:320] := a[319:256]
IF (imm[5] == 1) tmp_dst[383:320] := a[383:320]
IF (imm[6] == 0) tmp_dst[447:384] := a[447:384]
IF (imm[6] == 1) tmp_dst[447:384] := a[511:448]
IF (imm[7] == 0) tmp_dst[511:448] := a[447:384]
IF (imm[7] == 1) tmp_dst[511:448] := a[511:448]
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp_dst[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpermilpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_permutevar_pd / vpermilpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_permutevar_pd">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512i"/>
	<description>Shuffle double-precision (64-bit) floating-point elements in "a" within 128-bit lanes using the control in "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
IF (b[1] == 0) tmp_dst[63:0] := a[63:0]
IF (b[1] == 1) tmp_dst[63:0] := a[127:64]
IF (b[65] == 0) tmp_dst[127:64] := a[63:0]
IF (b[65] == 1) tmp_dst[127:64] := a[127:64]
IF (b[129] == 0) tmp_dst[191:128] := a[191:128]
IF (b[129] == 1) tmp_dst[191:128] := a[255:192]
IF (b[193] == 0) tmp_dst[255:192] := a[191:128]
IF (b[193] == 1) tmp_dst[255:192] := a[255:192]
IF (b[257] == 0) tmp_dst[319:256] := a[319:256]
IF (b[257] == 1) tmp_dst[319:256] := a[383:320]
IF (b[321] == 0) tmp_dst[383:320] := a[319:256]
IF (b[321] == 1) tmp_dst[383:320] := a[383:320]
IF (b[385] == 0) tmp_dst[447:384] := a[447:384]
IF (b[385] == 1) tmp_dst[447:384] := a[511:448]
IF (b[449] == 0) tmp_dst[511:448] := a[447:384]
IF (b[449] == 1) tmp_dst[511:448] := a[511:448]
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp_dst[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpermilpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_permute_pd / vpermpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_permute_pd">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="imm" type="const int"/>
	<description>Shuffle double-precision (64-bit) floating-point elements in "a" within 128-bit lanes using the control in "imm", and store the results in "dst".</description>
	<description code="true">
IF (imm[0] == 0) dst[63:0] := a[63:0]
IF (imm[0] == 1) dst[63:0] := a[127:64]
IF (imm[1] == 0) dst[127:64] := a[63:0]
IF (imm[1] == 1) dst[127:64] := a[127:64]
IF (imm[2] == 0) dst[191:128] := a[191:128]
IF (imm[2] == 1) dst[191:128] := a[255:192]
IF (imm[3] == 0) dst[255:192] := a[191:128]
IF (imm[3] == 1) dst[255:192] := a[255:192]
IF (imm[4] == 0) dst[319:256] := a[319:256]
IF (imm[4] == 1) dst[319:256] := a[383:320]
IF (imm[5] == 0) dst[383:320] := a[319:256]
IF (imm[5] == 1) dst[383:320] := a[383:320]
IF (imm[6] == 0) dst[447:384] := a[447:384]
IF (imm[6] == 1) dst[447:384] := a[511:448]
IF (imm[7] == 0) dst[511:448] := a[447:384]
IF (imm[7] == 1) dst[511:448] := a[511:448]
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpermpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_permutevar_pd / vpermpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_permutevar_pd">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512i"/>
	<description>Shuffle double-precision (64-bit) floating-point elements in "a" within 128-bit lanes using the control in "b", and store the results in "dst".</description>
	<description code="true">
IF (b[1] == 0) dst[63:0] := a[63:0]
IF (b[1] == 1) dst[63:0] := a[127:64]
IF (b[65] == 0) dst[127:64] := a[63:0]
IF (b[65] == 1) dst[127:64] := a[127:64]
IF (b[129] == 0) dst[191:128] := a[191:128]
IF (b[129] == 1) dst[191:128] := a[255:192]
IF (b[193] == 0) dst[255:192] := a[191:128]
IF (b[193] == 1) dst[255:192] := a[255:192]
IF (b[257] == 0) dst[319:256] := a[319:256]
IF (b[257] == 1) dst[319:256] := a[383:320]
IF (b[321] == 0) dst[383:320] := a[319:256]
IF (b[321] == 1) dst[383:320] := a[383:320]
IF (b[385] == 0) dst[447:384] := a[447:384]
IF (b[385] == 1) dst[447:384] := a[511:448]
IF (b[449] == 0) dst[511:448] := a[447:384]
IF (b[449] == 1) dst[511:448] := a[511:448]
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpermpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_permute_ps / vpermilps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_permute_ps">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="src" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="imm" type="const int"/>
	<description>Shuffle single-precision (32-bit) floating-point elements in "a" within 128-bit lanes using the control in "imm", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<description code="true">
SELECT4(src, control){
	CASE(control[1:0])
		0:	tmp[31:0] := src[31:0]
		1:	tmp[31:0] := src[63:32]
		2:	tmp[31:0] := src[95:64]
		3:	tmp[31:0] := src[127:96]
	ESAC
	RETURN tmp[31:0]
}

tmp_dst[31:0] := SELECT4(a[127:0], imm[1:0])
tmp_dst[63:32] := SELECT4(a[127:0], imm[3:2])
tmp_dst[95:64] := SELECT4(a[127:0], imm[5:4])
tmp_dst[127:96] := SELECT4(a[127:0], imm[7:6])
tmp_dst[159:128] := SELECT4(a[255:128], imm[1:0])
tmp_dst[191:160] := SELECT4(a[255:128], imm[3:2])
tmp_dst[223:192] := SELECT4(a[255:128], imm[5:4])
tmp_dst[255:224] := SELECT4(a[255:128], imm[7:6])
tmp_dst[287:256] := SELECT4(a[383:256], imm[1:0])
tmp_dst[319:288] := SELECT4(a[383:256], imm[3:2])
tmp_dst[351:320] := SELECT4(a[383:256], imm[5:4])
tmp_dst[383:352] := SELECT4(a[383:256], imm[7:6])
tmp_dst[415:384] := SELECT4(a[511:384], imm[1:0])
tmp_dst[447:416] := SELECT4(a[511:384], imm[3:2])
tmp_dst[479:448] := SELECT4(a[511:384], imm[5:4])
tmp_dst[511:480] := SELECT4(a[511:384], imm[7:6])
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp_dst[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpermilps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_permutevar_ps / vpermilps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_permutevar_ps">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="src" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512i"/>
	<description>Shuffle single-precision (32-bit) floating-point elements in "a" within 128-bit lanes using the control in "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<description code="true">
SELECT4(src, control){
	CASE(control[1:0])
		0:	tmp[31:0] := src[31:0]
		1:	tmp[31:0] := src[63:32]
		2:	tmp[31:0] := src[95:64]
		3:	tmp[31:0] := src[127:96]
	ESAC
	RETURN tmp[31:0]
}

tmp_dst[31:0] := SELECT4(a[127:0], b[1:0])
tmp_dst[63:32] := SELECT4(a[127:0], b[33:32])
tmp_dst[95:64] := SELECT4(a[127:0], b[65:64])
tmp_dst[127:96] := SELECT4(a[127:0], b[97:96])
tmp_dst[159:128] := SELECT4(a[255:128], b[129:128])
tmp_dst[191:160] := SELECT4(a[255:128], b[161:160])
tmp_dst[223:192] := SELECT4(a[255:128], b[193:192])
tmp_dst[255:224] := SELECT4(a[255:128], b[225:224])
tmp_dst[287:256] := SELECT4(a[383:256], b[257:256])
tmp_dst[319:288] := SELECT4(a[383:256], b[289:288])
tmp_dst[351:320] := SELECT4(a[383:256], b[321:320])
tmp_dst[383:352] := SELECT4(a[383:256], b[353:352])
tmp_dst[415:384] := SELECT4(a[511:384], b[385:384])
tmp_dst[447:416] := SELECT4(a[511:384], b[417:416])
tmp_dst[479:448] := SELECT4(a[511:384], b[449:448])
tmp_dst[511:480] := SELECT4(a[511:384], b[481:480])
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp_dst[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpermilps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_permute_ps / vpermilps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_permute_ps">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="imm" type="const int"/>
	<description>Shuffle single-precision (32-bit) floating-point elements in "a" within 128-bit lanes using the control in "imm", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
SELECT4(src, control){
	CASE(control[1:0])
		0:	tmp[31:0] := src[31:0]
		1:	tmp[31:0] := src[63:32]
		2:	tmp[31:0] := src[95:64]
		3:	tmp[31:0] := src[127:96]
	ESAC
	RETURN tmp[31:0]
}

tmp_dst[31:0] := SELECT4(a[127:0], imm[1:0])
tmp_dst[63:32] := SELECT4(a[127:0], imm[3:2])
tmp_dst[95:64] := SELECT4(a[127:0], imm[5:4])
tmp_dst[127:96] := SELECT4(a[127:0], imm[7:6])
tmp_dst[159:128] := SELECT4(a[255:128], imm[1:0])
tmp_dst[191:160] := SELECT4(a[255:128], imm[3:2])
tmp_dst[223:192] := SELECT4(a[255:128], imm[5:4])
tmp_dst[255:224] := SELECT4(a[255:128], imm[7:6])
tmp_dst[287:256] := SELECT4(a[383:256], imm[1:0])
tmp_dst[319:288] := SELECT4(a[383:256], imm[3:2])
tmp_dst[351:320] := SELECT4(a[383:256], imm[5:4])
tmp_dst[383:352] := SELECT4(a[383:256], imm[7:6])
tmp_dst[415:384] := SELECT4(a[511:384], imm[1:0])
tmp_dst[447:416] := SELECT4(a[511:384], imm[3:2])
tmp_dst[479:448] := SELECT4(a[511:384], imm[5:4])
tmp_dst[511:480] := SELECT4(a[511:384], imm[7:6])
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp_dst[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpermilps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_permutevar_ps / vpermilps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_permutevar_ps">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512i"/>
	<description>Shuffle single-precision (32-bit) floating-point elements in "a" within 128-bit lanes using the control in "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
SELECT4(src, control){
	CASE(control[1:0])
		0:	tmp[31:0] := src[31:0]
		1:	tmp[31:0] := src[63:32]
		2:	tmp[31:0] := src[95:64]
		3:	tmp[31:0] := src[127:96]
	ESAC
	RETURN tmp[31:0]
}

tmp_dst[31:0] := SELECT4(a[127:0], b[1:0])
tmp_dst[63:32] := SELECT4(a[127:0], b[33:32])
tmp_dst[95:64] := SELECT4(a[127:0], b[65:64])
tmp_dst[127:96] := SELECT4(a[127:0], b[97:96])
tmp_dst[159:128] := SELECT4(a[255:128], b[129:128])
tmp_dst[191:160] := SELECT4(a[255:128], b[161:160])
tmp_dst[223:192] := SELECT4(a[255:128], b[193:192])
tmp_dst[255:224] := SELECT4(a[255:128], b[225:224])
tmp_dst[287:256] := SELECT4(a[383:256], b[257:256])
tmp_dst[319:288] := SELECT4(a[383:256], b[289:288])
tmp_dst[351:320] := SELECT4(a[383:256], b[321:320])
tmp_dst[383:352] := SELECT4(a[383:256], b[353:352])
tmp_dst[415:384] := SELECT4(a[511:384], b[385:384])
tmp_dst[447:416] := SELECT4(a[511:384], b[417:416])
tmp_dst[479:448] := SELECT4(a[511:384], b[449:448])
tmp_dst[511:480] := SELECT4(a[511:384], b[481:480])
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp_dst[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpermilps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_permute_ps / vpermilps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_permute_ps">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="imm" type="const int"/>
	<description>Shuffle single-precision (32-bit) floating-point elements in "a" within 128-bit lanes using the control in "imm", and store the results in "dst".</description>
	<description code="true">
SELECT4(src, control){
	CASE(control[1:0])
		0:	tmp[31:0] := src[31:0]
		1:	tmp[31:0] := src[63:32]
		2:	tmp[31:0] := src[95:64]
		3:	tmp[31:0] := src[127:96]
	ESAC
	RETURN tmp[31:0]
}

dst[31:0] := SELECT4(a[127:0], imm[1:0])
dst[63:32] := SELECT4(a[127:0], imm[3:2])
dst[95:64] := SELECT4(a[127:0], imm[5:4])
dst[127:96] := SELECT4(a[127:0], imm[7:6])
dst[159:128] := SELECT4(a[255:128], imm[1:0])
dst[191:160] := SELECT4(a[255:128], imm[3:2])
dst[223:192] := SELECT4(a[255:128], imm[5:4])
dst[255:224] := SELECT4(a[255:128], imm[7:6])
dst[287:256] := SELECT4(a[383:256], imm[1:0])
dst[319:288] := SELECT4(a[383:256], imm[3:2])
dst[351:320] := SELECT4(a[383:256], imm[5:4])
dst[383:352] := SELECT4(a[383:256], imm[7:6])
dst[415:384] := SELECT4(a[511:384], imm[1:0])
dst[447:416] := SELECT4(a[511:384], imm[3:2])
dst[479:448] := SELECT4(a[511:384], imm[5:4])
dst[511:480] := SELECT4(a[511:384], imm[7:6])
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpermilps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_permutevar_ps / vpermps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_permutevar_ps">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512i"/>
	<description>Shuffle single-precision (32-bit) floating-point elements in "a" within 128-bit lanes using the control in "b", and store the results in "dst".</description>
	<description code="true">
SELECT4(src, control){
	CASE(control[1:0])
		0:	tmp[31:0] := src[31:0]
		1:	tmp[31:0] := src[63:32]
		2:	tmp[31:0] := src[95:64]
		3:	tmp[31:0] := src[127:96]
	ESAC
	RETURN tmp[31:0]
}

dst[31:0] := SELECT4(a[127:0], b[1:0])
dst[63:32] := SELECT4(a[127:0], b[33:32])
dst[95:64] := SELECT4(a[127:0], b[65:64])
dst[127:96] := SELECT4(a[127:0], b[97:96])
dst[159:128] := SELECT4(a[255:128], b[129:128])
dst[191:160] := SELECT4(a[255:128], b[161:160])
dst[223:192] := SELECT4(a[255:128], b[193:192])
dst[255:224] := SELECT4(a[255:128], b[225:224])
dst[287:256] := SELECT4(a[383:256], b[257:256])
dst[319:288] := SELECT4(a[383:256], b[289:288])
dst[351:320] := SELECT4(a[383:256], b[321:320])
dst[383:352] := SELECT4(a[383:256], b[353:352])
dst[415:384] := SELECT4(a[511:384], b[385:384])
dst[447:416] := SELECT4(a[511:384], b[417:416])
dst[479:448] := SELECT4(a[511:384], b[449:448])
dst[511:480] := SELECT4(a[511:384], b[481:480])
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpermps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_permutex_pd / vpermpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_permutex_pd">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="src" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="imm" type="const int"/>
	<description>Shuffle double-precision (64-bit) floating-point elements in "a" within 256-bit lanes using the control in "imm", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<description code="true">
SELECT4(src, control){
	CASE(control[1:0])
		0:	tmp[63:0] := src[63:0]
		1:	tmp[63:0] := src[127:64]
		2:	tmp[63:0] := src[191:128]
		3:	tmp[63:0] := src[255:192]
	ESAC
	RETURN tmp[63:0]
}

tmp_dst[63:0] := SELECT4(a[255:0], imm[1:0])
tmp_dst[127:64] := SELECT4(a[255:0], imm[3:2])
tmp_dst[191:128] := SELECT4(a[255:0], imm[5:4])
tmp_dst[255:192] := SELECT4(a[255:0], imm[7:6])
tmp_dst[319:256] := SELECT4(a[511:256], imm[1:0])
tmp_dst[383:320] := SELECT4(a[511:256], imm[3:2])
tmp_dst[447:384] := SELECT4(a[511:256], imm[5:4])
tmp_dst[511:448] := SELECT4(a[511:256], imm[7:6])
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp_dst[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpermpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_permutexvar_pd / vpermpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_permutexvar_pd">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="src" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="idx" type="__m512i"/>
	<parameter varname="a" type="__m512d"/>
	<description>Shuffle double-precision (64-bit) floating-point elements in "a" across lanes using the corresponding index in "idx", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	id := idx[i+2:i]*64
	IF k[j]
		dst[i+63:i] := a[id+63:id]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpermpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_permutex_pd / vpermpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_permutex_pd">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="imm" type="const int"/>
	<description>Shuffle double-precision (64-bit) floating-point elements in "a" within 256-bit lanes using the control in "imm", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
SELECT4(src, control){
	CASE(control[1:0])
		0:	tmp[63:0] := src[63:0]
		1:	tmp[63:0] := src[127:64]
		2:	tmp[63:0] := src[191:128]
		3:	tmp[63:0] := src[255:192]
	ESAC
	RETURN tmp[63:0]
}

tmp_dst[63:0] := SELECT4(a[255:0], imm[1:0])
tmp_dst[127:64] := SELECT4(a[255:0], imm[3:2])
tmp_dst[191:128] := SELECT4(a[255:0], imm[5:4])
tmp_dst[255:192] := SELECT4(a[255:0], imm[7:6])
tmp_dst[319:256] := SELECT4(a[511:256], imm[1:0])
tmp_dst[383:320] := SELECT4(a[511:256], imm[3:2])
tmp_dst[447:384] := SELECT4(a[511:256], imm[5:4])
tmp_dst[511:448] := SELECT4(a[511:256], imm[7:6])
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp_dst[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpermpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_permutexvar_pd / vpermpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_permutexvar_pd">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="idx" type="__m512i"/>
	<parameter varname="a" type="__m512d"/>
	<description>Shuffle double-precision (64-bit) floating-point elements in "a" across lanes using the corresponding index in "idx", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	id := idx[i+2:i]*64
	IF k[j]
		dst[i+63:i] := a[id+63:id]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpermpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_permutex_pd / vpermpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_permutex_pd">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="imm" type="const int"/>
	<description>Shuffle double-precision (64-bit) floating-point elements in "a" within 256-bit lanes using the control in "imm", and store the results in "dst".</description>
	<description code="true">
SELECT4(src, control){
	CASE(control[1:0])
		0:	tmp[63:0] := src[63:0]
		1:	tmp[63:0] := src[127:64]
		2:	tmp[63:0] := src[191:128]
		3:	tmp[63:0] := src[255:192]
	ESAC
	RETURN tmp[63:0]
}

dst[63:0] := SELECT4(a[255:0], imm[1:0])
dst[127:64] := SELECT4(a[255:0], imm[3:2])
dst[191:128] := SELECT4(a[255:0], imm[5:4])
dst[255:192] := SELECT4(a[255:0], imm[7:6])
dst[319:256] := SELECT4(a[511:256], imm[1:0])
dst[383:320] := SELECT4(a[511:256], imm[3:2])
dst[447:384] := SELECT4(a[511:256], imm[5:4])
dst[511:448] := SELECT4(a[511:256], imm[7:6])
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpermpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_permutexvar_pd / vpermpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_permutexvar_pd">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="idx" type="__m512i"/>
	<parameter varname="a" type="__m512d"/>
	<description>Shuffle double-precision (64-bit) floating-point elements in "a" across lanes using the corresponding index in "idx", and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	id := idx[i+2:i]*64
	dst[i+63:i] := a[id+63:id]
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpermpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_permutexvar_ps / vpermps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_permutexvar_ps">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="src" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="idx" type="__m512i"/>
	<parameter varname="a" type="__m512"/>
	<description>Shuffle single-precision (32-bit) floating-point elements in "a" across lanes using the corresponding index in "idx", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	id := idx[i+3:i]*32
	IF k[j]
		dst[i+31:i] := a[id+31:id]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpermps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_permutexvar_ps / vpermps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_permutexvar_ps">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="idx" type="__m512i"/>
	<parameter varname="a" type="__m512"/>
	<description>Shuffle single-precision (32-bit) floating-point elements in "a" across lanes using the corresponding index in "idx", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	id := idx[i+3:i]*32
	IF k[j]
		dst[i+31:i] := a[id+31:id]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpermps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_permutexvar_ps / vpermps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_permutexvar_ps">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="idx" type="__m512i"/>
	<parameter varname="a" type="__m512"/>
	<description>Shuffle single-precision (32-bit) floating-point elements in "a" across lanes using the corresponding index in "idx".</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	id := idx[i+3:i]*32
	dst[i+31:i] := a[id+31:id]
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpermps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_permutex_epi64 / vpermq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_permutex_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="imm" type="const int"/>
	<description>Shuffle 64-bit integers in "a" within 256-bit lanes using the control in "imm", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<description code="true">
SELECT4(src, control){
	CASE(control[1:0])
		0:	tmp[63:0] := src[63:0]
		1:	tmp[63:0] := src[127:64]
		2:	tmp[63:0] := src[191:128]
		3:	tmp[63:0] := src[255:192]
	ESAC
	RETURN tmp[63:0]
}

tmp_dst[63:0] := SELECT4(a[255:0], imm[1:0])
tmp_dst[127:64] := SELECT4(a[255:0], imm[3:2])
tmp_dst[191:128] := SELECT4(a[255:0], imm[5:4])
tmp_dst[255:192] := SELECT4(a[255:0], imm[7:6])
tmp_dst[319:256] := SELECT4(a[511:256], imm[1:0])
tmp_dst[383:320] := SELECT4(a[511:256], imm[3:2])
tmp_dst[447:384] := SELECT4(a[511:256], imm[5:4])
tmp_dst[511:448] := SELECT4(a[511:256], imm[7:6])
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp_dst[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpermq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_permutexvar_epi64 / vpermq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_permutexvar_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="idx" type="__m512i"/>
	<parameter varname="a" type="__m512i"/>
	<description>Shuffle 64-bit integers in "a" across lanes using the corresponding index in "idx", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	id := idx[i+2:i]*64
	IF k[j]
		dst[i+63:i] := a[id+63:id]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpermq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_permutex_epi64 / vpermq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_permutex_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="imm" type="const int"/>
	<description>Shuffle 64-bit integers in "a" within 256-bit lanes using the control in "imm", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
SELECT4(src, control){
	CASE(control[1:0])
		0:	tmp[63:0] := src[63:0]
		1:	tmp[63:0] := src[127:64]
		2:	tmp[63:0] := src[191:128]
		3:	tmp[63:0] := src[255:192]
	ESAC
	RETURN tmp[63:0]
}

tmp_dst[63:0] := SELECT4(a[255:0], imm[1:0])
tmp_dst[127:64] := SELECT4(a[255:0], imm[3:2])
tmp_dst[191:128] := SELECT4(a[255:0], imm[5:4])
tmp_dst[255:192] := SELECT4(a[255:0], imm[7:6])
tmp_dst[319:256] := SELECT4(a[511:256], imm[1:0])
tmp_dst[383:320] := SELECT4(a[511:256], imm[3:2])
tmp_dst[447:384] := SELECT4(a[511:256], imm[5:4])
tmp_dst[511:448] := SELECT4(a[511:256], imm[7:6])
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp_dst[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpermq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_permutexvar_epi64 / vpermq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_permutexvar_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="idx" type="__m512i"/>
	<parameter varname="a" type="__m512i"/>
	<description>Shuffle 64-bit integers in "a" across lanes using the corresponding index in "idx", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	id := idx[i+2:i]*64
	IF k[j]
		dst[i+63:i] := a[id+63:id]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpermq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_permutex_epi64 / vpermq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_permutex_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="imm" type="const int"/>
	<description>Shuffle 64-bit integers in "a" within 256-bit lanes using the control in "imm", and store the results in "dst".</description>
	<description code="true">
SELECT4(src, control){
	CASE(control[1:0])
		0:	tmp[63:0] := src[63:0]
		1:	tmp[63:0] := src[127:64]
		2:	tmp[63:0] := src[191:128]
		3:	tmp[63:0] := src[255:192]
	ESAC
	RETURN tmp[63:0]
}

dst[63:0] := SELECT4(a[255:0], imm[1:0])
dst[127:64] := SELECT4(a[255:0], imm[3:2])
dst[191:128] := SELECT4(a[255:0], imm[5:4])
dst[255:192] := SELECT4(a[255:0], imm[7:6])
dst[319:256] := SELECT4(a[511:256], imm[1:0])
dst[383:320] := SELECT4(a[511:256], imm[3:2])
dst[447:384] := SELECT4(a[511:256], imm[5:4])
dst[511:448] := SELECT4(a[511:256], imm[7:6])
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpermq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_permutexvar_epi64 / vpermq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_permutexvar_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="idx" type="__m512i"/>
	<parameter varname="a" type="__m512i"/>
	<description>Shuffle 64-bit integers in "a" across lanes using the corresponding index in "idx", and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	id := idx[i+2:i]*64
	dst[i+63:i] := a[id+63:id]
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpermq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_expand_epi32 / vpexpandd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_expand_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<description>Load contiguous active 32-bit integers from "a" (those with their respective bit set in mask "k"), and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<description code="true">
m := 0
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := a[m+31:m]
		m := m + 32
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpexpandd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_expandloadu_epi32 / vpexpandd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_expandloadu_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Load</category>
	<category>Swizzle</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="mem_addr" type="void const*"/>
	<description>Load contiguous active 32-bit integers from unaligned memory at "mem_addr" (those with their respective bit set in mask "k"), and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<description code="true">
m := 0
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := MEM[mem_addr+m+31:mem_addr+m]
		m := m + 32
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpexpandd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_expand_epi32 / vpexpandd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_expand_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<description>Load contiguous active 32-bit integers from "a" (those with their respective bit set in mask "k"), and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
m := 0
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := a[m+31:m]
		m := m + 32
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpexpandd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_expandloadu_epi32 / vpexpandd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_expandloadu_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Load</category>
	<category>Swizzle</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="mem_addr" type="void const*"/>
	<description>Load contiguous active 32-bit integers from unaligned memory at "mem_addr" (those with their respective bit set in mask "k"), and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
m := 0
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := MEM[mem_addr+m+31:mem_addr+m]
		m := m + 32
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpexpandd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_expand_epi64 / vpexpandq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_expand_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<description>Load contiguous active 64-bit integers from "a" (those with their respective bit set in mask "k"), and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<description code="true">
m := 0
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[m+63:m]
		m := m + 64
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpexpandq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_expandloadu_epi64 / vpexpandq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_expandloadu_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Load</category>
	<category>Swizzle</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="mem_addr" type="void const*"/>
	<description>Load contiguous active 64-bit integers from unaligned memory at "mem_addr" (those with their respective bit set in mask "k"), and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<description code="true">
m := 0
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := MEM[mem_addr+m+63:mem_addr+m]
		m := m + 64
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpexpandq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_expand_epi64 / vpexpandq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_expand_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<description>Load contiguous active 64-bit integers from "a" (those with their respective bit set in mask "k"), and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
m := 0
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[m+63:m]
		m := m + 64
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpexpandq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_expandloadu_epi64 / vpexpandq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_expandloadu_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Load</category>
	<category>Swizzle</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="mem_addr" type="void const*"/>
	<description>Load contiguous active 64-bit integers from unaligned memory at "mem_addr" (those with their respective bit set in mask "k"), and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
m := 0
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := MEM[mem_addr+m+63:mem_addr+m]
		m := m + 64
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpexpandq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_i32gather_epi32 / vpgatherdd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_i32gather_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Load</category>
	<parameter varname="vindex" type="__m512i"/>
	<parameter varname="base_addr" type="void const*"/>
	<parameter varname="scale" type="int"/>
	<description>
	Gather 32-bit integers from memory using 32-bit indices. 32-bit elements are loaded from addresses starting at "base_addr" and offset by each 32-bit element in "vindex" (each index is scaled by the factor in "scale"). Gathered elements are merged into "dst". "scale" should be 1, 2, 4 or 8.
	</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := MEM[base_addr + SignExtend(vindex[i+31:i])*scale]
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpgatherdd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_i32gather_epi32 / vpgatherdd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_i32gather_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Load</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="vindex" type="__m512i"/>
	<parameter varname="base_addr" type="void const*"/>
	<parameter varname="scale" type="int"/>
	<description>
	Gather 32-bit integers from memory using 32-bit indices. 32-bit elements are loaded from addresses starting at "base_addr" and offset by each 32-bit element in "vindex" (each index is scaled by the factor in "scale"). Gathered elements are merged into "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). "scale" should be 1, 2, 4 or 8.
	</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := MEM[base_addr + SignExtend(vindex[i+31:i])*scale]
		k[j] := 0
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
k[MAX:16] := 0
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpgatherdd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_i32gather_epi64 / vpgatherdq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_i32gather_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Load</category>
	<parameter varname="vindex" type="__m256i"/>
	<parameter varname="base_addr" type="void const*"/>
	<parameter varname="scale" type="int"/>
	<description>Gather 64-bit integers from memory using 32-bit indices. 64-bit elements are loaded from addresses starting at "base_addr" and offset by each 32-bit element in "vindex" (each index is scaled by the factor in "scale"). Gathered elements are merged into "dst". "scale" should be 1, 2, 4 or 8.
	</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	m := j*32
	dst[i+63:i] := MEM[base_addr + SignExtend(vindex[m+31:m])*scale]
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpgatherdq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_i32gather_epi64 / vpgatherdq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_i32gather_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Load</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="vindex" type="__m256i"/>
	<parameter varname="base_addr" type="void const*"/>
	<parameter varname="scale" type="int"/>
	<description>Gather 64-bit integers from memory using 32-bit indices. 64-bit elements are loaded from addresses starting at "base_addr" and offset by each 32-bit element in "vindex" (each index is scaled by the factor in "scale"). Gathered elements are merged into "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). "scale" should be 1, 2, 4 or 8.
	</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	m := j*32
	IF k[j]
		dst[i+63:i] := MEM[base_addr + SignExtend(vindex[m+31:m])*scale]
		k[j] := 0
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
k[MAX:8] := 0
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpgatherdq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_i64gather_epi32 / vpgatherqd -->
<intrinsic tech="AVX-512" rettype="__m256i" name="_mm512_i64gather_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Load</category>
	<parameter varname="vindex" type="__m512i"/>
	<parameter varname="base_addr" type="void const*"/>
	<parameter varname="scale" type="int"/>
	<description>Gather 32-bit integers from memory using 64-bit indices. 32-bit elements are loaded from addresses starting at "base_addr" and offset by each 64-bit element in "vindex" (each index is scaled by the factor in "scale"). Gathered elements are merged into "dst". "scale" should be 1, 2, 4 or 8.
	</description>
	<description code="true">
FOR j := 0 to 7
	i := j*32
	m := j*64
	dst[i+31:i] := MEM[base_addr + SignExtend(vindex[i+63:i])*scale]
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base="vpgatherqd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_i64gather_epi32 / vpgatherqd -->
<intrinsic tech="AVX-512" rettype="__m256i" name="_mm512_mask_i64gather_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Load</category>
	<parameter varname="src" type="__m256i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="vindex" type="__m512i"/>
	<parameter varname="base_addr" type="void const*"/>
	<parameter varname="scale" type="int"/>
	<description>Gather 32-bit integers from memory using 64-bit indices. 32-bit elements are loaded from addresses starting at "base_addr" and offset by each 64-bit element in "vindex" (each index is scaled by the factor in "scale"). Gathered elements are merged into "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). "scale" should be 1, 2, 4 or 8.
	</description>
	<description code="true">
FOR j := 0 to 7
	i := j*32
	m := j*64
	IF k[j]
		dst[i+31:i] := MEM[base_addr + SignExtend(vindex[i+63:i])*scale]
		k[j] := 0
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
k[MAX:8] := 0
dst[MAX:256] := 0
	</description>
	<mnemonic base="vpgatherqd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_i64gather_epi64 / vpgatherqq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_i64gather_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Load</category>
	<parameter varname="vindex" type="__m512i"/>
	<parameter varname="base_addr" type="void const*"/>
	<parameter varname="scale" type="int"/>
	<description>Gather 64-bit integers from memory using 64-bit indices. 64-bit elements are loaded from addresses starting at "base_addr" and offset by each 64-bit element in "vindex" (each index is scaled by the factor in "scale"). Gathered elements are merged into "dst". "scale" should be 1, 2, 4 or 8.
	</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := MEM[base_addr + SignExtend(vindex[i+63:i])*scale]
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpgatherqq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_i64gather_epi64 / vpgatherqq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_i64gather_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Load</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="vindex" type="__m512i"/>
	<parameter varname="base_addr" type="void const*"/>
	<parameter varname="scale" type="int"/>
	<description>Gather 64-bit integers from memory using 64-bit indices. 64-bit elements are loaded from addresses starting at "base_addr" and offset by each 64-bit element in "vindex" (each index is scaled by the factor in "scale"). Gathered elements are merged into "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). "scale" should be 1, 2, 4 or 8.
	</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := MEM[base_addr + SignExtend(vindex[i+63:i])*scale]
		k[j] := 0
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
k[MAX:8] := 0
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpgatherqq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_lzcnt_epi32 / vplzcntd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_lzcnt_epi32">
	<CPUID>AVX-512.CDI</CPUID>
	<category>Bit Manipulation</category>
	<parameter varname="a" type="__m512i"/>
	<description>Counts the number of leading zero bits in each packed 32-bit integer in "a", and store the results in "dst". </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	tmp := 31
	dst[i+31:i] := 0
	DO WHILE (tmp &gt;= 0 AND a[i+tmp] == 0)
		tmp := tmp - 1
		dst[i+31:i] := dst[i+31:i] + 1
	OD
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vplzcntd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_lzcnt_epi32 / vplzcntd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_lzcnt_epi32">
	<CPUID>AVX-512.CDI</CPUID>
	<category>Bit Manipulation</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<description>Counts the number of leading zero bits in each packed 32-bit integer in "a", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		tmp := 31
		dst[i+31:i] := 0
		DO WHILE (tmp &gt;= 0 AND a[i+tmp] == 0)
			tmp := tmp - 1
			dst[i+31:i] := dst[i+31:i] + 1
		OD
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vplzcntd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_lzcnt_epi32 / vplzcntd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_lzcnt_epi32">
	<CPUID>AVX-512.CDI</CPUID>
	<category>Bit Manipulation</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<description>Counts the number of leading zero bits in each packed 32-bit integer in "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		tmp := 31
		dst[i+31:i] := 0
		DO WHILE (tmp &gt;= 0 AND a[i+tmp] == 0)
			tmp := tmp - 1
			dst[i+31:i] := dst[i+31:i] + 1
		OD
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vplzcntd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_lzcnt_epi64 / vplzcntq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_lzcnt_epi64">
	<CPUID>AVX-512.CDI</CPUID>
	<category>Bit Manipulation</category>
	<parameter varname="a" type="__m512i"/>
	<description>Counts the number of leading zero bits in each packed 64-bit integer in "a", and store the results in "dst". </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	tmp := 63
	dst[i+63:i] := 0
	DO WHILE (tmp &gt;= 0 AND a[i+tmp] == 0)
		tmp := tmp - 1
		dst[i+63:i] := dst[i+63:i] + 1
	OD
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vplzcntq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_lzcnt_epi64 / vplzcntq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_lzcnt_epi64">
	<CPUID>AVX-512.CDI</CPUID>
	<category>Bit Manipulation</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<description>Counts the number of leading zero bits in each packed 64-bit integer in "a", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		tmp := 63
		dst[i+63:i] := 0
		DO WHILE (tmp &gt;= 0 AND a[i+tmp] == 0)
			tmp := tmp - 1
			dst[i+63:i] := dst[i+63:i] + 1
		OD
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vplzcntq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_lzcnt_epi64 / vplzcntq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_lzcnt_epi64">
	<CPUID>AVX-512.CDI</CPUID>
	<category>Bit Manipulation</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<description>Counts the number of leading zero bits in each packed 64-bit integer in "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		tmp := 63
		dst[i+63:i] := 0
		DO WHILE (tmp &gt;= 0 AND a[i+tmp] == 0)
			tmp := tmp - 1
			dst[i+63:i] := dst[i+63:i] + 1
		OD
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vplzcntq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_max_epi32 / vpmaxsd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_max_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed 32-bit integers in "a" and "b", and store packed maximum values in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF a[i+31:i] &gt; b[i+31:i]
			dst[i+31:i] := a[i+31:i]
		ELSE
			dst[i+31:i] := b[i+31:i]
		FI
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpmaxsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_max_epi32 / vpmaxsd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_max_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed 32-bit integers in "a" and "b", and store packed maximum values in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF a[i+31:i] &gt; b[i+31:i]
			dst[i+31:i] := a[i+31:i]
		ELSE
			dst[i+31:i] := b[i+31:i]
		FI
	ELSE
		dst[i+31:i] := 0 
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpmaxsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_max_epi32 / vpmaxsd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_max_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed 32-bit integers in "a" and "b", and store packed maximum values in "dst".</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF a[i+31:i] &gt; b[i+31:i]
		dst[i+31:i] := a[i+31:i]
	ELSE
		dst[i+31:i] := b[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpmaxsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_max_epi64 / vpmaxsq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_max_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed 64-bit integers in "a" and "b", and store packed maximum values in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF a[i+63:i] &gt; b[i+63:i]
			dst[i+63:i] := a[i+63:i]
		ELSE
			dst[i+63:i] := b[i+63:i]
		FI
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpmaxsq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_max_epi64 / vpmaxsq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_max_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed 64-bit integers in "a" and "b", and store packed maximum values in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF a[i+63:i] &gt; b[i+63:i]
			dst[i+63:i] := a[i+63:i]
		ELSE
			dst[i+63:i] := b[i+63:i]
		FI
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpmaxsq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_max_epi64 / vpmaxsq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_max_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed 64-bit integers in "a" and "b", and store packed maximum values in "dst".</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF a[i+63:i] &gt; b[i+63:i]
		dst[i+63:i] := a[i+63:i]
	ELSE
		dst[i+63:i] := b[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpmaxsq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_max_epu32 / vpmaxud -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_max_epu32">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed unsigned 32-bit integers in "a" and "b", and store packed maximum values in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF a[i+31:i] &gt; b[i+31:i]
			dst[i+31:i] := a[i+31:i]
		ELSE
			dst[i+31:i] := b[i+31:i]
		FI
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpmaxud"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_max_epu32 / vpmaxud -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_max_epu32">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed unsigned 32-bit integers in "a" and "b", and store packed maximum values in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF a[i+31:i] &gt; b[i+31:i]
			dst[i+31:i] := a[i+31:i]
		ELSE
			dst[i+31:i] := b[i+31:i]
		FI
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpmaxud"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_max_epu32 / vpmaxud -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_max_epu32">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed unsigned 32-bit integers in "a" and "b", and store packed maximum values in "dst".</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF a[i+31:i] &gt; b[i+31:i]
		dst[i+31:i] := a[i+31:i]
	ELSE
		dst[i+31:i] := b[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpmaxud"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_max_epu64 / vpmaxuq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_max_epu64">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed unsigned 64-bit integers in "a" and "b", and store packed maximum values in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF a[i+63:i] &gt; b[i+63:i]
			dst[i+63:i] := a[i+63:i]
		ELSE
			dst[i+63:i] := b[i+63:i]
		FI
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpmaxuq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_max_epu64 / vpmaxuq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_max_epu64">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed unsigned 64-bit integers in "a" and "b", and store packed maximum values in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF a[i+63:i] &gt; b[i+63:i]
			dst[i+63:i] := a[i+63:i]
		ELSE
			dst[i+63:i] := b[i+63:i]
		FI
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpmaxuq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_max_epu64 / vpmaxuq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_max_epu64">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed unsigned 64-bit integers in "a" and "b", and store packed maximum values in "dst". </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF a[i+63:i] &gt; b[i+63:i]
		dst[i+63:i] := a[i+63:i]
	ELSE
		dst[i+63:i] := b[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpmaxuq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_min_epi32 / vpminsd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_min_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed 32-bit integers in "a" and "b", and store packed minimum values in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF a[i+31:i] &lt; b[i+31:i]
				dst[i+31:i] := a[i+31:i]
		ELSE
			dst[i+31:i] := b[i+31:i]
		FI
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpminsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_min_epi32 / vpminsd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_min_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed 32-bit integers in "a" and "b", and store packed minimum values in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF a[i+31:i] &lt; b[i+31:i]
			dst[i+31:i] := a[i+31:i]
		ELSE
			dst[i+31:i] := b[i+31:i]
		FI
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpminsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_min_epi32 / vpminsd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_min_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed 32-bit integers in "a" and "b", and store packed minimum values in "dst".
	</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF a[i+31:i] &lt; b[i+31:i]
		dst[i+31:i] := a[i+31:i]
	ELSE
		dst[i+31:i] := b[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpminsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_min_epi64 / vpminsq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_min_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed 64-bit integers in "a" and "b", and store packed minimum values in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF a[i+63:i] &lt; b[i+63:i]
			dst[i+63:i] := a[i+63:i]
		ELSE
			dst[i+63:i] := b[i+63:i]
		FI
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpminsq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_min_epi64 / vpminsq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_min_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed 64-bit integers in "a" and "b", and store packed minimum values in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF a[i+63:i] &lt; b[i+63:i]
			dst[i+63:i] := a[i+63:i]
		ELSE
			dst[i+63:i] := b[i+63:i]
		FI
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpminsq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_min_epi64 / vpminsq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_min_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed 64-bit integers in "a" and "b", and store packed minimum values in "dst".</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF a[i+63:i] &lt; b[i+63:i]
		dst[i+63:i] := a[i+63:i]
	ELSE
		dst[i+63:i] := b[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpminsq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_min_epu32 / vpminud -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_min_epu32">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed unsigned 32-bit integers in "a" and "b", and store packed minimum values in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF a[i+31:i] &lt; b[i+31:i]
			dst[i+31:i] := a[i+31:i]
		ELSE
			dst[i+31:i] := b[i+31:i]
		FI
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpminud"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_min_epu32 / vpminud -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_min_epu32">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed unsigned 32-bit integers in "a" and "b", and store packed minimum values in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF a[i+31:i] &lt; b[i+31:i]
			dst[i+31:i] := a[i+31:i]
		ELSE
			dst[i+31:i] := b[i+31:i]
		FI
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpminud"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_min_epu32 / vpminud -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_min_epu32">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed unsigned 32-bit integers in "a" and "b", and store packed minimum values in "dst".
	</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF a[i+31:i] &lt; b[i+31:i]
		dst[i+31:i] := a[i+31:i]
	ELSE
		dst[i+31:i] := b[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpminud"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_min_epu64 / vpminuq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_min_epu64">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed unsigned 64-bit integers in "a" and "b", and store packed minimum values in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF a[i+63:i] &lt; b[i+63:i]
			dst[i+63:i] := a[i+63:i]
		ELSE
			dst[i+63:i] := b[i+63:i]
		FI
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpminuq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_min_epu64 / vpminuq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_min_epu64">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed unsigned 64-bit integers in "a" and "b", and store packed minimum values in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF a[i+63:i] &lt; b[i+63:i]
			dst[i+63:i] := a[i+63:i]
		ELSE
			dst[i+63:i] := b[i+63:i]
		FI
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpminuq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_min_epu64 / vpminuq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_min_epu64">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compare packed unsigned 64-bit integers in "a" and "b", and store packed minimum values in "dst".</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF a[i+63:i] &lt; b[i+63:i]
		dst[i+63:i] := a[i+63:i]
	ELSE
		dst[i+63:i] := b[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpminuq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cvtepi32_epi8 / vpmovdb -->
<intrinsic tech="AVX-512" rettype="__m128i" name="_mm512_cvtepi32_epi8">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m512i"/>
	<description>Convert packed 32-bit integers in "a" to packed 8-bit integers with truncation, and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 15
	i := 32*j
	k := 8*j
	dst[k+7:k] := Truncate_Int32_To_Int8(a[i+31:i])
ENDFOR
dst[MAX:128] := 0
	</description>
	<mnemonic base="vpmovdb"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvtepi32_epi8 / vpmovdb -->
<intrinsic tech="AVX-512" rettype="__m128i" name="_mm512_mask_cvtepi32_epi8">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="src" type="__m128i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<description>Convert packed 32-bit integers in "a" to packed 8-bit integers with truncation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := 32*j
	l := 8*j
	IF k[j]
		dst[l+7:l] := Truncate_Int32_To_Int8(a[i+31:i])
	ELSE
		dst[l+7:l] := src[l+7:l]
	FI
ENDFOR
dst[MAX:128] := 0
	</description>
	<mnemonic base="vpmovdb"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvtepi32_storeu_epi8 / vpmovdb -->
<intrinsic tech="AVX-512" rettype="void" name="_mm512_mask_cvtepi32_storeu_epi8">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<category>Store</category>
	<parameter varname="base_addr" type="void*"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<description>Convert packed 32-bit integers in "a" to packed 8-bit integers with truncation, and store the active results (those with their respective bit set in writemask "k") to unaligned memory at "base_addr".</description>
	<description code="true">
FOR j := 0 to 15
	i := 32*j
	l := 8*j
	IF k[j]
		MEM[base_addr+l+7:base_addr+l] := Truncate_Int32_To_Int8(a[i+31:i])
	FI
ENDFOR
	</description>
	<mnemonic base="vpmovdb"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_cvtepi32_epi8 / vpmovdb -->
<intrinsic tech="AVX-512" rettype="__m128i" name="_mm512_maskz_cvtepi32_epi8">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<description>Convert packed 32-bit integers in "a" to packed 8-bit integers with truncation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := 32*j
	l := 8*j
	IF k[j]
		dst[l+7:l] := Truncate_Int32_To_Int8(a[i+31:i])
	ELSE
		dst[l+7:l] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</description>
	<mnemonic base="vpmovdb"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cvtepi32_epi16 / vpmovdw -->
<intrinsic tech="AVX-512" rettype="__m256i" name="_mm512_cvtepi32_epi16">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m512i"/>
	<description>Convert packed 32-bit integers in "a" to packed 16-bit integers with truncation, and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 15
	i := 32*j
	k := 16*j
	dst[k+15:k] := Truncate_Int32_To_Int16(a[i+31:i])
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base="vpmovdw"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvtepi32_epi16 / vpmovdw -->
<intrinsic tech="AVX-512" rettype="__m256i" name="_mm512_mask_cvtepi32_epi16">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="src" type="__m256i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<description>Convert packed 32-bit integers in "a" to packed 16-bit integers with truncation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := 32*j
	l := 16*j
	IF k[j]
		dst[l+15:l] := Truncate_Int32_To_Int16(a[i+31:i])
	ELSE
		dst[l+15:l] := src[l+15:l]
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base="vpmovdw"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvtepi32_storeu_epi16 / vpmovdw -->
<intrinsic tech="AVX-512" rettype="void" name="_mm512_mask_cvtepi32_storeu_epi16">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<category>Store</category>
	<parameter varname="base_addr" type="void*"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<description>Convert packed 32-bit integers in "a" to packed 16-bit integers with truncation, and store the active results (those with their respective bit set in writemask "k") to unaligned memory at "base_addr".</description>
	<description code="true">
FOR j := 0 to 15
	i := 32*j
	l := 16*j
	IF k[j]
		MEM[base_addr+l+15:base_addr+l] := Truncate_Int32_To_Int16(a[i+31:i])
	FI
ENDFOR
	</description>
	<mnemonic base="vpmovdw"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_cvtepi32_epi16 / vpmovdw -->
<intrinsic tech="AVX-512" rettype="__m256i" name="_mm512_maskz_cvtepi32_epi16">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<description>Convert packed 32-bit integers in "a" to packed 16-bit integers with truncation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := 32*j
	l := 16*j
	IF k[j]
		dst[l+15:l] := Truncate_Int32_To_Int16(a[i+31:i])
	ELSE
		dst[l+15:l] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base="vpmovdw"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cvtepi64_epi8 / vpmovqb -->
<intrinsic tech="AVX-512" rettype="__m128i" name="_mm512_cvtepi64_epi8">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m512i"/>
	<description>Convert packed 64-bit integers in "a" to packed 8-bit integers with truncation, and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 7
	i := 64*j
	k := 8*j
	dst[k+7:k] := Truncate_Int64_To_Int8(a[i+63:i])
ENDFOR
dst[MAX:128] := 0
	</description>
	<mnemonic base="vpmovqb"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvtepi64_epi8 / vpmovqb -->
<intrinsic tech="AVX-512" rettype="__m128i" name="_mm512_mask_cvtepi64_epi8">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="src" type="__m128i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<description>Convert packed 64-bit integers in "a" to packed 8-bit integers with truncation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := 64*j
	l := 8*j
	IF k[j]
		dst[l+7:l] := Truncate_Int64_To_Int8(a[i+63:i])
	ELSE
		dst[l+7:l] := src[l+7:l]
	FI
ENDFOR
dst[MAX:128] := 0
	</description>
	<mnemonic base="vpmovqb"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvtepi64_storeu_epi8 / vpmovqb -->
<intrinsic tech="AVX-512" rettype="void" name="_mm512_mask_cvtepi64_storeu_epi8">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<category>Store</category>
	<parameter varname="base_addr" type="void*"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<description>Convert packed 64-bit integers in "a" to packed 8-bit integers with truncation, and store the active results (those with their respective bit set in writemask "k") to unaligned memory at "base_addr".</description>
	<description code="true">
FOR j := 0 to 7
	i := 64*j
	l := 8*j
	IF k[j]
		MEM[base_addr+l+7:base_addr+l] := Truncate_Int64_To_Int8(a[i+63:i])
	FI
ENDFOR
	</description>
	<mnemonic base="vpmovqb"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_cvtepi64_epi8 / vpmovqb -->
<intrinsic tech="AVX-512" rettype="__m128i" name="_mm512_maskz_cvtepi64_epi8">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<description>Convert packed 64-bit integers in "a" to packed 8-bit integers with truncation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := 64*j
	l := 8*j
	IF k[j]
		dst[l+7:l] := Truncate_Int64_To_Int8(a[i+63:i])
	ELSE
		dst[l+7:l] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</description>
	<mnemonic base="vpmovqb"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cvtepi64_epi32 / vpmovqd -->
<intrinsic tech="AVX-512" rettype="__m256i" name="_mm512_cvtepi64_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m512i"/>
	<description>Convert packed 64-bit integers in "a" to packed 32-bit integers with truncation, and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 7
	i := 64*j
	k := 32*j
	dst[k+31:k] := Truncate_Int64_To_Int32(a[i+63:i])
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base="vpmovqd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvtepi64_epi32 / vpmovqd -->
<intrinsic tech="AVX-512" rettype="__m256i" name="_mm512_mask_cvtepi64_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="src" type="__m256i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<description>Convert packed 64-bit integers in "a" to packed 32-bit integers with truncation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := 64*j
	l := 32*j
	IF k[j]
		dst[l+31:l] := Truncate_Int64_To_Int32(a[i+63:i])
	ELSE
		dst[l+31:l] := src[l+31:l]
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base="vpmovqd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvtepi64_storeu_epi32 / vpmovqd -->
<intrinsic tech="AVX-512" rettype="void" name="_mm512_mask_cvtepi64_storeu_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<category>Store</category>
	<parameter varname="base_addr" type="void*"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<description>Convert packed 64-bit integers in "a" to packed 32-bit integers with truncation, and store the active results (those with their respective bit set in writemask "k") to unaligned memory at "base_addr".</description>
	<description code="true">
FOR j := 0 to 7
	i := 64*j
	l := 32*j
	IF k[j]
		MEM[base_addr+l+31:base_addr+l] := Truncate_Int64_To_Int16(a[i+63:i])
	FI
ENDFOR
	</description>
	<mnemonic base="vpmovqd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_cvtepi64_epi32 / vpmovqd -->
<intrinsic tech="AVX-512" rettype="__m256i" name="_mm512_maskz_cvtepi64_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<description>Convert packed 64-bit integers in "a" to packed 32-bit integers with truncation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := 64*j
	l := 32*j
	IF k[j]
		dst[l+31:l] := Truncate_Int64_To_Int32(a[i+63:i])
	ELSE
		dst[l+31:l] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base="vpmovqd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cvtepi64_epi16 / vpmovqw -->
<intrinsic tech="AVX-512" rettype="__m128i" name="_mm512_cvtepi64_epi16">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m512i"/>
	<description>Convert packed 64-bit integers in "a" to packed 16-bit integers with truncation, and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 7
	i := 64*j
	k := 16*j
	dst[k+15:k] := Truncate_Int64_To_Int16(a[i+63:i])
ENDFOR
dst[MAX:128] := 0
	</description>
	<mnemonic base="vpmovqw"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvtepi64_epi16 / vpmovqw -->
<intrinsic tech="AVX-512" rettype="__m128i" name="_mm512_mask_cvtepi64_epi16">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="src" type="__m128i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<description>Convert packed 64-bit integers in "a" to packed 16-bit integers with truncation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := 64*j
	l := 16*j
	IF k[j]
		dst[l+15:l] := Truncate_Int64_To_Int16(a[i+63:i])
	ELSE
		dst[l+15:l] := src[l+15:l]
	FI
ENDFOR
dst[MAX:128] := 0
	</description>
	<mnemonic base="vpmovqw"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvtepi64_storeu_epi16 / vpmovqw -->
<intrinsic tech="AVX-512" rettype="void" name="_mm512_mask_cvtepi64_storeu_epi16">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<category>Store</category>
	<parameter varname="base_addr" type="void*"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<description>Convert packed 64-bit integers in "a" to packed 16-bit integers with truncation, and store the active results (those with their respective bit set in writemask "k") to unaligned memory at "base_addr".</description>
	<description code="true">
FOR j := 0 to 7
	i := 64*j
	l := 16*j
	IF k[j]
		MEM[base_addr+l+15:base_addr+l] := Truncate_Int64_To_Int16(a[i+63:i])
	FI
ENDFOR
	</description>
	<mnemonic base="vpmovqw"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_cvtepi64_epi16 / vpmovqw -->
<intrinsic tech="AVX-512" rettype="__m128i" name="_mm512_maskz_cvtepi64_epi16">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<description>Convert packed 64-bit integers in "a" to packed 16-bit integers with truncation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := 64*j
	l := 16*j
	IF k[j]
		dst[l+15:l] := Truncate_Int64_To_Int16(a[i+63:i])
	ELSE
		dst[l+15:l] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</description>
	<mnemonic base="vpmovqw"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cvtsepi32_epi8 / vpmovsdb -->
<intrinsic tech="AVX-512" rettype="__m128i" name="_mm512_cvtsepi32_epi8">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m512i"/>
	<description>Convert packed 32-bit integers in "a" to packed 8-bit integers with signed saturation, and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 15
	i := 32*j
	k := 8*j
	dst[k+7:k] := Saturate_Int32_To_Int8(a[i+31:i])
ENDFOR
dst[MAX:128] := 0
	</description>
	<mnemonic base="vpmovsdb"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvtsepi32_epi8 / vpmovsdb -->
<intrinsic tech="AVX-512" rettype="__m128i" name="_mm512_mask_cvtsepi32_epi8">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="src" type="__m128i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<description>Convert packed 32-bit integers in "a" to packed 8-bit integers with signed saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := 32*j
	l := 8*j
	IF k[j]
		dst[l+7:l] := Saturate_Int32_To_Int8(a[i+31:i])
	ELSE
		dst[l+7:l] := src[l+7:l]
	FI
ENDFOR
dst[MAX:128] := 0
	</description>
	<mnemonic base="vpmovsdb"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvtsepi32_storeu_epi8 / vpmovsdb -->
<intrinsic tech="AVX-512" rettype="void" name="_mm512_mask_cvtsepi32_storeu_epi8">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<category>Store</category>
	<parameter varname="base_addr" type="void*"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<description>Convert packed 32-bit integers in "a" to packed 8-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask "k") to unaligned memory at "base_addr".</description>
	<description code="true">
FOR j := 0 to 15
	i := 32*j
	l := 8*j
	IF k[j]
		MEM[base_addr+l+7:base_addr+l] := Saturate_Int32_To_Int8(a[i+31:i])
	FI
ENDFOR
	</description>
	<mnemonic base="vpmovsdb"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_cvtsepi32_epi8 / vpmovsdb -->
<intrinsic tech="AVX-512" rettype="__m128i" name="_mm512_maskz_cvtsepi32_epi8">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<description>Convert packed 32-bit integers in "a" to packed 8-bit integers with signed saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := 32*j
	l := 8*j
	IF k[j]
		dst[l+7:l] := Saturate_Int32_To_Int8(a[i+31:i])
	ELSE
		dst[l+7:l] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</description>
	<mnemonic base="vpmovsdb"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cvtsepi32_epi16 / vpmovsdw -->
<intrinsic tech="AVX-512" rettype="__m256i" name="_mm512_cvtsepi32_epi16">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m512i"/>
	<description>Convert packed 32-bit integers in "a" to packed 16-bit integers with signed saturation, and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 15
	i := 32*j
	k := 16*j
	dst[k+15:k] := Saturate_Int32_To_Int16(a[i+31:i])
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base="vpmovsdw"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvtsepi32_epi16 / vpmovsdw -->
<intrinsic tech="AVX-512" rettype="__m256i" name="_mm512_mask_cvtsepi32_epi16">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="src" type="__m256i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<description>Convert packed 32-bit integers in "a" to packed 16-bit integers with signed saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := 32*j
	l := 16*j
	IF k[j]
		dst[l+15:l] := Saturate_Int32_To_Int16(a[i+31:i])
	ELSE
		dst[l+15:l] := src[l+15:l]
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base="vpmovsdw"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvtsepi32_storeu_epi16 / vpmovsdw -->
<intrinsic tech="AVX-512" rettype="void" name="_mm512_mask_cvtsepi32_storeu_epi16">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<category>Store</category>
	<parameter varname="base_addr" type="void*"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<description>Convert packed 32-bit integers in "a" to packed 16-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask "k") to unaligned memory at "base_addr".</description>
	<description code="true">
FOR j := 0 to 15
	i := 32*j
	l := 16*j
	IF k[j]
		MEM[base_addr+l+15:base_addr+l] := Saturate_Int32_To_Int16(a[i+31:i])
	FI
ENDFOR
	</description>
	<mnemonic base="vpmovsdw"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_cvtsepi32_epi16 / vpmovsdw -->
<intrinsic tech="AVX-512" rettype="__m256i" name="_mm512_maskz_cvtsepi32_epi16">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<description>Convert packed 32-bit integers in "a" to packed 16-bit integers with signed saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := 32*j
	l := 16*j
	IF k[j]
		dst[l+15:l] := Saturate_Int32_To_Int16(a[i+31:i])
	ELSE
		dst[l+15:l] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base="vpmovsdw"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cvtsepi64_epi8 / vpmovsqb -->
<intrinsic tech="AVX-512" rettype="__m128i" name="_mm512_cvtsepi64_epi8">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m512i"/>
	<description>Convert packed 64-bit integers in "a" to packed 8-bit integers with signed saturation, and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 7
	i := 64*j
	k := 8*j
	dst[k+7:k] := Saturate_Int64_To_Int8(a[i+63:i])
ENDFOR
dst[MAX:64] := 0
	</description>
	<mnemonic base="vpmovsqb"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvtsepi64_epi8 / vpmovsqb -->
<intrinsic tech="AVX-512" rettype="__m128i" name="_mm512_mask_cvtsepi64_epi8">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="src" type="__m128i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<description>Convert packed 64-bit integers in "a" to packed 8-bit integers with signed saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := 64*j
	l := 8*j
	IF k[j]
		dst[l+7:l] := Saturate_Int64_To_Int8(a[i+63:i])
	ELSE
		dst[l+7:l] := src[l+7:l]
	FI
ENDFOR
dst[MAX:64] := 0
	</description>
	<mnemonic base="vpmovsqb"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvtsepi64_storeu_epi8 / vpmovsqb -->
<intrinsic tech="AVX-512" rettype="void" name="_mm512_mask_cvtsepi64_storeu_epi8">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<category>Store</category>
	<parameter varname="base_addr" type="void*"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<description>Convert packed 64-bit integers in "a" to packed 8-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask "k") to unaligned memory at "base_addr".</description>
	<description code="true">
FOR j := 0 to 7
	i := 64*j
	l := 8*j
	IF k[j]
		MEM[base_addr+l+7:base_addr+l] := Saturate_Int64_To_Int8(a[i+63:i])
	FI
ENDFOR
	</description>
	<mnemonic base="vpmovsqb"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_cvtsepi64_epi8 / vpmovsqb -->
<intrinsic tech="AVX-512" rettype="__m128i" name="_mm512_maskz_cvtsepi64_epi8">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<description>Convert packed 64-bit integers in "a" to packed 8-bit integers with signed saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := 64*j
	l := 8*j
	IF k[j]
		dst[l+7:l] := Saturate_Int64_To_Int8(a[i+63:i])
	ELSE
		dst[l+7:l] := 0
	FI
ENDFOR
dst[MAX:64] := 0
	</description>
	<mnemonic base="vpmovsqb"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cvtsepi64_epi32 / vpmovsqd -->
<intrinsic tech="AVX-512" rettype="__m256i" name="_mm512_cvtsepi64_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m512i"/>
	<description>Convert packed 64-bit integers in "a" to packed 32-bit integers with signed saturation, and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 7
	i := 64*j
	k := 32*j
	dst[k+31:k] := Saturate_Int64_To_Int32(a[i+63:i])
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base="vpmovsqd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvtsepi64_epi32 / vpmovsqd -->
<intrinsic tech="AVX-512" rettype="__m256i" name="_mm512_mask_cvtsepi64_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="src" type="__m256i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<description>Convert packed 64-bit integers in "a" to packed 32-bit integers with signed saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := 64*j
	l := 32*j
	IF k[j]
		dst[l+31:l] := Saturate_Int64_To_Int32(a[i+63:i])
	ELSE
		dst[l+31:l] := src[l+31:l]
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base="vpmovsqd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvtsepi64_storeu_epi32 / vpmovsqd -->
<intrinsic tech="AVX-512" rettype="void" name="_mm512_mask_cvtsepi64_storeu_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<category>Store</category>
	<parameter varname="base_addr" type="void*"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<description>Convert packed 64-bit integers in "a" to packed 32-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask "k") to unaligned memory at "base_addr".</description>
	<description code="true">
FOR j := 0 to 7
	i := 64*j
	l := 32*j
	IF k[j]
		MEM[base_addr+l+31:base_addr+l] := Saturate_Int64_To_Int32(a[i+63:i])
	FI
ENDFOR
	</description>
	<mnemonic base="vpmovsqd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_cvtsepi64_epi32 / vpmovsqd -->
<intrinsic tech="AVX-512" rettype="__m256i" name="_mm512_maskz_cvtsepi64_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<description>Convert packed 64-bit integers in "a" to packed 32-bit integers with signed saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := 64*j
	l := 32*j
	IF k[j]
		dst[l+31:l] := Saturate_Int64_To_Int32(a[i+63:i])
	ELSE
		dst[l+31:l] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base="vpmovsqd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cvtsepi64_epi16 / vpmovsqw -->
<intrinsic tech="AVX-512" rettype="__m128i" name="_mm512_cvtsepi64_epi16">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m512i"/>
	<description>Convert packed 64-bit integers in "a" to packed 16-bit integers with signed saturation, and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 7
	i := 64*j
	k := 16*j
	dst[k+15:k] := Saturate_Int64_To_Int16(a[i+63:i])
ENDFOR
dst[MAX:128] := 0
	</description>
	<mnemonic base="vpmovsqw"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvtsepi64_epi16 / vpmovsqw -->
<intrinsic tech="AVX-512" rettype="__m128i" name="_mm512_mask_cvtsepi64_epi16">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="src" type="__m128i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<description>Convert packed 64-bit integers in "a" to packed 16-bit integers with signed saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := 64*j
	l := 16*j
	IF k[j]
		dst[l+15:l] := Saturate_Int64_To_Int16(a[i+63:i])
	ELSE
		dst[l+15:l] := src[l+15:l]
	FI
ENDFOR
dst[MAX:128] := 0
	</description>
	<mnemonic base="vpmovsqw"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvtsepi64_storeu_epi16 / vpmovsqw -->
<intrinsic tech="AVX-512" rettype="void" name="_mm512_mask_cvtsepi64_storeu_epi16">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<category>Store</category>
	<parameter varname="base_addr" type="void*"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<description>Convert packed 64-bit integers in "a" to packed 16-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask "k") to unaligned memory at "base_addr".</description>
	<description code="true">
FOR j := 0 to 7
	i := 64*j
	l := 16*j
	IF k[j]
		MEM[base_addr+l+15:base_addr+l] := Saturate_Int64_To_Int16(a[i+63:i])
	FI
ENDFOR
	</description>
	<mnemonic base="vpmovsqw"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_cvtsepi64_epi16 / vpmovsqw -->
<intrinsic tech="AVX-512" rettype="__m128i" name="_mm512_maskz_cvtsepi64_epi16">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<description>Convert packed 64-bit integers in "a" to packed 16-bit integers with signed saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := 64*j
	l := 16*j
	IF k[j]
		dst[l+15:l] := Saturate_Int64_To_Int16(a[i+63:i])
	ELSE
		dst[l+15:l] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</description>
	<mnemonic base="vpmovsqw"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cvtepi8_epi32 / vpmovsxbd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_cvtepi8_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m128i"/>
	<description>Sign extend packed 8-bit integers in "a" to packed 32-bit integers, and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 15
	i := 32*j
	k := 8*j
	dst[i+31:i] := SignExtend(a[k+7:k])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpmovsxbd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvtepi8_epi32 / vpmovsxbd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_cvtepi8_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m128i"/>
	<description>Sign extend packed 8-bit integers in "a" to packed 32-bit integers, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := 32*j
	l := 8*j
	IF k[j]
		dst[i+31:i] := SignExtend(a[l+7:l])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpmovsxbd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_cvtepi8_epi32 / vpmovsxbd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_cvtepi8_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m128i"/>
	<description>Sign extend packed 8-bit integers in "a" to packed 32-bit integers, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := 32*j
	l := 8*j
	IF k[j]
		dst[i+31:i] := SignExtend(a[l+7:l])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpmovsxbd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cvtepi8_epi64 / vpmovsxbq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_cvtepi8_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m128i"/>
	<description>Sign extend packed 8-bit integers in the low 8 bytes of "a" to packed 64-bit integers, and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 7
	i := 64*j
	k := 8*j
	dst[i+63:i] := SignExtend(a[k+7:k])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpmovsxbq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvtepi8_epi64 / vpmovsxbq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_cvtepi8_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128i"/>
	<description>Sign extend packed 8-bit integers in the low 8 bytes of "a" to packed 64-bit integers, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := 64*j
	l := 8*j
	IF k[j]
		dst[i+63:i] := SignExtend(a[l+7:l])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpmovsxbq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_cvtepi8_epi64 / vpmovsxbq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_cvtepi8_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128i"/>
	<description>Sign extend packed 8-bit integers in the low 8 bytes of "a" to packed 64-bit integers, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := 64*j
	l := 8*j
	IF k[j]
		dst[i+63:i] := SignExtend(a[l+7:l])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpmovsxbq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cvtepi32_epi64 / vpmovsxdq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_cvtepi32_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m256i"/>
	<description>Sign extend packed 32-bit integers in "a" to packed 64-bit integers, and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 7
	i := 64*j
	k := 32*j
	dst[i+63:i] := SignExtend(a[k+31:k])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpmovsxdq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvtepi32_epi64 / vpmovsxdq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_cvtepi32_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m256i"/>
	<description>Sign extend packed 32-bit integers in "a" to packed 64-bit integers, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := 64*j
	l := 32*j
	IF k[j]
		dst[i+63:i] := SignExtend(a[l+31:l])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpmovsxdq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_cvtepi32_epi64 / vpmovsxdq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_cvtepi32_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m256i"/>
	<description>Sign extend packed 32-bit integers in "a" to packed 64-bit integers, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 7
	i := 64*j
	l := 32*j
	IF k[j]
		dst[i+63:i] := SignExtend(a[l+31:l])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpmovsxdq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cvtepi16_epi32 / vpmovsxwd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_cvtepi16_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m256i"/>
	<description>Sign extend packed 16-bit integers in "a" to packed 32-bit integers, and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 15
	i := 32*j
	k := 16*j
	dst[i+31:i] := SignExtend(a[k+15:k])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpmovsxwd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvtepi16_epi32 / vpmovsxwd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_cvtepi16_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m256i"/>
	<description>Sign extend packed 16-bit integers in "a" to packed 32-bit integers, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	l := j*16
	IF k[j]
		dst[i+31:i] := SignExtend(a[l+15:l])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpmovsxwd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_cvtepi16_epi32 / vpmovsxwd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_cvtepi16_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m256i"/>
	<description>Sign extend packed 16-bit integers in "a" to packed 32-bit integers, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 15
	i := 32*j
	l := 16*j
	IF k[j]
		dst[i+31:i] := SignExtend(a[l+15:l])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpmovsxwd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cvtepi16_epi64 / vpmovsxwq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_cvtepi16_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m128i"/>
	<description>Sign extend packed 16-bit integers in "a" to packed 64-bit integers, and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 7
	i := 64*j
	k := 16*j
	dst[i+63:i] := SignExtend(a[k+15:k])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpmovsxwq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvtepi16_epi64 / vpmovsxwq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_cvtepi16_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128i"/>
	<description>Sign extend packed 16-bit integers in "a" to packed 64-bit integers, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := 64*j
	l := 16*j
	IF k[j]
		dst[i+63:i] := SignExtend(a[l+15:l])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpmovsxwq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_cvtepi16_epi64 / vpmovsxwq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_cvtepi16_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128i"/>
	<description>Sign extend packed 16-bit integers in "a" to packed 64-bit integers, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := 64*j
	l := 16*j
	IF k[j]
		dst[i+63:i] := SignExtend(a[l+15:l])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpmovsxwq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cvtusepi32_epi8 / vpmovusdb -->
<intrinsic tech="AVX-512" rettype="__m128i" name="_mm512_cvtusepi32_epi8">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m512i"/>
	<description>Convert packed unsigned 32-bit integers in "a" to packed unsigned 8-bit integers with unsigned saturation, and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 15
	i := 32*j
	k := 8*j
	dst[k+7:k] := Saturate_UnsignedInt32_To_Int8(a[i+31:i])
ENDFOR
dst[MAX:128] := 0
	</description>
	<mnemonic base="vpmovusdb"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvtusepi32_epi8 / vpmovusdb -->
<intrinsic tech="AVX-512" rettype="__m128i" name="_mm512_mask_cvtusepi32_epi8">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="src" type="__m128i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<description>Convert packed unsigned 32-bit integers in "a" to packed unsigned 8-bit integers with unsigned saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := 32*j
	l := 8*j
	IF k[j]
		dst[l+7:l] := Saturate_UnsignedInt32_To_Int8(a[i+31:i])
	ELSE
		dst[l+7:l] := src[l+7:l]
	FI
ENDFOR
dst[MAX:128] := 0
	</description>
	<mnemonic base="vpmovusdb"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvtusepi32_storeu_epi8 / vpmovusdb -->
<intrinsic tech="AVX-512" rettype="void" name="_mm512_mask_cvtusepi32_storeu_epi8">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<category>Store</category>
	<parameter varname="base_addr" type="void*"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<description>Convert packed unsigned 32-bit integers in "a" to packed 8-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask "k") to unaligned memory at "base_addr".</description>
	<description code="true">
FOR j := 0 to 15
	i := 32*j
	l := 8*j
	IF k[j]
		MEM[base_addr+l+7:base_addr+l] := Saturate_UnsignedInt32_To_Int8(a[i+31:i])
	FI
ENDFOR
	</description>
	<mnemonic base="vpmovusdb"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_cvtusepi32_epi8 / vpmovusdb -->
<intrinsic tech="AVX-512" rettype="__m128i" name="_mm512_maskz_cvtusepi32_epi8">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<description>Convert packed unsigned 32-bit integers in "a" to packed unsigned 8-bit integers with unsigned saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := 32*j
	l := 8*j
	IF k[j]
		dst[l+7:l] := Saturate_UnsignedInt32_To_Int8(a[i+31:i])
	ELSE
		dst[l+7:l] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</description>
	<mnemonic base="vpmovusdb"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cvtusepi32_epi16 / vpmovusdw -->
<intrinsic tech="AVX-512" rettype="__m256i" name="_mm512_cvtusepi32_epi16">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m512i"/>
	<description>Convert packed unsigned 32-bit integers in "a" to packed unsigned 16-bit integers with unsigned saturation, and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 15
	i := 32*j
	k := 16*j
	dst[k+15:k] := Saturate_UnsignedInt32_To_Int16(a[i+31:i])
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base="vpmovusdw"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvtusepi32_epi16 / vpmovusdw -->
<intrinsic tech="AVX-512" rettype="__m256i" name="_mm512_mask_cvtusepi32_epi16">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="src" type="__m256i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<description>Convert packed unsigned 32-bit integers in "a" to packed unsigned 16-bit integers with unsigned saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := 32*j
	l := 16*j
	IF k[j]
		dst[l+15:l] := Saturate_UnsignedInt32_To_Int16(a[i+31:i])
	ELSE
		dst[l+15:l] := src[l+15:l]
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base="vpmovusdw"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvtusepi32_storeu_epi16 / vpmovusdw -->
<intrinsic tech="AVX-512" rettype="void" name="_mm512_mask_cvtusepi32_storeu_epi16">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<category>Store</category>
	<parameter varname="base_addr" type="void*"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<description>Convert packed unsigned 32-bit integers in "a" to packed 16-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask "k") to unaligned memory at "base_addr".</description>
	<description code="true">
FOR j := 0 to 15
	i := 32*j
	l := 16*j
	IF k[j]
		MEM[base_addr+l+15:base_addr+l] := Saturate_UnsignedInt32_To_Int16(a[i+31:i])
	FI
ENDFOR
	</description>
	<mnemonic base="vpmovusdw"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_cvtusepi32_epi16 / vpmovusdw -->
<intrinsic tech="AVX-512" rettype="__m256i" name="_mm512_maskz_cvtusepi32_epi16">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<description>Convert packed unsigned 32-bit integers in "a" to packed unsigned 16-bit integers with unsigned saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := 32*j
	l := 16*j
	IF k[j]
		dst[l+15:l] := Saturate_UnsignedInt32_To_Int16(a[i+31:i])
	ELSE
		dst[l+15:l] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base="vpmovusdw"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cvtusepi64_epi8 / vpmovusqb -->
<intrinsic tech="AVX-512" rettype="__m128i" name="_mm512_cvtusepi64_epi8">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m512i"/>
	<description>Convert packed unsigned 64-bit integers in "a" to packed unsigned 8-bit integers with unsigned saturation, and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 7
	i := 64*j
	k := 8*j
	dst[k+7:k] := Saturate_UnsignedInt64_To_Int8(a[i+63:i])
ENDFOR
dst[MAX:64] := 0
	</description>
	<mnemonic base="vpmovusqb"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvtusepi64_epi8 / vpmovusqb -->
<intrinsic tech="AVX-512" rettype="__m128i" name="_mm512_mask_cvtusepi64_epi8">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="src" type="__m128i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<description>Convert packed unsigned 64-bit integers in "a" to packed unsigned 8-bit integers with unsigned saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := 64*j
	l := 8*j
	IF k[j]
		dst[l+7:l] := Saturate_UnsignedInt64_To_Int8(a[i+63:i])
	ELSE
		dst[l+7:l] := src[l+7:l]
	FI
ENDFOR
dst[MAX:64] := 0
	</description>
	<mnemonic base="vpmovusqb"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvtusepi64_storeu_epi8 / vpmovusqb -->
<intrinsic tech="AVX-512" rettype="void" name="_mm512_mask_cvtusepi64_storeu_epi8">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<category>Store</category>
	<parameter varname="base_addr" type="void*"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<description>Convert packed unsigned 64-bit integers in "a" to packed 8-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask "k") to unaligned memory at "base_addr".</description>
	<description code="true">
FOR j := 0 to 7
	i := 64*j
	l := 8*j
	IF k[j]
		MEM[base_addr+l+7:base_addr+l] := Saturate_UnsignedInt64_To_Int8(a[i+63:i])
	FI
ENDFOR
	</description>
	<mnemonic base="vpmovusqb"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_cvtusepi64_epi8 / vpmovusqb -->
<intrinsic tech="AVX-512" rettype="__m128i" name="_mm512_maskz_cvtusepi64_epi8">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<description>Convert packed unsigned 64-bit integers in "a" to packed unsigned 8-bit integers with unsigned saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := 64*j
	l := 8*j
	IF k[j]
		dst[l+7:l] := Saturate_UnsignedInt64_To_Int8(a[i+63:i])
	ELSE
		dst[l+7:l] := 0
	FI
ENDFOR
dst[MAX:64] := 0
	</description>
	<mnemonic base="vpmovusqb"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cvtusepi64_epi32 / vpmovusqd -->
<intrinsic tech="AVX-512" rettype="__m256i" name="_mm512_cvtusepi64_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m512i"/>
	<description>Convert packed unsigned 64-bit integers in "a" to packed unsigned 32-bit integers with unsigned saturation, and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 7
	i := 64*j
	k := 32*j
	dst[k+31:k] := Saturate_UnsignedInt64_To_Int32(a[i+63:i])
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base="vpmovusqd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvtusepi64_epi32 / vpmovusqd -->
<intrinsic tech="AVX-512" rettype="__m256i" name="_mm512_mask_cvtusepi64_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="src" type="__m256i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<description>Convert packed unsigned 64-bit integers in "a" to packed unsigned 32-bit integers with unsigned saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := 64*j
	l := 32*j
	IF k[j]
		dst[l+31:l] := Saturate_UnsignedInt64_To_Int32(a[i+63:i])
	ELSE
		dst[l+31:l] := src[l+31:l]
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base="vpmovusqd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvtusepi64_storeu_epi32 / vpmovusqd -->
<intrinsic tech="AVX-512" rettype="void" name="_mm512_mask_cvtusepi64_storeu_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<category>Store</category>
	<parameter varname="base_addr" type="void*"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<description>Convert packed unsigned 64-bit integers in "a" to packed 32-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask "k") to unaligned memory at "base_addr".</description>
	<description code="true">
FOR j := 0 to 7
	i := 64*j
	l := 32*j
	IF k[j]
		MEM[base_addr+l+31:base_addr+l] := Saturate_UnsignedInt64_To_Int32(a[i+63:i])
	FI
ENDFOR
	</description>
	<mnemonic base="vpmovusqd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_cvtusepi64_epi32 / vpmovusqd -->
<intrinsic tech="AVX-512" rettype="__m256i" name="_mm512_maskz_cvtusepi64_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<description>Convert packed unsigned 64-bit integers in "a" to packed unsigned 32-bit integers with unsigned saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := 64*j
	l := 32*j
	IF k[j]
		dst[l+31:l] := Saturate_UnsignedInt64_To_Int32(a[i+63:i])
	ELSE
		dst[l+31:l] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</description>
	<mnemonic base="vpmovusqd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cvtusepi64_epi16 / vpmovusqw -->
<intrinsic tech="AVX-512" rettype="__m128i" name="_mm512_cvtusepi64_epi16">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m512i"/>
	<description>Convert packed unsigned 64-bit integers in "a" to packed unsigned 16-bit integers with unsigned saturation, and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 7
	i := 64*j
	k := 16*j
	dst[k+15:k] := Saturate_UnsignedInt64_To_Int16(a[i+63:i])
ENDFOR
dst[MAX:128] := 0
	</description>
	<mnemonic base="vpmovusqw"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvtusepi64_epi16 / vpmovusqw -->
<intrinsic tech="AVX-512" rettype="__m128i" name="_mm512_mask_cvtusepi64_epi16">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="src" type="__m128i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<description>Convert packed unsigned 64-bit integers in "a" to packed unsigned 16-bit integers with unsigned saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := 64*j
	l := 16*j
	IF k[j]
		dst[l+15:l] := Saturate_UnsignedInt64_To_Int16(a[i+63:i])
	ELSE
		dst[l+15:l] := src[l+15:l]
	FI
ENDFOR
dst[MAX:128] := 0
	</description>
	<mnemonic base="vpmovusqw"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvtusepi64_storeu_epi16 / vpmovusqw -->
<intrinsic tech="AVX-512" rettype="void" name="_mm512_mask_cvtusepi64_storeu_epi16">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<category>Store</category>
	<parameter varname="base_addr" type="void*"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<description>Convert packed unsigned 64-bit integers in "a" to packed 16-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask "k") to unaligned memory at "base_addr".</description>
	<description code="true">
FOR j := 0 to 7
	i := 64*j
	l := 16*j
	IF k[j]
		MEM[base_addr+l+15:base_addr+l] := Saturate_UnsignedInt64_To_Int16(a[i+63:i])
	FI
ENDFOR
	</description>
	<mnemonic base="vpmovusqw"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_cvtusepi64_epi16 / vpmovusqw -->
<intrinsic tech="AVX-512" rettype="__m128i" name="_mm512_maskz_cvtusepi64_epi16">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<description>Convert packed unsigned 64-bit integers in "a" to packed unsigned 16-bit integers with unsigned saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := 64*j
	l := 16*j
	IF k[j]
		dst[l+15:l] := Saturate_UnsignedInt64_To_Int16(a[i+63:i])
	ELSE
		dst[l+15:l] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</description>
	<mnemonic base="vpmovusqw"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cvtepu8_epi32 / vpmovzxbd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_cvtepu8_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m128i"/>
	<description>Zero extend packed unsigned 8-bit integers in "a" to packed 32-bit integers, and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 15
	i := 32*j
	k := 8*j
	dst[i+31:i] := ZeroExtend(a[k+7:k])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpmovzxbd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvtepu8_epi32 / vpmovzxbd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_cvtepu8_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m128i"/>
	<description>Zero extend packed unsigned 8-bit integers in "a" to packed 32-bit integers, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := 32*j
	l := 8*j
	IF k[j]
		dst[i+31:i] := ZeroExtend(a[l+7:l])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpmovzxbd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_cvtepu8_epi32 / vpmovzxbd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_cvtepu8_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m128i"/>
	<description>Zero extend packed unsigned 8-bit integers in "a" to packed 32-bit integers, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := 32*j
	l := 8*j
	IF k[j]
		dst[i+31:i] := ZeroExtend(a[l+7:l])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpmovzxbd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cvtepu8_epi64 / vpmovzxbq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_cvtepu8_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m128i"/>
	<description>Zero extend packed unsigned 8-bit integers in the low 8 byte sof "a" to packed 64-bit integers, and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 7
	i := 64*j
	k := 8*j
	dst[i+63:i] := ZeroExtend(a[k+7:k])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpmovzxbq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvtepu8_epi64 / vpmovzxbq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_cvtepu8_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128i"/>
	<description>Zero extend packed unsigned 8-bit integers in the low 8 bytes of "a" to packed 64-bit integers, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := 64*j
	l := 8*j
	IF k[j]
		dst[i+63:i] := ZeroExtend(a[l+7:l])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpmovzxbq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_cvtepu8_epi64 / vpmovzxbq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_cvtepu8_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128i"/>
	<description>Zero extend packed unsigned 8-bit integers in the low 8 bytes of "a" to packed 64-bit integers, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := 64*j
	l := 8*j
	IF k[j]
		dst[i+63:i] := ZeroExtend(a[l+7:l])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpmovzxbq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cvtepu32_epi64 / vpmovzxdq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_cvtepu32_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m256i"/>
	<description>Zero extend packed unsigned 32-bit integers in "a" to packed 64-bit integers, and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 7
	i := 64*j
	k := 32*j
	dst[i+63:i] := ZeroExtend(a[k+31:k])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpmovzxdq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvtepu32_epi64 / vpmovzxdq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_cvtepu32_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m256i"/>
	<description>Zero extend packed unsigned 32-bit integers in "a" to packed 64-bit integers, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := 64*j
	l := 32*j
	IF k[j]
		dst[i+63:i] := ZeroExtend(a[l+31:l])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpmovzxdq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_cvtepu32_epi64 / vpmovzxdq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_cvtepu32_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m256i"/>
	<description>Zero extend packed unsigned 32-bit integers in "a" to packed 64-bit integers, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 7
	i := 64*j
	l := 32*j
	IF k[j]
		dst[i+63:i] := ZeroExtend(a[l+31:l])
	ELSE 
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpmovzxdq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cvtepu16_epi32 / vpmovzxwd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_cvtepu16_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m256i"/>
	<description>Zero extend packed unsigned 16-bit integers in "a" to packed 32-bit integers, and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 15
	i := 32*j
	k := 16*j
	dst[i+31:i] := ZeroExtend(a[k+15:k])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpmovzxwd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvtepu16_epi32 / vpmovzxwd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_cvtepu16_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m256i"/>
	<description>Zero extend packed unsigned 16-bit integers in "a" to packed 32-bit integers, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := 32*j
	l := 16*j
	IF k[j]
		dst[i+31:i] := ZeroExtend(a[l+15:l])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpmovzxwd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_cvtepu16_epi32 / vpmovzxwd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_cvtepu16_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m256i"/>
	<description>Zero extend packed unsigned 16-bit integers in "a" to packed 32-bit integers, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 15
	i := 32*j
	l := 16*j
	IF k[j]
		dst[i+31:i] := ZeroExtend(a[l+15:l])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpmovzxwd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_cvtepu16_epi64 / vpmovzxwq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_cvtepu16_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="a" type="__m128i"/>
	<description>Zero extend packed unsigned 16-bit integers in "a" to packed 64-bit integers, and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 7
	i := 64*j
	k := 16*j
	dst[i+63:i] := ZeroExtend(a[k+15:k])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpmovzxwq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_cvtepu16_epi64 / vpmovzxwq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_cvtepu16_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128i"/>
	<description>Zero extend packed unsigned 16-bit integers in "a" to packed 64-bit integers, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := 64*j
	l := 16*j
	IF k[j]
		dst[i+63:i] := ZeroExtend(a[l+15:l])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpmovzxwq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_cvtepu16_epi64 / vpmovzxwq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_cvtepu16_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Convert</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128i"/>
	<description>Zero extend packed unsigned 16-bit integers in "a" to packed 64-bit integers, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := 64*j
	l := 16*j
	IF k[j]
		dst[i+63:i] := ZeroExtend(a[l+15:l])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpmovzxwq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_mul_epi32 / vpmuldq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_mul_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Multiply the low 32-bit integers from each packed 64-bit element in "a" and "b", and store the signed 64-bit results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+31:i] * b[i+31:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpmuldq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_mul_epi32 / vpmuldq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_mul_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Multiply the low 32-bit integers from each packed 64-bit element in "a" and "b", and store the signed 64-bit results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+31:i] * b[i+31:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpmuldq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mul_epi32 / vpmuldq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mul_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Multiply the low 32-bit integers from each packed 64-bit element in "a" and "b", and store the signed 64-bit results in "dst". </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := a[i+31:i] * b[i+31:i]
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpmuldq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_mullo_epi32 / vpmulld -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_mullo_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Multiply the packed 32-bit integers in "a" and "b", producing intermediate 64-bit integers, and store the low 32 bits of the intermediate integers in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		tmp[63:0] := a[i+31:i] * b[i+31:i]
		dst[i+31:i] := tmp[31:0]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpmulld"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mullo_epi32 / vpmulld -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mullo_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Multiply the packed 32-bit integers in "a" and "b", producing intermediate 64-bit integers, and store the low 32 bits of the intermediate integers in "dst". </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	tmp[63:0] := a[i+31:i] * b[i+31:i]
	dst[i+31:i] := tmp[31:0]
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpmulld"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_mul_epu32 / vpmuludq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_mul_epu32">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>	
	<description>Multiply the low unsigned 32-bit integers from each packed 64-bit element in "a" and "b", and store the unsigned 64-bit results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+31:i] * b[i+31:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpmuludq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_mul_epu32 / vpmuludq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_mul_epu32">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Multiply the low unsigned 32-bit integers from each packed 64-bit element in "a" and "b", and store the unsigned 64-bit results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+31:i] * b[i+31:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpmuludq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mul_epu32 / vpmuludq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mul_epu32">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Multiply the low unsigned 32-bit integers from each packed 64-bit element in "a" and "b", and store the unsigned 64-bit results in "dst". </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := a[i+31:i] * b[i+31:i]
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpmuludq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_or_epi32 / vpord -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_or_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Logical</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compute the bitwise OR of packed 32-bit integers in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i] OR b[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpord"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_or_epi32 / vpord -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_or_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Logical</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compute the bitwise OR of packed 32-bit integers in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i] OR b[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpord"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_or_epi32 / vpord -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_or_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Logical</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compute the bitwise OR of packed 32-bit integers in "a" and "b", and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := a[i+31:i] OR b[i+31:i]
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpord"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_or_si512 / vpord -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_or_si512">
	<CPUID>AVX-512</CPUID>
	<category>Logical</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compute the bitwise OR of 512 bits (representing integer data) in "a" and "b", and store the result in "dst".</description>
	<description code="true">
dst[511:0] := (a[511:0] OR b[511:0])
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpord"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_or_epi64 / vporq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_or_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Logical</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compute the bitwise OR of packed 64-bit integers in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] OR b[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vporq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_or_epi64 / vporq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_or_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Logical</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compute the bitwise OR of packed 64-bit integers in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] OR b[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vporq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_or_epi64 / vporq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_or_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Logical</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compute the bitwise OR of packed 64-bit integers in "a" and "b", and store the resut in "dst".
	</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := a[i+63:i] OR b[i+63:i]
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vporq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_rol_epi32 / vprold -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_rol_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="imm" type="const int"/>
	<description>Rotate the bits in each packed 32-bit integer in "a" to the left by the number of bits specified in "imm", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
LEFT_ROTATE_DWORDS(src, count_src){
	count := count_src modulo 32
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (32 - count))
}
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := LEFT_ROTATE_DWORDS(a[i+31:i], imm[7:0])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vprold"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_rol_epi32 / vprold -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_rol_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="imm" type="const int"/>
	<description>Rotate the bits in each packed 32-bit integer in "a" to the left by the number of bits specified in "imm", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
LEFT_ROTATE_DWORDS(src, count_src){
	count := count_src modulo 32
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (32 - count))
}
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := LEFT_ROTATE_DWORDS(a[i+31:i], imm[7:0])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vprold"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_rol_epi32 / vprold -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_rol_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="imm" type="const int"/>
	<description>Rotate the bits in each packed 32-bit integer in "a" to the left by the number of bits specified in "imm", and store the results in "dst". </description>
	<description code="true">
LEFT_ROTATE_DWORDS(src, count_src){
	count := count_src modulo 32
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (32 - count))
}
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := LEFT_ROTATE_DWORDS(a[i+31:i], imm[7:0])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vprold"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_rol_epi64 / vprolq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_rol_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="imm" type="const int"/>
	<description>Rotate the bits in each packed 64-bit integer in "a" to the left by the number of bits specified in "imm", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
LEFT_ROTATE_QWORDS(src, count_src){
	count := count_src modulo 64
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (64 - count))
}
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := LEFT_ROTATE_QWORDS(a[i+63:i], imm[7:0])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vprolq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_rol_epi64 / vprolq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_rol_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="imm" type="const int"/>
	<description>Rotate the bits in each packed 64-bit integer in "a" to the left by the number of bits specified in "imm", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
LEFT_ROTATE_QWORDS(src, count_src){
	count := count_src modulo 64
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (64 - count))
}
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := LEFT_ROTATE_QWORDS(a[i+63:i], imm[7:0])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vprolq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_rol_epi64 / vprolq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_rol_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="imm" type="const int"/>
	<description>Rotate the bits in each packed 64-bit integer in "a" to the left by the number of bits specified in "imm", and store the results in "dst". </description>
	<description code="true">
LEFT_ROTATE_QWORDS(src, count_src){
	count := count_src modulo 64
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (64 - count))
}
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := LEFT_ROTATE_QWORDS(a[i+63:i], imm[7:0])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vprolq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_rolv_epi32 / vprolvd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_rolv_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Rotate the bits in each packed 32-bit integer in "a" to the left by the number of bits specified in the corresponding element of "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
LEFT_ROTATE_DWORDS(src, count_src){
	count := count_src modulo 32
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (32 - count))
}
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := LEFT_ROTATE_DWORDS(a[i+31:i], b[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vprolvd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_rolv_epi32 / vprolvd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_rolv_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Rotate the bits in each packed 32-bit integer in "a" to the left by the number of bits specified in the corresponding element of "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
LEFT_ROTATE_DWORDS(src, count_src){
	count := count_src modulo 32
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (32 - count))
}
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := LEFT_ROTATE_DWORDS(a[i+31:i], b[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vprolvd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_rolv_epi32 / vprolvd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_rolv_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Rotate the bits in each packed 32-bit integer in "a" to the left by the number of bits specified in the corresponding element of "b", and store the results in "dst". </description>
	<description code="true">
LEFT_ROTATE_DWORDS(src, count_src){
	count := count_src modulo 32
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (32 - count))
}
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := LEFT_ROTATE_DWORDS(a[i+31:i], b[i+31:i])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vprolvd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_rolv_epi64 / vprolvq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_rolv_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Rotate the bits in each packed 64-bit integer in "a" to the left by the number of bits specified in the corresponding element of "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
LEFT_ROTATE_QWORDS(src, count_src){
	count := count_src modulo 64
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (64 - count))
}
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := LEFT_ROTATE_QWORDS(a[i+63:i], b[i+63:i])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vprolvq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_rolv_epi64 / vprolvq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_rolv_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Rotate the bits in each packed 64-bit integer in "a" to the left by the number of bits specified in the corresponding element of "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
LEFT_ROTATE_QWORDS(src, count_src){
	count := count_src modulo 64
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (64 - count))
}
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := LEFT_ROTATE_QWORDS(a[i+63:i], b[i+63:i])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vprolvq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_rolv_epi64 / vprolvq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_rolv_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Rotate the bits in each packed 64-bit integer in "a" to the left by the number of bits specified in the corresponding element of "b", and store the results in "dst". </description>
	<description code="true">
LEFT_ROTATE_QWORDS(src, count_src){
	count := count_src modulo 64
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (64 - count))
}
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := LEFT_ROTATE_QWORDS(a[i+63:i], b[i+63:i])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vprolvq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_ror_epi32 / vprord -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_ror_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="imm" type="int"/>
	<description>Rotate the bits in each packed 32-bit integer in "a" to the right by the number of bits specified in "imm", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
RIGHT_ROTATE_DWORDS(src, count_src){
	count := count_src modulo 32
	RETURN (src &gt;&gt;count) OR (src &lt;&lt; (32 - count))
}
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := RIGHT_ROTATE_DWORDS(a[i+31:i], imm[7:0])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vprord"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_ror_epi32 / vprord -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_ror_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="imm" type="int"/>
	<description>Rotate the bits in each packed 32-bit integer in "a" to the right by the number of bits specified in "imm", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
RIGHT_ROTATE_DWORDS(src, count_src){
	count := count_src modulo 32
	RETURN (src &gt;&gt;count) OR (src &lt;&lt; (32 - count))
}
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := RIGHT_ROTATE_DWORDS(a[i+31:i], imm[7:0])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vprord"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_ror_epi32 / vprord -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_ror_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="imm" type="int"/>
	<description>Rotate the bits in each packed 32-bit integer in "a" to the right by the number of bits specified in "imm", and store the results in "dst". </description>
	<description code="true">
RIGHT_ROTATE_DWORDS(src, count_src){
	count := count_src modulo 32
	RETURN (src &gt;&gt;count) OR (src &lt;&lt; (32 - count))
}
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := RIGHT_ROTATE_DWORDS(a[i+31:i], imm[7:0])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vprord"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_ror_epi64 / vprorq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_ror_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="imm" type="int"/>
	<description>Rotate the bits in each packed 64-bit integer in "a" to the right by the number of bits specified in "imm", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
RIGHT_ROTATE_QWORDS(src, count_src){
	count := count_src modulo 64
	RETURN (src &gt;&gt; count) OR (src &lt;&lt; (64 - count))
}
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := RIGHT_ROTATE_QWORDS(a[i+63:i], imm[7:0])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vprorq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_ror_epi64 / vprorq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_ror_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="imm" type="int"/>
	<description>Rotate the bits in each packed 64-bit integer in "a" to the right by the number of bits specified in "imm", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
RIGHT_ROTATE_QWORDS(src, count_src){
	count := count_src modulo 64
	RETURN (src &gt;&gt; count) OR (src &lt;&lt; (64 - count))
}
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := RIGHT_ROTATE_QWORDS(a[i+63:i], imm[7:0])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vprorq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_ror_epi64 / vprorq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_ror_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="imm" type="int"/>
	<description>Rotate the bits in each packed 64-bit integer in "a" to the right by the number of bits specified in "imm", and store the results in "dst". </description>
	<description code="true">
RIGHT_ROTATE_QWORDS(src, count_src){
	count := count_src modulo 64
	RETURN (src &gt;&gt; count) OR (src &lt;&lt; (64 - count))
}
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := RIGHT_ROTATE_QWORDS(a[i+63:i], imm[7:0])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vprorq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_rorv_epi32 / vprorvd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_rorv_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Rotate the bits in each packed 32-bit integer in "a" to the right by the number of bits specified in the corresponding element of "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
RIGHT_ROTATE_DWORDS(src, count_src){
	count := count_src modulo 32
	RETURN (src &gt;&gt;count) OR (src &lt;&lt; (32 - count))
}
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := RIGHT_ROTATE_DWORDS(a[i+31:i], b[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vprorvd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_rorv_epi32 / vprorvd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_rorv_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Rotate the bits in each packed 32-bit integer in "a" to the right by the number of bits specified in the corresponding element of "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
RIGHT_ROTATE_DWORDS(src, count_src){
	count := count_src modulo 32
	RETURN (src &gt;&gt;count) OR (src &lt;&lt; (32 - count))
}
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := RIGHT_ROTATE_DWORDS(a[i+31:i], b[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vprorvd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_rorv_epi32 / vprorvd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_rorv_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Rotate the bits in each packed 32-bit integer in "a" to the right by the number of bits specified in the corresponding element of "b", and store the results in "dst". </description>
	<description code="true">
RIGHT_ROTATE_DWORDS(src, count_src){
	count := count_src modulo 32
	RETURN (src &gt;&gt;count) OR (src &lt;&lt; (32 - count))
}
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := RIGHT_ROTATE_DWORDS(a[i+31:i], b[i+31:i])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vprorvd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_rorv_epi64 / vprorvq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_rorv_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Rotate the bits in each packed 64-bit integer in "a" to the right by the number of bits specified in the corresponding element of "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
RIGHT_ROTATE_QWORDS(src, count_src){
	count := count_src modulo 64
	RETURN (src &gt;&gt; count) OR (src &lt;&lt; (64 - count))
}
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := RIGHT_ROTATE_QWORDS(a[i+63:i], b[i+63:i])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vprorvq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_rorv_epi64 / vprorvq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_rorv_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Rotate the bits in each packed 64-bit integer in "a" to the right by the number of bits specified in the corresponding element of "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
RIGHT_ROTATE_QWORDS(src, count_src){
	count := count_src modulo 64
	RETURN (src &gt;&gt; count) OR (src &lt;&lt; (64 - count))
}
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := RIGHT_ROTATE_QWORDS(a[i+63:i], b[i+63:i])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vprorvq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_rorv_epi64 / vprorvq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_rorv_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Rotate the bits in each packed 64-bit integer in "a" to the right by the number of bits specified in the corresponding element of "b", and store the results in "dst". </description>
	<description code="true">
RIGHT_ROTATE_QWORDS(src, count_src){
	count := count_src modulo 64
	RETURN (src &gt;&gt; count) OR (src &lt;&lt; (64 - count))
}
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := RIGHT_ROTATE_QWORDS(a[i+63:i], b[i+63:i])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vprorvq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_i32scatter_epi32 / vpscatterdd -->
<intrinsic tech="AVX-512" rettype="void" name="_mm512_i32scatter_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Store</category>
	<parameter varname="base_addr" type="void*"/>
	<parameter varname="vindex" type="__m512i"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="scale" type="int"/>
	<description>Scatter 32-bit integers from "a" into memory using 32-bit indices. 32-bit elements are stored at addresses starting at "base_addr" and offset by each 32-bit element in "vindex" (each index is scaled by the factor in "scale"). "scale" should be 1, 2, 4 or 8.</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	MEM[base_addr + SignExtend(vindex[i+31:i])*scale] := a[i+31:i]
ENDFOR
	</description>
	<mnemonic base="vpscatterdd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_i32scatter_epi32 / vpscatterdd -->
<intrinsic tech="AVX-512" rettype="void" name="_mm512_mask_i32scatter_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Store</category>
	<parameter varname="base_addr" type="void*"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="vindex" type="__m512i"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="scale" type="int"/>
	<description>Scatter 32-bit integers from "a" into memory using 32-bit indices. 32-bit elements are stored at addresses starting at "base_addr" and offset by each 32-bit element in "vindex" (each index is scaled by the factor in "scale") subject to mask "k" (elements are not stored when the corresponding mask bit is not set). "scale" should be 1, 2, 4 or 8.
	</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		MEM[base_addr + SignExtend(vindex[i+31:i])*scale] := a[i+31:i]
		k[j] := 0
	FI
ENDFOR
k[MAX:16] := 0
	</description>
	<mnemonic base="vpscatterdd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_i32scatter_epi64 / vpscatterdq -->
<intrinsic tech="AVX-512" rettype="void" name="_mm512_i32scatter_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Store</category>
	<parameter varname="base_addr" type="void*"/>
	<parameter varname="vindex" type="__m256i"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="scale" type="int"/>
	<description>Scatter 64-bit integers from "a" into memory using 32-bit indices. 64-bit elements are stored at addresses starting at "base_addr" and offset by each 32-bit element in "vindex" (each index is scaled by the factor in "scale"). "scale" should be 1, 2, 4 or 8.
	</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	l := j*32
	MEM[base_addr + SignExtend(vindex[l+31:l])*scale] := a[i+63:i]
ENDFOR
	</description>
	<mnemonic base="vpscatterdq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_i32scatter_epi64 / vpscatterdq -->
<intrinsic tech="AVX-512" rettype="void" name="_mm512_mask_i32scatter_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Store</category>
	<parameter varname="base_addr" type="void*"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="vindex" type="__m256i"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="scale" type="int"/>
	<description>Scatter 64-bit integers from "a" into memory using 32-bit indices. 64-bit elements are stored at addresses starting at "base_addr" and offset by each 32-bit element in "vindex" (each index is scaled by the factor in "scale") subject to mask "k" (elements are not stored when the corresponding mask bit is not set). "scale" should be 1, 2, 4 or 8.
	</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	l := j*32
	IF k[j]
		MEM[base_addr + SignExtend(vindex[l+31:l])*scale] := a[i+63:i]
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</description>
	<mnemonic base="vpscatterdq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_i64scatter_epi32 / vpscatterqd -->
<intrinsic tech="AVX-512" rettype="void" name="_mm512_i64scatter_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Store</category>
	<parameter varname="base_addr" type="void*"/>
	<parameter varname="vindex" type="__m512i"/>
	<parameter varname="a" type="__m256i"/>
	<parameter varname="scale" type="int"/>
	<description>Scatter 32-bit integers from "a" into memory using 64-bit indices. 32-bit elements are stored at addresses starting at "base_addr" and offset by each 64-bit element in "vindex" (each index is scaled by the factor in "scale"). "scale" should be 1, 2, 4 or 8.
	</description>
	<description code="true">
FOR j := 0 to 7
	i := j*32
	l := j*64
	MEM[base_addr + SignExtend(vindex[l+63:l])*scale] := a[i+31:i]
ENDFOR
	</description>
	<mnemonic base="vpscatterqd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_i64scatter_epi32 / vpscatterqd -->
<intrinsic tech="AVX-512" rettype="void" name="_mm512_mask_i64scatter_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Store</category>
	<parameter varname="base_addr" type="void*"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="vindex" type="__m512i"/>
	<parameter varname="a" type="__m256i"/>
	<parameter varname="scale" type="int"/>
	<description>Scatter 32-bit integers from "a" into memory using 64-bit indices. 32-bit elements are stored at addresses starting at "base_addr" and offset by each 64-bit element in "vindex" (each index is scaled by the factor in "scale") subject to mask "k" (elements are not stored when the corresponding mask bit is not set). "scale" should be 1, 2, 4 or 8.
	</description>
	<description code="true">
FOR j := 0 to 7
	i := j*32
	l := j*64
	IF k[j]
		MEM[base_addr + SignExtend(vindex[l+63:l])*scale] := a[i+31:i]
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</description>
	<mnemonic base="vpscatterqd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_i64scatter_epi64 / vpscatterqq -->
<intrinsic tech="AVX-512" rettype="void" name="_mm512_i64scatter_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Store</category>
	<parameter varname="base_addr" type="void*"/>
	<parameter varname="vindex" type="__m512i"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="scale" type="int"/>
	<description>Scatter 64-bit integers from "a" into memory using 64-bit indices. 64-bit elements are stored at addresses starting at "base_addr" and offset by each 64-bit element in "vindex" (each index is scaled by the factor in "scale"). "scale" should be 1, 2, 4 or 8.
	</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	MEM[base_addr + SignExtend(vindex[i+63:i])*scale] := a[i+63:i]
ENDFOR
	</description>
	<mnemonic base="vpscatterqq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_i64scatter_epi64 / vpscatterqq -->
<intrinsic tech="AVX-512" rettype="void" name="_mm512_mask_i64scatter_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Store</category>
	<parameter varname="base_addr" type="void*"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="vindex" type="__m512i"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="scale" type="int"/>
	<description>Scatter 64-bit integers from "a" into memory using 64-bit indices. 64-bit elements are stored at addresses starting at "base_addr" and offset by each 64-bit element in "vindex" (each index is scaled by the factor in "scale") subject to mask "k" (elements are not stored when the corresponding mask bit is not set). "scale" should be 1, 2, 4 or 8.
	</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		MEM[base_addr + SignExtend(vindex[i+63:i])*scale] := a[i+63:i]
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</description>
	<mnemonic base="vpscatterqq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_shuffle_epi32 / vpshufd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_shuffle_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="imm" type="_MM_PERM_ENUM"/>
	<description>Shuffle 32-bit integers in "a" within 128-bit lanes using the control in "imm", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<description code="true">
SELECT4(src, control){
	CASE(control[1:0])
		0:	tmp[31:0] := src[31:0]
		1:	tmp[31:0] := src[63:32]
		2:	tmp[31:0] := src[95:64]
		3:	tmp[31:0] := src[127:96]
	ESAC
	RETURN tmp[31:0]
}

tmp_dst[31:0] := SELECT4(a[127:0], imm[1:0])
tmp_dst[63:32] := SELECT4(a[127:0], imm[3:2])
tmp_dst[95:64] := SELECT4(a[127:0], imm[5:4])
tmp_dst[127:96] := SELECT4(a[127:0], imm[7:6])
tmp_dst[159:128] := SELECT4(a[255:128], imm[1:0])
tmp_dst[191:160] := SELECT4(a[255:128], imm[3:2])
tmp_dst[223:192] := SELECT4(a[255:128], imm[5:4])
tmp_dst[255:224] := SELECT4(a[255:128], imm[7:6])
tmp_dst[287:256] := SELECT4(a[383:256], imm[1:0])
tmp_dst[319:288] := SELECT4(a[383:256], imm[3:2])
tmp_dst[351:320] := SELECT4(a[383:256], imm[5:4])
tmp_dst[383:352] := SELECT4(a[383:256], imm[7:6])
tmp_dst[415:384] := SELECT4(a[511:384], imm[1:0])
tmp_dst[447:416] := SELECT4(a[511:384], imm[3:2])
tmp_dst[479:448] := SELECT4(a[511:384], imm[5:4])
tmp_dst[511:480] := SELECT4(a[511:384], imm[7:6])
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp_dst[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpshufd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_shuffle_epi32 / vpshufd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_shuffle_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="imm" type="_MM_PERM_ENUM"/>
	<description>Shuffle 32-bit integers in "a" within 128-bit lanes using the control in "imm", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
SELECT4(src, control){
	CASE(control[1:0])
		0:	tmp[31:0] := src[31:0]
		1:	tmp[31:0] := src[63:32]
		2:	tmp[31:0] := src[95:64]
		3:	tmp[31:0] := src[127:96]
	ESAC
	RETURN tmp[31:0]
}

tmp_dst[31:0] := SELECT4(a[127:0], imm[1:0])
tmp_dst[63:32] := SELECT4(a[127:0], imm[3:2])
tmp_dst[95:64] := SELECT4(a[127:0], imm[5:4])
tmp_dst[127:96] := SELECT4(a[127:0], imm[7:6])
tmp_dst[159:128] := SELECT4(a[255:128], imm[1:0])
tmp_dst[191:160] := SELECT4(a[255:128], imm[3:2])
tmp_dst[223:192] := SELECT4(a[255:128], imm[5:4])
tmp_dst[255:224] := SELECT4(a[255:128], imm[7:6])
tmp_dst[287:256] := SELECT4(a[383:256], imm[1:0])
tmp_dst[319:288] := SELECT4(a[383:256], imm[3:2])
tmp_dst[351:320] := SELECT4(a[383:256], imm[5:4])
tmp_dst[383:352] := SELECT4(a[383:256], imm[7:6])
tmp_dst[415:384] := SELECT4(a[511:384], imm[1:0])
tmp_dst[447:416] := SELECT4(a[511:384], imm[3:2])
tmp_dst[479:448] := SELECT4(a[511:384], imm[5:4])
tmp_dst[511:480] := SELECT4(a[511:384], imm[7:6])
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp_dst[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpshufd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_shuffle_epi32 / vpshufd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_shuffle_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="imm" type="_MM_PERM_ENUM"/>
	<description>Shuffle 32-bit integers in "a" within 128-bit lanes using the control in "imm", and store the results in "dst".</description>
	<description code="true">
SELECT4(src, control){
	CASE(control[1:0])
		0:	tmp[31:0] := src[31:0]
		1:	tmp[31:0] := src[63:32]
		2:	tmp[31:0] := src[95:64]
		3:	tmp[31:0] := src[127:96]
	ESAC
	RETURN tmp[31:0]
}

dst[31:0] := SELECT4(a[127:0], imm[1:0])
dst[63:32] := SELECT4(a[127:0], imm[3:2])
dst[95:64] := SELECT4(a[127:0], imm[5:4])
dst[127:96] := SELECT4(a[127:0], imm[7:6])
dst[159:128] := SELECT4(a[255:128], imm[1:0])
dst[191:160] := SELECT4(a[255:128], imm[3:2])
dst[223:192] := SELECT4(a[255:128], imm[5:4])
dst[255:224] := SELECT4(a[255:128], imm[7:6])
dst[287:256] := SELECT4(a[383:256], imm[1:0])
dst[319:288] := SELECT4(a[383:256], imm[3:2])
dst[351:320] := SELECT4(a[383:256], imm[5:4])
dst[383:352] := SELECT4(a[383:256], imm[7:6])
dst[415:384] := SELECT4(a[511:384], imm[1:0])
dst[447:416] := SELECT4(a[511:384], imm[3:2])
dst[479:448] := SELECT4(a[511:384], imm[5:4])
dst[511:480] := SELECT4(a[511:384], imm[7:6])
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpshufd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_sll_epi32 / vpslld -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_sll_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="count" type="__m128i"/>
	<description>Shift packed 32-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF count[63:0] &gt; 31
			dst[i+31:i] := 0
		ELSE
			dst[i+31:i] := ZeroExtend(a[i+31:i] &lt;&lt; count[63:0])
		FI
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpslld"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_slli_epi32 / vpslld -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_slli_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="imm" type="unsigned int"/>
	<description>Shift packed 32-bit integers in "a" left by "imm" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF imm &gt; 31
			dst[i+31:i] := 0
		ELSE
			dst[i+31:i] := ZeroExtend(a[i+31:i] &lt;&lt; imm)
		FI
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpslld"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_sll_epi32 / vpslld -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_sll_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="count" type="__m128i"/>
	<description>Shift packed 32-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF count[63:0] &gt; 31
			dst[i+31:i] := 0
		ELSE
			dst[i+31:i] := ZeroExtend(a[i+31:i] &lt;&lt; count[63:0])
		FI
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpslld"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_slli_epi32 / vpslld -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_slli_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="imm" type="unsigned int"/>
	<description>Shift packed 32-bit integers in "a" left by "imm" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF imm &gt; 31
			dst[i+31:i] := 0
		ELSE
			dst[i+31:i] := ZeroExtend(a[i+31:i] &lt;&lt; imm)
		FI
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpslld"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_sll_epi32 / vpslld -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_sll_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="count" type="__m128i"/>
	<description>Shift packed 32-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst". </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF count[63:0] &gt; 31
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := ZeroExtend(a[i+31:i] &lt;&lt; count[63:0])
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpslld"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_slli_epi32 / vpslld -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_slli_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="imm" type="unsigned int"/>
	<description>Shift packed 32-bit integers in "a" left by "imm" while shifting in zeros, and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF imm &gt; 31
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := ZeroExtend(a[i+31:i] &lt;&lt; imm)
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpslld"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_sll_epi64 / vpsllq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_sll_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="count" type="__m128i"/>
	<description>Shift packed 64-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF count[63:0] &gt; 63
			dst[i+63:i] := 0
		ELSE
			dst[i+63:i] := ZeroExtend(a[i+63:i] &lt;&lt; count[63:0])
		FI
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpsllq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_slli_epi64 / vpsllq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_slli_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="imm" type="unsigned int"/>
	<description>Shift packed 64-bit integers in "a" left by "imm" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF imm &gt; 63
			dst[i+63:i] := 0
		ELSE
			dst[i+63:i] := ZeroExtend(a[i+63:i] &lt;&lt; imm)
		FI
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>	
	<mnemonic base="vpsllq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_sll_epi64 / vpsllq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_sll_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="count" type="__m128i"/>
	<description>Shift packed 64-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF count[63:0] &gt; 63
			dst[i+63:i] := 0
		ELSE
			dst[i+63:i] := ZeroExtend(a[i+63:i] &lt;&lt; count[63:0])
		FI
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpsllq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_slli_epi64 / vpsllq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_slli_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="imm" type="unsigned int"/>
	<description>Shift packed 64-bit integers in "a" left by "imm" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF imm &gt; 63
			dst[i+63:i] := 0
		ELSE
			dst[i+63:i] := ZeroExtend(a[i+63:i] &lt;&lt; imm)
		FI
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>	
	<mnemonic base="vpsllq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_sll_epi64 / vpsllq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_sll_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="count" type="__m128i"/>
	<description>Shift packed 64-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst". </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF count[63:0] &gt; 63
		dst[i+63:i] := 0
	ELSE
		dst[i+63:i] := ZeroExtend(a[i+63:i] &lt;&lt; count[63:0])
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpsllq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_slli_epi64 / vpsllq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_slli_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="imm" type="unsigned int"/>
	<description>Shift packed 64-bit integers in "a" left by "imm" while shifting in zeros, and store the results in "dst". </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF imm &gt; 63
		dst[i+63:i] := 0
	ELSE
		dst[i+63:i] := ZeroExtend(a[i+63:i] &lt;&lt; imm)
	FI
ENDFOR
dst[MAX:512] := 0
	</description>	
	<mnemonic base="vpsllq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_sllv_epi32 / vpsllvd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_sllv_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="count" type="__m512i"/>
	<description>Shift packed 32-bit integers in "a" left by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := ZeroExtend(a[i+31:i] &lt;&lt; count[i+4:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI	
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpsllvd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_sllv_epi32 / vpsllvd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_sllv_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="count" type="__m512i"/>
	<description>Shift packed 32-bit integers in "a" left by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := ZeroExtend(a[i+31:i] &lt;&lt; count[i+4:i])
	ELSE
		dst[i+31:i] := 0
	FI	
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpsllvd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_sllv_epi32 / vpsllvd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_sllv_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="count" type="__m512i"/>
	<description>Shift packed 32-bit integers in "a" left by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst". </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := ZeroExtend(a[i+31:i] &lt;&lt; count[i+4:i])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpsllvd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_sllv_epi64 / vpsllvq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_sllv_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="count" type="__m512i"/>
	<description>Shift packed 64-bit integers in "a" left by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := ZeroExtend(a[i+63:i] &lt;&lt; count[i+5:i])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI	
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpsllvq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_sllv_epi64 / vpsllvq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_sllv_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="count" type="__m512i"/>
	<description>Shift packed 64-bit integers in "a" left by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := ZeroExtend(a[i+63:i] &lt;&lt; count[i+5:i])
	ELSE
		dst[i+63:i] := 0
	FI	
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpsllvq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_sllv_epi64 / vpsllvq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_sllv_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="count" type="__m512i"/>
	<description>Shift packed 64-bit integers in "a" left by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst". </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := ZeroExtend(a[i+63:i] &lt;&lt; count[i+5:i])	
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpsllvq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_sra_epi32 / vpsrad -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_sra_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="count" type="__m128i"/>
	<description>Shift packed 32-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF count[63:0] &gt; 31
			dst[i+31:i] := SignBit
		ELSE
			dst[i+31:i] := SignExtend(a[i+31:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>	
	<mnemonic base="vpsrad"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_srai_epi32 / vpsrad -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_srai_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="imm" type="unsigned int"/>	
	<description>Shift packed 32-bit integers in "a" right by "imm" while shifting in sign bits, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF imm &gt; 31
			dst[i+31:i] := SignBit
		ELSE
			dst[i+31:i] := SignExtend(a[i+31:i] &gt;&gt; imm)
		FI
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpsrad"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_sra_epi32 / vpsrad -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_sra_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="count" type="__m128i"/>
	<description>Shift packed 32-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF count[63:0] &gt; 31
			dst[i+31:i] := SignBit
		ELSE
			dst[i+31:i] := SignExtend(a[i+31:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>	
	<mnemonic base="vpsrad"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_srai_epi32 / vpsrad -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_srai_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="imm" type="unsigned int"/>
	<description>Shift packed 32-bit integers in "a" right by "imm" while shifting in sign bits, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF imm &gt; 31
			dst[i+31:i] := SignBit
		ELSE
			dst[i+31:i] := SignExtend(a[i+31:i] &gt;&gt; imm)
		FI
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpsrad"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_sra_epi32 / vpsrad -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_sra_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="count" type="__m128i"/>
	<description>Shift packed 32-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst". </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF count[63:0] &gt; 31
		dst[i+31:i] := SignBit
	ELSE
		dst[i+31:i] := SignExtend(a[i+31:i] &gt;&gt; count[63:0])
	FI
ENDFOR
dst[MAX:512] := 0
	</description>	
	<mnemonic base="vpsrad"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_srai_epi32 / vpsrad -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_srai_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="imm" type="unsigned int"/>
	<description>Shift packed 32-bit integers in "a" right by "imm" while shifting in sign bits, and store the results in "dst". </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF imm &gt; 31
		dst[i+31:i] := SignBit
	ELSE
		dst[i+31:i] := SignExtend(a[i+31:i] &gt;&gt; imm)
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpsrad"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_sra_epi64 / vpsraq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_sra_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="count" type="__m128i"/>
	<description>Shift packed 64-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF count[63:0] &gt; 63
			dst[i+63:i] := SignBit
		ELSE
			dst[i+63:i] := SignExtend(a[i+63:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpsraq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_srai_epi64 / vpsraq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_srai_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="imm" type="unsigned int"/>
	<description>Shift packed 64-bit integers in "a" right by "imm" while shifting in sign bits, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF imm &gt; 63
			dst[i+63:i] := SignBit
		ELSE
			dst[i+63:i] := SignExtend(a[i+63:i] &lt;&lt; imm)
		FI
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>	
	<mnemonic base="vpsraq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_sra_epi64 / vpsraq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_sra_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="count" type="__m128i"/>
	<description>Shift packed 64-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF count[63:0] &gt; 63
			dst[i+63:i] := SignBit
		ELSE
			dst[i+63:i] := SignExtend(a[i+63:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpsraq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_srai_epi64 / vpsraq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_srai_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="imm" type="unsigned int"/>
	<description>Shift packed 64-bit integers in "a" right by "imm" while shifting in sign bits, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF imm &gt; 63
			dst[i+63:i] := SignBit
		ELSE
			dst[i+63:i] := SignExtend(a[i+63:i] &lt;&lt; imm)
		FI
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpsraq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_sra_epi64 / vpsraq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_sra_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="count" type="__m128i"/>
	<description>Shift packed 64-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst". </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF count[63:0] &gt; 63
		dst[i+63:i] := SignBit
	ELSE
		dst[i+63:i] := SignExtend(a[i+63:i] &gt;&gt; count[63:0])
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpsraq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_srai_epi64 / vpsraq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_srai_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="imm" type="unsigned int"/>
	<description>Shift packed 64-bit integers in "a" right by "imm" while shifting in sign bits, and store the results in "dst". </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF imm &gt; 63
		dst[i+63:i] := SignBit
	ELSE
		dst[i+63:i] := SignExtend(a[i+63:i] &lt;&lt; imm)
	FI
ENDFOR
dst[MAX:512] := 0
	</description>	
	<mnemonic base="vpsraq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_srav_epi32 / vpsravd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_srav_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="count" type="__m512i"/>
	<description>Shift packed 32-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in sign bits, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := SignExtend(a[i+31:i] &gt;&gt; count[i+4:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI	
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpsravd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_srav_epi32 / vpsravd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_srav_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="count" type="__m512i"/>
	<description>Shift packed 32-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in sign bits, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := SignExtend(a[i+31:i] &gt;&gt; count[i+4:i])
	ELSE
		dst[i+31:i] := 0
	FI	
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpsravd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_srav_epi32 / vpsravd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_srav_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="count" type="__m512i"/>
	<description>Shift packed 32-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in sign bits, and store the results in "dst". </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := SignExtend(a[i+31:i] &gt;&gt; count[i+4:i])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpsravd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_srav_epi64 / vpsravq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_srav_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="count" type="__m512i"/>
	<description>Shift packed 64-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in sign bits, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := SignExtend(a[i+63:i] &gt;&gt; count[i+5:i])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI	
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpsravq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_srav_epi64 / vpsravq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_srav_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="count" type="__m512i"/>
	<description>Shift packed 64-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in sign bits, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := SignExtend(a[i+63:i] &gt;&gt; count[i+5:i])
	ELSE
		dst[i+63:i] := 0
	FI	
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpsravq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_srav_epi64 / vpsravq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_srav_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="count" type="__m512i"/>
	<description>Shift packed 64-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in sign bits, and store the results in "dst". </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := SignExtend(a[i+63:i] &gt;&gt; count[i+5:i])	
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpsravq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_srl_epi32 / vpsrld -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_srl_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="count" type="__m128i"/>
	<description>Shift packed 32-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF count[63:0] &gt; 31
			dst[i+31:i] := 0
		ELSE
			dst[i+31:i] := ZeroExtend(a[i+31:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpsrld"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_srli_epi32 / vpsrld -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_srli_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="imm" type="unsigned int"/>
	<description>Shift packed 32-bit integers in "a" right by "imm" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF imm &gt; 31
			dst[i+31:i] := 0
		ELSE
			dst[i+31:i] := ZeroExtend(a[i+31:i] &gt;&gt; imm)
		FI
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpsrld"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_srl_epi32 / vpsrld -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_srl_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="count" type="__m128i"/>
	<description>Shift packed 32-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF count[63:0] &gt; 31
			dst[i+31:i] := 0
		ELSE
			dst[i+31:i] := ZeroExtend(a[i+31:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpsrld"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_srli_epi32 / vpsrld -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_srli_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="imm" type="unsigned int"/>
	<description>Shift packed 32-bit integers in "a" right by "imm" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF imm &gt; 31
			dst[i+31:i] := 0
		ELSE
			dst[i+31:i] := ZeroExtend(a[i+31:i] &gt;&gt; imm)
		FI
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpsrld"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_srl_epi32 / vpsrld -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_srl_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="count" type="__m128i"/>
	<description>Shift packed 32-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst". </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF count[63:0] &gt; 31
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := ZeroExtend(a[i+31:i] &gt;&gt; count[63:0])
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpsrld"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_srli_epi32 / vpsrld -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_srli_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="imm" type="unsigned int"/>
	<description>Shift packed 32-bit integers in "a" right by "imm" while shifting in zeros, and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF imm &gt; 31
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := ZeroExtend(a[i+31:i] &gt;&gt; imm)
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpsrld"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_srl_epi64 / vpsrlq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_srl_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="count" type="__m128i"/>
	<description>Shift packed 64-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF count[63:0] &gt; 63
			dst[i+63:i] := 0
		ELSE
			dst[i+63:i] := ZeroExtend(a[i+63:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpsrlq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_srli_epi64 / vpsrlq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_srli_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="imm" type="unsigned int"/>
	<description>Shift packed 64-bit integers in "a" right by "imm" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF imm &gt; 63
			dst[i+63:i] := 0
		ELSE
			dst[i+63:i] := ZeroExtend(a[i+63:i] &gt;&gt; imm)
		FI
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>	
	<mnemonic base="vpsrlq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_srl_epi64 / vpsrlq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_srl_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="count" type="__m128i"/>
	<description>Shift packed 64-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF count[63:0] &gt; 63
			dst[i+63:i] := 0
		ELSE
			dst[i+63:i] := ZeroExtend(a[i+63:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpsrlq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_srli_epi64 / vpsrlq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_srli_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="imm" type="unsigned int"/>
	<description>Shift packed 64-bit integers in "a" right by "imm" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF imm &gt; 63
			dst[i+63:i] := 0
		ELSE
			dst[i+63:i] := ZeroExtend(a[i+63:i] &gt;&gt; imm)
		FI
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>	
	<mnemonic base="vpsrlq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_srl_epi64 / vpsrlq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_srl_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="count" type="__m128i"/>
	<description>Shift packed 64-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst". </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF count[63:0] &gt; 63
		dst[i+63:i] := 0
	ELSE
		dst[i+63:i] := ZeroExtend(a[i+63:i] &gt;&gt; count[63:0])
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpsrlq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_srli_epi64 / vpsrlq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_srli_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="imm" type="unsigned int"/>
	<description>Shift packed 64-bit integers in "a" right by "imm" while shifting in zeros, and store the results in "dst". </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF imm &gt; 63
		dst[i+63:i] := 0
	ELSE
		dst[i+63:i] := ZeroExtend(a[i+63:i] &gt;&gt; imm)
	FI
ENDFOR
dst[MAX:512] := 0
	</description>	
	<mnemonic base="vpsrlq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_srlv_epi32 / vpsrlvd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_srlv_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="count" type="__m512i"/>
	<description>Shift packed 32-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := ZeroExtend(a[i+31:i] &gt;&gt; count[i+4:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI	
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpsrlvd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_srlv_epi32 / vpsrlvd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_srlv_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="count" type="__m512i"/>
	<description>Shift packed 32-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := ZeroExtend(a[i+31:i] &gt;&gt; count[i+4:i])
	ELSE
		dst[i+31:i] := 0
	FI	
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpsrlvd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_srlv_epi32 / vpsrlvd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_srlv_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="count" type="__m512i"/>
	<description>Shift packed 32-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst". </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := ZeroExtend(a[i+31:i] &gt;&gt; count[i+4:i])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpsrlvd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_srlv_epi64 / vpsrlvq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_srlv_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="count" type="__m512i"/>
	<description>Shift packed 64-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := ZeroExtend(a[i+63:i] &gt;&gt; count[i+5:i])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI	
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpsrlvq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_srlv_epi64 / vpsrlvq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_srlv_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="count" type="__m512i"/>
	<description>Shift packed 64-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := ZeroExtend(a[i+63:i] &gt;&gt; count[i+5:i])
	ELSE
		dst[i+63:i] := 0
	FI	
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpsrlvq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_srlv_epi64 / vpsrlvq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_srlv_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Shift</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="count" type="__m512i"/>
	<description>Shift packed 64-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst". </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := ZeroExtend(a[i+63:i] &gt;&gt; count[i+5:i])	
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpsrlvq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_sub_epi32 / vpsubd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_sub_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Subtract packed 32-bit integers in "b" from packed 32-bit integers in "a", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i] - b[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI	
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpsubd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_sub_epi32 / vpsubd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_sub_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Subtract packed 32-bit integers in "b" from packed 32-bit integers in "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i] - b[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI	
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpsubd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_sub_epi32 / vpsubd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_sub_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Subtract packed 32-bit integers in "b" from packed 32-bit integers in "a", and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := a[i+31:i] - b[i+31:i]
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpsubd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_sub_epi64 / vpsubq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_sub_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Subtract packed 64-bit integers in "b" from packed 64-bit integers in "a", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] - b[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI	
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpsubq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_sub_epi64 / vpsubq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_sub_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Subtract packed 64-bit integers in "b" from packed 64-bit integers in "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] - b[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI	
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpsubq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_sub_epi64 / vpsubq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_sub_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Subtract packed 64-bit integers in "b" from packed 64-bit integers in "a", and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := a[i+63:i] - b[i+63:i]
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpsubq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_ternarylogic_epi32 / vpternlogd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_ternarylogic_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Logical</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<parameter varname="imm8" type="int"/>
	<description>Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in "imm8". For each bit in each packed 32-bit integer, the corresponding bit from "src", "a", and "b" are used to form a 3 bit index into "imm8", and the value at that bit in "imm8" is written to the corresponding bit in "dst" using writemask "k" at 32-bit granularity (32-bit elements are copied from "src" when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		FOR h := 0 to 31
			index[2:0] := (src[i+h] &lt;&lt; 2) OR (a[i+h] &lt;&lt; 1) OR b[i+h]
			dst[i+h] := imm8[index[2:0]]
		ENDFOR
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpternlogd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_ternarylogic_epi32 / vpternlogd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_ternarylogic_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Logical</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<parameter varname="c" type="__m512i"/>
	<parameter varname="imm8" type="int"/>
	<description>Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in "imm8". For each bit in each packed 32-bit integer, the corresponding bit from "a", "b", and "c" are used to form a 3 bit index into "imm8", and the value at that bit in "imm8" is written to the corresponding bit in "dst" using zeromask "k" at 32-bit granularity (32-bit elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		FOR h := 0 to 31
			index[2:0] := (a[i+h] &lt;&lt; 2) OR (b[i+h] &lt;&lt; 1) OR c[i+h]
			dst[i+h] := imm8[index[2:0]]
		ENDFOR
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpternlogd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_ternarylogic_epi32 / vpternlogd -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_ternarylogic_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Logical</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<parameter varname="c" type="__m512i"/>
	<parameter varname="imm8" type="int"/>
	<description>Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in "imm8". For each bit in each packed 32-bit integer, the corresponding bit from "a", "b", and "c" are used to form a 3 bit index into "imm8", and the value at that bit in "imm8" is written to the corresponding bit in "dst".</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	FOR h := 0 to 31
		index[2:0] := (a[i+h] &lt;&lt; 2) OR (b[i+h] &lt;&lt; 1) OR c[i+h]
		dst[i+h] := imm8[index[2:0]]
	ENDFOR
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpternlogd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_ternarylogic_epi64 / vpternlogq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_ternarylogic_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Logical</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<parameter varname="imm8" type="int"/>
	<description>Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in "imm8". For each bit in each packed 64-bit integer, the corresponding bit from "src", "a", and "b" are used to form a 3 bit index into "imm8", and the value at that bit in "imm8" is written to the corresponding bit in "dst" using writemask "k" at 64-bit granularity (64-bit elements are copied from "src" when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		FOR h := 0 to 63
			index[2:0] := (src[i+h] &lt;&lt; 2) OR (a[i+h] &lt;&lt; 1) OR b[i+h]
			dst[i+h] := imm8[index[2:0]]
		ENDFOR
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpternlogq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_ternarylogic_epi64 / vpternlogq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_ternarylogic_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Logical</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<parameter varname="c" type="__m512i"/>
	<parameter varname="imm8" type="int"/>
	<description>Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in "imm8". For each bit in each packed 64-bit integer, the corresponding bit from "a", "b", and "c" are used to form a 3 bit index into "imm8", and the value at that bit in "imm8" is written to the corresponding bit in "dst" using zeromask "k" at 64-bit granularity (64-bit elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		FOR h := 0 to 63
			index[2:0] := (a[i+h] &lt;&lt; 2) OR (b[i+h] &lt;&lt; 1) OR c[i+h]
			dst[i+h] := imm8[index[2:0]]
		ENDFOR
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpternlogq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_ternarylogic_epi64 / vpternlogq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_ternarylogic_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Logical</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<parameter varname="c" type="__m512i"/>
	<parameter varname="imm8" type="int"/>
	<description>Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in "imm8". For each bit in each packed 64-bit integer, the corresponding bit from "a", "b", and "c" are used to form a 3 bit index into "imm8", and the value at that bit in "imm8" is written to the corresponding bit in "dst".</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	FOR h := 0 to 63
		index[2:0] := (a[i+h] &lt;&lt; 2) OR (b[i+h] &lt;&lt; 1) OR c[i+h]
		dst[i+h] := imm8[index[2:0]]
	ENDFOR
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpternlogq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_test_epi32_mask / vptestmd -->
<intrinsic tech="AVX-512" rettype="__mmask16" name="_mm512_mask_test_epi32_mask">
	<CPUID>AVX-512</CPUID>
	<category>Logical</category>
	<parameter varname="k1" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compute the bitwise AND of packed 32-bit integers in "a" and "b", producing intermediate 32-bit values, and set the corresponding bit in result mask "k" (subject to writemask "k") if the intermediate value is non-zero.</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k1[j]
		k[j] := ((a[i+31:i] AND b[i+31:i]) != 0) ? 1 : 0
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:16] := 0
	</description>
	<mnemonic base="vptestmd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_test_epi32_mask / vptestmd -->
<intrinsic tech="AVX-512" rettype="__mmask16" name="_mm512_test_epi32_mask">
	<CPUID>AVX-512</CPUID>
	<category>Logical</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compute the bitwise AND of packed 32-bit integers in "a" and "b", producing intermediate 32-bit values, and set the corresponding bit in result mask "k" if the intermediate value is non-zero.</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	k[j] := ((a[i+31:i] AND b[i+31:i]) != 0) ? 1 : 0
ENDFOR
k[MAX:16] := 0
	</description>
	<mnemonic base="vptestmd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_test_epi64_mask / vptestmq -->
<intrinsic tech="AVX-512" rettype="__mmask8" name="_mm512_mask_test_epi64_mask">
	<CPUID>AVX-512</CPUID>
	<category>Logical</category>
	<parameter varname="k1" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compute the bitwise AND of packed 64-bit integers in "a" and "b", producing intermediate 64-bit values, and set the corresponding bit in result mask "k" (subject to writemask "k") if the intermediate value is non-zero.</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k1[j]
		k[j] := ((a[i+63:i] AND b[i+63:i]) != 0) ? 1 : 0
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</description>
	<mnemonic base="vptestmq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_test_epi64_mask / vptestmq -->
<intrinsic tech="AVX-512" rettype="__mmask8" name="_mm512_test_epi64_mask">
	<CPUID>AVX-512</CPUID>
	<category>Logical</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compute the bitwise AND of packed 64-bit integers in "a" and "b", producing intermediate 64-bit values, and set the corresponding bit in result mask "k" if the intermediate value is non-zero.</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	k[j] := ((a[i+63:i] AND b[i+63:i]) != 0) ? 1 : 0
ENDFOR
k[MAX:8] := 0
	</description>
	<mnemonic base="vptestmq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_testn_epi32_mask / vptestnmd -->
<intrinsic tech="AVX-512" rettype="__mmask16" name="_mm512_mask_testn_epi32_mask">
	<CPUID>AVX-512.CDI</CPUID>
	<category>Logical</category>
	<parameter varname="k1" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compute the bitwise AND NOT of packed 32-bit integers in "a" and "b", producing intermediate 32-bit values, and set the corresponding bit in result mask "k" (subject to writemask "k") if the intermediate value is zero.</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k1[j]
		k[j] := ((a[i+31:i] AND NOT b[i+31:i]) == 0) ? 1 : 0
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:16] := 0
	</description>
	<mnemonic base="vptestnmd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_testn_epi32_mask / vptestnmd -->
<intrinsic tech="AVX-512" rettype="__mmask16" name="_mm512_testn_epi32_mask">
	<CPUID>AVX-512.CDI</CPUID>
	<category>Logical</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compute the bitwise AND NOT of packed 32-bit integers in "a" and "b", producing intermediate 32-bit values, and set the corresponding bit in result mask "k" if the intermediate value is zero.</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	k[j] := ((a[i+31:i] AND NOT b[i+31:i]) == 0) ? 1 : 0
ENDFOR
k[MAX:16] := 0
	</description>
	<mnemonic base="vptestnmd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_testn_epi64_mask / vptestnmq -->
<intrinsic tech="AVX-512" rettype="__mmask8" name="_mm512_mask_testn_epi64_mask">
	<CPUID>AVX-512.CDI</CPUID>
	<category>Logical</category>
	<parameter varname="k1" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compute the bitwise AND NOT of packed 64-bit integers in "a" and "b", producing intermediate 64-bit values, and set the corresponding bit in result mask "k" (subject to writemask "k") if the intermediate value is zero.</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k1[j]
		k[j] := ((a[i+63:i] AND NOT b[i+63:i]) == 0) ? 1 : 0
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</description>
	<mnemonic base="vptestnmq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_testn_epi64_mask / vptestnmq -->
<intrinsic tech="AVX-512" rettype="__mmask8" name="_mm512_testn_epi64_mask">
	<CPUID>AVX-512.CDI</CPUID>
	<category>Logical</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compute the bitwise AND NOT of packed 64-bit integers in "a" and "b", producing intermediate 64-bit values, and set the corresponding bit in result mask "k" if the intermediate value is zero.</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	k[j] := ((a[i+63:i] AND NOT b[i+63:i]) == 0) ? 1 : 0
ENDFOR
k[MAX:8] := 0
	</description>
	<mnemonic base="vptestnmq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_unpackhi_epi32 / vpunpckhdq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_unpackhi_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Unpack and interleave 32-bit integers from the high half of each 128-bit lane in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
INTERLEAVE_HIGH_DWORDS(src1[127:0], src2[127:0]){
	dst[31:0] := src1[95:64] 
	dst[63:32] := src2[95:64] 
	dst[95:64] := src1[127:96] 
	dst[127:96] := src2[127:96] 
	RETURN dst[127:0]
}	
	
tmp_dst[127:0] := INTERLEAVE_HIGH_DWORDS(a[127:0], b[127:0])
tmp_dst[255:128] := INTERLEAVE_HIGH_DWORDS(a[255:128], b[255:128])
tmp_dst[383:256] := INTERLEAVE_HIGH_DWORDS(a[383:256], b[383:256])
tmp_dst[511:384] := INTERLEAVE_HIGH_DWORDS(a[511:384], b[511:384])

FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp_dst[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpunpckhdq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_unpackhi_epi32 / vpunpckhdq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_unpackhi_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Unpack and interleave 32-bit integers from the high half of each 128-bit lane in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
INTERLEAVE_HIGH_DWORDS(src1[127:0], src2[127:0]){
	dst[31:0] := src1[95:64] 
	dst[63:32] := src2[95:64] 
	dst[95:64] := src1[127:96] 
	dst[127:96] := src2[127:96] 
	RETURN dst[127:0]
}	
	
tmp_dst[127:0] := INTERLEAVE_HIGH_DWORDS(a[127:0], b[127:0])
tmp_dst[255:128] := INTERLEAVE_HIGH_DWORDS(a[255:128], b[255:128])
tmp_dst[383:256] := INTERLEAVE_HIGH_DWORDS(a[383:256], b[383:256])
tmp_dst[511:384] := INTERLEAVE_HIGH_DWORDS(a[511:384], b[511:384])

FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp_dst[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpunpckhdq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_unpackhi_epi32 / vpunpckhdq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_unpackhi_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Unpack and interleave 32-bit integers from the high half of each 128-bit lane in "a" and "b", and store the results in "dst". </description>
	<description code="true">
INTERLEAVE_HIGH_DWORDS(src1[127:0], src2[127:0]){
	dst[31:0] := src1[95:64] 
	dst[63:32] := src2[95:64] 
	dst[95:64] := src1[127:96] 
	dst[127:96] := src2[127:96] 
	RETURN dst[127:0]
}	
	
dst[127:0] := INTERLEAVE_HIGH_DWORDS(a[127:0], b[127:0])
dst[255:128] := INTERLEAVE_HIGH_DWORDS(a[255:128], b[255:128])
dst[383:256] := INTERLEAVE_HIGH_DWORDS(a[383:256], b[383:256])
dst[511:384] := INTERLEAVE_HIGH_DWORDS(a[511:384], b[511:384])
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpunpckhdq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_unpackhi_epi64 / vpunpckhqdq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_unpackhi_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Unpack and interleave 64-bit integers from the high half of each 128-bit lane in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
INTERLEAVE_HIGH_QWORDS(src1[127:0], src2[127:0]){
	dst[63:0] := src1[127:64] 
	dst[127:64] := src2[127:64] 
	RETURN dst[127:0]
}	
	
tmp_dst[127:0] := INTERLEAVE_HIGH_QWORDS(a[127:0], b[127:0])
tmp_dst[255:128] := INTERLEAVE_HIGH_QWORDS(a[255:128], b[255:128])
tmp_dst[383:256] := INTERLEAVE_HIGH_QWORDS(a[383:256], b[383:256])
tmp_dst[511:384] := INTERLEAVE_HIGH_QWORDS(a[511:384], b[511:384])

FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp_dst[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpunpckhqdq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_unpackhi_epi64 / vpunpckhqdq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_unpackhi_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Unpack and interleave 64-bit integers from the high half of each 128-bit lane in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
INTERLEAVE_HIGH_QWORDS(src1[127:0], src2[127:0]){
	dst[63:0] := src1[127:64] 
	dst[127:64] := src2[127:64] 
	RETURN dst[127:0]
}	
	
tmp_dst[127:0] := INTERLEAVE_HIGH_QWORDS(a[127:0], b[127:0])
tmp_dst[255:128] := INTERLEAVE_HIGH_QWORDS(a[255:128], b[255:128])
tmp_dst[383:256] := INTERLEAVE_HIGH_QWORDS(a[383:256], b[383:256])
tmp_dst[511:384] := INTERLEAVE_HIGH_QWORDS(a[511:384], b[511:384])

FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp_dst[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpunpckhqdq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_unpackhi_epi64 / vpunpckhqdq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_unpackhi_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Unpack and interleave 64-bit integers from the high half of each 128-bit lane in "a" and "b", and store the results in "dst". </description>
	<description code="true">
INTERLEAVE_HIGH_QWORDS(src1[127:0], src2[127:0]){
	dst[63:0] := src1[127:64] 
	dst[127:64] := src2[127:64] 
	RETURN dst[127:0]
}	
	
dst[127:0] := INTERLEAVE_HIGH_QWORDS(a[127:0], b[127:0])
dst[255:128] := INTERLEAVE_HIGH_QWORDS(a[255:128], b[255:128])
dst[383:256] := INTERLEAVE_HIGH_QWORDS(a[383:256], b[383:256])
dst[511:384] := INTERLEAVE_HIGH_QWORDS(a[511:384], b[511:384])
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpunpckhqdq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_unpacklo_epi32 / vpunpckldq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_unpacklo_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Unpack and interleave 32-bit integers from the low half of each 128-bit lane in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
INTERLEAVE_DWORDS(src1[127:0], src2[127:0]){
	dst[31:0] := src1[31:0] 
	dst[63:32] := src2[31:0] 
	dst[95:64] := src1[63:32] 
	dst[127:96] := src2[63:32] 
	RETURN dst[127:0]
}	

tmp_dst[127:0] := INTERLEAVE_DWORDS(a[127:0], b[127:0])
tmp_dst[255:128] := INTERLEAVE_DWORDS(a[255:128], b[255:128])
tmp_dst[383:256] := INTERLEAVE_DWORDS(a[383:256], b[383:256])
tmp_dst[511:384] := INTERLEAVE_DWORDS(a[511:384], b[511:384])

FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp_dst[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpunpckldq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_unpacklo_epi32 / vpunpckldq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_unpacklo_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Unpack and interleave 32-bit integers from the low half of each 128-bit lane in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
INTERLEAVE_DWORDS(src1[127:0], src2[127:0]){
	dst[31:0] := src1[31:0] 
	dst[63:32] := src2[31:0] 
	dst[95:64] := src1[63:32] 
	dst[127:96] := src2[63:32] 
	RETURN dst[127:0]
}	

tmp_dst[127:0] := INTERLEAVE_DWORDS(a[127:0], b[127:0])
tmp_dst[255:128] := INTERLEAVE_DWORDS(a[255:128], b[255:128])
tmp_dst[383:256] := INTERLEAVE_DWORDS(a[383:256], b[383:256])
tmp_dst[511:384] := INTERLEAVE_DWORDS(a[511:384], b[511:384])

FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp_dst[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpunpckldq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_unpacklo_epi32 / vpunpckldq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_unpacklo_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Unpack and interleave 32-bit integers from the low half of each 128-bit lane in "a" and "b", and store the results in "dst". </description>
	<description code="true">
INTERLEAVE_DWORDS(src1[127:0], src2[127:0]){
	dst[31:0] := src1[31:0] 
	dst[63:32] := src2[31:0] 
	dst[95:64] := src1[63:32] 
	dst[127:96] := src2[63:32] 
	RETURN dst[127:0]
}	

dst[127:0] := INTERLEAVE_DWORDS(a[127:0], b[127:0])
dst[255:128] := INTERLEAVE_DWORDS(a[255:128], b[255:128])
dst[383:256] := INTERLEAVE_DWORDS(a[383:256], b[383:256])
dst[511:384] := INTERLEAVE_DWORDS(a[511:384], b[511:384])
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpunpckldq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_unpacklo_epi64 / vpunpcklqdq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_unpacklo_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Unpack and interleave 64-bit integers from the low half of each 128-bit lane in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
INTERLEAVE_QWORDS(src1[127:0], src2[127:0]){
	dst[63:0] := src1[63:0] 
	dst[127:64] := src2[63:0] 
	RETURN dst[127:0]
}

tmp_dst[127:0] := INTERLEAVE_QWORDS(a[127:0], b[127:0])
tmp_dst[255:128] := INTERLEAVE_QWORDS(a[255:128], b[255:128])
tmp_dst[383:256] := INTERLEAVE_QWORDS(a[383:256], b[383:256])
tmp_dst[511:384] := INTERLEAVE_QWORDS(a[511:384], b[511:384])

FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp_dst[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpunpcklqdq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_unpacklo_epi64 / vpunpcklqdq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_unpacklo_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Unpack and interleave 64-bit integers from the low half of each 128-bit lane in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
INTERLEAVE_QWORDS(src1[127:0], src2[127:0]){
	dst[63:0] := src1[63:0] 
	dst[127:64] := src2[63:0] 
	RETURN dst[127:0]
}

tmp_dst[127:0] := INTERLEAVE_QWORDS(a[127:0], b[127:0])
tmp_dst[255:128] := INTERLEAVE_QWORDS(a[255:128], b[255:128])
tmp_dst[383:256] := INTERLEAVE_QWORDS(a[383:256], b[383:256])
tmp_dst[511:384] := INTERLEAVE_QWORDS(a[511:384], b[511:384])

FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp_dst[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpunpcklqdq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_unpacklo_epi64 / vpunpcklqdq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_unpacklo_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Unpack and interleave 64-bit integers from the low half of each 128-bit lane in "a" and "b", and store the results in "dst". </description>
	<description code="true">
INTERLEAVE_QWORDS(src1[127:0], src2[127:0]){
	dst[63:0] := src1[63:0] 
	dst[127:64] := src2[63:0] 
	RETURN dst[127:0]
}

dst[127:0] := INTERLEAVE_QWORDS(a[127:0], b[127:0])
dst[255:128] := INTERLEAVE_QWORDS(a[255:128], b[255:128])
dst[383:256] := INTERLEAVE_QWORDS(a[383:256], b[383:256])
dst[511:384] := INTERLEAVE_QWORDS(a[511:384], b[511:384])
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpunpcklqdq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_xor_epi32 / vpxord -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_xor_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Logical</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compute the bitwise XOR of packed 32-bit integers in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i] XOR b[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpxord"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_xor_epi32 / vpxord -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_xor_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Logical</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compute the bitwise XOR of packed 32-bit integers in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i] XOR b[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpxord"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_xor_epi32 / vpxord -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_xor_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Logical</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compute the bitwise XOR of packed 32-bit integers in "a" and "b", and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := a[i+31:i] XOR b[i+31:i]
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpxord"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_xor_si512 / vpxord -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_xor_si512">
	<CPUID>AVX-512</CPUID>
	<category>Logical</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compute the bitwise OR of 512 bits (representing integer data) in "a" and "b", and store the result in "dst".</description>
	<description code="true">
dst[511:0] := (a[511:0] XOR b[511:0])
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpxord"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_xor_epi64 / vpxorq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_xor_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Logical</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compute the bitwise XOR of packed 64-bit integers in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] XOR b[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpxorq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_xor_epi64 / vpxorq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_xor_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Logical</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compute the bitwise XOR of packed 64-bit integers in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] XOR b[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpxorq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_xor_epi64 / vpxorq -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_xor_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Logical</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<description>Compute the bitwise XOR of packed 64-bit integers in "a" and "b", and store the results in "dst".
	</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := a[i+63:i] XOR b[i+63:i]
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vpxorq"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_rcp14_pd / vrcp14pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_rcp14_pd">
	<CPUID>AVX-512</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="src" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<description>Compute the approximate reciprocal of packed double-precision (64-bit) floating-point elements in "a", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := APPROXIMATE(1.0/a[i+63:i])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vrcp14pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_rcp14_pd / vrcp14pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_rcp14_pd">
	<CPUID>AVX-512</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<description>Compute the approximate reciprocal of packed double-precision (64-bit) floating-point elements in "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := APPROXIMATE(1.0/a[i+63:i])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vrcp14pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_rcp14_pd / vrcp14pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_rcp14_pd">
	<CPUID>AVX-512</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="a" type="__m512d"/>
	<description>Compute the approximate reciprocal of packed double-precision (64-bit) floating-point elements in "a", and store the results in "dst". The maximum relative error for this approximation is less than 2^-14.</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := APPROXIMATE(1.0/a[i+63:i])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vrcp14pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_rcp14_ps / vrcp14ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_rcp14_ps">
	<CPUID>AVX-512</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="src" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<description>Compute the approximate reciprocal of packed single-precision (32-bit) floating-point elements in "a", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := APPROXIMATE(1.0/a[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vrcp14ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_rcp14_ps / vrcp14ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_rcp14_ps">
	<CPUID>AVX-512</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<description>Compute the approximate reciprocal of packed single-precision (32-bit) floating-point elements in "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := APPROXIMATE(1.0/a[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vrcp14ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_rcp14_ps / vrcp14ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_rcp14_ps">
	<CPUID>AVX-512</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="a" type="__m512"/>
	<description>Compute the approximate reciprocal of packed single-precision (32-bit) floating-point elements in "a", and store the results in "dst". The maximum relative error for this approximation is less than 2^-14.</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := APPROXIMATE(1.0/a[i+31:i])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vrcp14ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_rcp14_sd / vrcp14sd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_mask_rcp14_sd">
	<CPUID>AVX-512</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="src" type="__m128d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<description>Compute the approximate reciprocal of the lower double-precision (64-bit) floating-point element in "b", store the result in the lower element of "dst" using writemask "k" (the element is copied from "src" when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst". The maximum relative error for this approximation is less than 2^-14.</description>
	<description code="true">
IF k[0]
	dst[63:0] := APPROXIMATE(1.0/b[63:0])
ELSE
	dst[63:0] := src[63:0]
FI
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>	
	<mnemonic base="vrcp14sd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_rcp14_sd / vrcp14sd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_maskz_rcp14_sd">
	<CPUID>AVX-512</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<description>Compute the approximate reciprocal of the lower double-precision (64-bit) floating-point element in "b", store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst". The maximum relative error for this approximation is less than 2^-14.</description>
	<description code="true">
IF k[0]
	dst[63:0] := APPROXIMATE(1.0/b[63:0])
ELSE
	dst[63:0] := 0
FI
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vrcp14sd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_rcp14_sd / vrcp14sd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_rcp14_sd">
	<CPUID>AVX-512</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<description>Compute the approximate reciprocal of the lower double-precision (64-bit) floating-point element in "b", store the result in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst". The maximum relative error for this approximation is less than 2^-14.</description>
	<description code="true">
dst[63:0] := APPROXIMATE(1.0/b[63:0])
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vrcp14sd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_rcp14_ss / vrcp14ss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_mask_rcp14_ss">
	<CPUID>AVX-512</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="src" type="__m128"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<description>Compute the approximate reciprocal of the lower single-precision (32-bit) floating-point element in "b", store the result in the lower element of "dst" using writemask "k" (the element is copied from "src" when mask bit 0 is not set), and copy the upper 3 packed elements from "a" to the upper elements of "dst". The maximum relative error for this approximation is less than 2^-14.</description>
	<description code="true">
IF k[0]
	dst[31:0] := APPROXIMATE(1.0/b[31:0])
ELSE
	dst[31:0] := src[31:0]
FI
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>	
	<mnemonic base="vrcp14ss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_rcp14_ss / vrcp14ss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_maskz_rcp14_ss">
	<CPUID>AVX-512</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<description>Compute the approximate reciprocal of the lower single-precision (32-bit) floating-point element in "b", store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from "a" to the upper elements of "dst". The maximum relative error for this approximation is less than 2^-14.</description>
	<description code="true">
IF k[0]
	dst[31:0] := APPROXIMATE(1.0/b[31:0])
ELSE
	dst[31:0] := 0
FI
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vrcp14ss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_rcp14_ss / vrcp14ss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_rcp14_ss">
	<CPUID>AVX-512</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<description>Compute the approximate reciprocal of the lower single-precision (32-bit) floating-point element in "b", store the result in the lower element of "dst", and copy the upper 3 packed elements from "a" to the upper elements of "dst". The maximum relative error for this approximation is less than 2^-14.</description>
	<description code="true">
dst[31:0] := APPROXIMATE(1.0/b[31:0])
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vrcp14ss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_roundscale_pd / vrndscalepd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_roundscale_pd">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="src" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="imm" type="int"/>
	<description>Round packed double-precision (64-bit) floating-point elements in "a" to the number of fraction bits specified by "imm", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
RoundTo_IntegerPD(src[63:0], imm[7:0]){
	IF(imm[2] == 1)
		rounding_direction := MXCSR.RC //Use the rounding mode specified by MXCSR.RC
	ELSE
		rounding_direction := imm[1:0] //Use the rounding mode specified by imm[1:0]
	FI
	
	M := imm[7:4] // The scaling factor (number of fraction bits to round to)
	
	CASE(rounding_direction)
		0: tmp[63:0] := round_to_nearest_even_integer(2^M * src[63:0])
		1: tmp[63:0] := round_to_equal_or_smaller_integer(2^M * src[63:0])
		2: tmp[63:0] := round_to_equal_or_larger_integer(2^M * src[63:0])
		3: tmp[63:0] := round_to_nearest_smallest_magnitude_integer(2^M * src[63:0])
	ESAC
	
	dst[63:0] := 2^-M * tmp[63:0] // scale back down
	
	IF imm[3] == 0 //check SPE
		IF src[63:0] != dst[63:0] //check if precision has been lost
			set_precision() //set #PE
		FI
	FI
	RETURN dst[63:0]
}	

FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := RoundTo_IntegerPD(a[i+63:i], imm[7:0])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vrndscalepd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_roundscale_round_pd / vrndscalepd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_roundscale_round_pd">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="src" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="imm" type="int"/>
	<parameter varname="rounding" type="int"/>
	<description>Round packed double-precision (64-bit) floating-point elements in "a" to the number of fraction bits specified by "imm", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).
	[round_note]</description>
	<description code="true">
RoundTo_IntegerPD(src[63:0], imm[7:0]){
	IF(imm[2] == 1)
		rounding_direction := MXCSR.RC //Use the rounding mode specified by MXCSR.RC
	ELSE
		rounding_direction := imm[1:0] //Use the rounding mode specified by imm[1:0]
	FI
	
	M := imm[7:4] // The scaling factor (number of fraction bits to round to)
	
	CASE(rounding_direction)
		0: tmp[63:0] := round_to_nearest_even_integer(2^M * src[63:0])
		1: tmp[63:0] := round_to_equal_or_smaller_integer(2^M * src[63:0])
		2: tmp[63:0] := round_to_equal_or_larger_integer(2^M * src[63:0])
		3: tmp[63:0] := round_to_nearest_smallest_magnitude_integer(2^M * src[63:0])
	ESAC
	
	dst[63:0] := 2^-M * tmp[63:0] // scale back down
	
	IF imm[3] == 0 //check SPE
		IF src[63:0] != dst[63:0] //check if precision has been lost
			set_precision() //set #PE
		FI
	FI
	RETURN dst[63:0]
}	

FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := RoundTo_IntegerPD(a[i+63:i], imm[7:0])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vrndscalepd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_roundscale_pd / vrndscalepd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_roundscale_pd">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="imm" type="int"/>
	<description>Round packed double-precision (64-bit) floating-point elements in "a" to the number of fraction bits specified by "imm", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
RoundTo_IntegerPD(src[63:0], imm[7:0]){
	IF(imm[2] == 1)
		rounding_direction := MXCSR.RC //Use the rounding mode specified by MXCSR.RC
	ELSE
		rounding_direction := imm[1:0] //Use the rounding mode specified by imm[1:0]
	FI
	
	M := imm[7:4] // The scaling factor (number of fraction bits to round to)
	
	CASE(rounding_direction)
		0: tmp[63:0] := round_to_nearest_even_integer(2^M * src[63:0])
		1: tmp[63:0] := round_to_equal_or_smaller_integer(2^M * src[63:0])
		2: tmp[63:0] := round_to_equal_or_larger_integer(2^M * src[63:0])
		3: tmp[63:0] := round_to_nearest_smallest_magnitude_integer(2^M * src[63:0])
	ESAC
	
	dst[63:0] := 2^-M * tmp[63:0] // scale back down
	
	IF imm[3] == 0 //check SPE
		IF src[63:0] != dst[63:0] //check if precision has been lost
			set_precision() //set #PE
		FI
	FI
	RETURN dst[63:0]
}	

FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := RoundTo_IntegerPD(a[i+63:i], imm[7:0])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vrndscalepd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_roundscale_round_pd / vrndscalepd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_roundscale_round_pd">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="imm" type="int"/>
	<parameter varname="rounding" type="int"/>
	<description>Round packed double-precision (64-bit) floating-point elements in "a" to the number of fraction bits specified by "imm", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).
	[round_note]</description>
	<description code="true">
RoundTo_IntegerPD(src[63:0], imm[7:0]){
	IF(imm[2] == 1)
		rounding_direction := MXCSR.RC //Use the rounding mode specified by MXCSR.RC
	ELSE
		rounding_direction := imm[1:0] //Use the rounding mode specified by imm[1:0]
	FI
	
	M := imm[7:4] // The scaling factor (number of fraction bits to round to)
	
	CASE(rounding_direction)
		0: tmp[63:0] := round_to_nearest_even_integer(2^M * src[63:0])
		1: tmp[63:0] := round_to_equal_or_smaller_integer(2^M * src[63:0])
		2: tmp[63:0] := round_to_equal_or_larger_integer(2^M * src[63:0])
		3: tmp[63:0] := round_to_nearest_smallest_magnitude_integer(2^M * src[63:0])
	ESAC
	
	dst[63:0] := 2^-M * tmp[63:0] // scale back down
	
	IF imm[3] == 0 //check SPE
		IF src[63:0] != dst[63:0] //check if precision has been lost
			set_precision() //set #PE
		FI
	FI
	RETURN dst[63:0]
}	

FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := RoundTo_IntegerPD(a[i+63:i], imm[7:0])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vrndscalepd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_roundscale_pd / vrndscalepd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_roundscale_pd">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="imm" type="int"/>
	<description>Round packed double-precision (64-bit) floating-point elements in "a" to the number of fraction bits specified by "imm", and store the results in "dst".
	</description>
	<description code="true">
RoundTo_IntegerPD(src[63:0], imm[7:0]){
	IF(imm[2] == 1)
		rounding_direction := MXCSR.RC //Use the rounding mode specified by MXCSR.RC
	ELSE
		rounding_direction := imm[1:0] //Use the rounding mode specified by imm[1:0]
	FI
	
	M := imm[7:4] // The scaling factor (number of fraction bits to round to)
	
	CASE(rounding_direction)
		0: tmp[63:0] := round_to_nearest_even_integer(2^M * src[63:0])
		1: tmp[63:0] := round_to_equal_or_smaller_integer(2^M * src[63:0])
		2: tmp[63:0] := round_to_equal_or_larger_integer(2^M * src[63:0])
		3: tmp[63:0] := round_to_nearest_smallest_magnitude_integer(2^M * src[63:0])
	ESAC
	
	dst[63:0] := 2^-M * tmp[63:0] // scale back down
	
	IF imm[3] == 0 //check SPE
		IF src[63:0] != dst[63:0] //check if precision has been lost
			set_precision() //set #PE
		FI
	FI
	RETURN dst[63:0]
}	

FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := RoundTo_IntegerPD(a[i+63:i], imm[7:0])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vrndscalepd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_roundscale_round_pd / vrndscalepd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_roundscale_round_pd">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="imm" type="int"/>
	<parameter varname="rounding" type="int"/>
	<description>Round packed double-precision (64-bit) floating-point elements in "a" to the number of fraction bits specified by "imm", and store the results in "dst".
	[round_note]</description>
	<description code="true">
RoundTo_IntegerPD(src[63:0], imm[7:0]){
	IF(imm[2] == 1)
		rounding_direction := MXCSR.RC //Use the rounding mode specified by MXCSR.RC
	ELSE
		rounding_direction := imm[1:0] //Use the rounding mode specified by imm[1:0]
	FI
	
	M := imm[7:4] // The scaling factor (number of fraction bits to round to)
	
	CASE(rounding_direction)
		0: tmp[63:0] := round_to_nearest_even_integer(2^M * src[63:0])
		1: tmp[63:0] := round_to_equal_or_smaller_integer(2^M * src[63:0])
		2: tmp[63:0] := round_to_equal_or_larger_integer(2^M * src[63:0])
		3: tmp[63:0] := round_to_nearest_smallest_magnitude_integer(2^M * src[63:0])
	ESAC
	
	dst[63:0] := 2^-M * tmp[63:0] // scale back down
	
	IF imm[3] == 0 //check SPE
		IF src[63:0] != dst[63:0] //check if precision has been lost
			set_precision() //set #PE
		FI
	FI
	RETURN dst[63:0]
}	

FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := RoundTo_IntegerPD(a[i+63:i], imm[7:0])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vrndscalepd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_roundscale_ps / vrndscaleps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_roundscale_ps">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="src" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="imm" type="int"/>
	<description>Round packed single-precision (32-bit) floating-point elements in "a" to the number of fraction bits specified by "imm", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
RoundTo_IntegerPS(src[31:0], imm[7:0]){
	IF(imm[2] == 1)
		rounding_direction := MXCSR.RC //Use the rounding mode specified by MXCSR.RC
	ELSE
		rounding_direction := imm[1:0] //Use the rounding mode specified by imm[1:0]
	FI
	
	M := imm[7:4] // The scaling factor (number of fraction bits to round to)
	
	CASE(rounding_direction)
		0: tmp[31:0] := round_to_nearest_even_integer(2^M * src[31:0])
		1: tmp[31:0] := round_to_equal_or_smaller_integer(2^M * src[31:0])
		2: tmp[31:0] := round_to_equal_or_larger_integer(2^M * src[31:0])
		3: tmp[31:0] := round_to_nearest_smallest_magnitude_integer(2^M * src[31:0])
	ESAC
	
	dst[31:0] := 2^-M * tmp[31:0] // scale back down
	
	IF imm[3] == 0 //check SPE
		IF src[31:0] != dst[31:0] //check if precision has been lost
			set_precision() //set #PE
		FI
	FI
	RETURN dst[31:0]
}	

FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := RoundTo_IntegerPS(a[i+31:i], imm[7:0])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vrndscaleps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_roundscale_round_ps / vrndscaleps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_roundscale_round_ps">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="src" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="imm" type="int"/>
	<parameter varname="rounding" type="int"/>
	<description>Round packed single-precision (32-bit) floating-point elements in "a" to the number of fraction bits specified by "imm", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).
	[round_note]</description>
	<description code="true">
RoundTo_IntegerPS(src[31:0], imm[7:0]){
	IF(imm[2] == 1)
		rounding_direction := MXCSR.RC //Use the rounding mode specified by MXCSR.RC
	ELSE
		rounding_direction := imm[1:0] //Use the rounding mode specified by imm[1:0]
	FI
	
	M := imm[7:4] // The scaling factor (number of fraction bits to round to)
	
	CASE(rounding_direction)
		0: tmp[31:0] := round_to_nearest_even_integer(2^M * src[31:0])
		1: tmp[31:0] := round_to_equal_or_smaller_integer(2^M * src[31:0])
		2: tmp[31:0] := round_to_equal_or_larger_integer(2^M * src[31:0])
		3: tmp[31:0] := round_to_nearest_smallest_magnitude_integer(2^M * src[31:0])
	ESAC
	
	dst[31:0] := 2^-M * tmp[31:0] // scale back down
	
	IF imm[3] == 0 //check SPE
		IF src[31:0] != dst[31:0] //check if precision has been lost
			set_precision() //set #PE
		FI
	FI
	RETURN dst[31:0]
}	

FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := RoundTo_IntegerPS(a[i+31:i], imm[7:0])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vrndscaleps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_roundscale_ps / vrndscaleps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_roundscale_ps">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="imm" type="int"/>
	<description>Round packed single-precision (32-bit) floating-point elements in "a" to the number of fraction bits specified by "imm", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
RoundTo_IntegerPS(src[31:0], imm[7:0]){
	IF(imm[2] == 1)
		rounding_direction := MXCSR.RC //Use the rounding mode specified by MXCSR.RC
	ELSE
		rounding_direction := imm[1:0] //Use the rounding mode specified by imm[1:0]
	FI
	
	M := imm[7:4] // The scaling factor (number of fraction bits to round to)
	
	CASE(rounding_direction)
		0: tmp[31:0] := round_to_nearest_even_integer(2^M * src[31:0])
		1: tmp[31:0] := round_to_equal_or_smaller_integer(2^M * src[31:0])
		2: tmp[31:0] := round_to_equal_or_larger_integer(2^M * src[31:0])
		3: tmp[31:0] := round_to_nearest_smallest_magnitude_integer(2^M * src[31:0])
	ESAC
	
	dst[31:0] := 2^-M * tmp[31:0] // scale back down
	
	IF imm[3] == 0 //check SPE
		IF src[31:0] != dst[31:0] //check if precision has been lost
			set_precision() //set #PE
		FI
	FI
	RETURN dst[31:0]
}	

FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := RoundTo_IntegerPS(a[i+31:i], imm[7:0])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vrndscaleps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_roundscale_round_ps / vrndscaleps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_roundscale_round_ps">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="imm" type="int"/>
	<parameter varname="rounding" type="int"/>
	<description>Round packed single-precision (32-bit) floating-point elements in "a" to the number of fraction bits specified by "imm", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).
	[round_note]</description>
	<description code="true">
RoundTo_IntegerPS(src[31:0], imm[7:0]){
	IF(imm[2] == 1)
		rounding_direction := MXCSR.RC //Use the rounding mode specified by MXCSR.RC
	ELSE
		rounding_direction := imm[1:0] //Use the rounding mode specified by imm[1:0]
	FI
	
	M := imm[7:4] // The scaling factor (number of fraction bits to round to)
	
	CASE(rounding_direction)
		0: tmp[31:0] := round_to_nearest_even_integer(2^M * src[31:0])
		1: tmp[31:0] := round_to_equal_or_smaller_integer(2^M * src[31:0])
		2: tmp[31:0] := round_to_equal_or_larger_integer(2^M * src[31:0])
		3: tmp[31:0] := round_to_nearest_smallest_magnitude_integer(2^M * src[31:0])
	ESAC
	
	dst[31:0] := 2^-M * tmp[31:0] // scale back down
	
	IF imm[3] == 0 //check SPE
		IF src[31:0] != dst[31:0] //check if precision has been lost
			set_precision() //set #PE
		FI
	FI
	RETURN dst[31:0]
}	

FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := RoundTo_IntegerPS(a[i+31:i], imm[7:0])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vrndscaleps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_roundscale_ps / vrndscaleps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_roundscale_ps">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="imm" type="int"/>
	<description>Round packed single-precision (32-bit) floating-point elements in "a" to the number of fraction bits specified by "imm", and store the results in "dst".
	</description>
	<description code="true">
RoundTo_IntegerPS(src[31:0], imm[7:0]){
	IF(imm[2] == 1)
		rounding_direction := MXCSR.RC //Use the rounding mode specified by MXCSR.RC
	ELSE
		rounding_direction := imm[1:0] //Use the rounding mode specified by imm[1:0]
	FI
	
	M := imm[7:4] // The scaling factor (number of fraction bits to round to)
	
	CASE(rounding_direction)
		0: tmp[31:0] := round_to_nearest_even_integer(2^M * src[31:0])
		1: tmp[31:0] := round_to_equal_or_smaller_integer(2^M * src[31:0])
		2: tmp[31:0] := round_to_equal_or_larger_integer(2^M * src[31:0])
		3: tmp[31:0] := round_to_nearest_smallest_magnitude_integer(2^M * src[31:0])
	ESAC
	
	dst[31:0] := 2^-M * tmp[31:0] // scale back down
	
	IF imm[3] == 0 //check SPE
		IF src[31:0] != dst[31:0] //check if precision has been lost
			set_precision() //set #PE
		FI
	FI
	RETURN dst[31:0]
}	

FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := RoundTo_IntegerPS(a[i+31:i], imm[7:0])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vrndscaleps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_roundscale_round_ps / vrndscaleps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_roundscale_round_ps">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="imm" type="int"/>
	<parameter varname="rounding" type="int"/>
	<description>Round packed single-precision (32-bit) floating-point elements in "a" to the number of fraction bits specified by "imm", and store the results in "dst".
	[round_note]</description>
	<description code="true">
RoundTo_IntegerPS(src[31:0], imm[7:0]){
	IF(imm[2] == 1)
		rounding_direction := MXCSR.RC //Use the rounding mode specified by MXCSR.RC
	ELSE
		rounding_direction := imm[1:0] //Use the rounding mode specified by imm[1:0]
	FI
	
	M := imm[7:4] // The scaling factor (number of fraction bits to round to)
	
	CASE(rounding_direction)
		0: tmp[31:0] := round_to_nearest_even_integer(2^M * src[31:0])
		1: tmp[31:0] := round_to_equal_or_smaller_integer(2^M * src[31:0])
		2: tmp[31:0] := round_to_equal_or_larger_integer(2^M * src[31:0])
		3: tmp[31:0] := round_to_nearest_smallest_magnitude_integer(2^M * src[31:0])
	ESAC
	
	dst[31:0] := 2^-M * tmp[31:0] // scale back down
	
	IF imm[3] == 0 //check SPE
		IF src[31:0] != dst[31:0] //check if precision has been lost
			set_precision() //set #PE
		FI
	FI
	RETURN dst[31:0]
}	

FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := RoundTo_IntegerPS(a[i+31:i], imm[7:0])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vrndscaleps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_roundscale_round_sd / vrndscalesd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_mask_roundscale_round_sd">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="src" type="__m128d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="imm" type="const int"/>
	<parameter varname="rounding" type="const int"/>
	<description>Round the lower double-precision (64-bit) floating-point element in "a" to the number of fraction bits specified by "imm", store the result in the lower element of "dst" using writemask "k" (the element is copied from "src" when mask bit 0 is not set), and copy the upper element from "b" to the upper element of "dst".
	[round_note]</description>
	<description code="true">
RoundTo_IntegerPD(src[63:0], imm[7:0]){
	IF(imm[2] == 1)
		rounding_direction := MXCSR.RC //Use the rounding mode specified by MXCSR.RC
	ELSE
		rounding_direction := imm[1:0] //Use the rounding mode specified by imm[1:0]
	FI
	
	M := imm[7:4] // The scaling factor (number of fraction bits to round to)
	
	CASE(rounding_direction)
		0: tmp[63:0] := round_to_nearest_even_integer(2^M * src[63:0])
		1: tmp[63:0] := round_to_equal_or_smaller_integer(2^M * src[63:0])
		2: tmp[63:0] := round_to_equal_or_larger_integer(2^M * src[63:0])
		3: tmp[63:0] := round_to_nearest_smallest_magnitude_integer(2^M * src[63:0])
	ESAC
	
	dst[63:0] := 2^-M * tmp[63:0] // scale back down
	
	IF imm[3] == 0 //check SPE
		IF src[63:0] != dst[63:0] //check if precision has been lost
			set_precision() //set #PE
		FI
	FI
	RETURN dst[63:0]
}		

IF k[0]
	dst[63:0] := RoundTo_IntegerPD(a[63:0], imm[7:0])
ELSE
	dst[63:0] := src[63:0]
FI
dst[127:64] := b[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vrndscalesd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_roundscale_sd / vrndscalesd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_mask_roundscale_sd">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="src" type="__m128d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="imm" type="const int"/>
	<description>Round the lower double-precision (64-bit) floating-point element in "a" to the number of fraction bits specified by "imm", store the result in the lower element of "dst" using writemask "k" (the element is copied from "src" when mask bit 0 is not set), and copy the upper element from "b" to the upper element of "dst".</description>
	<description code="true">
RoundTo_IntegerPD(src[63:0], imm[7:0]){
	IF(imm[2] == 1)
		rounding_direction := MXCSR.RC //Use the rounding mode specified by MXCSR.RC
	ELSE
		rounding_direction := imm[1:0] //Use the rounding mode specified by imm[1:0]
	FI
	
	M := imm[7:4] // The scaling factor (number of fraction bits to round to)
	
	CASE(rounding_direction)
		0: tmp[63:0] := round_to_nearest_even_integer(2^M * src[63:0])
		1: tmp[63:0] := round_to_equal_or_smaller_integer(2^M * src[63:0])
		2: tmp[63:0] := round_to_equal_or_larger_integer(2^M * src[63:0])
		3: tmp[63:0] := round_to_nearest_smallest_magnitude_integer(2^M * src[63:0])
	ESAC
	
	dst[63:0] := 2^-M * tmp[63:0] // scale back down
	
	IF imm[3] == 0 //check SPE
		IF src[63:0] != dst[63:0] //check if precision has been lost
			set_precision() //set #PE
		FI
	FI
	RETURN dst[63:0]
}		

IF k[0]
	dst[63:0] := RoundTo_IntegerPD(a[63:0], imm[7:0])
ELSE
	dst[63:0] := src[63:0]
FI
dst[127:64] := b[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vrndscalesd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_roundscale_round_sd / vrndscalesd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_maskz_roundscale_round_sd">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="imm" type="const int"/>
	<parameter varname="rounding" type="const int"/>
	<description>Round the lower double-precision (64-bit) floating-point element in "a" to the number of fraction bits specified by "imm", store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper element from "b" to the upper element of "dst".
	[round_note]</description>
	<description code="true">
RoundTo_IntegerPD(src[63:0], imm[7:0]){
	IF(imm[2] == 1)
		rounding_direction := MXCSR.RC //Use the rounding mode specified by MXCSR.RC
	ELSE
		rounding_direction := imm[1:0] //Use the rounding mode specified by imm[1:0]
	FI
	
	M := imm[7:4] // The scaling factor (number of fraction bits to round to)
	
	CASE(rounding_direction)
		0: tmp[63:0] := round_to_nearest_even_integer(2^M * src[63:0])
		1: tmp[63:0] := round_to_equal_or_smaller_integer(2^M * src[63:0])
		2: tmp[63:0] := round_to_equal_or_larger_integer(2^M * src[63:0])
		3: tmp[63:0] := round_to_nearest_smallest_magnitude_integer(2^M * src[63:0])
	ESAC
	
	dst[63:0] := 2^-M * tmp[63:0] // scale back down
	
	IF imm[3] == 0 //check SPE
		IF src[63:0] != dst[63:0] //check if precision has been lost
			set_precision() //set #PE
		FI
	FI
	RETURN dst[63:0]
}		

IF k[0]
	dst[63:0] := RoundTo_IntegerPD(a[63:0], imm[7:0])
ELSE
	dst[63:0] := 0
FI
dst[127:64] := b[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vrndscalesd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_roundscale_sd / vrndscalesd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_maskz_roundscale_sd">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="imm" type="const int"/>
	<description>Round the lower double-precision (64-bit) floating-point element in "a" to the number of fraction bits specified by "imm", store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper element from "b" to the upper element of "dst".</description>
	<description code="true">
RoundTo_IntegerPD(src[63:0], imm[7:0]){
	IF(imm[2] == 1)
		rounding_direction := MXCSR.RC //Use the rounding mode specified by MXCSR.RC
	ELSE
		rounding_direction := imm[1:0] //Use the rounding mode specified by imm[1:0]
	FI
	
	M := imm[7:4] // The scaling factor (number of fraction bits to round to)
	
	CASE(rounding_direction)
		0: tmp[63:0] := round_to_nearest_even_integer(2^M * src[63:0])
		1: tmp[63:0] := round_to_equal_or_smaller_integer(2^M * src[63:0])
		2: tmp[63:0] := round_to_equal_or_larger_integer(2^M * src[63:0])
		3: tmp[63:0] := round_to_nearest_smallest_magnitude_integer(2^M * src[63:0])
	ESAC
	
	dst[63:0] := 2^-M * tmp[63:0] // scale back down
	
	IF imm[3] == 0 //check SPE
		IF src[63:0] != dst[63:0] //check if precision has been lost
			set_precision() //set #PE
		FI
	FI
	RETURN dst[63:0]
}		

IF k[0]
	dst[63:0] := RoundTo_IntegerPD(a[63:0], imm[7:0])
ELSE
	dst[63:0] := 0
FI
dst[127:64] := b[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vrndscalesd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_roundscale_round_sd / vrndscalesd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_roundscale_round_sd">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="imm" type="const int"/>
	<parameter varname="rounding" type="const int"/>
	<description>Round the lower double-precision (64-bit) floating-point element in "a" to the number of fraction bits specified by "imm", store the result in the lower element of "dst", and copy the upper element from "b" to the upper element of "dst".
	[round_note]</description>
	<description code="true">
RoundTo_IntegerPD(src[63:0], imm[7:0]){
	IF(imm[2] == 1)
		rounding_direction := MXCSR.RC //Use the rounding mode specified by MXCSR.RC
	ELSE
		rounding_direction := imm[1:0] //Use the rounding mode specified by imm[1:0]
	FI
	
	M := imm[7:4] // The scaling factor (number of fraction bits to round to)
	
	CASE(rounding_direction)
		0: tmp[63:0] := round_to_nearest_even_integer(2^M * src[63:0])
		1: tmp[63:0] := round_to_equal_or_smaller_integer(2^M * src[63:0])
		2: tmp[63:0] := round_to_equal_or_larger_integer(2^M * src[63:0])
		3: tmp[63:0] := round_to_nearest_smallest_magnitude_integer(2^M * src[63:0])
	ESAC
	
	dst[63:0] := 2^-M * tmp[63:0] // scale back down
	
	IF imm[3] == 0 //check SPE
		IF src[63:0] != dst[63:0] //check if precision has been lost
			set_precision() //set #PE
		FI
	FI
	RETURN dst[63:0]
}		

dst[63:0] := RoundTo_IntegerPD(a[63:0], imm[7:0])
dst[127:64] := b[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vrndscalesd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_roundscale_sd / vrndscalesd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_roundscale_sd">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="imm" type="const int"/>
	<description>Round the lower double-precision (64-bit) floating-point element in "a" to the number of fraction bits specified by "imm", store the result in the lower element of "dst", and copy the upper element from "b" to the upper element of "dst".</description>
	<description code="true">
RoundTo_IntegerPD(src[63:0], imm[7:0]){
	IF(imm[2] == 1)
		rounding_direction := MXCSR.RC //Use the rounding mode specified by MXCSR.RC
	ELSE
		rounding_direction := imm[1:0] //Use the rounding mode specified by imm[1:0]
	FI
	
	M := imm[7:4] // The scaling factor (number of fraction bits to round to)
	
	CASE(rounding_direction)
		0: tmp[63:0] := round_to_nearest_even_integer(2^M * src[63:0])
		1: tmp[63:0] := round_to_equal_or_smaller_integer(2^M * src[63:0])
		2: tmp[63:0] := round_to_equal_or_larger_integer(2^M * src[63:0])
		3: tmp[63:0] := round_to_nearest_smallest_magnitude_integer(2^M * src[63:0])
	ESAC
	
	dst[63:0] := 2^-M * tmp[63:0] // scale back down
	
	IF imm[3] == 0 //check SPE
		IF src[63:0] != dst[63:0] //check if precision has been lost
			set_precision() //set #PE
		FI
	FI
	RETURN dst[63:0]
}		

dst[63:0] := RoundTo_IntegerPD(a[63:0], imm[7:0])
dst[127:64] := b[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vrndscalesd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_roundscale_round_ss / vrndscaless -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_mask_roundscale_round_ss">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="src" type="__m128"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="imm" type="const int"/>
	<parameter varname="rounding" type="const int"/>	
	<description>Round the lower single-precision (32-bit) floating-point element in "a" to the number of fraction bits specified by "imm", store the result in the lower element of "dst" using writemask "k" (the element is copied from "src" when mask bit 0 is not set), and copy the upper 3 packed elements from "b" to the upper elements of "dst".
	[round_note]</description>
	<description code="true">
RoundTo_IntegerPS(src[31:0], imm[7:0]){
	IF(imm[2] == 1)
		rounding_direction := MXCSR.RC //Use the rounding mode specified by MXCSR.RC
	ELSE
		rounding_direction := imm[1:0] //Use the rounding mode specified by imm[1:0]
	FI
	
	M := imm[7:4] // The scaling factor (number of fraction bits to round to)
	
	CASE(rounding_direction)
		0: tmp[31:0] := round_to_nearest_even_integer(2^M * src[31:0])
		1: tmp[31:0] := round_to_equal_or_smaller_integer(2^M * src[31:0])
		2: tmp[31:0] := round_to_equal_or_larger_integer(2^M * src[31:0])
		3: tmp[31:0] := round_to_nearest_smallest_magnitude_integer(2^M * src[31:0])
	ESAC
	
	dst[31:0] := 2^-M * tmp[31:0] // scale back down
	
	IF imm[3] == 0 //check SPE
		IF src[31:0] != dst[31:0] //check if precision has been lost
			set_precision() //set #PE
		FI
	FI
	RETURN dst[31:0]
}

IF k[0]
	dst[31:0] := RoundTo_IntegerPS(a[31:0], imm[7:0])
ELSE
	dst[31:0] := src[31:0]
FI
dst[127:32] := b[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vrndscaless"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_roundscale_ss / vrndscaless -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_mask_roundscale_ss">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="src" type="__m128"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="imm" type="const int"/>
	<description>Round the lower single-precision (32-bit) floating-point element in "a" to the number of fraction bits specified by "imm", store the result in the lower element of "dst" using writemask "k" (the element is copied from "src" when mask bit 0 is not set), and copy the upper 3 packed elements from "b" to the upper elements of "dst".</description>
	<description code="true">
RoundTo_IntegerPS(src[31:0], imm[7:0]){
	IF(imm[2] == 1)
		rounding_direction := MXCSR.RC //Use the rounding mode specified by MXCSR.RC
	ELSE
		rounding_direction := imm[1:0] //Use the rounding mode specified by imm[1:0]
	FI
	
	M := imm[7:4] // The scaling factor (number of fraction bits to round to)
	
	CASE(rounding_direction)
		0: tmp[31:0] := round_to_nearest_even_integer(2^M * src[31:0])
		1: tmp[31:0] := round_to_equal_or_smaller_integer(2^M * src[31:0])
		2: tmp[31:0] := round_to_equal_or_larger_integer(2^M * src[31:0])
		3: tmp[31:0] := round_to_nearest_smallest_magnitude_integer(2^M * src[31:0])
	ESAC
	
	dst[31:0] := 2^-M * tmp[31:0] // scale back down
	
	IF imm[3] == 0 //check SPE
		IF src[31:0] != dst[31:0] //check if precision has been lost
			set_precision() //set #PE
		FI
	FI
	RETURN dst[31:0]
}

IF k[0]
	dst[31:0] := RoundTo_IntegerPS(a[31:0], imm[7:0])
ELSE
	dst[31:0] := src[31:0]
FI
dst[127:32] := b[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vrndscaless"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_roundscale_round_ss / vrndscaless -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_maskz_roundscale_round_ss">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="imm" type="const int"/>
	<parameter varname="rounding" type="const int"/>
	<description>Round the lower single-precision (32-bit) floating-point element in "a" to the number of fraction bits specified by "imm", store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from "b" to the upper elements of "dst".
	[round_note]</description>
	<description code="true">
RoundTo_IntegerPS(src[31:0], imm[7:0]){
	IF(imm[2] == 1)
		rounding_direction := MXCSR.RC //Use the rounding mode specified by MXCSR.RC
	ELSE
		rounding_direction := imm[1:0] //Use the rounding mode specified by imm[1:0]
	FI
	
	M := imm[7:4] // The scaling factor (number of fraction bits to round to)
	
	CASE(rounding_direction)
		0: tmp[31:0] := round_to_nearest_even_integer(2^M * src[31:0])
		1: tmp[31:0] := round_to_equal_or_smaller_integer(2^M * src[31:0])
		2: tmp[31:0] := round_to_equal_or_larger_integer(2^M * src[31:0])
		3: tmp[31:0] := round_to_nearest_smallest_magnitude_integer(2^M * src[31:0])
	ESAC
	
	dst[31:0] := 2^-M * tmp[31:0] // scale back down
	
	IF imm[3] == 0 //check SPE
		IF src[31:0] != dst[31:0] //check if precision has been lost
			set_precision() //set #PE
		FI
	FI
	RETURN dst[31:0]
}

IF k[0]
	dst[31:0] := RoundTo_IntegerPS(a[31:0], imm[7:0])
ELSE
	dst[31:0] := 0
FI
dst[127:32] := b[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vrndscaless"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_roundscale_ss / vrndscaless -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_maskz_roundscale_ss">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="imm" type="const int"/>
	<description>Round the lower single-precision (32-bit) floating-point element in "a" to the number of fraction bits specified by "imm", store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from "b" to the upper elements of "dst".</description>
	<description code="true">
RoundTo_IntegerPS(src[31:0], imm[7:0]){
	IF(imm[2] == 1)
		rounding_direction := MXCSR.RC //Use the rounding mode specified by MXCSR.RC
	ELSE
		rounding_direction := imm[1:0] //Use the rounding mode specified by imm[1:0]
	FI
	
	M := imm[7:4] // The scaling factor (number of fraction bits to round to)
	
	CASE(rounding_direction)
		0: tmp[31:0] := round_to_nearest_even_integer(2^M * src[31:0])
		1: tmp[31:0] := round_to_equal_or_smaller_integer(2^M * src[31:0])
		2: tmp[31:0] := round_to_equal_or_larger_integer(2^M * src[31:0])
		3: tmp[31:0] := round_to_nearest_smallest_magnitude_integer(2^M * src[31:0])
	ESAC
	
	dst[31:0] := 2^-M * tmp[31:0] // scale back down
	
	IF imm[3] == 0 //check SPE
		IF src[31:0] != dst[31:0] //check if precision has been lost
			set_precision() //set #PE
		FI
	FI
	RETURN dst[31:0]
}

IF k[0]
	dst[31:0] := RoundTo_IntegerPS(a[31:0], imm[7:0])
ELSE
	dst[31:0] := 0
FI
dst[127:32] := b[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vrndscaless"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_roundscale_round_ss / vrndscaless -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_roundscale_round_ss">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="imm" type="const int"/>
	<parameter varname="rounding" type="const int"/>
	<description>Round the lower single-precision (32-bit) floating-point element in "a" to the number of fraction bits specified by "imm", store the result in the lower element of "dst", and copy the upper 3 packed elements from "b" to the upper elements of "dst".
	[round_note]</description>
	<description code="true">
RoundTo_IntegerPS(src[31:0], imm[7:0]){
	IF(imm[2] == 1)
		rounding_direction := MXCSR.RC //Use the rounding mode specified by MXCSR.RC
	ELSE
		rounding_direction := imm[1:0] //Use the rounding mode specified by imm[1:0]
	FI
	
	M := imm[7:4] // The scaling factor (number of fraction bits to round to)
	
	CASE(rounding_direction)
		0: tmp[31:0] := round_to_nearest_even_integer(2^M * src[31:0])
		1: tmp[31:0] := round_to_equal_or_smaller_integer(2^M * src[31:0])
		2: tmp[31:0] := round_to_equal_or_larger_integer(2^M * src[31:0])
		3: tmp[31:0] := round_to_nearest_smallest_magnitude_integer(2^M * src[31:0])
	ESAC
	
	dst[31:0] := 2^-M * tmp[31:0] // scale back down
	
	IF imm[3] == 0 //check SPE
		IF src[31:0] != dst[31:0] //check if precision has been lost
			set_precision() //set #PE
		FI
	FI
	RETURN dst[31:0]
}

dst[31:0] := RoundTo_IntegerPS(a[31:0], imm[7:0])
dst[127:32] := b[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vrndscaless"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_roundscale_ss / vrndscaless -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_roundscale_ss">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="imm" type="const int"/>
	<description>Round the lower single-precision (32-bit) floating-point element in "a" to the number of fraction bits specified by "imm", store the result in the lower element of "dst", and copy the upper 3 packed elements from "b" to the upper elements of "dst".</description>
	<description code="true">
RoundTo_IntegerPS(src[31:0], imm[7:0]){
	IF(imm[2] == 1)
		rounding_direction := MXCSR.RC //Use the rounding mode specified by MXCSR.RC
	ELSE
		rounding_direction := imm[1:0] //Use the rounding mode specified by imm[1:0]
	FI
	
	M := imm[7:4] // The scaling factor (number of fraction bits to round to)
	
	CASE(rounding_direction)
		0: tmp[31:0] := round_to_nearest_even_integer(2^M * src[31:0])
		1: tmp[31:0] := round_to_equal_or_smaller_integer(2^M * src[31:0])
		2: tmp[31:0] := round_to_equal_or_larger_integer(2^M * src[31:0])
		3: tmp[31:0] := round_to_nearest_smallest_magnitude_integer(2^M * src[31:0])
	ESAC
	
	dst[31:0] := 2^-M * tmp[31:0] // scale back down
	
	IF imm[3] == 0 //check SPE
		IF src[31:0] != dst[31:0] //check if precision has been lost
			set_precision() //set #PE
		FI
	FI
	RETURN dst[31:0]
}

dst[31:0] := RoundTo_IntegerPS(a[31:0], imm[7:0])
dst[127:32] := b[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vrndscaless"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_rsqrt14_pd / vrsqrt14pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_rsqrt14_pd">
	<CPUID>AVX-512</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="src" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<description>Compute the approximate reciprocal square root of packed double-precision (64-bit) floating-point elements in "a", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := APPROXIMATE(1.0 / SQRT(a[i+63:i]))
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>	
	<mnemonic base="vrsqrt14pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_rsqrt14_pd / vrsqrt14pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_rsqrt14_pd">
	<CPUID>AVX-512</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<description>Compute the approximate reciprocal square root of packed double-precision (64-bit) floating-point elements in "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := APPROXIMATE(1.0 / SQRT(a[i+63:i]))
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vrsqrt14pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_rsqrt14_pd / vrsqrt14pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_rsqrt14_pd">
	<CPUID>AVX-512</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="a" type="__m512d"/>
	<description>Compute the approximate reciprocal square root of packed double-precision (64-bit) floating-point elements in "a", and store the results in "dst". The maximum relative error for this approximation is less than 2^-14.</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := APPROXIMATE(1.0 / SQRT(a[i+63:i]))
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vrsqrt14pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_rsqrt14_ps / vrsqrt14ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_rsqrt14_ps">
	<CPUID>AVX-512</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="src" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<description>Compute the approximate reciprocal square root of packed single-precision (32-bit) floating-point elements in "a", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := APPROXIMATE(1.0 / SQRT(a[i+31:i]))
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vrsqrt14ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_rsqrt14_ps / vrsqrt14ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_rsqrt14_ps">
	<CPUID>AVX-512</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<description>Compute the approximate reciprocal square root of packed single-precision (32-bit) floating-point elements in "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := APPROXIMATE(1.0 / SQRT(a[i+31:i]))
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vrsqrt14ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_rsqrt14_ps / vrsqrt14ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_rsqrt14_ps">
	<CPUID>AVX-512</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="a" type="__m512"/>
	<description>Compute the approximate reciprocal square root of packed single-precision (32-bit) floating-point elements in "a", and store the results in "dst". The maximum relative error for this approximation is less than 2^-14.</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := APPROXIMATE(1.0 / SQRT(a[i+31:i]))
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vrsqrt14ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_rsqrt14_sd / vrsqrt14sd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_mask_rsqrt14_sd">
	<CPUID>AVX-512</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="src" type="__m128d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<description>Compute the approximate reciprocal square root of the lower double-precision (64-bit) floating-point element in "b", store the result in the lower element of "dst" using writemask "k" (the element is copied from "src" when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst". The maximum relative error for this approximation is less than 2^-14.</description>
	<description code="true">
IF k[0]
	dst[63:0] := APPROXIMATE(1.0 / SQRT(b[63:0]))
ELSE
	dst[63:0] := src[63:0]
FI
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vrsqrt14sd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_rsqrt14_sd / vrsqrt14sd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_maskz_rsqrt14_sd">
	<CPUID>AVX-512</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<description>Compute the approximate reciprocal square root of the lower double-precision (64-bit) floating-point element in "b", store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst". The maximum relative error for this approximation is less than 2^-14.</description>
	<description code="true">
IF k[0]
	dst[63:0] := APPROXIMATE(1.0 / SQRT(b[63:0]))
ELSE
	dst[63:0] := 0
FI
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vrsqrt14sd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_rsqrt14_sd / vrsqrt14sd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_rsqrt14_sd">
	<CPUID>AVX-512</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<description>Compute the approximate reciprocal square root of the lower double-precision (64-bit) floating-point element in "b", store the result in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst". The maximum relative error for this approximation is less than 2^-14.</description>
	<description code="true">
dst[63:0] := APPROXIMATE(1.0 / SQRT(b[63:0]))
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vrsqrt14sd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_rsqrt14_ss / vrsqrt14ss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_mask_rsqrt14_ss">
	<CPUID>AVX-512</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="src" type="__m128"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<description>Compute the approximate reciprocal square root of the lower single-precision (32-bit) floating-point element in "b", store the result in the lower element of "dst" using writemask "k" (the element is copied from "src" when mask bit 0 is not set), and copy the upper 3 packed elements from "a" to the upper elements of "dst". The maximum relative error for this approximation is less than 2^-14.</description>
	<description code="true">
IF k[0]
	dst[31:0] := APPROXIMATE(1.0 / SQRT(b[31:0]))
ELSE
	dst[31:0] := src[31:0]
FI
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>	
	<mnemonic base="vrsqrt14ss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_rsqrt14_ss / vrsqrt14ss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_maskz_rsqrt14_ss">
	<CPUID>AVX-512</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<description>Compute the approximate reciprocal square root of the lower single-precision (32-bit) floating-point element in "b", store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from "a" to the upper elements of "dst". The maximum relative error for this approximation is less than 2^-14.</description>
	<description code="true">
IF k[0]
	dst[31:0] := APPROXIMATE(1.0 / SQRT(b[31:0]))
ELSE
	dst[31:0] := 0
FI
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>	
	<mnemonic base="vrsqrt14ss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_rsqrt14_ss / vrsqrt14ss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_rsqrt14_ss">
	<CPUID>AVX-512</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<description>Compute the approximate reciprocal square root of the lower single-precision (32-bit) floating-point element in "b", store the result in the lower element of "dst", and copy the upper 3 packed elements from "a" to the upper elements of "dst". The maximum relative error for this approximation is less than 2^-14.</description>
	<description code="true">
dst[31:0] := APPROXIMATE(1.0 / SQRT(b[31:0]))
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>	
	<mnemonic base="vrsqrt14ss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_scalef_pd / vscalefpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_scalef_pd">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="src" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<description>Scale the packed double-precision (64-bit) floating-point elements in "a" using values from "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<description code="true">
SCALE(src1, src2){
	IF (src2 == NaN)
		IF (src2 == SNaN)
			RETURN QNAN(src2)
		FI
	ELSE IF (src1 == NaN)
		IF (src1 == SNaN)
			RETURN QNAN(src1)
		FI
		IF (src2 != INF)
			RETURN QNAN(src1)
		FI
	ELSE
		tmp_src2 := src2
		tmp_src1 := src1
		IF (src2 is denormal AND MXCSR.DAZ)
			tmp_src2 := 0
		FI
		IF (src1 is denormal AND MXCSR.DAZ)
			tmp_src1 := 0
		FI
	FI
	dst[63:0] := tmp_src1[63:0] * POW(2, FLOOR(tmp_src2[63:0]))
	RETURN dst[63:0]
}

FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := SCALE(a[i+63:0], b[i+63:i])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vscalefpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_scalef_round_pd / vscalefpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_scalef_round_pd">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="src" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="rounding" type="int"/>
	<description>Scale the packed double-precision (64-bit) floating-point elements in "a" using values from "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).
	[round_note]</description>
	<description code="true">
SCALE(src1, src2){
	IF (src2 == NaN)
		IF (src2 == SNaN)
			RETURN QNAN(src2)
		FI
	ELSE IF (src1 == NaN)
		IF (src1 == SNaN)
			RETURN QNAN(src1)
		FI
		IF (src2 != INF)
			RETURN QNAN(src1)
		FI
	ELSE
		tmp_src2 := src2
		tmp_src1 := src1
		IF (src2 is denormal AND MXCSR.DAZ)
			tmp_src2 := 0
		FI
		IF (src1 is denormal AND MXCSR.DAZ)
			tmp_src1 := 0
		FI
	FI
	dst[63:0] := tmp_src1[63:0] * POW(2, FLOOR(tmp_src2[63:0]))
	RETURN dst[63:0]
}

FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := SCALE(a[i+63:0], b[i+63:i])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vscalefpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_scalef_pd / vscalefpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_scalef_pd">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<description>Scale the packed double-precision (64-bit) floating-point elements in "a" using values from "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
SCALE(src1, src2){
	IF (src2 == NaN)
		IF (src2 == SNaN)
			RETURN QNAN(src2)
		FI
	ELSE IF (src1 == NaN)
		IF (src1 == SNaN)
			RETURN QNAN(src1)
		FI
		IF (src2 != INF)
			RETURN QNAN(src1)
		FI
	ELSE
		tmp_src2 := src2
		tmp_src1 := src1
		IF (src2 is denormal AND MXCSR.DAZ)
			tmp_src2 := 0
		FI
		IF (src1 is denormal AND MXCSR.DAZ)
			tmp_src1 := 0
		FI
	FI
	dst[63:0] := tmp_src1[63:0] * POW(2, FLOOR(tmp_src2[63:0]))
	RETURN dst[63:0]
}

FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := SCALE(a[i+63:0], b[i+63:i])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vscalefpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_scalef_round_pd / vscalefpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_scalef_round_pd">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="rounding" type="int"/>
	<description>Scale the packed double-precision (64-bit) floating-point elements in "a" using values from "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).
	[round_note]</description>
	<description code="true">
SCALE(src1, src2){
	IF (src2 == NaN)
		IF (src2 == SNaN)
			RETURN QNAN(src2)
		FI
	ELSE IF (src1 == NaN)
		IF (src1 == SNaN)
			RETURN QNAN(src1)
		FI
		IF (src2 != INF)
			RETURN QNAN(src1)
		FI
	ELSE
		tmp_src2 := src2
		tmp_src1 := src1
		IF (src2 is denormal AND MXCSR.DAZ)
			tmp_src2 := 0
		FI
		IF (src1 is denormal AND MXCSR.DAZ)
			tmp_src1 := 0
		FI
	FI
	dst[63:0] := tmp_src1[63:0] * POW(2, FLOOR(tmp_src2[63:0]))
	RETURN dst[63:0]
}

FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := SCALE(a[i+63:0], b[i+63:i])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vscalefpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_scalef_pd / vscalefpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_scalef_pd">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<description>Scale the packed double-precision (64-bit) floating-point elements in "a" using values from "b", and store the results in "dst".</description>
	<description code="true">
SCALE(src1, src2){
	IF (src2 == NaN)
		IF (src2 == SNaN)
			RETURN QNAN(src2)
		FI
	ELSE IF (src1 == NaN)
		IF (src1 == SNaN)
			RETURN QNAN(src1)
		FI
		IF (src2 != INF)
			RETURN QNAN(src1)
		FI
	ELSE
		tmp_src2 := src2
		tmp_src1 := src1
		IF (src2 is denormal AND MXCSR.DAZ)
			tmp_src2 := 0
		FI
		IF (src1 is denormal AND MXCSR.DAZ)
			tmp_src1 := 0
		FI
	FI
	dst[63:0] := tmp_src1[63:0] * POW(2, FLOOR(tmp_src2[63:0]))
	RETURN dst[63:0]
}

FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := SCALE(a[i+63:0], b[i+63:i])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vscalefpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_scalef_round_pd / vscalefpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_scalef_round_pd">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="rounding" type="int"/>
	<description>Scale the packed double-precision (64-bit) floating-point elements in "a" using values from "b", and store the results in "dst".
	[round_note]</description>
	<description code="true">
SCALE(src1, src2){
	IF (src2 == NaN)
		IF (src2 == SNaN)
			RETURN QNAN(src2)
		FI
	ELSE IF (src1 == NaN)
		IF (src1 == SNaN)
			RETURN QNAN(src1)
		FI
		IF (src2 != INF)
			RETURN QNAN(src1)
		FI
	ELSE
		tmp_src2 := src2
		tmp_src1 := src1
		IF (src2 is denormal AND MXCSR.DAZ)
			tmp_src2 := 0
		FI
		IF (src1 is denormal AND MXCSR.DAZ)
			tmp_src1 := 0
		FI
	FI
	dst[63:0] := tmp_src1[63:0] * POW(2, FLOOR(tmp_src2[63:0]))
	RETURN dst[63:0]
}

FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := SCALE(a[i+63:0], b[i+63:i])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vscalefpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_scalef_ps / vscalefps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_scalef_ps">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="src" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<description>Scale the packed single-precision (32-bit) floating-point elements in "a" using values from "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<description code="true">
SCALE(src1, src2){
	IF (src2 == NaN)
		IF (src2 == SNaN)
			RETURN QNAN(src2)
		FI
	ELSE IF (src1 == NaN)
		IF (src1 == SNaN)
			RETURN QNAN(src1)
		FI
		IF (src2 != INF)
			RETURN QNAN(src1)
		FI
	ELSE
		tmp_src2 := src2
		tmp_src1 := src1
		IF (src2 is denormal AND MXCSR.DAZ)
			tmp_src2 := 0
		FI
		IF (src1 is denormal AND MXCSR.DAZ)
			tmp_src1 := 0
		FI
	FI
	dst[31:0] := tmp_src1[31:0] * POW(2, FLOOR(tmp_src2[31:0]))
	RETURN dst[31:0]
}

FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := SCALE(a[i+31:0], b[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vscalefps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_scalef_round_ps / vscalefps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_scalef_round_ps">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="src" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="rounding" type="int"/>
	<description>Scale the packed single-precision (32-bit) floating-point elements in "a" using values from "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).
	[round_note]</description>
	<description code="true">
SCALE(src1, src2){
	IF (src2 == NaN)
		IF (src2 == SNaN)
			RETURN QNAN(src2)
		FI
	ELSE IF (src1 == NaN)
		IF (src1 == SNaN)
			RETURN QNAN(src1)
		FI
		IF (src2 != INF)
			RETURN QNAN(src1)
		FI
	ELSE
		tmp_src2 := src2
		tmp_src1 := src1
		IF (src2 is denormal AND MXCSR.DAZ)
			tmp_src2 := 0
		FI
		IF (src1 is denormal AND MXCSR.DAZ)
			tmp_src1 := 0
		FI
	FI
	dst[31:0] := tmp_src1[31:0] * POW(2, FLOOR(tmp_src2[31:0]))
	RETURN dst[31:0]
}

FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := SCALE(a[i+31:0], b[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vscalefps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_scalef_ps / vscalefps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_scalef_ps">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<description>Scale the packed single-precision (32-bit) floating-point elements in "a" using values from "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
SCALE(src1, src2){
	IF (src2 == NaN)
		IF (src2 == SNaN)
			RETURN QNAN(src2)
		FI
	ELSE IF (src1 == NaN)
		IF (src1 == SNaN)
			RETURN QNAN(src1)
		FI
		IF (src2 != INF)
			RETURN QNAN(src1)
		FI
	ELSE
		tmp_src2 := src2
		tmp_src1 := src1
		IF (src2 is denormal AND MXCSR.DAZ)
			tmp_src2 := 0
		FI
		IF (src1 is denormal AND MXCSR.DAZ)
			tmp_src1 := 0
		FI
	FI
	dst[31:0] := tmp_src1[31:0] * POW(2, FLOOR(tmp_src2[31:0]))
	RETURN dst[31:0]
}

FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := SCALE(a[i+31:0], b[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vscalefps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_scalef_round_ps / vscalefps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_scalef_round_ps">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>	
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="rounding" type="int"/>
	<description>Scale the packed single-precision (32-bit) floating-point elements in "a" using values from "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).
	[round_note]</description>
	<description code="true">
SCALE(src1, src2){
	IF (src2 == NaN)
		IF (src2 == SNaN)
			RETURN QNAN(src2)
		FI
	ELSE IF (src1 == NaN)
		IF (src1 == SNaN)
			RETURN QNAN(src1)
		FI
		IF (src2 != INF)
			RETURN QNAN(src1)
		FI
	ELSE
		tmp_src2 := src2
		tmp_src1 := src1
		IF (src2 is denormal AND MXCSR.DAZ)
			tmp_src2 := 0
		FI
		IF (src1 is denormal AND MXCSR.DAZ)
			tmp_src1 := 0
		FI
	FI
	dst[31:0] := tmp_src1[31:0] * POW(2, FLOOR(tmp_src2[31:0]))
	RETURN dst[31:0]
}

FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := SCALE(a[i+31:0], b[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vscalefps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_scalef_ps / vscalefps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_scalef_ps">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<description>Scale the packed single-precision (32-bit) floating-point elements in "a" using values from "b", and store the results in "dst".</description>
	<description code="true">
SCALE(src1, src2){
	IF (src2 == NaN)
		IF (src2 == SNaN)
			RETURN QNAN(src2)
		FI
	ELSE IF (src1 == NaN)
		IF (src1 == SNaN)
			RETURN QNAN(src1)
		FI
		IF (src2 != INF)
			RETURN QNAN(src1)
		FI
	ELSE
		tmp_src2 := src2
		tmp_src1 := src1
		IF (src2 is denormal AND MXCSR.DAZ)
			tmp_src2 := 0
		FI
		IF (src1 is denormal AND MXCSR.DAZ)
			tmp_src1 := 0
		FI
	FI
	dst[31:0] := tmp_src1[31:0] * POW(2, FLOOR(tmp_src2[31:0]))
	RETURN dst[31:0]
}

FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := SCALE(a[i+31:0], b[i+31:i])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vscalefps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_scalef_round_ps / vscalefps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_scalef_round_ps">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="rounding" type="int"/>
	<description>Scale the packed single-precision (32-bit) floating-point elements in "a" using values from "b", and store the results in "dst".
	[round_note]</description>
	<description code="true">
SCALE(src1, src2){
	IF (src2 == NaN)
		IF (src2 == SNaN)
			RETURN QNAN(src2)
		FI
	ELSE IF (src1 == NaN)
		IF (src1 == SNaN)
			RETURN QNAN(src1)
		FI
		IF (src2 != INF)
			RETURN QNAN(src1)
		FI
	ELSE
		tmp_src2 := src2
		tmp_src1 := src1
		IF (src2 is denormal AND MXCSR.DAZ)
			tmp_src2 := 0
		FI
		IF (src1 is denormal AND MXCSR.DAZ)
			tmp_src1 := 0
		FI
	FI
	dst[31:0] := tmp_src1[31:0] * POW(2, FLOOR(tmp_src2[31:0]))
	RETURN dst[31:0]
}

FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := SCALE(a[i+31:0], b[i+31:i])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vscalefps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_scalef_round_sd / vscalefsd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_mask_scalef_round_sd">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="src" type="__m128d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="rounding" type="int"/>	
	<description>Scale the packed double-precision (64-bit) floating-point elements in "a" using values from "b", store the result in the lower element of "dst" using writemask "k" (the element is copied from "src" when mask bit 0 is not set), and copy the upper element from "b" to the upper element of "dst".
	[round_note]</description>
	<description code="true">
SCALE(src1, src2){
	IF (src2 == NaN)
		IF (src2 == SNaN)
			RETURN QNAN(src2)
		FI
	ELSE IF (src1 == NaN)
		IF (src1 == SNaN)
			RETURN QNAN(src1)
		FI
		IF (src2 != INF)
			RETURN QNAN(src1)
		FI
	ELSE
		tmp_src2 := src2
		tmp_src1 := src1
		IF (src2 is denormal AND MXCSR.DAZ)
			tmp_src2 := 0
		FI
		IF (src1 is denormal AND MXCSR.DAZ)
			tmp_src1 := 0
		FI
	FI
	dst[63:0] := tmp_src1[63:0] * POW(2, FLOOR(tmp_src2[63:0]))
	RETURN dst[63:0]
}

IF k[0]
	dst[63:0] := SCALE(a[63:0], b[63:0])
ELSE
	dst[63:0] := src[63:0]
FI
dst[127:64] := b[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vscalefsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_scalef_sd / vscalefsd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_mask_scalef_sd">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="src" type="__m128d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<description>Scale the packed double-precision (64-bit) floating-point elements in "a" using values from "b", store the result in the lower element of "dst" using writemask "k" (the element is copied from "src" when mask bit 0 is not set), and copy the upper element from "b" to the upper element of "dst".</description>
	<description code="true">
SCALE(src1, src2){
	IF (src2 == NaN)
		IF (src2 == SNaN)
			RETURN QNAN(src2)
		FI
	ELSE IF (src1 == NaN)
		IF (src1 == SNaN)
			RETURN QNAN(src1)
		FI
		IF (src2 != INF)
			RETURN QNAN(src1)
		FI
	ELSE
		tmp_src2 := src2
		tmp_src1 := src1
		IF (src2 is denormal AND MXCSR.DAZ)
			tmp_src2 := 0
		FI
		IF (src1 is denormal AND MXCSR.DAZ)
			tmp_src1 := 0
		FI
	FI
	dst[63:0] := tmp_src1[63:0] * POW(2, FLOOR(tmp_src2[63:0]))
	RETURN dst[63:0]
}

IF k[0]
	dst[63:0] := SCALE(a[63:0], b[63:0])
ELSE
	dst[63:0] := src[63:0]
FI
dst[127:64] := b[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vscalefsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_scalef_round_sd / vscalefsd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_maskz_scalef_round_sd">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="rounding" type="int"/>
	<description>Scale the packed double-precision (64-bit) floating-point elements in "a" using values from "b", store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper element from "b" to the upper element of "dst".
	[round_note]</description>
	<description code="true">
SCALE(src1, src2){
	IF (src2 == NaN)
		IF (src2 == SNaN)
			RETURN QNAN(src2)
		FI
	ELSE IF (src1 == NaN)
		IF (src1 == SNaN)
			RETURN QNAN(src1)
		FI
		IF (src2 != INF)
			RETURN QNAN(src1)
		FI
	ELSE
		tmp_src2 := src2
		tmp_src1 := src1
		IF (src2 is denormal AND MXCSR.DAZ)
			tmp_src2 := 0
		FI
		IF (src1 is denormal AND MXCSR.DAZ)
			tmp_src1 := 0
		FI
	FI
	dst[63:0] := tmp_src1[63:0] * POW(2, FLOOR(tmp_src2[63:0]))
	RETURN dst[63:0]
}

IF k[0]
	dst[63:0] := SCALE(a[63:0], b[63:0])
ELSE
	dst[63:0] := 0
FI
dst[127:64] := b[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vscalefsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_scalef_sd / vscalefsd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_maskz_scalef_sd">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<description>Scale the packed double-precision (64-bit) floating-point elements in "a" using values from "b", store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper element from "b" to the upper element of "dst".</description>
	<description code="true">
SCALE(src1, src2){
	IF (src2 == NaN)
		IF (src2 == SNaN)
			RETURN QNAN(src2)
		FI
	ELSE IF (src1 == NaN)
		IF (src1 == SNaN)
			RETURN QNAN(src1)
		FI
		IF (src2 != INF)
			RETURN QNAN(src1)
		FI
	ELSE
		tmp_src2 := src2
		tmp_src1 := src1
		IF (src2 is denormal AND MXCSR.DAZ)
			tmp_src2 := 0
		FI
		IF (src1 is denormal AND MXCSR.DAZ)
			tmp_src1 := 0
		FI
	FI
	dst[63:0] := tmp_src1[63:0] * POW(2, FLOOR(tmp_src2[63:0]))
	RETURN dst[63:0]
}

IF k[0]
	dst[63:0] := SCALE(a[63:0], b[63:0])
ELSE
	dst[63:0] := 0
FI
dst[127:64] := b[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vscalefsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_scalef_round_sd / vscalefsd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_scalef_round_sd">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="rounding" type="int"/>
	<description>Scale the packed double-precision (64-bit) floating-point elements in "a" using values from "b", store the result in the lower element of "dst", and copy the upper element from "b" to the upper element of "dst".
	[round_note]</description>
	<description code="true">
SCALE(src1, src2){
	IF (src2 == NaN)
		IF (src2 == SNaN)
			RETURN QNAN(src2)
		FI
	ELSE IF (src1 == NaN)
		IF (src1 == SNaN)
			RETURN QNAN(src1)
		FI
		IF (src2 != INF)
			RETURN QNAN(src1)
		FI
	ELSE
		tmp_src2 := src2
		tmp_src1 := src1
		IF (src2 is denormal AND MXCSR.DAZ)
			tmp_src2 := 0
		FI
		IF (src1 is denormal AND MXCSR.DAZ)
			tmp_src1 := 0
		FI
	FI
	dst[63:0] := tmp_src1[63:0] * POW(2, FLOOR(tmp_src2[63:0]))
	RETURN dst[63:0]
}

dst[63:0] := SCALE(a[63:0], b[63:0])
dst[127:64] := b[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vscalefsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_scalef_sd / vscalefsd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_scalef_sd">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<description>Scale the packed double-precision (64-bit) floating-point elements in "a" using values from "b", store the result in the lower element of "dst", and copy the upper element from "b" to the upper element of "dst".</description>
	<description code="true">
SCALE(src1, src2){
	IF (src2 == NaN)
		IF (src2 == SNaN)
			RETURN QNAN(src2)
		FI
	ELSE IF (src1 == NaN)
		IF (src1 == SNaN)
			RETURN QNAN(src1)
		FI
		IF (src2 != INF)
			RETURN QNAN(src1)
		FI
	ELSE
		tmp_src2 := src2
		tmp_src1 := src1
		IF (src2 is denormal AND MXCSR.DAZ)
			tmp_src2 := 0
		FI
		IF (src1 is denormal AND MXCSR.DAZ)
			tmp_src1 := 0
		FI
	FI
	dst[63:0] := tmp_src1[63:0] * POW(2, FLOOR(tmp_src2[63:0]))
	RETURN dst[63:0]
}

dst[63:0] := SCALE(a[63:0], b[63:0])
dst[127:64] := b[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vscalefsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_scalef_round_ss / vscalefss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_mask_scalef_round_ss">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="src" type="__m128"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="rounding" type="int"/>
	<description>Scale the packed single-precision (32-bit) floating-point elements in "a" using values from "b", store the result in the lower element of "dst" using writemask "k" (the element is copied from "src" when mask bit 0 is not set), and copy the upper 3 packed elements from "b" to the upper elements of "dst".
	[round_note]</description>
	<description code="true">
SCALE(src1, src2){
	IF (src2 == NaN)
		IF (src2 == SNaN)
			RETURN QNAN(src2)
		FI
	ELSE IF (src1 == NaN)
		IF (src1 == SNaN)
			RETURN QNAN(src1)
		FI
		IF (src2 != INF)
			RETURN QNAN(src1)
		FI
	ELSE
		tmp_src2 := src2
		tmp_src1 := src1
		IF (src2 is denormal AND MXCSR.DAZ)
			tmp_src2 := 0
		FI
		IF (src1 is denormal AND MXCSR.DAZ)
			tmp_src1 := 0
		FI
	FI
	dst[31:0] := tmp_src1[31:0] * POW(2, FLOOR(tmp_src2[31:0]))
	RETURN dst[63:0]
}

IF k[0]
	dst[31:0] := SCALE(a[31:0], b[31:0])
ELSE
	dst[31:0] := src[31:0]
FI
dst[127:32] := b[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vscalefss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_scalef_ss / vscalefss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_mask_scalef_ss">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="src" type="__m128"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<description>Scale the packed single-precision (32-bit) floating-point elements in "a" using values from "b", store the result in the lower element of "dst" using writemask "k" (the element is copied from "src" when mask bit 0 is not set), and copy the upper 3 packed elements from "b" to the upper elements of "dst".</description>
	<description code="true">
SCALE(src1, src2){
	IF (src2 == NaN)
		IF (src2 == SNaN)
			RETURN QNAN(src2)
		FI
	ELSE IF (src1 == NaN)
		IF (src1 == SNaN)
			RETURN QNAN(src1)
		FI
		IF (src2 != INF)
			RETURN QNAN(src1)
		FI
	ELSE
		tmp_src2 := src2
		tmp_src1 := src1
		IF (src2 is denormal AND MXCSR.DAZ)
			tmp_src2 := 0
		FI
		IF (src1 is denormal AND MXCSR.DAZ)
			tmp_src1 := 0
		FI
	FI
	dst[31:0] := tmp_src1[31:0] * POW(2, FLOOR(tmp_src2[31:0]))
	RETURN dst[63:0]
}

IF k[0]
	dst[31:0] := SCALE(a[31:0], b[31:0])
ELSE
	dst[31:0] := src[31:0]
FI
dst[127:32] := b[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vscalefss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_scalef_round_ss / vscalefss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_maskz_scalef_round_ss">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="rounding" type="int"/>
	<description>Scale the packed single-precision (32-bit) floating-point elements in "a" using values from "b", store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from "b" to the upper elements of "dst".
	[round_note]</description>
	<description code="true">
SCALE(src1, src2){
	IF (src2 == NaN)
		IF (src2 == SNaN)
			RETURN QNAN(src2)
		FI
	ELSE IF (src1 == NaN)
		IF (src1 == SNaN)
			RETURN QNAN(src1)
		FI
		IF (src2 != INF)
			RETURN QNAN(src1)
		FI
	ELSE
		tmp_src2 := src2
		tmp_src1 := src1
		IF (src2 is denormal AND MXCSR.DAZ)
			tmp_src2 := 0
		FI
		IF (src1 is denormal AND MXCSR.DAZ)
			tmp_src1 := 0
		FI
	FI
	dst[31:0] := tmp_src1[31:0] * POW(2, FLOOR(tmp_src2[31:0]))
	RETURN dst[63:0]
}

IF k[0]
	dst[31:0] := SCALE(a[31:0], b[31:0])
ELSE
	dst[31:0] := 0
FI
dst[127:32] := b[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vscalefss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_scalef_ss / vscalefss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_maskz_scalef_ss">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<description>Scale the packed single-precision (32-bit) floating-point elements in "a" using values from "b", store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from "b" to the upper elements of "dst".</description>
	<description code="true">
SCALE(src1, src2){
	IF (src2 == NaN)
		IF (src2 == SNaN)
			RETURN QNAN(src2)
		FI
	ELSE IF (src1 == NaN)
		IF (src1 == SNaN)
			RETURN QNAN(src1)
		FI
		IF (src2 != INF)
			RETURN QNAN(src1)
		FI
	ELSE
		tmp_src2 := src2
		tmp_src1 := src1
		IF (src2 is denormal AND MXCSR.DAZ)
			tmp_src2 := 0
		FI
		IF (src1 is denormal AND MXCSR.DAZ)
			tmp_src1 := 0
		FI
	FI
	dst[31:0] := tmp_src1[31:0] * POW(2, FLOOR(tmp_src2[31:0]))
	RETURN dst[63:0]
}

IF k[0]
	dst[31:0] := SCALE(a[31:0], b[31:0])
ELSE
	dst[31:0] := 0
FI
dst[127:32] := b[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vscalefss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_scalef_round_ss / vscalefss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_scalef_round_ss">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="rounding" type="int"/>
	<description>Scale the packed single-precision (32-bit) floating-point elements in "a" using values from "b", store the result in the lower element of "dst", and copy the upper 3 packed elements from "b" to the upper elements of "dst".
	[round_note]</description>
	<description code="true">
SCALE(src1, src2){
	IF (src2 == NaN)
		IF (src2 == SNaN)
			RETURN QNAN(src2)
		FI
	ELSE IF (src1 == NaN)
		IF (src1 == SNaN)
			RETURN QNAN(src1)
		FI
		IF (src2 != INF)
			RETURN QNAN(src1)
		FI
	ELSE
		tmp_src2 := src2
		tmp_src1 := src1
		IF (src2 is denormal AND MXCSR.DAZ)
			tmp_src2 := 0
		FI
		IF (src1 is denormal AND MXCSR.DAZ)
			tmp_src1 := 0
		FI
	FI
	dst[31:0] := tmp_src1[31:0] * POW(2, FLOOR(tmp_src2[31:0]))
	RETURN dst[63:0]
}

dst[31:0] := SCALE(a[31:0], b[31:0])
dst[127:32] := b[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vscalefss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_scalef_ss / vscalefss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_scalef_ss">
	<CPUID>AVX-512</CPUID>
	<category>Miscellaneous</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<description>Scale the packed single-precision (32-bit) floating-point elements in "a" using values from "b", store the result in the lower element of "dst", and copy the upper 3 packed elements from "b" to the upper elements of "dst".</description>
	<description code="true">
SCALE(src1, src2){
	IF (src2 == NaN)
		IF (src2 == SNaN)
			RETURN QNAN(src2)
		FI
	ELSE IF (src1 == NaN)
		IF (src1 == SNaN)
			RETURN QNAN(src1)
		FI
		IF (src2 != INF)
			RETURN QNAN(src1)
		FI
	ELSE
		tmp_src2 := src2
		tmp_src1 := src1
		IF (src2 is denormal AND MXCSR.DAZ)
			tmp_src2 := 0
		FI
		IF (src1 is denormal AND MXCSR.DAZ)
			tmp_src1 := 0
		FI
	FI
	dst[31:0] := tmp_src1[31:0] * POW(2, FLOOR(tmp_src2[31:0]))
	RETURN dst[63:0]
}

dst[31:0] := SCALE(a[31:0], b[31:0])
dst[127:32] := b[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vscalefss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_i32scatter_pd / vscatterdpd -->
<intrinsic tech="AVX-512" rettype="void" name="_mm512_i32scatter_pd">
	<CPUID>AVX-512</CPUID>
	<category>Store</category>
	<parameter varname="base_addr" type="void*"/>
	<parameter varname="vindex" type="__m256i"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="scale" type="int"/>
	<description>Scatter double-precision (64-bit) floating-point elements from "a" into memory using 32-bit indices. 64-bit elements are stored at addresses starting at "base_addr" and offset by each 32-bit element in "vindex" (each index is scaled by the factor in "scale"). "scale" should be 1, 2, 4 or 8.
	</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	l := j*32
	MEM[base_addr + SignExtend(vindex[l+31:l])*scale] := a[i+63:i]
ENDFOR
	</description>
	<mnemonic base="vscatterdpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_i32scatter_pd / vscatterdpd -->
<intrinsic tech="AVX-512" rettype="void" name="_mm512_mask_i32scatter_pd">
	<CPUID>AVX-512</CPUID>
	<category>Store</category>
	<parameter varname="base_addr" type="void*"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="vindex" type="__m256i"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="scale" type="int"/>
	<description>Scatter double-precision (64-bit) floating-point elements from "a" into memory using 32-bit indices. 64-bit elements are stored at addresses starting at "base_addr" and offset by each 32-bit element in "vindex" (each index is scaled by the factor in "scale") subject to mask "k" (elements are not stored when the corresponding mask bit is not set). "scale" should be 1, 2, 4 or 8.
	</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	l := j*32
	IF k[j]
		MEM[base_addr + SignExtend(vindex[l+31:l])*scale] := a[i+63:i]
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</description>
	<mnemonic base="vscatterdpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_i32scatter_ps / vscatterdps -->
<intrinsic tech="AVX-512" rettype="void" name="_mm512_i32scatter_ps">
	<CPUID>AVX-512</CPUID>
	<category>Store</category>
	<parameter varname="base_addr" type="void*"/>
	<parameter varname="vindex" type="__m512i"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="scale" type="int"/>
	<description>Scatter single-precision (32-bit) floating-point elements from "a" into memory using 32-bit indices. 32-bit elements are stored at addresses starting at "base_addr" and offset by each 32-bit element in "vindex" (each index is scaled by the factor in "scale"). "scale" should be 1, 2, 4 or 8.</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	MEM[base_addr + SignExtend(vindex[i+31:i])*scale] := a[i+31:i]
ENDFOR
	</description>
	<mnemonic base="vscatterdps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_i32scatter_ps / vscatterdps -->
<intrinsic tech="AVX-512" rettype="void" name="_mm512_mask_i32scatter_ps">
	<CPUID>AVX-512</CPUID>
	<category>Store</category>
	<parameter varname="base_addr" type="void*"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="vindex" type="__m512i"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="scale" type="int"/>
	<description>Scatter single-precision (32-bit) floating-point elements from "a" into memory using 32-bit indices. 32-bit elements are stored at addresses starting at "base_addr" and offset by each 32-bit element in "vindex" (each index is scaled by the factor in "scale") subject to mask "k" (elements are not stored when the corresponding mask bit is not set). "scale" should be 1, 2, 4 or 8.</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		MEM[base_addr + SignExtend(vindex[i+31:i])*scale] := a[i+31:i]
		k[j] := 0
	FI
ENDFOR
k[MAX:16] := 0
	</description>
	<mnemonic base="vscatterdps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_i64scatter_pd / vscatterqpd -->
<intrinsic tech="AVX-512" rettype="void" name="_mm512_i64scatter_pd">
	<CPUID>AVX-512</CPUID>
	<category>Store</category>
	<parameter varname="base_addr" type="void*"/>
	<parameter varname="vindex" type="__m512i"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="scale" type="int"/>
	<description>Scatter double-precision (64-bit) floating-point elements from "a" into memory using 64-bit indices. 64-bit elements are stored at addresses starting at "base_addr" and offset by each 64-bit element in "vindex" (each index is scaled by the factor in "scale"). "scale" should be 1, 2, 4 or 8.
	</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	MEM[base_addr + SignExtend(vindex[i+63:i])*scale] := a[i+63:i]
ENDFOR
	</description>
	<mnemonic base="vscatterqpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_i64scatter_pd / vscatterqpd -->
<intrinsic tech="AVX-512" rettype="void" name="_mm512_mask_i64scatter_pd">
	<CPUID>AVX-512</CPUID>
	<category>Store</category>
	<parameter varname="base_addr" type="void*"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="vindex" type="__m512i"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="scale" type="int"/>
	<description>Scatter double-precision (64-bit) floating-point elements from "a" into memory using 64-bit indices. 64-bit elements are stored at addresses starting at "base_addr" and offset by each 64-bit element in "vindex" (each index is scaled by the factor in "scale") subject to mask "k" (elements are not stored when the corresponding mask bit is not set). "scale" should be 1, 2, 4 or 8.
	</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		MEM[base_addr + SignExtend(vindex[i+63:i])*scale] := a[i+63:i]
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</description>
	<mnemonic base="vscatterqpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_i64scatter_ps / vscatterqps -->
<intrinsic tech="AVX-512" rettype="void" name="_mm512_i64scatter_ps">
	<CPUID>AVX-512</CPUID>
	<category>Store</category>
	<parameter varname="base_addr" type="void*"/>
	<parameter varname="vindex" type="__m512i"/>
	<parameter varname="a" type="__m256"/>
	<parameter varname="scale" type="int"/>
	<description>Scatter single-precision (32-bit) floating-point elements from "a" into memory using 64-bit indices. 32-bit elements are stored at addresses starting at "base_addr" and offset by each 64-bit element in "vindex" (each index is scaled by the factor in "scale") subject to mask "k" (elements are not stored when the corresponding mask bit is not set). "scale" should be 1, 2, 4 or 8.
	</description>
	<description code="true">
FOR j := 0 to 7
	i := j*32
	l := j*64
	MEM[base_addr + SignExtend(vindex[l+63:l])*scale] := a[i+31:i]
ENDFOR
	</description>
	<mnemonic base="vscatterqps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_i64scatter_ps / vscatterqps -->
<intrinsic tech="AVX-512" rettype="void" name="_mm512_mask_i64scatter_ps">
	<CPUID>AVX-512</CPUID>
	<category>Store</category>
	<parameter varname="base_addr" type="void*"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="vindex" type="__m512i"/>
	<parameter varname="a" type="__m256"/>
	<parameter varname="scale" type="int"/>
	<description>Scatter single-precision (32-bit) floating-point elements from "a" into memory using 64-bit indices. 32-bit elements are stored at addresses starting at "base_addr" and offset by each 64-bit element in "vindex" (each index is scaled by the factor in "scale") subject to mask "k" (elements are not stored when the corresponding mask bit is not set). "scale" should be 1, 2, 4 or 8.
	</description>
	<description code="true">
FOR j := 0 to 7
	i := j*32
	l := j*64
	IF k[j]
		MEM[base_addr + SignExtend(vindex[l+63:l])*scale] := a[i+31:i]
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</description>
	<mnemonic base="vscatterqps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_shuffle_f32x4 / vshuff32x4 -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_shuffle_f32x4">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="src" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="imm" type="const int"/>
	<description>Shuffle 128-bits (composed of 4 single-precision (32-bit) floating-point elements) selected by "imm" from "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
SELECT4(src, control){
	CASE(control[1:0])
		0:	tmp[127:0] := src[127:0]
		1:	tmp[127:0] := src[255:128]
		2:	tmp[127:0] := src[383:256]
		3:	tmp[127:0] := src[511:384]
	ESAC
	RETURN tmp[127:0]
}

tmp_dst[127:0] := SELECT4(a[511:0], imm[1:0])
tmp_dst[255:128] := SELECT4(a[511:0], imm[3:2])
tmp_dst[383:256] := SELECT4(b[511:0], imm[5:4])
tmp_dst[511:384] := SELECT4(b[511:0], imm[7:6])

FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp_dst[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vshuff32x4"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_shuffle_f32x4 / vshuff32x4 -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_shuffle_f32x4">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="imm" type="const int"/>
	<description>Shuffle 128-bits (composed of 4 single-precision (32-bit) floating-point elements) selected by "imm" from "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
SELECT4(src, control){
	CASE(control[1:0])
		0:	tmp[127:0] := src[127:0]
		1:	tmp[127:0] := src[255:128]
		2:	tmp[127:0] := src[383:256]
		3:	tmp[127:0] := src[511:384]
	ESAC
	RETURN tmp[127:0]
}

tmp_dst[127:0] := SELECT4(a[511:0], imm[1:0])
tmp_dst[255:128] := SELECT4(a[511:0], imm[3:2])
tmp_dst[383:256] := SELECT4(b[511:0], imm[5:4])
tmp_dst[511:384] := SELECT4(b[511:0], imm[7:6])

FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp_dst[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vshuff32x4"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_shuffle_f32x4 / vshuff32x4 -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_shuffle_f32x4">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="imm" type="const int"/>
	<description>Shuffle 128-bits (composed of 4 single-precision (32-bit) floating-point elements) selected by "imm" from "a" and "b", and store the results in "dst".
	</description>
	<description code="true">
SELECT4(src, control){
	CASE(control[1:0])
		0:	tmp[127:0] := src[127:0]
		1:	tmp[127:0] := src[255:128]
		2:	tmp[127:0] := src[383:256]
		3:	tmp[127:0] := src[511:384]
	ESAC
	RETURN tmp[127:0]
}

dst[127:0] := SELECT4(a[511:0], imm[1:0])
dst[255:128] := SELECT4(a[511:0], imm[3:2])
dst[383:256] := SELECT4(b[511:0], imm[5:4])
dst[511:384] := SELECT4(b[511:0], imm[7:6])
dst[MAX:512] := 0
	</description>
	<mnemonic base="vshuff32x4"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_shuffle_f64x2 / vshuff64x2 -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_shuffle_f64x2">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="src" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="imm" type="const int"/>
	<description>Shuffle 128-bits (composed of 2 double-precision (64-bit) floating-point elements) selected by "imm" from "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
SELECT4(src, control){
	CASE(control[1:0])
		0:	tmp[127:0] := src[127:0]
		1:	tmp[127:0] := src[255:128]
		2:	tmp[127:0] := src[383:256]
		3:	tmp[127:0] := src[511:384]
	ESAC
	RETURN tmp[127:0]
}

tmp_dst[127:0] := SELECT4(a[511:0], imm[1:0])
tmp_dst[255:128] := SELECT4(a[511:0], imm[3:2])
tmp_dst[383:256] := SELECT4(b[511:0], imm[5:4])
tmp_dst[511:384] := SELECT4(b[511:0], imm[7:6])

FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp_dst[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vshuff64x2"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_shuffle_f64x2 / vshuff64x2 -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_shuffle_f64x2">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="imm" type="const int"/>
	<description>Shuffle 128-bits (composed of 2 double-precision (64-bit) floating-point elements) selected by "imm" from "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
SELECT4(src, control){
	CASE(control[1:0])
		0:	tmp[127:0] := src[127:0]
		1:	tmp[127:0] := src[255:128]
		2:	tmp[127:0] := src[383:256]
		3:	tmp[127:0] := src[511:384]
	ESAC
	RETURN tmp[127:0]
}

tmp_dst[127:0] := SELECT4(a[511:0], imm[1:0])
tmp_dst[255:128] := SELECT4(a[511:0], imm[3:2])
tmp_dst[383:256] := SELECT4(b[511:0], imm[5:4])
tmp_dst[511:384] := SELECT4(b[511:0], imm[7:6])

FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp_dst[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vshuff64x2"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_shuffle_f64x2 / vshuff64x2 -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_shuffle_f64x2">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="imm" type="const int"/>
	<description>Shuffle 128-bits (composed of 2 double-precision (64-bit) floating-point elements) selected by "imm" from "a" and "b", and store the results in "dst".</description>
	<description code="true">
SELECT4(src, control){
	CASE(control[1:0])
		0:	tmp[127:0] := src[127:0]
		1:	tmp[127:0] := src[255:128]
		2:	tmp[127:0] := src[383:256]
		3:	tmp[127:0] := src[511:384]
	ESAC
	RETURN tmp[127:0]
}

dst[127:0] := SELECT4(a[511:0], imm[1:0])
dst[255:128] := SELECT4(a[511:0], imm[3:2])
dst[383:256] := SELECT4(b[511:0], imm[5:4])
dst[511:384] := SELECT4(b[511:0], imm[7:6])
dst[MAX:512] := 0
	</description>
	<mnemonic base="vshuff64x2"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_shuffle_i32x4 / vshufi32x4 -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_shuffle_i32x4">
	<type>Integer</type>
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<parameter varname="imm" type="const int"/>
	<description>Shuffle 128-bits (composed of 4 32-bit integers) selected by "imm" from "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
SELECT4(src, control){
	CASE(control[1:0])
		0:	tmp[127:0] := src[127:0]
		1:	tmp[127:0] := src[255:128]
		2:	tmp[127:0] := src[383:256]
		3:	tmp[127:0] := src[511:384]
	ESAC
	RETURN tmp[127:0]
}

tmp_dst[127:0] := SELECT4(a[511:0], imm[1:0])
tmp_dst[255:128] := SELECT4(a[511:0], imm[3:2])
tmp_dst[383:256] := SELECT4(b[511:0], imm[5:4])
tmp_dst[511:384] := SELECT4(b[511:0], imm[7:6])

FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp_dst[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vshufi32x4"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_shuffle_i32x4 / vshufi32x4 -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_shuffle_i32x4">
	<type>Integer</type>
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<parameter varname="imm" type="const int"/>
	<description>Shuffle 128-bits (composed of 4 32-bit integers) selected by "imm" from "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
SELECT4(src, control){
	CASE(control[1:0])
		0:	tmp[127:0] := src[127:0]
		1:	tmp[127:0] := src[255:128]
		2:	tmp[127:0] := src[383:256]
		3:	tmp[127:0] := src[511:384]
	ESAC
	RETURN tmp[127:0]
}

tmp_dst[127:0] := SELECT4(a[511:0], imm[1:0])
tmp_dst[255:128] := SELECT4(a[511:0], imm[3:2])
tmp_dst[383:256] := SELECT4(b[511:0], imm[5:4])
tmp_dst[511:384] := SELECT4(b[511:0], imm[7:6])

FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp_dst[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vshufi32x4"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_shuffle_i32x4 / vshufi32x4 -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_shuffle_i32x4">
	<type>Integer</type>
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<parameter varname="imm" type="const int"/>
	<description>Shuffle 128-bits (composed of 4 32-bit integers) selected by "imm" from "a" and "b", and store the results in "dst".</description>
	<description code="true">
SELECT4(src, control){
	CASE(control[1:0])
		0:	tmp[127:0] := src[127:0]
		1:	tmp[127:0] := src[255:128]
		2:	tmp[127:0] := src[383:256]
		3:	tmp[127:0] := src[511:384]
	ESAC
	RETURN tmp[127:0]
}

dst[127:0] := SELECT4(a[511:0], imm[1:0])
dst[255:128] := SELECT4(a[511:0], imm[3:2])
dst[383:256] := SELECT4(b[511:0], imm[5:4])
dst[511:384] := SELECT4(b[511:0], imm[7:6])
dst[MAX:512] := 0
	</description>
	<mnemonic base="vshufi32x4"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_shuffle_i64x2 / vshufi64x2 -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_mask_shuffle_i64x2">
	<type>Integer</type>
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="src" type="__m512i"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<parameter varname="imm" type="const int"/>
	<description>Shuffle 128-bits (composed of 2 64-bit integers) selected by "imm" from "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
SELECT4(src, control){
	CASE(control[1:0])
		0:	tmp[127:0] := src[127:0]
		1:	tmp[127:0] := src[255:128]
		2:	tmp[127:0] := src[383:256]
		3:	tmp[127:0] := src[511:384]
	ESAC
	RETURN tmp[127:0]
}

tmp_dst[127:0] := SELECT4(a[511:0], imm[1:0])
tmp_dst[255:128] := SELECT4(a[511:0], imm[3:2])
tmp_dst[383:256] := SELECT4(b[511:0], imm[5:4])
tmp_dst[511:384] := SELECT4(b[511:0], imm[7:6])

FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp_dst[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vshufi64x2"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_shuffle_i64x2 / vshufi64x2 -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_maskz_shuffle_i64x2">
	<type>Integer</type>
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<parameter varname="imm" type="const int"/>
	<description>Shuffle 128-bits (composed of 2 64-bit integers) selected by "imm" from "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
SELECT4(src, control){
	CASE(control[1:0])
		0:	tmp[127:0] := src[127:0]
		1:	tmp[127:0] := src[255:128]
		2:	tmp[127:0] := src[383:256]
		3:	tmp[127:0] := src[511:384]
	ESAC
	RETURN tmp[127:0]
}

tmp_dst[127:0] := SELECT4(a[511:0], imm[1:0])
tmp_dst[255:128] := SELECT4(a[511:0], imm[3:2])
tmp_dst[383:256] := SELECT4(b[511:0], imm[5:4])
tmp_dst[511:384] := SELECT4(b[511:0], imm[7:6])

FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp_dst[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vshufi64x2"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_shuffle_i64x2 / vshufi64x2 -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_shuffle_i64x2">
	<type>Integer</type>
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="a" type="__m512i"/>
	<parameter varname="b" type="__m512i"/>
	<parameter varname="imm" type="const int"/>
	<description>Shuffle 128-bits (composed of 2 64-bit integers) selected by "imm" from "a" and "b", and store the results in "dst".</description>
	<description code="true">
SELECT4(src, control){
	CASE(control[1:0])
		0:	tmp[127:0] := src[127:0]
		1:	tmp[127:0] := src[255:128]
		2:	tmp[127:0] := src[383:256]
		3:	tmp[127:0] := src[511:384]
	ESAC
	RETURN tmp[127:0]
}

dst[127:0] := SELECT4(a[511:0], imm[1:0])
dst[255:128] := SELECT4(a[511:0], imm[3:2])
dst[383:256] := SELECT4(b[511:0], imm[5:4])
dst[511:384] := SELECT4(b[511:0], imm[7:6])
dst[MAX:512] := 0
	</description>
	<mnemonic base="vshufi64x2"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_shuffle_pd / vshufpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_shuffle_pd">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="src" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="imm" type="const int"/>
	<description>Shuffle double-precision (64-bit) floating-point elements within 128-bit lanes using the control in "imm", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
tmp_dst[63:0] := (imm[0] == 0) ? a[63:0] : a[127:64]
tmp_dst[127:64] := (imm[1] == 0) ? b[63:0] : b[127:64]
tmp_dst[191:128] := (imm[2] == 0) ? a[191:128] : a[255:192]
tmp_dst[255:192] := (imm[3] == 0) ? b[191:128] : b[255:192]
tmp_dst[319:256] := (imm[4] == 0) ? a[319:256] : a[383:320]
tmp_dst[383:320] := (imm[5] == 0) ? b[319:256] : b[383:320]
tmp_dst[447:384] := (imm[6] == 0) ? a[447:384] : a[511:448]
tmp_dst[511:448] := (imm[7] == 0) ? b[447:384] : b[511:448]

FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp_dst[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>	
	<mnemonic base="vshufpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_shuffle_pd / vshufpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_shuffle_pd">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="imm" type="const int"/>
	<description>Shuffle double-precision (64-bit) floating-point elements within 128-bit lanes using the control in "imm", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
tmp_dst[63:0] := (imm[0] == 0) ? a[63:0] : a[127:64]
tmp_dst[127:64] := (imm[1] == 0) ? b[63:0] : b[127:64]
tmp_dst[191:128] := (imm[2] == 0) ? a[191:128] : a[255:192]
tmp_dst[255:192] := (imm[3] == 0) ? b[191:128] : b[255:192]
tmp_dst[319:256] := (imm[4] == 0) ? a[319:256] : a[383:320]
tmp_dst[383:320] := (imm[5] == 0) ? b[319:256] : b[383:320]
tmp_dst[447:384] := (imm[6] == 0) ? a[447:384] : a[511:448]
tmp_dst[511:448] := (imm[7] == 0) ? b[447:384] : b[511:448]

FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp_dst[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vshufpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_shuffle_pd / vshufpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_shuffle_pd">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="imm" type="const int"/>
	<description>Shuffle double-precision (64-bit) floating-point elements within 128-bit lanes using the control in "imm", and store the results in "dst". </description>
	<description code="true">
dst[63:0] := (imm[0] == 0) ? a[63:0] : a[127:64]
dst[127:64] := (imm[1] == 0) ? b[63:0] : b[127:64]
dst[191:128] := (imm[2] == 0) ? a[191:128] : a[255:192]
dst[255:192] := (imm[3] == 0) ? b[191:128] : b[255:192]
dst[319:256] := (imm[4] == 0) ? a[319:256] : a[383:320]
dst[383:320] := (imm[5] == 0) ? b[319:256] : b[383:320]
dst[447:384] := (imm[6] == 0) ? a[447:384] : a[511:448]
dst[511:448] := (imm[7] == 0) ? b[447:384] : b[511:448]
dst[MAX:512] := 0
	</description>
	<mnemonic base="vshufpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_shuffle_ps / vshufps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_shuffle_ps">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="src" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="imm" type="const int"/>
	<description>Shuffle single-precision (32-bit) floating-point elements in "a" within 128-bit lanes using the control in "imm", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<description code="true">
SELECT4(src, control){
	CASE(control[1:0])
		0:	tmp[31:0] := src[31:0]
		1:	tmp[31:0] := src[63:32]
		2:	tmp[31:0] := src[95:64]
		3:	tmp[31:0] := src[127:96]
	ESAC
	RETURN tmp[31:0]
}

tmp_dst[31:0] := SELECT4(a[127:0], imm[1:0])
tmp_dst[63:32] := SELECT4(a[127:0], imm[3:2])
tmp_dst[95:64] := SELECT4(b[127:0], imm[5:4])
tmp_dst[127:96] := SELECT4(b[127:0], imm[7:6])
tmp_dst[159:128] := SELECT4(a[255:128], imm[1:0])
tmp_dst[191:160] := SELECT4(a[255:128], imm[3:2])
tmp_dst[223:192] := SELECT4(b[255:128], imm[5:4])
tmp_dst[255:224] := SELECT4(b[255:128], imm[7:6])
tmp_dst[287:256] := SELECT4(a[383:256], imm[1:0])
tmp_dst[319:288] := SELECT4(a[383:256], imm[3:2])
tmp_dst[351:320] := SELECT4(b[383:256], imm[5:4])
tmp_dst[383:352] := SELECT4(b[383:256], imm[7:6])
tmp_dst[415:384] := SELECT4(a[511:384], imm[1:0])
tmp_dst[447:416] := SELECT4(a[511:384], imm[3:2])
tmp_dst[479:448] := SELECT4(b[511:384], imm[5:4])
tmp_dst[511:480] := SELECT4(b[511:384], imm[7:6])

FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp_dst[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vshufps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_shuffle_ps / vshufps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_shuffle_ps">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="imm" type="const int"/>
	<description>Shuffle single-precision (32-bit) floating-point elements in "a" within 128-bit lanes using the control in "imm", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
SELECT4(src, control){
	CASE(control[1:0])
		0:	tmp[31:0] := src[31:0]
		1:	tmp[31:0] := src[63:32]
		2:	tmp[31:0] := src[95:64]
		3:	tmp[31:0] := src[127:96]
	ESAC
	RETURN tmp[31:0]
}

tmp_dst[31:0] := SELECT4(a[127:0], imm[1:0])
tmp_dst[63:32] := SELECT4(a[127:0], imm[3:2])
tmp_dst[95:64] := SELECT4(b[127:0], imm[5:4])
tmp_dst[127:96] := SELECT4(b[127:0], imm[7:6])
tmp_dst[159:128] := SELECT4(a[255:128], imm[1:0])
tmp_dst[191:160] := SELECT4(a[255:128], imm[3:2])
tmp_dst[223:192] := SELECT4(b[255:128], imm[5:4])
tmp_dst[255:224] := SELECT4(b[255:128], imm[7:6])
tmp_dst[287:256] := SELECT4(a[383:256], imm[1:0])
tmp_dst[319:288] := SELECT4(a[383:256], imm[3:2])
tmp_dst[351:320] := SELECT4(b[383:256], imm[5:4])
tmp_dst[383:352] := SELECT4(b[383:256], imm[7:6])
tmp_dst[415:384] := SELECT4(a[511:384], imm[1:0])
tmp_dst[447:416] := SELECT4(a[511:384], imm[3:2])
tmp_dst[479:448] := SELECT4(b[511:384], imm[5:4])
tmp_dst[511:480] := SELECT4(b[511:384], imm[7:6])

FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp_dst[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vshufps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_shuffle_ps / vshufps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_shuffle_ps">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="imm" type="const int"/>
	<description>Shuffle single-precision (32-bit) floating-point elements in "a" within 128-bit lanes using the control in "imm", and store the results in "dst".</description>
	<description code="true">
SELECT4(src, control){
	CASE(control[1:0])
		0:	tmp[31:0] := src[31:0]
		1:	tmp[31:0] := src[63:32]
		2:	tmp[31:0] := src[95:64]
		3:	tmp[31:0] := src[127:96]
	ESAC
	RETURN tmp[31:0]
}

dst[31:0] := SELECT4(a[127:0], imm[1:0])
dst[63:32] := SELECT4(a[127:0], imm[3:2])
dst[95:64] := SELECT4(b[127:0], imm[5:4])
dst[127:96] := SELECT4(b[127:0], imm[7:6])
dst[159:128] := SELECT4(a[255:128], imm[1:0])
dst[191:160] := SELECT4(a[255:128], imm[3:2])
dst[223:192] := SELECT4(b[255:128], imm[5:4])
dst[255:224] := SELECT4(b[255:128], imm[7:6])
dst[287:256] := SELECT4(a[383:256], imm[1:0])
dst[319:288] := SELECT4(a[383:256], imm[3:2])
dst[351:320] := SELECT4(b[383:256], imm[5:4])
dst[383:352] := SELECT4(b[383:256], imm[7:6])
dst[415:384] := SELECT4(a[511:384], imm[1:0])
dst[447:416] := SELECT4(a[511:384], imm[3:2])
dst[479:448] := SELECT4(b[511:384], imm[5:4])
dst[511:480] := SELECT4(b[511:384], imm[7:6])
dst[MAX:512] := 0
	</description>
	<mnemonic base="vshufps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_sqrt_pd / vsqrtpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_sqrt_pd">
	<CPUID>AVX-512</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="src" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<description>Compute the square root of packed double-precision (64-bit) floating-point elements in "a", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := SQRT(a[i+63:i])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vsqrtpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_sqrt_round_pd / vsqrtpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_sqrt_round_pd">
	<CPUID>AVX-512</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="src" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="rounding" type="int"/>
	<description>Compute the square root of packed double-precision (64-bit) floating-point elements in "a", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).
	[round_note]</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := SQRT(a[i+63:i])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vsqrtpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_sqrt_pd / vsqrtpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_sqrt_pd">
	<CPUID>AVX-512</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<description>Compute the square root of packed double-precision (64-bit) floating-point elements in "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := SQRT(a[i+63:i])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vsqrtpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_sqrt_round_pd / vsqrtpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_sqrt_round_pd">
	<CPUID>AVX-512</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="rounding" type="int"/>
	<description>Compute the square root of packed double-precision (64-bit) floating-point elements in "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).
	[round_note].</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := SQRT(a[i+63:i])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vsqrtpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_sqrt_pd / vsqrtpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_sqrt_pd">
	<CPUID>AVX-512</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="a" type="__m512d"/>
	<description>Compute the square root of packed double-precision (64-bit) floating-point elements in "a", and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := SQRT(a[i+63:i])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vsqrtpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_sqrt_round_pd / vsqrtpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_sqrt_round_pd">
	<CPUID>AVX-512</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="rounding" type="int"/>
	<description>Compute the square root of packed double-precision (64-bit) floating-point elements in "a", and store the results in "dst".
	[round_note].</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := SQRT(a[i+63:i])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vsqrtpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_sqrt_ps / vsqrtps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_sqrt_ps">
	<CPUID>AVX-512</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="src" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<description>Compute the square root of packed single-precision (32-bit) floating-point elements in "a", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := SQRT(a[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vsqrtps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_sqrt_round_ps / vsqrtps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_sqrt_round_ps">
	<CPUID>AVX-512</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="src" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="rounding" type="int"/>
	<description>Compute the square root of packed single-precision (32-bit) floating-point elements in "a", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).
	[round_note]</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := SQRT(a[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vsqrtps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_sqrt_ps / vsqrtps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_sqrt_ps">
	<CPUID>AVX-512</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<description>Compute the square root of packed single-precision (32-bit) floating-point elements in "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := SQRT(a[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vsqrtps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_sqrt_round_ps / vsqrtps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_sqrt_round_ps">
	<CPUID>AVX-512</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="rounding" type="int"/>
	<description>Compute the square root of packed single-precision (32-bit) floating-point elements in "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).
	[round_note]</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := SQRT(a[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vsqrtps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_sqrt_ps / vsqrtps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_sqrt_ps">
	<CPUID>AVX-512</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="a" type="__m512"/>
	<description>Compute the square root of packed single-precision (32-bit) floating-point elements in "a", and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := SQRT(a[i+31:i])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vsqrtps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_sqrt_round_ps / vsqrtps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_sqrt_round_ps">
	<CPUID>AVX-512</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="rounding" type="int"/>
	<description>Compute the square root of packed single-precision (32-bit) floating-point elements in "a", and store the results in "dst".
	[round_note].</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := SQRT(a[i+31:i])
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vsqrtps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_sqrt_round_sd / vsqrtsd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_mask_sqrt_round_sd">
	<CPUID>AVX-512</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="src" type="__m128d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="rounding" type="int"/>
	<description>Compute the square root of the lower double-precision (64-bit) floating-point element in "a", store the result in the lower element of "dst" using writemask "k" (the element is copied from "src" when mask bit 0 is not set), and copy the upper element from "b" to the upper element of "dst".
	[round_note]
	</description>
	<description code="true">
IF k[0]
	dst[63:0] := SQRT(a[63:0])
ELSE
	dst[63:0] := src[63:0]
FI
dst[127:64] := b[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vsqrtsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_sqrt_sd / vsqrtsd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_mask_sqrt_sd">
	<CPUID>AVX-512</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="src" type="__m128d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<description>Compute the square root of the lower double-precision (64-bit) floating-point element in "a", store the result in the lower element of "dst" using writemask "k" (the element is copied from "src" when mask bit 0 is not set), and copy the upper element from "b" to the upper element of "dst".</description>
	<description code="true">
IF k[0]
	dst[63:0] := SQRT(a[63:0])
ELSE
	dst[63:0] := src[63:0]
FI
dst[127:64] := b[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vsqrtsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_sqrt_round_sd / vsqrtsd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_maskz_sqrt_round_sd">
	<CPUID>AVX-512</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="rounding" type="int"/>
	<description>Compute the square root of the lower double-precision (64-bit) floating-point element in "a", store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper element from "b" to the upper element of "dst".
	[round_note]
	</description>
	<description code="true">
IF k[0]
	dst[63:0] := SQRT(a[63:0])
ELSE
	dst[63:0] := 0
FI
dst[127:64] := b[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vsqrtsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_sqrt_sd / vsqrtsd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_maskz_sqrt_sd">
	<CPUID>AVX-512</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<description>Compute the square root of the lower double-precision (64-bit) floating-point element in "a", store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper element from "b" to the upper element of "dst".</description>
	<description code="true">
IF k[0]
	dst[63:0] := SQRT(a[63:0])
ELSE
	dst[63:0] := 0
FI
dst[127:64] := b[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vsqrtsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_sqrt_round_sd / vsqrtsd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_sqrt_round_sd">
	<CPUID>AVX-512</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="rounding" type="int"/>
	<description>Compute the square root of the lower double-precision (64-bit) floating-point element in "a", store the result in the lower element of "dst", and copy the upper element from "b" to the upper element of "dst".
	[round_note]
	</description>
	<description code="true">
dst[63:0] := SQRT(a[63:0])
dst[127:64] := b[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vsqrtsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_sqrt_round_ss / vsqrtss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_mask_sqrt_round_ss">
	<CPUID>AVX-512</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="src" type="__m128"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="rounding" type="int"/>
	<description>Compute the square root of the lower single-precision (32-bit) floating-point element in "a", store the result in the lower element of "dst" using writemask "k" (the element is copied from "src" when mask bit 0 is not set), and copy the upper 3 packed elements from "b" to the upper elements of "dst".
	[round_note]
	</description>
	<description code="true">
IF k[0]
	dst[31:0] := SQRT(a[31:0])
ELSE
	dst[31:0] := src[31:0]
FI
dst[127:32] := b[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vsqrtss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_sqrt_ss / vsqrtss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_mask_sqrt_ss">
	<CPUID>AVX-512</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="src" type="__m128"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<description>Compute the square root of the lower single-precision (32-bit) floating-point element in "a", store the result in the lower element of "dst" using writemask "k" (the element is copied from "src" when mask bit 0 is not set), and copy the upper 3 packed elements from "b" to the upper elements of "dst".</description>
	<description code="true">
IF k[0]
	dst[31:0] := SQRT(a[31:0])
ELSE
	dst[31:0] := src[31:0]
FI
dst[127:32] := b[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vsqrtss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_sqrt_round_ss / vsqrtss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_maskz_sqrt_round_ss">
	<CPUID>AVX-512</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="rounding" type="int"/>
	<description>Compute the square root of the lower single-precision (32-bit) floating-point element in "a", store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from "b" to the upper elements of "dst".
	[round_note]
	</description>
	<description code="true">
IF k[0]
	dst[31:0] := SQRT(a[31:0])
ELSE
	dst[31:0] := 0
FI
dst[127:32] := b[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vsqrtss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_sqrt_ss / vsqrtss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_maskz_sqrt_ss">
	<CPUID>AVX-512</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<description>Compute the square root of the lower single-precision (32-bit) floating-point element in "a", store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from "b" to the upper elements of "dst".</description>
	<description code="true">
IF k[0]
	dst[31:0] := SQRT(a[31:0])
ELSE
	dst[31:0] := 0
FI
dst[127:32] := b[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vsqrtss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_sqrt_round_ss / vsqrtss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_sqrt_round_ss">
	<CPUID>AVX-512</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="rounding" type="int"/>
	<description>Compute the square root of the lower single-precision (32-bit) floating-point element in "a", store the result in the lower element of "dst", and copy the upper 3 packed elements from "b" to the upper elements of "dst".
	[round_note]
	</description>
	<description code="true">
dst[31:0] := SQRT(a[31:0])
dst[127:32] := b[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vsqrtss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_sub_pd / vsubpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_sub_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="src" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<description>Subtract packed double-precision (64-bit) floating-point elements in "b" from packed double-precision (64-bit) floating-point elements in "a", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] - b[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>	
	<mnemonic base="vsubpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_sub_round_pd / vsubpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_sub_round_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="src" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="rounding" type="int"/>
	<description>Subtract packed double-precision (64-bit) floating-point elements in "b" from packed double-precision (64-bit) floating-point elements in "a", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).
	[round_note]</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] - b[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>	
	<mnemonic base="vsubpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_sub_pd / vsubpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_sub_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<description>Subtract packed double-precision (64-bit) floating-point elements in "b" from packed double-precision (64-bit) floating-point elements in "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] - b[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vsubpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_sub_round_pd / vsubpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_sub_round_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="rounding" type="int"/>
	<description>Subtract packed double-precision (64-bit) floating-point elements in "b" from packed double-precision (64-bit) floating-point elements in "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).
	[round_note]</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] - b[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>	
	<mnemonic base="vsubpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_sub_pd / vsubpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_sub_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<description>Subtract packed double-precision (64-bit) floating-point elements in "b" from packed double-precision (64-bit) floating-point elements in "a", and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := a[i+63:i] - b[i+63:i]
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vsubpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_sub_round_pd / vsubpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_sub_round_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<parameter varname="rounding" type="int"/>
	<description>Subtract packed double-precision (64-bit) floating-point elements in "b" from packed double-precision (64-bit) floating-point elements in "a", and store the results in "dst".
	[round_note]</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := a[i+63:i] - b[i+63:i]
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vsubpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_sub_ps / vsubps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_sub_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="src" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<description>Subtract packed single-precision (32-bit) floating-point elements in "b" from packed single-precision (32-bit) floating-point elements in "a", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i] - b[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI	
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vsubps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_sub_round_ps / vsubps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_sub_round_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="src" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="rounding" type="int"/>
	<description>Subtract packed single-precision (32-bit) floating-point elements in "b" from packed single-precision (32-bit) floating-point elements in "a", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).
	[round_note]</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i] - b[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI	
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vsubps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_sub_ps / vsubps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_sub_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<description>Subtract packed single-precision (32-bit) floating-point elements in "b" from packed single-precision (32-bit) floating-point elements in "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i] - b[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI	
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vsubps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_sub_round_ps / vsubps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_sub_round_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="rounding" type="int"/>
	<description>Subtract packed single-precision (32-bit) floating-point elements in "b" from packed single-precision (32-bit) floating-point elements in "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).
	[round_note]</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i] - b[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI	
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vsubps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_sub_ps / vsubps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_sub_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<description>Subtract packed single-precision (32-bit) floating-point elements in "b" from packed single-precision (32-bit) floating-point elements in "a", and store the results in "dst".</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := a[i+31:i] - b[i+31:i]
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vsubps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_sub_round_ps / vsubps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_sub_round_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<parameter varname="rounding" type="int"/>
	<description>Subtract packed single-precision (32-bit) floating-point elements in "b" from packed single-precision (32-bit) floating-point elements in "a", and store the results in "dst".
	[round_note]</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := a[i+31:i] - b[i+31:i]
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vsubps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_sub_round_sd / vsubsd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_mask_sub_round_sd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="src" type="__m128d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="rounding" type="int"/>
	<description>Subtract the lower double-precision (64-bit) floating-point element in "b" from the lower double-precision (64-bit) floating-point element in "a", store the result in the lower element of "dst" using writemask "k" (the element is copied from "src" when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst".
	[round_note]
	</description>
	<description code="true">
IF k[0]
	dst[63:0] := a[63:0] - b[63:0]
ELSE
	dst[63:0] := src[63:0]
FI
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vsubsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_sub_sd / vsubsd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_mask_sub_sd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="src" type="__m128d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<description>Subtract the lower double-precision (64-bit) floating-point element in "b" from the lower double-precision (64-bit) floating-point element in "a", store the result in the lower element of "dst" using writemask "k" (the element is copied from "src" when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst".</description>
	<description code="true">
IF k[0]
	dst[63:0] := a[63:0] - b[63:0]
ELSE
	dst[63:0] := src[63:0]
FI
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vsubsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_sub_round_sd / vsubsd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_maskz_sub_round_sd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="rounding" type="int"/>
	<description>Subtract the lower double-precision (64-bit) floating-point element in "b" from the lower double-precision (64-bit) floating-point element in "a", store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst".
	[round_note]
	</description>
	<description code="true">
IF k[0]
	dst[63:0] := a[63:0] - b[63:0]
ELSE
	dst[63:0] := 0
FI
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vsubsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_sub_sd / vsubsd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_maskz_sub_sd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<description>Subtract the lower double-precision (64-bit) floating-point element in "b" from the lower double-precision (64-bit) floating-point element in "a", store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst".</description>
	<description code="true">
IF k[0]
	dst[63:0] := a[63:0] - b[63:0]
ELSE
	dst[63:0] := 0
FI
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vsubsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_sub_round_sd / vsubsd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_sub_round_sd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="rounding" type="int"/>
	<description>Subtract the lower double-precision (64-bit) floating-point element in "b" from the lower double-precision (64-bit) floating-point element in "a", store the result in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst".
	[round_note]
	</description>
	<description code="true">
dst[63:0] := a[63:0] - b[63:0]
dst[127:64] := a[127:64]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vsubsd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_sub_round_ss / vsubss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_mask_sub_round_ss">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="src" type="__m128"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="rounding" type="int"/>
	<description>Subtract the lower single-precision (32-bit) floating-point element in "b" from the lower single-precision (32-bit) floating-point element in "a", store the result in the lower element of "dst" using writemask "k" (the element is copied from "src" when mask bit 0 is not set), and copy the upper 3 packed elements from "a" to the upper elements of "dst".
	[round_note]
	</description>
	<description code="true">
IF k[0]
	dst[31:0] := a[31:0] - b[31:0]
ELSE
	dst[31:0] := src[31:0]
FI
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vsubss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_sub_ss / vsubss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_mask_sub_ss">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="src" type="__m128"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<description>Subtract the lower single-precision (32-bit) floating-point element in "b" from the lower single-precision (32-bit) floating-point element in "a", store the result in the lower element of "dst" using writemask "k" (the element is copied from "src" when mask bit 0 is not set), and copy the upper 3 packed elements from "a" to the upper elements of "dst".</description>
	<description code="true">
IF k[0]
	dst[31:0] := a[31:0] - b[31:0]
ELSE
	dst[31:0] := src[31:0]
FI
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vsubss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_sub_round_ss / vsubss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_maskz_sub_round_ss">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="rounding" type="int"/>
	<description>Subtract the lower single-precision (32-bit) floating-point element in "b" from the lower single-precision (32-bit) floating-point element in "a", store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from "a" to the upper elements of "dst".
	[round_note]
	</description>
	<description code="true">
IF k[0]
	dst[31:0] := a[31:0] - b[31:0]
ELSE
	dst[31:0] := 0
FI
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vsubss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_sub_ss / vsubss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_maskz_sub_ss">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<description>Subtract the lower single-precision (32-bit) floating-point element in "b" from the lower single-precision (32-bit) floating-point element in "a", store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from "a" to the upper elements of "dst".</description>
	<description code="true">
IF k[0]
	dst[31:0] := a[31:0] - b[31:0]
ELSE
	dst[31:0] := 0
FI
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vsubss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_sub_round_ss / vsubss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_sub_round_ss">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="rounding" type="int"/>
	<description>Subtract the lower single-precision (32-bit) floating-point element in "b" from the lower single-precision (32-bit) floating-point element in "a", store the result in the lower element of "dst", and copy the upper 3 packed elements from "a" to the upper elements of "dst".
	[round_note]
	</description>
	<description code="true">
dst[31:0] := a[31:0] - b[31:0]
dst[127:32] := a[127:32]
dst[MAX:128] := 0
	</description>
	<mnemonic base="vsubss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_unpackhi_pd / vunpckhpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_unpackhi_pd">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="src" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>	
	<description>Unpack and interleave double-precision (64-bit) floating-point elements from the high half of each 128-bit lane in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
INTERLEAVE_HIGH_QWORDS(src1[127:0], src2[127:0]){
	dst[63:0] := src1[127:64] 
	dst[127:64] := src2[127:64] 
	RETURN dst[127:0]
}	
	
tmp_dst[127:0] := INTERLEAVE_HIGH_QWORDS(a[127:0], b[127:0])
tmp_dst[255:128] := INTERLEAVE_HIGH_QWORDS(a[255:128], b[255:128])
tmp_dst[383:256] := INTERLEAVE_HIGH_QWORDS(a[383:256], b[383:256])
tmp_dst[511:384] := INTERLEAVE_HIGH_QWORDS(a[511:384], b[511:384])

FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp_dst[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vunpckhpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_unpackhi_pd / vunpckhpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_unpackhi_pd">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<description>Unpack and interleave double-precision (64-bit) floating-point elements from the high half of each 128-bit lane in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
INTERLEAVE_HIGH_QWORDS(src1[127:0], src2[127:0]){
	dst[63:0] := src1[127:64] 
	dst[127:64] := src2[127:64] 
	RETURN dst[127:0]
}	
	
tmp_dst[127:0] := INTERLEAVE_HIGH_QWORDS(a[127:0], b[127:0])
tmp_dst[255:128] := INTERLEAVE_HIGH_QWORDS(a[255:128], b[255:128])
tmp_dst[383:256] := INTERLEAVE_HIGH_QWORDS(a[383:256], b[383:256])
tmp_dst[511:384] := INTERLEAVE_HIGH_QWORDS(a[511:384], b[511:384])

FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp_dst[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vunpckhpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_unpackhi_pd / vunpckhpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_unpackhi_pd">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<description>Unpack and interleave double-precision (64-bit) floating-point elements from the high half of each 128-bit lane in "a" and "b", and store the results in "dst". </description>
	<description code="true">
INTERLEAVE_HIGH_QWORDS(src1[127:0], src2[127:0]){
	dst[63:0] := src1[127:64] 
	dst[127:64] := src2[127:64] 
	RETURN dst[127:0]
}	
	
dst[127:0] := INTERLEAVE_HIGH_QWORDS(a[127:0], b[127:0])
dst[255:128] := INTERLEAVE_HIGH_QWORDS(a[255:128], b[255:128])
dst[383:256] := INTERLEAVE_HIGH_QWORDS(a[383:256], b[383:256])
dst[511:384] := INTERLEAVE_HIGH_QWORDS(a[511:384], b[511:384])
dst[MAX:512] := 0
	</description>
	<mnemonic base="vunpckhpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_unpackhi_ps / vunpckhps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_unpackhi_ps">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="src" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<description>Unpack and interleave single-precision (32-bit) floating-point elements from the high half of each 128-bit lane in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
INTERLEAVE_HIGH_DWORDS(src1[127:0], src2[127:0]){
	dst[31:0] := src1[95:64] 
	dst[63:32] := src2[95:64] 
	dst[95:64] := src1[127:96] 
	dst[127:96] := src2[127:96] 
	RETURN dst[127:0]
}	
	
tmp_dst[127:0] := INTERLEAVE_HIGH_DWORDS(a[127:0], b[127:0])
tmp_dst[255:128] := INTERLEAVE_HIGH_DWORDS(a[255:128], b[255:128])
tmp_dst[383:256] := INTERLEAVE_HIGH_DWORDS(a[383:256], b[383:256])
tmp_dst[511:384] := INTERLEAVE_HIGH_DWORDS(a[511:384], b[511:384])

FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp_dst[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vunpckhps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_unpackhi_ps / vunpckhps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_unpackhi_ps">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<description>Unpack and interleave single-precision (32-bit) floating-point elements from the high half of each 128-bit lane in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
INTERLEAVE_HIGH_DWORDS(src1[127:0], src2[127:0]){
	dst[31:0] := src1[95:64] 
	dst[63:32] := src2[95:64] 
	dst[95:64] := src1[127:96] 
	dst[127:96] := src2[127:96] 
	RETURN dst[127:0]
}	
	
tmp_dst[127:0] := INTERLEAVE_HIGH_DWORDS(a[127:0], b[127:0])
tmp_dst[255:128] := INTERLEAVE_HIGH_DWORDS(a[255:128], b[255:128])
tmp_dst[383:256] := INTERLEAVE_HIGH_DWORDS(a[383:256], b[383:256])
tmp_dst[511:384] := INTERLEAVE_HIGH_DWORDS(a[511:384], b[511:384])

FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp_dst[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vunpckhps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_unpackhi_ps / vunpckhps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_unpackhi_ps">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<description>Unpack and interleave single-precision (32-bit) floating-point elements from the high half of each 128-bit lane in "a" and "b", and store the results in "dst". </description>
	<description code="true">
INTERLEAVE_HIGH_DWORDS(src1[127:0], src2[127:0]){
	dst[31:0] := src1[95:64] 
	dst[63:32] := src2[95:64] 
	dst[95:64] := src1[127:96] 
	dst[127:96] := src2[127:96] 
	RETURN dst[127:0]
}	
	
dst[127:0] := INTERLEAVE_HIGH_DWORDS(a[127:0], b[127:0])
dst[255:128] := INTERLEAVE_HIGH_DWORDS(a[255:128], b[255:128])
dst[383:256] := INTERLEAVE_HIGH_DWORDS(a[383:256], b[383:256])
dst[511:384] := INTERLEAVE_HIGH_DWORDS(a[511:384], b[511:384])
dst[MAX:512] := 0
	</description>
	<mnemonic base="vunpckhps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_unpacklo_pd / vunpcklpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_unpacklo_pd">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="src" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<description>Unpack and interleave double-precision (64-bit) floating-point elements from the low half of each 128-bit lane in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
INTERLEAVE_QWORDS(src1[127:0], src2[127:0]){
	dst[63:0] := src1[63:0] 
	dst[127:64] := src2[63:0] 
	RETURN dst[127:0]
}

tmp_dst[127:0] := INTERLEAVE_QWORDS(a[127:0], b[127:0])
tmp_dst[255:128] := INTERLEAVE_QWORDS(a[255:128], b[255:128])
tmp_dst[383:256] := INTERLEAVE_QWORDS(a[383:256], b[383:256])
tmp_dst[511:384] := INTERLEAVE_QWORDS(a[511:384], b[511:384])

FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp_dst[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vunpcklpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_unpacklo_pd / vunpcklpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_unpacklo_pd">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<description>Unpack and interleave double-precision (64-bit) floating-point elements from the low half of each 128-bit lane in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
INTERLEAVE_QWORDS(src1[127:0], src2[127:0]){
	dst[63:0] := src1[63:0] 
	dst[127:64] := src2[63:0] 
	RETURN dst[127:0]
}

tmp_dst[127:0] := INTERLEAVE_QWORDS(a[127:0], b[127:0])
tmp_dst[255:128] := INTERLEAVE_QWORDS(a[255:128], b[255:128])
tmp_dst[383:256] := INTERLEAVE_QWORDS(a[383:256], b[383:256])
tmp_dst[511:384] := INTERLEAVE_QWORDS(a[511:384], b[511:384])

FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp_dst[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vunpcklpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_unpacklo_pd / vunpcklpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_unpacklo_pd">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="b" type="__m512d"/>
	<description>Unpack and interleave double-precision (64-bit) floating-point elements from the low half of each 128-bit lane in "a" and "b", and store the results in "dst". </description>
	<description code="true">
INTERLEAVE_QWORDS(src1[127:0], src2[127:0]){
	dst[63:0] := src1[63:0] 
	dst[127:64] := src2[63:0] 
	RETURN dst[127:0]
}

dst[127:0] := INTERLEAVE_QWORDS(a[127:0], b[127:0])
dst[255:128] := INTERLEAVE_QWORDS(a[255:128], b[255:128])
dst[383:256] := INTERLEAVE_QWORDS(a[383:256], b[383:256])
dst[511:384] := INTERLEAVE_QWORDS(a[511:384], b[511:384])
dst[MAX:512] := 0
	</description>
	<mnemonic base="vunpcklpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_unpacklo_ps / vunpcklps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_unpacklo_ps">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="src" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<description>Unpack and interleave single-precision (32-bit) floating-point elements from the low half of each 128-bit lane in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). </description>
	<description code="true">
INTERLEAVE_DWORDS(src1[127:0], src2[127:0]){
	dst[31:0] := src1[31:0] 
	dst[63:32] := src2[31:0] 
	dst[95:64] := src1[63:32] 
	dst[127:96] := src2[63:32] 
	RETURN dst[127:0]
}	

tmp_dst[127:0] := INTERLEAVE_DWORDS(a[127:0], b[127:0])
tmp_dst[255:128] := INTERLEAVE_DWORDS(a[255:128], b[255:128])
tmp_dst[383:256] := INTERLEAVE_DWORDS(a[383:256], b[383:256])
tmp_dst[511:384] := INTERLEAVE_DWORDS(a[511:384], b[511:384])

FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp_dst[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vunpcklps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_unpacklo_ps / vunpcklps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_unpacklo_ps">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<description>Unpack and interleave single-precision (32-bit) floating-point elements from the low half of each 128-bit lane in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). </description>
	<description code="true">
INTERLEAVE_DWORDS(src1[127:0], src2[127:0]){
	dst[31:0] := src1[31:0] 
	dst[63:32] := src2[31:0] 
	dst[95:64] := src1[63:32] 
	dst[127:96] := src2[63:32] 
	RETURN dst[127:0]
}	

tmp_dst[127:0] := INTERLEAVE_DWORDS(a[127:0], b[127:0])
tmp_dst[255:128] := INTERLEAVE_DWORDS(a[255:128], b[255:128])
tmp_dst[383:256] := INTERLEAVE_DWORDS(a[383:256], b[383:256])
tmp_dst[511:384] := INTERLEAVE_DWORDS(a[511:384], b[511:384])

FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp_dst[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</description>
	<mnemonic base="vunpcklps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_unpacklo_ps / vunpcklps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_unpacklo_ps">
	<CPUID>AVX-512</CPUID>
	<category>Swizzle</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="b" type="__m512"/>
	<description>Unpack and interleave single-precision (32-bit) floating-point elements from the low half of each 128-bit lane in "a" and "b", and store the results in "dst". </description>
	<description code="true">
INTERLEAVE_DWORDS(src1[127:0], src2[127:0]){
	dst[31:0] := src1[31:0] 
	dst[63:32] := src2[31:0] 
	dst[95:64] := src1[63:32] 
	dst[127:96] := src2[63:32] 
	RETURN dst[127:0]
}	

dst[127:0] := INTERLEAVE_DWORDS(a[127:0], b[127:0])
dst[255:128] := INTERLEAVE_DWORDS(a[255:128], b[255:128])
dst[383:256] := INTERLEAVE_DWORDS(a[383:256], b[383:256])
dst[511:384] := INTERLEAVE_DWORDS(a[511:384], b[511:384])
dst[MAX:512] := 0
	</description>
	<mnemonic base="vunpcklps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_castpd128_pd512 -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_castpd128_pd512">
	<CPUID>AVX-512</CPUID>
	<category>Cast</category>
	<parameter varname="a" type="__m128d"/>
	<description>Cast vector of type __m128d to type __m512d; the upper 384 bits of the result are undefined. 
	This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</description>
	<mnemonic base="-"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_castpd256_pd512 -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_castpd256_pd512">
	<CPUID>AVX-512</CPUID>
	<category>Cast</category>
	<parameter varname="a" type="__m256d"/>
	<description>Cast vector of type __m256d to type __m512d; the upper 256 bits of the result are undefined. 
	This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</description>
	<mnemonic base="-"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_castpd512_pd128 -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm512_castpd512_pd128">
	<CPUID>AVX-512</CPUID>
	<category>Cast</category>
	<parameter varname="a" type="__m512d"/>
	<description>Cast vector of type __m512d to type __m128d. 
	This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</description>
	<mnemonic base="-"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_castps512_ps128 -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm512_castps512_ps128">
	<CPUID>AVX-512</CPUID>
	<category>Cast</category>
	<parameter varname="a" type="__m512"/>
	<description>Cast vector of type __m512 to type __m128. 
	This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</description>
	<mnemonic base="-"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_castpd512_pd256 -->
<intrinsic tech="AVX-512" rettype="__m256d" name="_mm512_castpd512_pd256">
	<CPUID>AVX-512</CPUID>
	<category>Cast</category>
	<parameter varname="a" type="__m512d"/>
	<description>Cast vector of type __m512d to type __m256d. 
	This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</description>
	<mnemonic base="-"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_castpd_ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_castpd_ps">
	<CPUID>AVX-512</CPUID>
	<category>Cast</category>
	<parameter varname="a" type="__m512d"/>
	<description>Cast vector of type __m512d to type __m512.
	This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</description>
	<mnemonic base="-"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_castpd_si512 -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_castpd_si512">
	<CPUID>AVX-512</CPUID>
	<category>Cast</category>
	<parameter varname="a" type="__m512d"/>
	<description>Cast vector of type __m512d to type __m512i.
	This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</description>
	<mnemonic base="-"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_castps128_ps512 -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_castps128_ps512">
	<CPUID>AVX-512</CPUID>
	<category>Cast</category>
	<parameter varname="a" type="__m128"/>
	<description>Cast vector of type __m128 to type __m512; the upper 384 bits of the result are undefined. 
	This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</description>
	<mnemonic base="-"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_castps256_ps512 -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_castps256_ps512">
	<CPUID>AVX-512</CPUID>
	<category>Cast</category>
	<parameter varname="a" type="__m256"/>
	<description>Cast vector of type __m256 to type __m512; the upper 256 bits of the result are undefined. 
	This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</description>
	<mnemonic base="-"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_castps512_ps256 -->
<intrinsic tech="AVX-512" rettype="__m256" name="_mm512_castps512_ps256">
	<CPUID>AVX-512</CPUID>
	<category>Cast</category>
	<parameter varname="a" type="__m512"/>
	<description>Cast vector of type __m512 to type __m256. 
	This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</description>
	<mnemonic base="-"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_castps_pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_castps_pd">
	<CPUID>AVX-512</CPUID>
	<category>Cast</category>
	<parameter varname="a" type="__m512"/>
	<description>Cast vector of type __m512 to type __m512d.
	This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</description>
	<mnemonic base="-"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_castps_si512 -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_castps_si512">
	<CPUID>AVX-512</CPUID>
	<category>Cast</category>
	<parameter varname="a" type="__m512"/>
	<description>Cast vector of type __m512 to type __m512i.
	This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</description>
	<mnemonic base="-"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_castsi128_si512 -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_castsi128_si512">
	<CPUID>AVX-512</CPUID>
	<category>Cast</category>
	<parameter varname="a" type="__m128i"/>
	<description>Cast vector of type __m128i to type __m512i; the upper 384 bits of the result are undefined. 
	This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</description>
	<mnemonic base="-"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_castsi256_si512 -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_castsi256_si512">
	<CPUID>AVX-512</CPUID>
	<category>Cast</category>
	<parameter varname="a" type="__m256i"/>
	<description>Cast vector of type __m256i to type __m512i; the upper 256 bits of the result are undefined.
	 This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</description>
	<mnemonic base="-"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_castsi512_pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_castsi512_pd">
	<CPUID>AVX-512</CPUID>
	<category>Cast</category>
	<parameter varname="a" type="__m512i"/>
	<description>Cast vector of type __m512i to type __m512d.
	This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</description>
	<mnemonic base="-"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_castsi512_ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_castsi512_ps">
	<CPUID>AVX-512</CPUID>
	<category>Cast</category>
	<parameter varname="a" type="__m512i"/>
	<description>Cast vector of type __m512i to type __m512.
	This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</description>
	<mnemonic base="-"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_castsi512_si128 -->
<intrinsic tech="AVX-512" rettype="__m128i" name="_mm512_castsi512_si128">
	<CPUID>AVX-512</CPUID>
	<category>Cast</category>
	<parameter varname="a" type="__m512i"/>
	<description>Cast vector of type __m512i to type __m128i.
	 This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</description>
	<mnemonic base="-"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_castsi512_si256 -->
<intrinsic tech="AVX-512" rettype="__m256i" name="_mm512_castsi512_si256">
	<CPUID>AVX-512</CPUID>
	<category>Cast</category>
	<parameter varname="a" type="__m512i"/>
	<description>Cast vector of type __m512i to type __m256i.
	 This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</description>
	<mnemonic base="-"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_reduce_add_epi32 -->
<intrinsic tech="AVX-512" rettype="int" name="_mm512_mask_reduce_add_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<description>Reduce the packed 32-bit integers in "a" by addition using mask "k". Returns the sum of all active elements in "a".</description>
	<description code="true">
sum[31:0] := 0
FOR j := 0 to 15
	i := j*32
	IF k[j]
		sum[31:0] := sum[31:0] + a[i+31:i]
	FI
ENDFOR
RETURN sum[31:0]
	</description>
	<mnemonic base=""/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_reduce_add_epi64 -->
<intrinsic tech="AVX-512" sequence="true" rettype="__int64" name="_mm512_mask_reduce_add_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<description>Reduce the packed 64-bit integers in "a" by addition using mask "k". Returns the sum of all active elements in "a".</description>
	<description code="true">
sum[63:0] := 0
FOR j := 0 to 7
	i := j*64
	IF k[j]
		sum[63:0] := sum[63:0] + a[i+63:i]
	FI
ENDFOR
RETURN sum[63:0]
	</description>
	<mnemonic base=""/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_reduce_add_pd -->
<intrinsic tech="AVX-512" sequence="true" rettype="double" name="_mm512_mask_reduce_add_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<description>Reduce the packed double-precision (64-bit) floating-point elements in "a" by addition using mask "k". Returns the sum of all active elements in "a".</description>
	<description code="true">
sum[63:0] := 0
FOR j := 0 to 7
	i := j*64
	IF k[j]
		sum[63:0] := sum[63:0] + a[i+63:i]
	FI
ENDFOR
RETURN sum[63:0]
	</description>
	<mnemonic base=""/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_reduce_add_ps -->
<intrinsic tech="AVX-512" sequence="true" rettype="float" name="_mm512_mask_reduce_add_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<description>Reduce the packed single-precision (32-bit) floating-point elements in "a" by addition using mask "k". Returns the sum of all active elements in "a".</description>
	<description code="true">
sum[31:0] := 0
FOR j := 0 to 15
	i := j*32
	IF k[j]
		sum[31:0] := sum[31:0] + a[i+31:i]
	FI
ENDFOR
RETURN sum[31:0]
	</description>
	<mnemonic base=""/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_reduce_and_epi32 -->
<intrinsic tech="AVX-512" sequence="true" rettype="int" name="_mm512_mask_reduce_and_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Logical</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<description>Reduce the packed 32-bit integers in "a" by bitwise AND using mask "k". Returns the bitwise AND of all active elements in "a".</description>
	<description code="true">
reduced[31:0] := 0xFFFFFFFF
FOR j := 0 to 15
	i := j*32
	IF k[j]
		reduced[31:0] := reduced[31:0] AND a[i+31:i]
	FI
ENDFOR
RETURN reduced[31:0]
	</description>
	<mnemonic base=""/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_reduce_and_epi64 -->
<intrinsic tech="AVX-512" sequence="true" rettype="__int64" name="_mm512_mask_reduce_and_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Logical</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<description>Reduce the packed 64-bit integers in "a" by bitwise AND using mask "k". Returns the bitwise AND of all active elements in "a".</description>
	<description code="true">
reduced[63:0] := 0xFFFFFFFFFFFFFFFF
FOR j := 0 to 7
	i := j*64
	IF k[j]
		reduced[63:0] := reduced[63:0] AND a[i+63:i]
	FI
ENDFOR
RETURN reduced[63:0]
	</description>
	<mnemonic base=""/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_reduce_max_epi32 -->
<intrinsic tech="AVX-512" sequence="true" rettype="int" name="_mm512_mask_reduce_max_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<description>Reduce the packed 32-bit integers in "a" by maximum using mask "k". Returns the maximum of all active elements in "a".</description>
	<description code="true">
max[31:0] := MIN_INT
FOR j := 0 to 15
	i := j*32
	IF k[j]
		max[31:0] := MAXIMUM(max[31:0], a[i+31:i])
	FI
ENDFOR
RETURN max[31:0]
	</description>
	<mnemonic base=""/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_reduce_max_epi64 -->
<intrinsic tech="AVX-512" sequence="true" rettype="__int64" name="_mm512_mask_reduce_max_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<description>Reduce the packed 64-bit integers in "a" by maximum using mask "k". Returns the maximum of all active elements in "a".</description>
	<description code="true">
max[63:0] := MIN_INT
FOR j := 0 to 7
	i := j*64
	IF k[j]
		max[63:0] := MAXIMUM(max[63:0], a[i+63:i])
	FI
ENDFOR
RETURN max[63:0]
	</description>
	<mnemonic base=""/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_reduce_max_epu32 -->
<intrinsic tech="AVX-512" sequence="true" rettype="unsigned int" name="_mm512_mask_reduce_max_epu32">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<description>Reduce the packed unsigned 32-bit integers in "a" by maximum using mask "k". Returns the maximum of all active elements in "a".</description>
	<description code="true">
max[31:0] := 0
FOR j := 0 to 15
	i := j*32
	IF k[j]
		max[31:0] := MAXIMUM(max[31:0], a[i+31:i])
	FI
ENDFOR
RETURN max[31:0]
	</description>
	<mnemonic base=""/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_reduce_max_epu64 -->
<intrinsic tech="AVX-512" sequence="true" rettype="unsigned __int64" name="_mm512_mask_reduce_max_epu64">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<description>Reduce the packed unsigned 64-bit integers in "a" by maximum using mask "k". Returns the maximum of all active elements in "a".</description>
	<description code="true">
max[63:0] := 0
FOR j := 0 to 7
	i := j*64
	IF k[j]
		max[63:0] := MAXIMUM(max[63:0], a[i+63:i])
	FI
ENDFOR
RETURN max[63:0]
	</description>
	<mnemonic base=""/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_reduce_max_pd -->
<intrinsic tech="AVX-512" sequence="true" rettype="double" name="_mm512_mask_reduce_max_pd">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<description>Reduce the packed double-precision (64-bit) floating-point elements in "a" by maximum using mask "k". Returns the maximum of all active elements in "a".</description>
	<description code="true">
max[63:0] := MIN_DOUBLE
FOR j := 0 to 7
	i := j*64
	IF k[j]
		max[63:0] := MAXIMUM(max[63:0], a[i+63:i])
	FI
ENDFOR
RETURN max[63:0]
	</description>
	<mnemonic base=""/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_reduce_max_ps -->
<intrinsic tech="AVX-512" sequence="true" rettype="float" name="_mm512_mask_reduce_max_ps">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<description>Reduce the packed single-precision (32-bit) floating-point elements in "a" by maximum using mask "k". Returns the maximum of all active elements in "a".</description>
	<description code="true">
max[31:0] := MIN_FLOAT
FOR j := 0 to 15
	i := j*32
	IF k[j]
		max[31:0] := MAXIMUM(max[31:0], a[i+31:i])
	FI
ENDFOR
RETURN max[31:0]
	</description>
	<mnemonic base=""/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_reduce_min_epi32 -->
<intrinsic tech="AVX-512" sequence="true" rettype="int" name="_mm512_mask_reduce_min_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<description>Reduce the packed 32-bit integers in "a" by maximum using mask "k". Returns the minimum of all active elements in "a".</description>
	<description code="true">
min[31:0] := MAX_INT
FOR j := 0 to 15
	i := j*32
	IF k[j]
		min[31:0] := MINIMUM(min[31:0], a[i+31:i])
	FI
ENDFOR
RETURN min[31:0]
	</description>
	<mnemonic base=""/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_reduce_min_epi64 -->
<intrinsic tech="AVX-512" sequence="true" rettype="__int64" name="_mm512_mask_reduce_min_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<description>Reduce the packed 64-bit integers in "a" by maximum using mask "k". Returns the minimum of all active elements in "a".</description>
	<description code="true">
min[63:0] := MAX_INT
FOR j := 0 to 7
	i := j*64
	IF k[j]
		min[63:0] := MINIMUM(min[63:0], a[i+63:i])
	FI
ENDFOR
RETURN min[63:0]
	</description>
	<mnemonic base=""/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_reduce_min_epu32 -->
<intrinsic tech="AVX-512" sequence="true" rettype="unsigned int" name="_mm512_mask_reduce_min_epu32">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<description>Reduce the packed unsigned 32-bit integers in "a" by maximum using mask "k". Returns the minimum of all active elements in "a".</description>
	<description code="true">
min[31:0] := MAX_UINT
FOR j := 0 to 15
	i := j*32
	IF k[j]
		min[31:0] := MINIMUM(min[31:0], a[i+31:i])
	FI
ENDFOR
RETURN min[31:0]
	</description>
	<mnemonic base=""/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_reduce_min_epu64 -->
<intrinsic tech="AVX-512" sequence="true" rettype="unsigned __int64" name="_mm512_mask_reduce_min_epu64">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<description>Reduce the packed unsigned 64-bit integers in "a" by minimum using mask "k". Returns the minimum of all active elements in "a".</description>
	<description code="true">
min[63:0] := MAX_UINT
FOR j := 0 to 7
	i := j*64
	IF k[j]
		min[63:0] := MINIMUM(min[63:0], a[i+63:i])
	FI
ENDFOR
RETURN min[63:0]
	</description>
	<mnemonic base=""/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_reduce_min_pd -->
<intrinsic tech="AVX-512" sequence="true" rettype="double" name="_mm512_mask_reduce_min_pd">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<description>Reduce the packed double-precision (64-bit) floating-point elements in "a" by maximum using mask "k". Returns the minimum of all active elements in "a".</description>
	<description code="true">
min[63:0] := MAX_DOUBLE
FOR j := 0 to 7
	i := j*64
	IF k[j]
		min[63:0] := MINIMUM(min[63:0], a[i+63:i])
	FI
ENDFOR
RETURN min[63:0]
	</description>
	<mnemonic base=""/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_reduce_min_ps -->
<intrinsic tech="AVX-512" sequence="true" rettype="float" name="_mm512_mask_reduce_min_ps">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<description>Reduce the packed single-precision (32-bit) floating-point elements in "a" by maximum using mask "k". Returns the minimum of all active elements in "a".</description>
	<description code="true">
min[31:0] := MAX_FLOAT
FOR j := 0 to 15
	i := j*32
	IF k[j]
		min[31:0] := MINIMUM(min[31:0], a[i+31:i])
	FI
ENDFOR
RETURN min[31:0]
	</description>
	<mnemonic base=""/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_reduce_mul_epi32 -->
<intrinsic tech="AVX-512" sequence="true" rettype="int" name="_mm512_mask_reduce_mul_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<description>Reduce the packed 32-bit integers in "a" by multiplication using mask "k". Returns the product of all active elements in "a".</description>
	<description code="true">
prod[31:0] := 1
FOR j := 0 to 15
	i := j*32
	IF k[j]
		prod[31:0] := prod[31:0] * a[i+31:i]
	FI
ENDFOR
RETURN prod[31:0]
	</description>
	<mnemonic base=""/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_reduce_mul_epi64 -->
<intrinsic tech="AVX-512" sequence="true" rettype="__int64" name="_mm512_mask_reduce_mul_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<description>Reduce the packed 64-bit integers in "a" by multiplication using mask "k". Returns the product of all active elements in "a".</description>
	<description code="true">
prod[63:0] := 1
FOR j := 0 to 7
	i := j*64
	IF k[j]
		prod[63:0] := prod[63:0] * a[i+63:i]
	FI
ENDFOR
RETURN prod[63:0]
	</description>
	<mnemonic base=""/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_reduce_mul_pd -->
<intrinsic tech="AVX-512" sequence="true" rettype="double" name="_mm512_mask_reduce_mul_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<description>Reduce the packed double-precision (64-bit) floating-point elements in "a" by multiplication using mask "k". Returns the product of all active elements in "a".</description>
	<description code="true">
prod[63:0] := 1
FOR j := 0 to 7
	i := j*64
	IF k[j]
		prod[63:0] := prod[63:0] * a[i+63:i]
	FI
ENDFOR
RETURN prod[63:0]
	</description>
	<mnemonic base=""/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_reduce_mul_ps -->
<intrinsic tech="AVX-512" sequence="true" rettype="float" name="_mm512_mask_reduce_mul_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<description>Reduce the packed single-precision (32-bit) floating-point elements in "a" by multiplication using mask "k". Returns the product of all active elements in "a".</description>
	<description code="true">
prod[31:0] := 1
FOR j := 0 to 15
	i := j*32
	IF k[j]
		prod[31:0] := prod[31:0] * a[i+31:i]
	FI
ENDFOR
RETURN prod[31:0]
	</description>
	<mnemonic base=""/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_reduce_or_epi32 -->
<intrinsic tech="AVX-512" sequence="true" rettype="int" name="_mm512_mask_reduce_or_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Logical</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512i"/>
	<description>Reduce the packed 32-bit integers in "a" by bitwise OR using mask "k". Returns the bitwise OR of all active elements in "a".</description>
	<description code="true">
reduced[31:0] := 0
FOR j := 0 to 15
	i := j*32
	IF k[j]
		reduced[31:0] := reduced[31:0] OR a[i+31:i]
	FI
ENDFOR
RETURN reduced[31:0]
	</description>
	<mnemonic base=""/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_reduce_or_epi64 -->
<intrinsic tech="AVX-512" sequence="true" rettype="__int64" name="_mm512_mask_reduce_or_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Logical</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512i"/>
	<description>Reduce the packed 64-bit integers in "a" by bitwise OR using mask "k". Returns the bitwise OR of all active elements in "a".</description>
	<description code="true">
reduced[63:0] := 0
FOR j := 0 to 7
	i := j*64
	IF k[j]
		reduced[63:0] := reduced[63:0] OR a[i+63:i]
	FI
ENDFOR
RETURN reduced[63:0]
	</description>
	<mnemonic base=""/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_reduce_add_epi32 -->
<intrinsic tech="AVX-512" sequence="true" rettype="int" name="_mm512_reduce_add_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512i"/>
	<description>Reduce the packed 32-bit integers in "a" by addition. Returns the sum of all elements in "a".</description>
	<description code="true">
sum[31:0] := 0
FOR j := 0 to 15
	i := j*32
	sum[31:0] := sum[31:0] + a[i+31:i]
ENDFOR
RETURN sum[63:0]
	</description>
	<mnemonic base=""/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_reduce_add_epi64 -->
<intrinsic tech="AVX-512" sequence="true" rettype="__int64" name="_mm512_reduce_add_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512i"/>
	<description>Reduce the packed 64-bit integers in "a" by addition. Returns the sum of all elements in "a".</description>
	<description code="true">
sum[63:0] := 0
FOR j := 0 to 7
	i := j*64
	sum[63:0] := sum[63:0] + a[i+63:i]
ENDFOR
RETURN sum[63:0]
	</description>
	<mnemonic base=""/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_reduce_add_pd -->
<intrinsic tech="AVX-512" sequence="true" rettype="double" name="_mm512_reduce_add_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512d"/>
	<description>Reduce the packed double-precision (64-bit) floating-point elements in "a" by addition. Returns the sum of all elements in "a".</description>
	<description code="true">
sum[63:0] := 0
FOR j := 0 to 7
	i := j*64
	sum[63:0] := sum[63:0] + a[i+63:i]
ENDFOR
RETURN sum[63:0]
	</description>
	<mnemonic base=""/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_reduce_add_ps -->
<intrinsic tech="AVX-512" sequence="true" rettype="float" name="_mm512_reduce_add_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512"/>
	<description>Reduce the packed single-precision (32-bit) floating-point elements in "a" by addition. Returns the sum of all elements in "a".</description>
	<description code="true">
sum[31:0] := 0
FOR j := 0 to 15
	i := j*32
	sum[31:0] := sum[31:0] + a[i+31:i]
ENDFOR
RETURN sum[63:0]
	</description>
	<mnemonic base=""/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_reduce_and_epi32 -->
<intrinsic tech="AVX-512" sequence="true" rettype="int" name="_mm512_reduce_and_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Logical</category>
	<parameter varname="a" type="__m512i"/>
	<description>Reduce the packed 32-bit integers in "a" by bitwise AND. Returns the bitwise AND of all elements in "a".</description>
	<description code="true">
reduced[31:0] := 0xFFFFFFFF
FOR j := 0 to 15
	i := j*32
	reduced[31:0] := reduced[31:0] AND a[i+31:i]
ENDFOR
RETURN reduced[31:0]
	</description>
	<mnemonic base=""/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_reduce_and_epi64 -->
<intrinsic tech="AVX-512" sequence="true" rettype="__int64" name="_mm512_reduce_and_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Logical</category>
	<parameter varname="a" type="__m512i"/>
	<description>Reduce the packed 64-bit integers in "a" by bitwise AND. Returns the bitwise AND of all elements in "a".</description>
	<description code="true">
reduced[63:0] := 0xFFFFFFFFFFFFFFFF
FOR j := 0 to 7
	i := j*64
	reduced[63:0] := reduced[63:0] AND a[i+63:i]
ENDFOR
RETURN reduced[63:0]
	</description>
	<mnemonic base=""/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_reduce_max_epi32 -->
<intrinsic tech="AVX-512" sequence="true" rettype="int" name="_mm512_reduce_max_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="a" type="__m512i"/>
	<description>Reduce the packed 32-bit integers in "a" by maximum. Returns the maximum of all elements in "a".</description>
	<description code="true">
max[31:0] := MIN_INT
FOR j := 0 to 15
	i := j*32
	max[31:0] := MAXIMUM(max[31:0], a[i+31:i])
ENDFOR
RETURN max[31:0]
	</description>
	<mnemonic base=""/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_reduce_max_epi64 -->
<intrinsic tech="AVX-512" sequence="true" rettype="__int64" name="_mm512_reduce_max_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="a" type="__m512i"/>
	<description>Reduce the packed 64-bit integers in "a" by maximum. Returns the maximum of all elements in "a".</description>
	<description code="true">
max[63:0] := MIN_INT
FOR j := 0 to 7
	i := j*64
	max[63:0] := MAXIMUM(max[63:0], a[i+63:i])
ENDFOR
RETURN max[63:0]
	</description>
	<mnemonic base=""/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_reduce_max_epu32 -->
<intrinsic tech="AVX-512" sequence="true" rettype="unsigned int" name="_mm512_reduce_max_epu32">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="a" type="__m512i"/>
	<description>Reduce the packed unsigned 32-bit integers in "a" by maximum. Returns the maximum of all elements in "a".</description>
	<description code="true">
max[31:0] := 0
FOR j := 0 to 15
	i := j*32
	max[31:0] := MAXIMUM(max[31:0], a[i+31:i])
ENDFOR
RETURN max[31:0]
	</description>
	<mnemonic base=""/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_reduce_max_epu64 -->
<intrinsic tech="AVX-512" sequence="true" rettype="unsigned __int64" name="_mm512_reduce_max_epu64">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="a" type="__m512i"/>
	<description>Reduce the packed unsigned 64-bit integers in "a" by maximum. Returns the maximum of all elements in "a".</description>
	<description code="true">
max[63:0] := 0
FOR j := 0 to 7
	i := j*64
	max[63:0] := MAXIMUM(max[63:0], a[i+63:i])
ENDFOR
RETURN max[63:0]
	</description>
	<mnemonic base=""/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_reduce_max_pd -->
<intrinsic tech="AVX-512" sequence="true" rettype="double" name="_mm512_reduce_max_pd">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="a" type="__m512d"/>
	<description>Reduce the packed double-precision (64-bit) floating-point elements in "a" by maximum. Returns the maximum of all elements in "a".</description>
	<description code="true">
max[63:0] := MIN_DOUBLE
FOR j := 0 to 7
	i := j*64
	max[63:0] := MAXIMUM(max[63:0], a[i+63:i])
ENDFOR
RETURN max[63:0]
	</description>
	<mnemonic base=""/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_reduce_max_ps -->
<intrinsic tech="AVX-512" sequence="true" rettype="float" name="_mm512_reduce_max_ps">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="a" type="__m512"/>
	<description>Reduce the packed single-precision (32-bit) floating-point elements in "a" by maximum. Returns the maximum of all elements in "a".</description>
	<description code="true">
max[31:0] := MIN_FLOAT
FOR j := 0 to 15
	i := j*32
	max[31:0] := MAXIMUM(max[31:0], a[i+31:i])
ENDFOR
RETURN max[31:0]
	</description>
	<mnemonic base=""/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_reduce_min_epi32 -->
<intrinsic tech="AVX-512" sequence="true" rettype="int" name="_mm512_reduce_min_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="a" type="__m512i"/>
	<description>Reduce the packed 32-bit integers in "a" by minimum. Returns the minimum of all elements in "a".</description>
	<description code="true">
min[31:0] := MAX_INT
FOR j := 0 to 15
	i := j*32
	min[31:0] := MINIMUM(min[31:0], a[i+31:i])
ENDFOR
RETURN min[31:0]
	</description>
	<mnemonic base=""/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_reduce_min_epi64 -->
<intrinsic tech="AVX-512" sequence="true" rettype="__int64" name="_mm512_reduce_min_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="a" type="__m512i"/>
	<description>Reduce the packed 64-bit integers in "a" by minimum. Returns the minimum of all elements in "a".</description>
	<description code="true">
min[63:0] := MAX_INT
FOR j := 0 to 7
	i := j*64
	min[63:0] := MINIMUM(min[63:0], a[i+63:i])
ENDFOR
RETURN min[63:0]
	</description>
	<mnemonic base=""/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_reduce_min_epu32 -->
<intrinsic tech="AVX-512" sequence="true" rettype="unsigned int" name="_mm512_reduce_min_epu32">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="a" type="__m512i"/>
	<description>Reduce the packed unsigned 32-bit integers in "a" by minimum. Returns the minimum of all elements in "a".</description>
	<description code="true">
min[31:0] := MAX_UINT
FOR j := 0 to 15
	i := j*32
	min[31:0] := MINIMUM(min[31:0], a[i+31:i])
ENDFOR
RETURN min[31:0]
	</description>
	<mnemonic base=""/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_reduce_min_epu64 -->
<intrinsic tech="AVX-512" sequence="true" rettype="unsigned __int64" name="_mm512_reduce_min_epu64">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="a" type="__m512i"/>
	<description>Reduce the packed unsigned 64-bit integers in "a" by minimum. Returns the minimum of all elements in "a".</description>
	<description code="true">
min[63:0] := MAX_UINT
FOR j := 0 to 7
	i := j*64
	min[63:0] := MINIMUM(min[63:0], a[i+63:i])
ENDFOR
RETURN min[63:0]
	</description>
	<mnemonic base=""/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_reduce_min_pd -->
<intrinsic tech="AVX-512" sequence="true" rettype="double" name="_mm512_reduce_min_pd">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="a" type="__m512d"/>
	<description>Reduce the packed double-precision (64-bit) floating-point elements in "a" by minimum. Returns the minimum of all elements in "a".</description>
	<description code="true">
min[63:0] := MAX_DOUBLE
FOR j := 0 to 7
	i := j*64
	min[63:0] := MINIMUM(min[63:0], a[i+63:i])
ENDFOR
RETURN min[63:0]
	</description>
	<mnemonic base=""/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_reduce_min_ps -->
<intrinsic tech="AVX-512" sequence="true" rettype="float" name="_mm512_reduce_min_ps">
	<CPUID>AVX-512</CPUID>
	<category>Special Math Functions</category>
	<parameter varname="a" type="__m512"/>
	<description>Reduce the packed single-precision (32-bit) floating-point elements in "a" by minimum. Returns the minimum of all elements in "a".</description>
	<description code="true">
min[31:0] := MAX_INT
FOR j := 0 to 15
	i := j*32
	min[31:0] := MINIMUM(min[31:0], a[i+31:i])
ENDFOR
RETURN min[31:0]
	</description>
	<mnemonic base=""/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_reduce_mul_epi32 -->
<intrinsic tech="AVX-512" sequence="true" rettype="int" name="_mm512_reduce_mul_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512i"/>
	<description>Reduce the packed 32-bit integers in "a" by multiplication. Returns the product of all elements in "a".</description>
	<description code="true">
prod[31:0] := 1
FOR j := 0 to 15
	i := j*32
	prod[31:0] := prod[31:0] * a[i+31:i]
ENDFOR
RETURN prod[31:0]
	</description>
	<mnemonic base=""/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_reduce_mul_epi64 -->
<intrinsic tech="AVX-512" sequence="true" rettype="__int64" name="_mm512_reduce_mul_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512i"/>
	<description>Reduce the packed 64-bit integers in "a" by multiplication. Returns the product of all elements in "a".</description>
	<description code="true">
prod[63:0] := 1
FOR j := 0 to 7
	i := j*64
	prod[63:0] := prod[63:0] * a[i+63:i]
ENDFOR
RETURN prod[63:0]
	</description>
	<mnemonic base=""/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_reduce_mul_pd -->
<intrinsic tech="AVX-512" sequence="true" rettype="double" name="_mm512_reduce_mul_pd">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512d"/>
	<description>Reduce the packed double-precision (64-bit) floating-point elements in "a" by multiplication. Returns the product of all elements in "a".</description>
	<description code="true">
prod[63:0] := 1
FOR j := 0 to 7
	i := j*64
	prod[63:0] := prod[63:0] * a[i+63:i]
ENDFOR
RETURN prod[63:0]
	</description>
	<mnemonic base=""/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_reduce_mul_ps -->
<intrinsic tech="AVX-512" sequence="true" rettype="float" name="_mm512_reduce_mul_ps">
	<CPUID>AVX-512</CPUID>
	<category>Arithmetic</category>
	<parameter varname="a" type="__m512"/>
	<description>Reduce the packed single-precision (32-bit) floating-point elements in "a" by multiplication. Returns the product of all elements in "a".</description>
	<description code="true">
prod[31:0] := 1
FOR j := 0 to 15
	i := j*32
	prod[31:0] := prod[31:0] * a[i+31:i]
ENDFOR
RETURN prod[31:0]
	</description>
	<mnemonic base=""/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_reduce_or_epi32 -->
<intrinsic tech="AVX-512" sequence="true" rettype="int" name="_mm512_reduce_or_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Logical</category>
	<parameter varname="a" type="__m512i"/>
	<description>Reduce the packed 32-bit integers in "a" by bitwise OR. Returns the bitwise OR of all elements in "a".</description>
	<description code="true">
reduced[31:0] := 0
FOR j := 0 to 15
	i := j*32
	reduced[31:0] := reduced[31:0] OR a[i+31:i]
ENDFOR
RETURN reduced[31:0]
	</description>
	<mnemonic base=""/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_reduce_or_epi64 -->
<intrinsic tech="AVX-512" sequence="true" rettype="__int64" name="_mm512_reduce_or_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Logical</category>
	<parameter varname="a" type="__m512i"/>
	<description>Reduce the packed 64-bit integers in "a" by bitwise OR. Returns the bitwise OR of all elements in "a".</description>
	<description code="true">
reduced[63:0] := 0
FOR j := 0 to 7
	i := j*64
	reduced[63:0] := reduced[63:0] OR a[i+63:i]
ENDFOR
RETURN reduced[63:0]
	</description>
	<mnemonic base=""/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_set1_pd -->
<intrinsic tech="AVX-512" sequence="true" rettype="__m512d" name="_mm512_set1_pd">
	<CPUID>AVX-512</CPUID>
	<category>Set</category>
	<parameter varname="a" type="double"/>
	<description>Broadcast double-precision (64-bit) floating-point value "a" to all elements of "dst".</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := a[63:0]
ENDFOR
dst[MAX:512] := 0
	</description>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_set1_ps -->
<intrinsic tech="AVX-512" sequence="true" rettype="__m512" name="_mm512_set1_ps">
	<CPUID>AVX-512</CPUID>
	<category>Set</category>
	<parameter varname="a" type="float"/>
	<description>Broadcast single-precision (32-bit) floating-point value "a" to all elements of "dst".</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := a[31:0]
ENDFOR
dst[MAX:512] := 0
	</description>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_set4_epi32 -->
<intrinsic tech="AVX-512" sequence="true" rettype="__m512i" name="_mm512_set4_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Set</category>
	<parameter varname="d" type="int"/>
	<parameter varname="c" type="int"/>
	<parameter varname="b" type="int"/>
	<parameter varname="a" type="int"/>
	<description>Set packed 32-bit integers in "dst" with the repeated 4 element sequence.</description>
	<description code="true">
dst[31:0] := d
dst[63:32] := c
dst[95:64] := b
dst[127:96] := a
dst[159:128] := d
dst[191:160] := c
dst[223:192] := b
dst[255:224] := a
dst[287:256] := d
dst[319:288] := c
dst[351:320] := b
dst[383:352] := a
dst[415:384] := d
dst[447:416] := c
dst[479:448] := b
dst[511:480] := a
dst[MAX:512] := 0
	</description>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_set4_epi64 -->
<intrinsic tech="AVX-512" sequence="true" rettype="__m512i" name="_mm512_set4_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Set</category>
	<parameter varname="d" type="__int64"/>
	<parameter varname="c" type="__int64"/>
	<parameter varname="b" type="__int64"/>
	<parameter varname="a" type="__int64"/>
	<description>Set packed 64-bit integers in "dst" with the repeated 4 element sequence.</description>
	<description code="true">
dst[63:0] := d
dst[127:64] := c
dst[191:128] := b
dst[255:192] := a
dst[319:256] := d
dst[383:320] := c
dst[447:384] := b
dst[511:448] := a
dst[MAX:512] := 0
	</description>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_set4_pd -->
<intrinsic tech="AVX-512" sequence="true" rettype="__m512d" name="_mm512_set4_pd">
	<CPUID>AVX-512</CPUID>
	<category>Set</category>
	<parameter varname="d" type="double"/>
	<parameter varname="c" type="double"/>
	<parameter varname="b" type="double"/>
	<parameter varname="a" type="double"/>
	<description>Set packed double-precision (64-bit) floating-point elements in "dst" with the repeated 4 element sequence.</description>
	<description code="true">
dst[63:0] := d
dst[127:64] := c
dst[191:128] := b
dst[255:192] := a
dst[319:256] := d
dst[383:320] := c
dst[447:384] := b
dst[511:448] := a
dst[MAX:512] := 0
	</description>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_set4_ps -->
<intrinsic tech="AVX-512" sequence="true" rettype="__m512" name="_mm512_set4_ps">
	<CPUID>AVX-512</CPUID>
	<category>Set</category>
	<parameter varname="d" type="float"/>
	<parameter varname="c" type="float"/>
	<parameter varname="b" type="float"/>
	<parameter varname="a" type="float"/>
	<description>Set packed single-precision (32-bit) floating-point elements in "dst" with the repeated 4 element sequence.</description>
	<description code="true">
dst[31:0] := d
dst[63:32] := c
dst[95:64] := b
dst[127:96] := a
dst[159:128] := d
dst[191:160] := c
dst[223:192] := b
dst[255:224] := a
dst[287:256] := d
dst[319:288] := c
dst[351:320] := b
dst[383:352] := a
dst[415:384] := d
dst[447:416] := c
dst[479:448] := b
dst[511:480] := a
dst[MAX:512] := 0
	</description>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_set_epi32 -->
<intrinsic tech="AVX-512" sequence="true" rettype="__m512i" name="_mm512_set_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Set</category>
	<parameter varname="e15" type="int"/>
	<parameter varname="e14" type="int"/>
	<parameter varname="e13" type="int"/>
	<parameter varname="e12" type="int"/>
	<parameter varname="e11" type="int"/>
	<parameter varname="e10" type="int"/>
	<parameter varname="e9" type="int"/>
	<parameter varname="e8" type="int"/>
	<parameter varname="e7" type="int"/>
	<parameter varname="e6" type="int"/>
	<parameter varname="e5" type="int"/>
	<parameter varname="e4" type="int"/>
	<parameter varname="e3" type="int"/>
	<parameter varname="e2" type="int"/>
	<parameter varname="e1" type="int"/>
	<parameter varname="e0" type="int"/>
	<description>Set packed 32-bit integers in "dst" with the supplied values.</description>
	<description code="true">
dst[31:0] := e0
dst[63:32] := e1
dst[95:64] := e2
dst[127:96] := e3
dst[159:128] := e4
dst[191:160] := e5
dst[223:192] := e6
dst[255:224] := e7
dst[287:256] := e8
dst[319:288] := e9
dst[351:320] := e10
dst[383:352] := e11
dst[415:384] := e12
dst[447:416] := e13
dst[479:448] := e14
dst[511:480] := e15
dst[MAX:512] := 0
	</description>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_set_epi64 -->
<intrinsic tech="AVX-512" sequence="true" rettype="__m512i" name="_mm512_set_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Set</category>
	<parameter varname="e7" type="__int64"/>
	<parameter varname="e6" type="__int64"/>
	<parameter varname="e5" type="__int64"/>
	<parameter varname="e4" type="__int64"/>
	<parameter varname="e3" type="__int64"/>
	<parameter varname="e2" type="__int64"/>
	<parameter varname="e1" type="__int64"/>
	<parameter varname="e0" type="__int64"/>
	<description>Set packed 64-bit integers in "dst" with the supplied values.</description>
	<description code="true">
dst[63:0] := e0
dst[127:64] := e1
dst[191:128] := e2
dst[255:192] := e3
dst[319:256] := e4
dst[383:320] := e5
dst[447:384] := e6
dst[511:448] := e7
dst[MAX:512] := 0
	</description>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_set_pd -->
<intrinsic tech="AVX-512" sequence="true" rettype="__m512d" name="_mm512_set_pd">
	<CPUID>AVX-512</CPUID>
	<category>Set</category>
	<parameter varname="e7" type="double"/>
	<parameter varname="e6" type="double"/>
	<parameter varname="e5" type="double"/>
	<parameter varname="e4" type="double"/>
	<parameter varname="e3" type="double"/>
	<parameter varname="e2" type="double"/>
	<parameter varname="e1" type="double"/>
	<parameter varname="e0" type="double"/>
	<description>Set packed double-precision (64-bit) floating-point elements in "dst" with the supplied values.</description>
	<description code="true">
dst[63:0] := e0
dst[127:64] := e1
dst[191:128] := e2
dst[255:192] := e3
dst[319:256] := e4
dst[383:320] := e5
dst[447:384] := e6
dst[511:448] := e7
dst[MAX:512] := 0
	</description>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_set_ps -->
<intrinsic tech="AVX-512" sequence="true" rettype="__m512" name="_mm512_set_ps">
	<CPUID>AVX-512</CPUID>
	<category>Set</category>
	<parameter varname="e15" type="float"/>
	<parameter varname="e14" type="float"/>
	<parameter varname="e13" type="float"/>
	<parameter varname="e12" type="float"/>
	<parameter varname="e11" type="float"/>
	<parameter varname="e10" type="float"/>
	<parameter varname="e9" type="float"/>
	<parameter varname="e8" type="float"/>
	<parameter varname="e7" type="float"/>
	<parameter varname="e6" type="float"/>
	<parameter varname="e5" type="float"/>
	<parameter varname="e4" type="float"/>
	<parameter varname="e3" type="float"/>
	<parameter varname="e2" type="float"/>
	<parameter varname="e1" type="float"/>
	<parameter varname="e0" type="float"/>
	<description>Set packed single-precision (32-bit) floating-point elements in "dst" with the supplied values.</description>
	<description code="true">
dst[31:0] := e0
dst[63:32] := e1
dst[95:64] := e2
dst[127:96] := e3
dst[159:128] := e4
dst[191:160] := e5
dst[223:192] := e6
dst[255:224] := e7
dst[287:256] := e8
dst[319:288] := e9
dst[351:320] := e10
dst[383:352] := e11
dst[415:384] := e12
dst[447:416] := e13
dst[479:448] := e14
dst[511:480] := e15
dst[MAX:512] := 0
	</description>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_setr4_epi32 -->
<intrinsic tech="AVX-512" sequence="true" rettype="__m512i" name="_mm512_setr4_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Set</category>
	<parameter varname="d" type="int"/>
	<parameter varname="c" type="int"/>
	<parameter varname="b" type="int"/>
	<parameter varname="a" type="int"/>
	<description>Set packed 32-bit integers in "dst" with the repeated 4 element sequence in reverse order.</description>
	<description code="true">
dst[31:0] := a
dst[63:32] := b
dst[95:64] := c
dst[127:96] := d
dst[159:128] := a
dst[191:160] := b
dst[223:192] := c
dst[255:224] := d
dst[287:256] := a
dst[319:288] := b
dst[351:320] := c
dst[383:352] := d
dst[415:384] := a
dst[447:416] := b
dst[479:448] := c
dst[511:480] := d
dst[MAX:512] := 0
	</description>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_setr4_epi64 -->
<intrinsic tech="AVX-512" sequence="true" rettype="__m512i" name="_mm512_setr4_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Set</category>
	<parameter varname="d" type="__int64"/>
	<parameter varname="c" type="__int64"/>
	<parameter varname="b" type="__int64"/>
	<parameter varname="a" type="__int64"/>
	<description>Set packed 64-bit integers in "dst" with the repeated 4 element sequence in reverse order.</description>
	<description code="true">
dst[63:0] := a
dst[127:64] := b
dst[191:128] := c
dst[255:192] := d
dst[319:256] := a
dst[383:320] := b
dst[447:384] := c
dst[511:448] := d
dst[MAX:512] := 0
	</description>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_setr4_pd -->
<intrinsic tech="AVX-512" sequence="true" rettype="__m512d" name="_mm512_setr4_pd">
	<CPUID>AVX-512</CPUID>
	<category>Set</category>
	<parameter varname="d" type="double"/>
	<parameter varname="c" type="double"/>
	<parameter varname="b" type="double"/>
	<parameter varname="a" type="double"/>
	<description>Set packed double-precision (64-bit) floating-point elements in "dst" with the repeated 4 element sequence in reverse order.</description>
	<description code="true">
dst[63:0] := a
dst[127:64] := b
dst[191:128] := c
dst[255:192] := d
dst[319:256] := a
dst[383:320] := b
dst[447:384] := c
dst[511:448] := d
dst[MAX:512] := 0
	</description>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_setr4_ps -->
<intrinsic tech="AVX-512" sequence="true" rettype="__m512" name="_mm512_setr4_ps">
	<CPUID>AVX-512</CPUID>
	<category>Set</category>
	<parameter varname="d" type="float"/>
	<parameter varname="c" type="float"/>
	<parameter varname="b" type="float"/>
	<parameter varname="a" type="float"/>
	<description>Set packed single-precision (32-bit) floating-point elements in "dst" with the repeated 4 element sequence in reverse order.</description>
	<description code="true">
dst[31:0] := a
dst[63:32] := b
dst[95:64] := c
dst[127:96] := d
dst[159:128] := a
dst[191:160] := b
dst[223:192] := c
dst[255:224] := d
dst[287:256] := a
dst[319:288] := b
dst[351:320] := c
dst[383:352] := d
dst[415:384] := a
dst[447:416] := b
dst[479:448] := c
dst[511:480] := d
dst[MAX:512] := 0
	</description>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_setr_epi32 -->
<intrinsic tech="AVX-512" sequence="true" rettype="__m512i" name="_mm512_setr_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Set</category>
	<parameter varname="e15" type="int"/>
	<parameter varname="e14" type="int"/>
	<parameter varname="e13" type="int"/>
	<parameter varname="e12" type="int"/>
	<parameter varname="e11" type="int"/>
	<parameter varname="e10" type="int"/>
	<parameter varname="e9" type="int"/>
	<parameter varname="e8" type="int"/>
	<parameter varname="e7" type="int"/>
	<parameter varname="e6" type="int"/>
	<parameter varname="e5" type="int"/>
	<parameter varname="e4" type="int"/>
	<parameter varname="e3" type="int"/>
	<parameter varname="e2" type="int"/>
	<parameter varname="e1" type="int"/>
	<parameter varname="e0" type="int"/>
	<description>Set packed 32-bit integers in "dst" with the supplied values in reverse order.</description>
	<description code="true">
dst[31:0] := e15
dst[63:32] := e14
dst[95:64] := e13
dst[127:96] := e12
dst[159:128] := e11
dst[191:160] := e10
dst[223:192] := e9
dst[255:224] := e8
dst[287:256] := e7
dst[319:288] := e6
dst[351:320] := e5
dst[383:352] := e4
dst[415:384] := e3
dst[447:416] := e2
dst[479:448] := e1
dst[511:480] := e0
dst[MAX:512] := 0
	</description>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_setr_epi64 -->
<intrinsic tech="AVX-512" sequence="true" rettype="__m512i" name="_mm512_setr_epi64">
	<CPUID>AVX-512</CPUID>
	<category>Set</category>
	<parameter varname="e7" type="__int64"/>
	<parameter varname="e6" type="__int64"/>
	<parameter varname="e5" type="__int64"/>
	<parameter varname="e4" type="__int64"/>
	<parameter varname="e3" type="__int64"/>
	<parameter varname="e2" type="__int64"/>
	<parameter varname="e1" type="__int64"/>
	<parameter varname="e0" type="__int64"/>
	<description>Set packed 64-bit integers in "dst" with the supplied values in reverse order.</description>
	<description code="true">
dst[63:0] := e7
dst[127:64] := e6
dst[191:128] := e5
dst[255:192] := e4
dst[319:256] := e3
dst[383:320] := e2
dst[447:384] := e1
dst[511:448] := e0
dst[MAX:512] := 0
	</description>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_setr_pd -->
<intrinsic tech="AVX-512" sequence="true" rettype="__m512d" name="_mm512_setr_pd">
	<CPUID>AVX-512</CPUID>
	<category>Set</category>
	<parameter varname="e7" type="double"/>
	<parameter varname="e6" type="double"/>
	<parameter varname="e5" type="double"/>
	<parameter varname="e4" type="double"/>
	<parameter varname="e3" type="double"/>
	<parameter varname="e2" type="double"/>
	<parameter varname="e1" type="double"/>
	<parameter varname="e0" type="double"/>
	<description>Set packed double-precision (64-bit) floating-point elements in "dst" with the supplied values in reverse order.</description>
	<description code="true">
dst[63:0] := e7
dst[127:64] := e6
dst[191:128] := e5
dst[255:192] := e4
dst[319:256] := e3
dst[383:320] := e2
dst[447:384] := e1
dst[511:448] := e0
dst[MAX:512] := 0
	</description>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_setr_ps -->
<intrinsic tech="AVX-512" sequence="true" rettype="__m512" name="_mm512_setr_ps">
	<CPUID>AVX-512</CPUID>
	<category>Set</category>
	<parameter varname="e15" type="float"/>
	<parameter varname="e14" type="float"/>
	<parameter varname="e13" type="float"/>
	<parameter varname="e12" type="float"/>
	<parameter varname="e11" type="float"/>
	<parameter varname="e10" type="float"/>
	<parameter varname="e9" type="float"/>
	<parameter varname="e8" type="float"/>
	<parameter varname="e7" type="float"/>
	<parameter varname="e6" type="float"/>
	<parameter varname="e5" type="float"/>
	<parameter varname="e4" type="float"/>
	<parameter varname="e3" type="float"/>
	<parameter varname="e2" type="float"/>
	<parameter varname="e1" type="float"/>
	<parameter varname="e0" type="float"/>
	<description>Set packed single-precision (32-bit) floating-point elements in "dst" with the supplied values in reverse order.</description>
	<description code="true">
dst[31:0] := e15
dst[63:32] := e14
dst[95:64] := e13
dst[127:96] := e12
dst[159:128] := e11
dst[191:160] := e10
dst[223:192] := e9
dst[255:224] := e8
dst[287:256] := e7
dst[319:288] := e6
dst[351:320] := e5
dst[383:352] := e4
dst[415:384] := e3
dst[447:416] := e2
dst[479:448] := e1
dst[511:480] := e0
dst[MAX:512] := 0
	</description>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_setzero / vxorps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_setzero">
	<CPUID>AVX-512</CPUID>
	<category>Set</category>
	<parameter varname="" type="void"/>
	<description>Return vector of type __m512 with all elements set to zero.</description>
	<description code="true">
dst[MAX:0] := 0
	</description>
	<mnemonic base="vxorps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_setzero_epi32 / vpxor -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_setzero_epi32">
	<CPUID>AVX-512</CPUID>
	<category>Set</category>
	<description>Return vector of type __m512i with all elements set to zero.</description>
	<description code="true">
dst[MAX:0] := 0
	</description>
	<mnemonic base="vpxor"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_setzero_pd / vxorpd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_setzero_pd">
	<CPUID>AVX-512</CPUID>
	<category>Set</category>
	<description>Return vector of type __m512d with all elements set to zero.</description>
	<description code="true">
dst[MAX:0] := 0
	</description>
	<mnemonic base="vxorpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_setzero_ps / vxorps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_setzero_ps">
	<CPUID>AVX-512</CPUID>
	<category>Set</category>
	<description>Return vector of type __m512 with all elements set to zero.</description>
	<description code="true">
dst[MAX:0] := 0
	</description>
	<mnemonic base="vxorps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_setzero_si512 / vpxor -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_setzero_si512">
	<CPUID>AVX-512</CPUID>
	<category>Set</category>
	<description>Return vector of type __m512i with all elements set to zero.</description>
	<description code="true">
dst[MAX:0] := 0
	</description>
	<mnemonic base="vpxor"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_undefined -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_undefined">
	<CPUID>AVX-512</CPUID>
	<category>General Support</category>
	<parameter varname="" type="void"/>
	<description>Return vector of type __m512 with undefined elements.</description>
	<mnemonic base="-"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_undefined_epi32 -->
<intrinsic tech="AVX-512" rettype="__m512i" name="_mm512_undefined_epi32">
	<CPUID>AVX-512</CPUID>
	<category>General Support</category>
	<description>Return vector of type __m512i with undefined elements.</description>
	<mnemonic base="-"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_undefined_pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_undefined_pd">
	<CPUID>AVX-512</CPUID>
	<category>General Support</category>
	<description>Return vector of type __m512d with undefined elements.</description>
	<mnemonic base="-"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_undefined_ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_undefined_ps">
	<CPUID>AVX-512</CPUID>
	<category>General Support</category>
	<description>Return vector of type __m512 with undefined elements.</description>
	<mnemonic base="-"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_prefetch_i64gather_ps / vgatherpf0qps|vgatherpf1qps -->
<intrinsic tech="AVX-512" rettype="void" name="_mm512_prefetch_i64gather_ps">
	<CPUID>AVX-512.PFI</CPUID>
	<category>Load</category>
	<parameter varname="vindex" type="__m512i"/>
	<parameter varname="base_addr" type="void const*"/>
	<parameter varname="scale" type="int"/>
	<parameter varname="hint" type="int"/>
	<description>Prefetch single-precision (32-bit) floating-point elements from memory using 64-bit indices. 32-bit elements are loaded from addresses starting at "base_addr" and offset by each 64-bit element in "vindex" (each index is scaled by the factor in "scale"). Gathered elements are merged in cache. "scale" should be 1, 2, 4 or 8. "hint" should be 0 or 1 and indicates which cache level to read values into.</description>
	<description code="true">
FOR j:= 0 to 7
	i := j*64;
	Prefetch([base_addr + SignExtend(vindex[i+63:i]) * scale], hint, RFO=0);
ENDFOR;
	</description>
	<mnemonic base="vgatherpf0qps"/>
	<mnemonic base="vgatherpf1qps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_prefetch_i64gather_ps / vgatherpf0qps|vgatherpf1qps -->
<intrinsic tech="AVX-512" rettype="void" name="_mm512_mask_prefetch_i64gather_ps">
	<CPUID>AVX-512.PFI</CPUID>
	<category>Load</category>
	<parameter varname="vindex" type="__m512i"/>
	<parameter varname="mask" type="__mmask8"/>
	<parameter varname="base_addr" type="void const*"/>
	<parameter varname="scale" type="int"/>
	<parameter varname="hint" type="int"/>
	<description>Prefetch single-precision (32-bit) floating-point elements from memory using 64-bit indices. 32-bit elements are loaded from addresses starting at "base_addr" and offset by each 64-bit element in "vindex" (each index is scaled by the factor in "scale"). Gathered elements are merged in cache using writemask "k" (elements are only brought into cache when their corresponding mask bit is set). "scale" should be 1, 2, 4 or 8. "hint" should be 0 or 1 and indicates which cache level to read values into.</description>
	<description code="true">
FOR j:= 0 to 7
	i := j*64;
	IF mask[j] THEN
		Prefetch([base_addr + SignExtend(vindex[i+63:i]) * scale], hint, RFO=0);
	FI
ENDFOR;
	</description>
	<mnemonic base="vgatherpf0qps"/>
	<mnemonic base="vgatherpf1qps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_prefetch_i64scatter_ps / vscatterpf0qps|vscatterpf1qps -->
<intrinsic tech="AVX-512" rettype="void" name="_mm512_prefetch_i64scatter_ps">
	<CPUID>AVX-512.PFI</CPUID>
	<category>Store</category>
	<parameter varname="base_addr" type="void*"/>
	<parameter varname="vindex" type="__m512i"/>
	<parameter varname="scale" type="int"/>
	<parameter varname="hint" type="int"/>
	<description>Prefetch single-precision (32-bit) floating-point elements with intent to write into memory using 64-bit indices. Elements are prefetched into cache level "hint", where "hint" is 0 or 1. 32-bit elements are stored at addresses starting at "base_addr" and offset by each 64-bit element in "vindex" (each index is scaled by the factor in "scale"). "scale" should be 1, 2, 4 or 8.</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64;
	Prefetch([base_addr + SignExtend(vindex[i+63:i]) * scale], Level=hint, RFO=1);
ENDFOR;
	</description>
	<mnemonic base="vscatterpf0qps"/>
	<mnemonic base="vscatterpf1qps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_prefetch_i64scatter_ps / vscatterpf0qps|vscatterpf1qps -->
<intrinsic tech="AVX-512" rettype="void" name="_mm512_mask_prefetch_i64scatter_ps">
	<CPUID>AVX-512.PFI</CPUID>
	<category>Store</category>
	<parameter varname="base_addr" type="void*"/>
	<parameter varname="mask" type="__mmask8"/>
	<parameter varname="vindex" type="__m512i"/>
	<parameter varname="scale" type="int"/>
	<parameter varname="hint" type="int"/>
	<description>Prefetch single-precision (32-bit) floating-point elements with intent to write into memory using 64-bit indices. Elements are prefetched into cache level "hint", where "hint" is 0 or 1. 32-bit elements are stored at addresses starting at "base_addr" and offset by each 64-bit element in "vindex" (each index is scaled by the factor in "scale") subject to mask "k" (elements are not brought into cache when the corresponding mask bit is not set). "scale" should be 1, 2, 4 or 8.</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64;
	IF mask[j] THEN
		Prefetch([base_addr + SignExtend(vindex[i+63:i]) * scale], Level=hint, RFO=1);
	FI
ENDFOR;
	</description>
	<mnemonic base="vscatterpf0qps"/>
	<mnemonic base="vscatterpf1qps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_prefetch_i32gather_pd / vgatherpf0dpd|vgatherpf1dpd -->
<intrinsic tech="AVX-512" rettype="void" name="_mm512_prefetch_i32gather_pd">
	<CPUID>AVX-512.PFI</CPUID>
	<category>Load</category>
	<parameter varname="vindex" type="__m256i"/>
	<parameter varname="base_addr" type="void const*"/>
	<parameter varname="scale" type="int"/>
	<parameter varname="hint" type="int"/>
	<description>Prefetch double-precision (64-bit) floating-point elements from memory using 32-bit indices. 64-bit elements are loaded from addresses starting at "base_addr" and offset by each 32-bit element in "vindex" (each index is scaled by the factor in "scale"). Gathered elements are merged in cache. "scale" should be 1, 2, 4 or 8. "hint" should be 0 or 1 and indicates which cache level to bring values into.</description>
	<description code="true">
FOR j := 0 to 7
	i := j*32;
	Prefetch([base_addr + SignExtend(vindex[i*31:i]) * scale], hint, RFO=0);
ENDFOR;
	</description>
	<mnemonic base="vgatherpf0dpd"/>
	<mnemonic base="vgatherpf1dpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_prefetch_i32gather_pd / vgatherpf0dpd|vgatherpf1dpd -->
<intrinsic tech="AVX-512" rettype="void" name="_mm512_mask_prefetch_i32gather_pd">
	<CPUID>AVX-512.PFI</CPUID>
	<category>Load</category>
	<parameter varname="vindex" type="__m256i"/>
	<parameter varname="mask" type="__mmask8"/>
	<parameter varname="base_addr" type="void const*"/>
	<parameter varname="scale" type="int"/>
	<parameter varname="hint" type="int"/>
	<description>Prefetch double-precision (64-bit) floating-point elements from memory using 32-bit indices. 64-bit elements are loaded from addresses starting at "base_addr" and offset by each 32-bit element in "vindex" (each index is scaled by the factor in "scale"). Gathered elements are merged in cache using writemask "k" (elements are brought into cache only when their corresponding mask bits are set). "scale" should be 1, 2, 4 or 8. "hint" should be 0 or 1 and indicates which cache level to bring values into.</description>
	<description code="true">
FOR j := 0 to 7
	i := j*32;
	IF mask[j] THEN
		Prefetch([base_addr + SignExtend(vindex[i*31:i]) * scale], hint, RFO=0);
	FI
ENDFOR;
	</description>
	<mnemonic base="vgatherpf0dpd"/>
	<mnemonic base="vgatherpf1dpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_prefetch_i32scatter_pd / vscatterpf0dpd|vscatterpf1dpd -->
<intrinsic tech="AVX-512" rettype="void" name="_mm512_prefetch_i32scatter_pd">
	<CPUID>AVX-512.PFI</CPUID>
	<category>Store</category>
	<parameter varname="base_addr" type="void*"/>
	<parameter varname="vindex" type="__m256i"/>
	<parameter varname="scale" type="int"/>
	<parameter varname="hint" type="int"/>
	<description>Prefetch double-precision (64-bit) floating-point elements with intent to write using 32-bit indices. Elements are prefetched into cache level "hint", where "hint" is 0 or 1. 64-bit elements are brought into cache from addresses starting at "base_addr" and offset by each 32-bit element in "vindex" (each index is scaled by the factor in "scale"). "scale" should be 1, 2, 4 or 8.</description>
	<description code="true">
FOR j := 0 TO 7
	i := j*32;
	Prefetch(base_addr + SignExtend(vindex[i+31:i]) * scale], Level=hint, RFO=1);
ENDFOR;
	</description>
	<mnemonic base="vscatterpf0dpd"/>
	<mnemonic base="vscatterpf1dpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_prefetch_i32scatter_pd / vscatterpf0dpd|vscatterpf1dpd -->
<intrinsic tech="AVX-512" rettype="void" name="_mm512_mask_prefetch_i32scatter_pd">
	<CPUID>AVX-512.PFI</CPUID>
	<category>Store</category>
	<parameter varname="base_addr" type="void*"/>
	<parameter varname="mask" type="__mmask8"/>
	<parameter varname="vinde" type="__m256i"/>
	<parameter varname="scale" type="int"/>
	<parameter varname="hint" type="int"/>
	<description>Prefetch double-precision (64-bit) floating-point elements with intent to write using 32-bit indices. Elements are prefetched into cache level "hint", where "hint" is 0 or 1. 64-bit elements are brought into cache from addresses starting at "base_addr" and offset by each 32-bit element in "vindex" (each index is scaled by the factor in "scale") subject to mask "k" (elements are not brought into cache when the corresponding mask bit is not set). "scale" should be 1, 2, 4 or 8.</description>
	<description code="true">
FOR j := 0 TO 7
	i := j*32;
	IF mask[j] THEN
		Prefetch(base_addr + SignExtend(vindex[i+31:i]) * scale], Level=hint, RFO=1);
	FI
ENDFOR;
	</description>
	<mnemonic base="vscatterpf0dpd"/>
	<mnemonic base="vscatterpf1dpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_prefetch_i64gather_pd / vgatherpf0qpd|vgatherpf1qpd -->
<intrinsic tech="AVX-512" rettype="void" name="_mm512_prefetch_i64gather_pd">
	<CPUID>AVX-512.PFI</CPUID>
	<category>Load</category>
	<parameter varname="vindex" type="__m512i"/>
	<parameter varname="base_addr" type="void const*"/>
	<parameter varname="scale" type="int"/>
	<parameter varname="hint" type="int"/>
	<description>Prefetch double-precision (64-bit) floating-point elements from memory into cache level specified by "hint" using 64-bit indices. 64-bit elements are loaded from addresses starting at "base_addr" and offset by each 64-bit element in "vindex" (each index is scaled by the factor in "scale"). "scale" should be 1, 2, 4 or 8. "hint" should be 0 or 1.</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64;
	Prefetch([base_addr + SignExtend(vindex[i*63:i] * scale]), Level=hint, RFO=0);
ENDFOR;
	</description>
	<mnemonic base="vgatherpf0qpd"/>
	<mnemonic base="vgatherpf1qpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_prefetch_i64gather_pd / vgatherpf0qpd|vgatherpf1qpd -->
<intrinsic tech="AVX-512" rettype="void" name="_mm512_mask_prefetch_i64gather_pd">
	<CPUID>AVX-512.PFI</CPUID>
	<category>Load</category>
	<parameter varname="vindex" type="__m512i"/>
	<parameter varname="mask" type="__mmask8"/>
	<parameter varname="base_addr" type="void const*"/>
	<parameter varname="scale" type="int"/>
	<parameter varname="hint" type="int"/>
	<description>Prefetch double-precision (64-bit) floating-point elements from memory into cache level specified by "hint" using 64-bit indices. 64-bit elements are loaded from addresses starting at "base_addr" and offset by each 64-bit element in "vindex" (each index is scaled by the factor in "scale"). Prefetched elements are merged in cache using writemask "k" (elements are copied from memory when the corresponding mask bit is set). "scale" should be 1, 2, 4 or 8. "hint" should be 0 or 1.</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64;
	IF mask[j] THEN
		Prefetch([base_addr + SignExtend(vindex[i*63:i] * scale]), Level=hint, RFO=0);
	FI
ENDFOR;
	</description>
	<mnemonic base="vgatherpf0qpd"/>
	<mnemonic base="vgatherpf1qpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_prefetch_i64scatter_pd / vscatterpf0qpd|vscatterpf1qpd -->
<intrinsic tech="AVX-512" rettype="void" name="_mm512_prefetch_i64scatter_pd">
	<CPUID>AVX-512.PFI</CPUID>
	<category>Store</category>
	<parameter varname="base_addr" type="void*"/>
	<parameter varname="vindex" type="__m512i"/>
	<parameter varname="scale" type="int"/>
	<parameter varname="hint" type="int"/>
	<description>Prefetch double-precision (64-bit) floating-point elements with intent to write into memory using 64-bit indices. Elements are prefetched into cache level "hint", where "hint" is 0 or 1. 64-bit elements are brought into cache from addresses starting at "base_addr" and offset by each 64-bit element in "vindex" (each index is scaled by the factor in "scale"). "scale" should be 1, 2, 4 or 8.</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64;
	Prefetch([base_addr + SignExtend(vdx[i+63:i]) * scale], Level=hint, RFO=1);
ENDFOR;
	</description>
	<mnemonic base="vscatterpf0qpd"/>
	<mnemonic base="vscatterpf1qpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_prefetch_i64scatter_pd / vscatterpf0qpd|vscatterpf1qpd -->
<intrinsic tech="AVX-512" rettype="void" name="_mm512_mask_prefetch_i64scatter_pd">
	<CPUID>AVX-512.PFI</CPUID>
	<category>Store</category>
	<parameter varname="base_addr" type="void*"/>
	<parameter varname="mask" type="__mmask8"/>
	<parameter varname="vindex" type="__m512i"/>
	<parameter varname="scale" type="int"/>
	<parameter varname="hint" type="int"/>
	<description>Prefetch double-precision (64-bit) floating-point elements with intent to write into memory using 64-bit indices. Elements are prefetched into cache level "hint", where "hint" is 0 or 1. 64-bit elements are brought into cache from addresses starting at "base_addr" and offset by each 64-bit element in "vindex" (each index is scaled by the factor in "scale") subject to mask "k" (elements are not brought into cache when the corresponding mask bit is not set). "scale" should be 1, 2, 4 or 8.</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64;
	IF mask[j] THEN
		Prefetch([base_addr + SignExtend(vdx[i+63:i]) * scale], Level=hint, RFO=1);
	FI
ENDFOR;
	</description>
	<mnemonic base="vscatterpf0qpd"/>
	<mnemonic base="vscatterpf1qpd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_exp2a23_round_ps / vexp2ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_exp2a23_round_ps">
	<CPUID>AVX-512.ERI</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="rounding" type="int"/>
	<description>Compute the approximate exponential value of 2 raised to the power of packed single-precision (32-bit) floating-point elements in "a", and store the results in "dst". The maximum relative error for this approximation is less than 2^-23. [round_note]</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32;
	dst[i+31:i] := EXP_2_23_SP(a[i+31:i]);
ENDFOR;
dst[MAX:512] := 0
	</description>
	<mnemonic base="vexp2ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_exp2a23_ps / vexp2ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_exp2a23_ps">
	<CPUID>AVX-512.ERI</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="a" type="__m512"/>
	<description>Compute the approximate exponential value of 2 raised to the power of packed single-precision (32-bit) floating-point elements in "a", and store the results in "dst". The maximum relative error for this approximation is less than 2^-23.</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32;
	dst[i+31:i] := EXP_2_23_SP(a[i+31:i]);
ENDFOR;
dst[MAX:512] := 0
	</description>
	<mnemonic base="vexp2ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_exp2a23_round_ps / vexp2ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_exp2a23_round_ps">
	<CPUID>AVX-512.ERI</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="src" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="rounding" type="int"/>
	<description>Compute the approximate exponential value of 2 raised to the power of packed single-precision (32-bit) floating-point elements in "a", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-23. [round_note]</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32;
	IF k[j] THEN
		dst[i+31:i] := EXP_2_23_SP(a[i+31:i]);
	ELSE
		dst[i*31:i] := a[i*31:i];
ENDFOR;
dst[MAX:512] := 0
	</description>
	<mnemonic base="vexp2ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_exp2a23_ps / vexp2ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_exp2a23_ps">
	<CPUID>AVX-512.ERI</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="src" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<description>Compute the approximate exponential value of 2 raised to the power of packed single-precision (32-bit) floating-point elements in "a", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-23.</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32;
	IF k[j] THEN
		dst[i+31:i] := EXP_2_23_SP(a[i+31:i]);
	ELSE
		dst[i*31:i] := a[i*31:i];
ENDFOR;
dst[MAX:512] := 0
	</description>
	<mnemonic base="vexp2ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_exp2a23_round_ps / vexp2ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_exp2a23_round_ps">
	<CPUID>AVX-512.ERI</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="rounding" type="int"/>
	<description>Compute the approximate exponential value of 2 raised to the power of packed single-precision (32-bit) floating-point elements in "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-23. [round_note]</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32;
	IF k[j] THEN
		dst[i+31:i] := EXP_2_23_SP(a[i+31:i]);
	ELSE
		dst[i*31:i] := 0;
ENDFOR;
dst[MAX:512] := 0
	</description>
	<mnemonic base="vexp2ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_exp2a23_ps / vexp2ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_exp2a23_ps">
	<CPUID>AVX-512.ERI</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<description>Compute the approximate exponential value of 2 raised to the power of packed single-precision (32-bit) floating-point elements in "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-23.</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32;
	IF k[j] THEN
		dst[i+31:i] := EXP_2_23_SP(a[i+31:i]);
	ELSE
		dst[i*31:i] := 0;
ENDFOR;
dst[MAX:512] := 0
	</description>
	<mnemonic base="vexp2ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_exp2a23_round_pd / vexp2pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_exp2a23_round_pd">
	<CPUID>AVX-512.ERI</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="rounding" type="int"/>
	<description>Compute the approximate exponential value of 2 raised to the power of packed double-precision (64-bit) floating-point elements in "a", and store the results in "dst". The maximum relative error for this approximation is less than 2^-23. [round_note]</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64;
	dst[i+63:i] := EXP_2_23_DP(a[i+63:i]);
ENDFOR;
dst[MAX:512] := 0
	</description>
	<mnemonic base="vexp2pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_exp2a23_pd / vexp2pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_exp2a23_pd">
	<CPUID>AVX-512.ERI</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="a" type="__m512d"/>
	<description>Compute the approximate exponential value of 2 raised to the power of packed double-precision (64-bit) floating-point elements in "a", and store the results in "dst". The maximum relative error for this approximation is less than 2^-23.</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64;
	dst[i+63:i] := EXP_2_23_DP(a[i+63:i]);
ENDFOR;
dst[MAX:512] := 0
	</description>
	<mnemonic base="vexp2pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_exp2a23_round_pd / vexp2pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_exp2a23_round_pd">
	<CPUID>AVX-512.ERI</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="src" type="__m512d"/>
	<parameter varname="rounding" type="int"/>
	<description>Compute the approximate exponential value of 2 raised to the power of packed double-precision (64-bit) floating-point elements in "a", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-23. [round_note]</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64;
	IF k[j] THEN
		dst[i+63:i] := EXP_2_23_DP(a[i+63:i]);
	ELSE
		dst[i+63:i] := src[i+63:i];
ENDFOR;
dst[MAX:512] := 0
	</description>
	<mnemonic base="vexp2pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_exp2a23_pd / vexp2pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_exp2a23_pd">
	<CPUID>AVX-512.ERI</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="src" type="__m512d"/>
	<description>Compute the approximate exponential value of 2 raised to the power of packed double-precision (64-bit) floating-point elements in "a", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-23.</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64;
	IF k[j] THEN
		dst[i+63:i] := EXP_2_23_DP(a[i+63:i]);
	ELSE
		dst[i+63:i] := src[i+63:i];
ENDFOR;
dst[MAX:512] := 0
	</description>
	<mnemonic base="vexp2pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_exp2a23_round_pd / vexp2pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_exp2a23_round_pd">
	<CPUID>AVX-512.ERI</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="rounding" type="int"/>
	<description>Compute the approximate exponential value of 2 raised to the power of packed double-precision (64-bit) floating-point elements in "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-23. [round_note]</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64;
	IF k[j] THEN
		dst[i+63:i] := EXP_2_23_DP(a[i+63:i]);
	ELSE
		dst[i+63:i] := 0;
ENDFOR;
dst[MAX:512] := 0
	</description>
	<mnemonic base="vexp2pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_exp2a23_pd / vexp2pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_exp2a23_pd">
	<CPUID>AVX-512.ERI</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<description>Compute the approximate exponential value of 2 raised to the power of packed double-precision (64-bit) floating-point elements in "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-23.</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64;
	IF k[j] THEN
		dst[i+63:i] := EXP_2_23_DP(a[i+63:i]);
	ELSE
		dst[i+63:i] := 0;
ENDFOR;
dst[MAX:512] := 0
	</description>
	<mnemonic base="vexp2pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_rcp28_round_sd / vrcp28sd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_rcp28_round_sd">
	<CPUID>AVX-512.ERI</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="rounding" type="int"/>
	<description>Compute the approximate reciprocal of the lower double-precision (64-bit) floating-point element in "b", store the result in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst". The maximum relative error for this approximation is less than 2^-28. [round_note]</description>
	<description code="true">
dst[63:0] := RCP_28_DP(1.0/b[63:0];
dst[127:64] := a[127:64];
dst[MAX:128] := 0;
	</description>
	<mnemonic base="vrcp28sd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_rcp28_sd / vrcp28sd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_rcp28_sd">
	<CPUID>AVX-512.ERI</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<description>Compute the approximate reciprocal of the lower double-precision (64-bit) floating-point element in "b", store the result in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst". The maximum relative error for this approximation is less than 2^-28.</description>
	<description code="true">
dst[63:0] := RCP_28_DP(1.0/b[63:0];
dst[127:64] := a[127:64];
dst[MAX:128] := 0;
	</description>
	<mnemonic base="vrcp28sd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_rcp28_round_sd / vrcp28sd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_mask_rcp28_round_sd">
	<CPUID>AVX-512.ERI</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="src" type="__m128d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="rounding" type="int"/>
	<description>Compute the approximate reciprocal of the lower double-precision (64-bit) floating-point element in "b", store the result in the lower element of "dst" using writemask "k" (the element is copied from "src" when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst". The maximum relative error for this approximation is less than 2^-28. [round_note]</description>
	<description code="true">
IF k[0] THEN
	dst[63:0] := RCP_28_DP(1.0/b[63:0];
ELSE
	dst[63:0] := src[63:0];
FI
dst[127:64] := a[127:64];
dst[MAX:128] := 0;
	</description>
	<mnemonic base="vrcp28sd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_rcp28_sd / vrcp28sd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_mask_rcp28_sd">
	<CPUID>AVX-512.ERI</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="src" type="__m128d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<description>Compute the approximate reciprocal of the lower double-precision (64-bit) floating-point element in "b", store the result in the lower element of "dst" using writemask "k" (the element is copied from "src" when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst". The maximum relative error for this approximation is less than 2^-28.</description>
	<description code="true">
IF k[0] THEN
	dst[63:0] := RCP_28_DP(1.0/b[63:0];
ELSE
	dst[63:0] := src[63:0];
FI
dst[127:64] := a[127:64];
dst[MAX:128] := 0;
	</description>
	<mnemonic base="vrcp28sd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_rcp28_round_sd / vrcp28sd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_maskz_rcp28_round_sd">
	<CPUID>AVX-512.ERI</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="rounding" type="int"/>
	<description>Compute the approximate reciprocal of the lower double-precision (64-bit) floating-point element in "b", store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst". The maximum relative error for this approximation is less than 2^-28. [round_note]</description>
	<description code="true">
IF k[0] THEN
	dst[63:0] := RCP_28_DP(1.0/b[63:0];
ELSE
	dst[63:0] := 0;
FI
dst[127:64] := a[127:64];
dst[MAX:128] := 0;
	</description>
	<mnemonic base="vrcp28sd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_rcp28_sd / vrcp28sd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_maskz_rcp28_sd">
	<CPUID>AVX-512.ERI</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<description>Compute the approximate reciprocal of the lower double-precision (64-bit) floating-point element in "b", store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst". The maximum relative error for this approximation is less than 2^-28.</description>
	<description code="true">
IF k[0] THEN
	dst[63:0] := RCP_28_DP(1.0/b[63:0];
ELSE
	dst[63:0] := 0;
FI
dst[127:64] := a[127:64];
dst[MAX:128] := 0;
	</description>
	<mnemonic base="vrcp28sd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_rcp28_round_ss / vrcp28ss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_rcp28_round_ss">
	<CPUID>AVX-512.ERI</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="rounding" type="int"/>
	<description>Compute the approximate reciprocal of the lower single-precision (32-bit) floating-point element in "b", store the result in the lower element of "dst". The maximum relative error for this approximation is less than 2^-28, and copy the upper 3 packed elements from "a" to the upper elements of "dst". [round_note]</description>
	<description code="true">
dst[31:0] := RCP_28_DP(1.0/b[31:0];
dst[127:32] := a[127:32];
dst[MAX:128] := 0;
	</description>
	<mnemonic base="vrcp28ss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_rcp28_ss / vrcp28ss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_rcp28_ss">
	<CPUID>AVX-512.ERI</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<description>Compute the approximate reciprocal of the lower single-precision (32-bit) floating-point element in "b", store the result in the lower element of "dst", and copy the upper 3 packed elements from "a" to the upper elements of "dst". The maximum relative error for this approximation is less than 2^-28.</description>
	<description code="true">
dst[31:0] := RCP_28_DP(1.0/b[31:0];
dst[127:32] := a[127:32];
dst[MAX:128] := 0;
	</description>
	<mnemonic base="vrcp28ss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_rcp28_round_ss / vrcp28ss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_mask_rcp28_round_ss">
	<CPUID>AVX-512.ERI</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="src" type="__m128"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="rounding" type="int"/>
	<description>Compute the approximate reciprocal of the lower single-precision (32-bit) floating-point element in "b", store the result in the lower element of "dst" using writemask "k" (the element is copied from "src" when mask bit 0 is not set), and copy the upper 3 packed elements from "a" to the upper elements of "dst". The maximum relative error for this approximation is less than 2^-28. [round_note]</description>
	<description code="true">
IF k[0] THEN
	dst[31:0] := RCP_28_DP(1.0/b[31:0];
ELSE
	dst[31:0] := src[31:0];
FI
dst[127:32] := a[127:32];
dst[MAX:128] := 0;
	</description>
	<mnemonic base="vrcp28ss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_rcp28_ss / vrcp28ss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_mask_rcp28_ss">
	<CPUID>AVX-512.ERI</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="src" type="__m128"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<description>Compute the approximate reciprocal of the lower single-precision (32-bit) floating-point element in "b", store the result in the lower element of "dst" using writemask "k" (the element is copied from "src" when mask bit 0 is not set), and copy the upper 3 packed elements from "a" to the upper elements of "dst". The maximum relative error for this approximation is less than 2^-28.</description>
	<description code="true">
IF k[0] THEN
	dst[31:0] := RCP_28_DP(1.0/b[31:0];
ELSE
	dst[31:0] := src[31:0];
FI
dst[127:32] := a[127:32];
dst[MAX:128] := 0;
	</description>
	<mnemonic base="vrcp28ss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_rcp28_round_ss / vrcp28ss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_maskz_rcp28_round_ss">
	<CPUID>AVX-512.ERI</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="rounding" type="int"/>
	<description>Compute the approximate reciprocal of the lower single-precision (32-bit) floating-point element in "b", store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from "a" to the upper elements of "dst". The maximum relative error for this approximation is less than 2^-28. [round_note]</description>
	<description code="true">
IF k[0] THEN
	dst[31:0] := RCP_28_DP(1.0/b[31:0];
ELSE
	dst[31:0] := 0;
FI
dst[127:32] := a[127:32];
dst[MAX:128] := 0;
	</description>
	<mnemonic base="vrcp28ss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_rcp28_ss / vrcp28ss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_maskz_rcp28_ss">
	<CPUID>AVX-512.ERI</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<description>Compute the approximate reciprocal of the lower single-precision (32-bit) floating-point element in "b", store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from "a" to the upper elements of "dst". The maximum relative error for this approximation is less than 2^-28.</description>
	<description code="true">
IF k[0] THEN
	dst[31:0] := RCP_28_DP(1.0/b[31:0];
ELSE
	dst[31:0] := 0;
FI
dst[127:32] := a[127:32];
dst[MAX:128] := 0;
	</description>
	<mnemonic base="vrcp28ss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_rcp28_round_ps / vrcp28ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_rcp28_round_ps">
	<CPUID>AVX-512.ERI</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="rounding" type="int"/>
	<description>Compute the approximate reciprocal of packed single-precision (32-bit) floating-point elements in "a", and store the results in "dst". The maximum relative error for this approximation is less than 2^-28. [round_note]</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32;
	dst[i+31:i] := RCP_28_SP(1.0/a[i+31:i];
ENDFOR;
	</description>
	<mnemonic base="vrcp28ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_rcp28_ps / vrcp28ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_rcp28_ps">
	<CPUID>AVX-512.ERI</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="a" type="__m512"/>
	<description>Compute the approximate reciprocal of packed single-precision (32-bit) floating-point elements in "a", and store the results in "dst". The maximum relative error for this approximation is less than 2^-28.</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32;
	dst[i+31:i] := RCP_28_SP(1.0/a[i+31:i];
ENDFOR;
	</description>
	<mnemonic base="vrcp28ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_rcp28_round_ps / vrcp28ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_rcp28_round_ps">
	<CPUID>AVX-512.ERI</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="src" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="rounding" type="int"/>
	<description>Compute the approximate reciprocal of packed single-precision (32-bit) floating-point elements in "a", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-28. [round_note]</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32;
	IF k[j] THEN
		dst[i+31:i] := RCP_28_SP(1.0/a[i+31:i];
	ELSE
		dst[i+31:i] := src[i+31:i];
	FI
ENDFOR;
	</description>
	<mnemonic base="vrcp28ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_rcp28_ps / vrcp28ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_rcp28_ps">
	<CPUID>AVX-512.ERI</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="src" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<description>Compute the approximate reciprocal of packed single-precision (32-bit) floating-point elements in "a", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-28.</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32;
	IF k[j] THEN
		dst[i+31:i] := RCP_28_SP(1.0/a[i+31:i];
	ELSE
		dst[i+31:i] := src[i+31:i];
	FI
ENDFOR;
	</description>
	<mnemonic base="vrcp28ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_rcp28_round_ps / vrcp28ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_rcp28_round_ps">
	<CPUID>AVX-512.ERI</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="rounding" type="int"/>
	<description>Compute the approximate reciprocal of packed single-precision (32-bit) floating-point elements in "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-28. [round_note]</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32;
	IF k[j] THEN
		dst[i+31:i] := RCP_28_SP(1.0/a[i+31:i];
	ELSE
		dst[i+31:i] := 0;
	FI
ENDFOR;
	</description>
	<mnemonic base="vrcp28ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_rcp28_ps / vrcp28ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_rcp28_ps">
	<CPUID>AVX-512.ERI</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<description>Compute the approximate reciprocal of packed single-precision (32-bit) floating-point elements in "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-28.</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32;
	IF k[j] THEN
		dst[i+31:i] := RCP_28_SP(1.0/a[i+31:i];
	ELSE
		dst[i+31:i] := 0;
	FI
ENDFOR;
	</description>
	<mnemonic base="vrcp28ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_rcp28_round_pd / vrcp28pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_rcp28_round_pd">
	<CPUID>AVX-512.ERI</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="rounding" type="int"/>
	<description>Compute the approximate reciprocal of packed double-precision (64-bit) floating-point elements in "a", and store the results in "dst". The maximum relative error for this approximation is less than 2^-28. [round_note]</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64;
	dst[i+63:i] := RCP_28_SP(1.0/a[i+63:i];
ENDFOR;
	</description>
	<mnemonic base="vrcp28pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_rcp28_pd / vrcp28pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_rcp28_pd">
	<CPUID>AVX-512.ERI</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="a" type="__m512d"/>
	<description>Compute the approximate reciprocal of packed double-precision (64-bit) floating-point elements in "a", and store the results in "dst". The maximum relative error for this approximation is less than 2^-28.</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64;
	dst[i+63:i] := RCP_28_SP(1.0/a[i+63:i];
ENDFOR;
	</description>
	<mnemonic base="vrcp28pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_rcp28_round_pd / vrcp28pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_rcp28_round_pd">
	<CPUID>AVX-512.ERI</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="src" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="rounding" type="int"/>
	<description>Compute the approximate reciprocal of packed double-precision (64-bit) floating-point elements in "a", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-28. [round_note]</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64;
	IF k[j] THEN
		dst[i+63:i] := RCP_28_SP(1.0/a[i+63:i];
	ELSE
		dst[i+63:i] := src[i+63:i];
	FI
ENDFOR;
	</description>
	<mnemonic base="vrcp28pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_rcp28_pd / vrcp28pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_rcp28_pd">
	<CPUID>AVX-512.ERI</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="src" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<description>Compute the approximate reciprocal of packed double-precision (64-bit) floating-point elements in "a", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-28.</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64;
	IF k[j] THEN
		dst[i+63:i] := RCP_28_SP(1.0/a[i+63:i];
	ELSE
		dst[i+63:i] := src[i+63:i];
	FI
ENDFOR;
	</description>
	<mnemonic base="vrcp28pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_rcp28_round_pd / vrcp28pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_rcp28_round_pd">
	<CPUID>AVX-512.ERI</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="rounding" type="int"/>
	<description>Compute the approximate reciprocal of packed double-precision (64-bit) floating-point elements in "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-28. [round_note]</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64;
	IF k[j] THEN
		dst[i+63:i] := RCP_28_SP(1.0/a[i+63:i];
	ELSE
		dst[i+63:i] := 0;
	FI
ENDFOR;
	</description>
	<mnemonic base="vrcp28pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_rcp28_pd / vrcp28pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_rcp28_pd">
	<CPUID>AVX-512.ERI</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<description>Compute the approximate reciprocal of packed double-precision (64-bit) floating-point elements in "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-28.</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64;
	IF k[j] THEN
		dst[i+63:i] := RCP_28_SP(1.0/a[i+63:i];
	ELSE
		dst[i+63:i] := 0;
	FI
ENDFOR;
	</description>
	<mnemonic base="vrcp28pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_rsqrt28_round_sd / vrsqrt28sd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_rsqrt28_round_sd">
	<CPUID>AVX-512.ERI</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="rounding" type="int"/>
	<description>Compute the approximate reciprocal square root of the lower double-precision (64-bit) floating-point element in "b", store the result in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst". The maximum relative error for this approximation is less than 2^-28. [round_note]</description>
	<description code="true">
dst[63:0] := (1.0/SQRT(b[63:0]));
dst[127:64] := a[127:64];
dst[MAX:128] := 0;
	</description>
	<mnemonic base="vrsqrt28sd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_rsqrt28_sd / vrsqrt28sd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_rsqrt28_sd">
	<CPUID>AVX-512.ERI</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<description>Compute the approximate reciprocal square root of the lower double-precision (64-bit) floating-point element in "b", store the result in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst". The maximum relative error for this approximation is less than 2^-28.</description>
	<description code="true">
dst[63:0] := (1.0/SQRT(b[63:0]));
dst[127:64] := a[127:64];
dst[MAX:128] := 0;
	</description>
	<mnemonic base="vrsqrt28sd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_rsqrt28_round_sd / vrsqrt28sd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_mask_rsqrt28_round_sd">
	<CPUID>AVX-512.ERI</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="src" type="__m128d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="rounding" type="int"/>
	<description>Compute the approximate reciprocal square root of the lower double-precision (64-bit) floating-point element in "b", store the result in the lower element of "dst" using writemask "k" (the element is copied from "src" when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst". The maximum relative error for this approximation is less than 2^-28. [round_note]</description>
	<description code="true">
IF k[0] THEN
	dst[63:0] := (1.0/SQRT(b[63:0]));
ELSE
	dst[63:0] := src[63:0];
FI
dst[127:64] := a[127:64];
dst[MAX:128] := 0;
	</description>
	<mnemonic base="vrsqrt28sd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_rsqrt28_sd / vrsqrt28sd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_mask_rsqrt28_sd">
	<CPUID>AVX-512.ERI</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="src" type="__m128d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<description>Compute the approximate reciprocal square root of the lower double-precision (64-bit) floating-point element in "b", store the result in the lower element of "dst" using writemask "k" (the element is copied from "src" when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst". The maximum relative error for this approximation is less than 2^-28.</description>
	<description code="true">
IF k[0] THEN
	dst[63:0] := (1.0/SQRT(b[63:0]));
ELSE
	dst[63:0] := src[63:0];
FI
dst[127:64] := a[127:64];
dst[MAX:128] := 0;
	</description>
	<mnemonic base="vrsqrt28sd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_rsqrt28_round_sd / vrsqrt28sd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_maskz_rsqrt28_round_sd">
	<CPUID>AVX-512.ERI</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<parameter varname="rounding" type="int"/>
	<description>Compute the approximate reciprocal square root of the lower double-precision (64-bit) floating-point element in "b", store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst". The maximum relative error for this approximation is less than 2^-28. [round_note]</description>
	<description code="true">
IF k[0] THEN
	dst[63:0] := (1.0/SQRT(b[63:0]));
ELSE
	dst[63:0] := 0;
FI
dst[127:64] := a[127:64];
dst[MAX:128] := 0;
	</description>
	<mnemonic base="vrsqrt28sd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_rsqrt28_sd / vrsqrt28sd -->
<intrinsic tech="AVX-512" rettype="__m128d" name="_mm_maskz_rsqrt28_sd">
	<CPUID>AVX-512.ERI</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128d"/>
	<parameter varname="b" type="__m128d"/>
	<description>Compute the approximate reciprocal square root of the lower double-precision (64-bit) floating-point element in "b", store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper element from "a" to the upper element of "dst". The maximum relative error for this approximation is less than 2^-28.</description>
	<description code="true">
IF k[0] THEN
	dst[63:0] := (1.0/SQRT(b[63:0]));
ELSE
	dst[63:0] := 0;
FI
dst[127:64] := a[127:64];
dst[MAX:128] := 0;
	</description>
	<mnemonic base="vrsqrt28sd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_rsqrt28_round_ss / vrsqrt28ss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_rsqrt28_round_ss">
	<CPUID>AVX-512.ERI</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="rounding" type="int"/>
	<description>Compute the approximate reciprocal square root of the lower single-precision (32-bit) floating-point element in "b", store the result in the lower element of "dst", and copy the upper 3 packed elements from "a" to the upper elements of "dst". The maximum relative error for this approximation is less than 2^-28. [round_note]</description>
	<description code="true">
dst[31:0] := (1.0/SQRT(b[31:0]));
dst[127:32] := a[127:32];
dst[MAX:128] := 0;
	</description>
	<mnemonic base="vrsqrt28ss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_rsqrt28_ss / vrsqrt28ss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_rsqrt28_ss">
	<CPUID>AVX-512.ERI</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<description>Compute the approximate reciprocal square root of the lower single-precision (32-bit) floating-point element in "b", store the result in the lower element of "dst", and copy the upper 3 packed elements from "a" to the upper elements of "dst". The maximum relative error for this approximation is less than 2^-28.</description>
	<description code="true">
dst[31:0] := (1.0/SQRT(b[31:0]));
dst[127:32] := a[127:32];
dst[MAX:128] := 0;
	</description>
	<mnemonic base="vrsqrt28ss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_rsqrt28_round_ss / vrsqrt28ss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_mask_rsqrt28_round_ss">
	<CPUID>AVX-512.ERI</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="src" type="__m128"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="rounding" type="int"/>
	<description>Compute the approximate reciprocal square root of the lower single-precision (32-bit) floating-point element in "b", store the result in the lower element of "dst" using writemask "k" (the element is copied from "src" when mask bit 0 is not set), and copy the upper 3 packed elements from "a" to the upper elements of "dst". The maximum relative error for this approximation is less than 2^-28. [round_note]</description>
	<description code="true">
IF k[0] THEN
	dst[31:0] := (1.0/SQRT(b[31:0]));
ELSE
	dst[31:0] := src[31:0];
FI
dst[127:32] := a[127:32];
dst[MAX:128] := 0;
	</description>
	<mnemonic base="vrsqrt28ss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_mask_rsqrt28_ss / vrsqrt28ss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_mask_rsqrt28_ss">
	<CPUID>AVX-512.ERI</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="src" type="__m128"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<description>Compute the approximate reciprocal square root of the lower single-precision (32-bit) floating-point element in "b", store the result in the lower element of "dst" using writemask "k" (the element is copied from "src" when mask bit 0 is not set), and copy the upper 3 packed elements from "a" to the upper elements of "dst". The maximum relative error for this approximation is less than 2^-28.</description>
	<description code="true">
IF k[0] THEN
	dst[31:0] := (1.0/SQRT(b[31:0]));
ELSE
	dst[31:0] := src[31:0];
FI
dst[127:32] := a[127:32];
dst[MAX:128] := 0;
	</description>
	<mnemonic base="vrsqrt28ss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_rsqrt28_round_ss / vrsqrt28ss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_maskz_rsqrt28_round_ss">
	<CPUID>AVX-512.ERI</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<parameter varname="rounding" type="int"/>
	<description>Compute the approximate reciprocal square root of the lower single-precision (32-bit) floating-point element in "b", store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from "a" to the upper elements of "dst". The maximum relative error for this approximation is less than 2^-28. [round_note]</description>
	<description code="true">
IF k[0] THEN
	dst[31:0] := (1.0/SQRT(b[31:0]));
ELSE
	dst[31:0] := 0;
FI
dst[127:32] := a[127:32];
dst[MAX:128] := 0;
	</description>
	<mnemonic base="vrsqrt28ss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm_maskz_rsqrt28_ss / vrsqrt28ss -->
<intrinsic tech="AVX-512" rettype="__m128" name="_mm_maskz_rsqrt28_ss">
	<CPUID>AVX-512.ERI</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m128"/>
	<parameter varname="b" type="__m128"/>
	<description>Compute the approximate reciprocal square root of the lower single-precision (32-bit) floating-point element in "b", store the result in the lower element of "dst" using zeromask "k" (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from "a" to the upper elements of "dst". The maximum relative error for this approximation is less than 2^-28.</description>
	<description code="true">
IF k[0] THEN
	dst[31:0] := (1.0/SQRT(b[31:0]));
ELSE
	dst[31:0] := 0;
FI
dst[127:32] := a[127:32];
dst[MAX:128] := 0;
	</description>
	<mnemonic base="vrsqrt28ss"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_rsqrt28_round_ps / vrsqrt28ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_rsqrt28_round_ps">
	<CPUID>AVX-512.ERI</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="a" type="__m512"/>
	<parameter varname="rounding" type="int"/>
	<description>Compute the approximate reciprocal square root of packed single-precision (32-bit) floating-point elements in "a", store the results in "dst". The maximum relative error for this approximation is less than 2^-28. [round_note]</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32;
	dst[i+31:i] := (1.0/SQRT(a[i+31:i]));
ENDFOR;
	</description>
	<mnemonic base="vrsqrt28ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_rsqrt28_ps / vrsqrt28ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_rsqrt28_ps">
	<CPUID>AVX-512.ERI</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="a" type="__m512"/>
	<description>Compute the approximate reciprocal square root of packed single-precision (32-bit) floating-point elements in "a", store the results in "dst". The maximum relative error for this approximation is less than 2^-28.</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32;
	dst[i+31:i] := (1.0/SQRT(a[i+31:i]));
ENDFOR;
	</description>
	<mnemonic base="vrsqrt28ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_rsqrt28_round_ps / vrsqrt28ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_rsqrt28_round_ps">
	<CPUID>AVX-512.ERI</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="src" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="rounding" type="int"/>
	<description>Compute the approximate reciprocal square root of packed single-precision (32-bit) floating-point elements in "a", store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-28. [round_note]</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32;
	IF k[j] THEN
		dst[i+31:i] := (1.0/SQRT(a[i+31:i]));
	ELSE
		dst[i+31:i] := src[i+31:i];
	FI
ENDFOR;
	</description>
	<mnemonic base="vrsqrt28ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_rsqrt28_ps / vrsqrt28ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_mask_rsqrt28_ps">
	<CPUID>AVX-512.ERI</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="src" type="__m512"/>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<description>Compute the approximate reciprocal square root of packed single-precision (32-bit) floating-point elements in "a", store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-28.</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32;
	IF k[j] THEN
		dst[i+31:i] := (1.0/SQRT(a[i+31:i]));
	ELSE
		dst[i+31:i] := src[i+31:i];
	FI
ENDFOR;
	</description>
	<mnemonic base="vrsqrt28ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_rsqrt28_round_ps / vrsqrt28ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_rsqrt28_round_ps">
	<CPUID>AVX-512.ERI</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<parameter varname="rounding" type="int"/>
	<description>Compute the approximate reciprocal square root of packed single-precision (32-bit) floating-point elements in "a", store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-28. [round_note]</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32;
	IF k[j] THEN
		dst[i+31:i] := (1.0/SQRT(a[i+31:i]));
	ELSE
		dst[i+31:i] := 0;
	FI
ENDFOR;
	</description>
	<mnemonic base="vrsqrt28ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_rsqrt28_ps / vrsqrt28ps -->
<intrinsic tech="AVX-512" rettype="__m512" name="_mm512_maskz_rsqrt28_ps">
	<CPUID>AVX-512.ERI</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="k" type="__mmask16"/>
	<parameter varname="a" type="__m512"/>
	<description>Compute the approximate reciprocal square root of packed single-precision (32-bit) floating-point elements in "a", store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-28.</description>
	<description code="true">
FOR j := 0 to 15
	i := j*32;
	IF k[j] THEN
		dst[i+31:i] := (1.0/SQRT(a[i+31:i]));
	ELSE
		dst[i+31:i] := 0;
	FI
ENDFOR;
	</description>
	<mnemonic base="vrsqrt28ps"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_rsqrt28_round_pd / vrsqrt28pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_rsqrt28_round_pd">
	<CPUID>AVX-512.ERI</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="rounding" type="int"/>
	<description>Compute the approximate reciprocal square root of packed double-precision (64-bit) floating-point elements in "a", store the results in "dst". The maximum relative error for this approximation is less than 2^-28. [round_note]</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64;
	dst[i+63:i] := (1.0/SQRT(a[i+63:i]));
ENDFOR;
	</description>
	<mnemonic base="vrsqrt28pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_rsqrt28_pd / vrsqrt28pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_rsqrt28_pd">
	<CPUID>AVX-512.ERI</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="a" type="__m512d"/>
	<description>Compute the approximate reciprocal square root of packed double-precision (64-bit) floating-point elements in "a", store the results in "dst". The maximum relative error for this approximation is less than 2^-28.</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64;
	dst[i+63:i] := (1.0/SQRT(a[i+63:i]));
ENDFOR;
	</description>
	<mnemonic base="vrsqrt28pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_rsqrt28_round_pd / vrsqrt28pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_rsqrt28_round_pd">
	<CPUID>AVX-512.ERI</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="src" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="rounding" type="int"/>
	<description>Compute the approximate reciprocal square root of packed double-precision (64-bit) floating-point elements in "a", store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-28. [round_note]</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64;
	IF k[j] THEN
		dst[i+63:i] := (1.0/SQRT(a[i+63:i]));
	ELSE
		dst[i+63:i] := src[i+63:i];
	FI
ENDFOR;
	</description>
	<mnemonic base="vrsqrt28pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_mask_rsqrt28_pd / vrsqrt28pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_mask_rsqrt28_pd">
	<CPUID>AVX-512.ERI</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="src" type="__m512d"/>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<description>Compute the approximate reciprocal square root of packed double-precision (64-bit) floating-point elements in "a", store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-28.</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64;
	IF k[j] THEN
		dst[i+63:i] := (1.0/SQRT(a[i+63:i]));
	ELSE
		dst[i+63:i] := src[i+63:i];
	FI
ENDFOR;
	</description>
	<mnemonic base="vrsqrt28pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_rsqrt28_round_pd / vrsqrt28pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_rsqrt28_round_pd">
	<CPUID>AVX-512.ERI</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<parameter varname="rounding" type="int"/>
	<description>Compute the approximate reciprocal square root of packed double-precision (64-bit) floating-point elements in "a", store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-28. [round_note]</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64;
	IF k[j] THEN
		dst[i+63:i] := (1.0/SQRT(a[i+63:i]));
	ELSE
		dst[i+63:i] := 0;
	FI
ENDFOR;
	</description>
	<mnemonic base="vrsqrt28pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


<!-- _mm512_maskz_rsqrt28_pd / vrsqrt28pd -->
<intrinsic tech="AVX-512" rettype="__m512d" name="_mm512_maskz_rsqrt28_pd">
	<CPUID>AVX-512.ERI</CPUID>
	<category>Elementary Math Functions</category>
	<parameter varname="k" type="__mmask8"/>
	<parameter varname="a" type="__m512d"/>
	<description>Compute the approximate reciprocal square root of packed double-precision (64-bit) floating-point elements in "a", store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-28.</description>
	<description code="true">
FOR j := 0 to 7
	i := j*64;
	IF k[j] THEN
		dst[i+63:i] := (1.0/SQRT(a[i+63:i]));
	ELSE
		dst[i+63:i] := 0;
	FI
ENDFOR;
	</description>
	<mnemonic base="vrsqrt28pd"/>
	<header>zmmintrin.h</header>
</intrinsic>


</intrinsic_list>
