
<intrinsic_list>


!-- _mm_empty / emms -->
<intrinsic tech='MMX' rettype='__m64' name='_mm_empty'>
	<CPUID>MMX</CPUID>
	<category>General Support</category>
	<description>Empty the MMX state, which marks the x87 FPU registers as available for use by x87 instructions. This instruction must be used at the end of all MMX technology procedures.</description>
	<mnemonic base='emms'/>
	<header>mmintrin.h</header>
</intrinsic>


<!-- _mm_add_pi8 / paddb -->
<intrinsic tech='MMX' rettype='__m64' name='_mm_add_pi8'>
	<CPUID>MMX</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m64'/>
	<parameter varname='b' type='__m64'/>
	<description>Add packed 8-bit integers in "a" and "b", and store the results in "dst".</description>
	<description code='true'>
FOR j := 0 to 7
	i := j*8
	dst[i+7:i] := a[i+7:i] + b[i+7:i]
ENDFOR
	</description>
	<mnemonic base='paddb' parameters="mm, mm" />
	<header>mmintrin.h</header>
</intrinsic>


<!-- _mm_add_pi16 / paddw -->
<intrinsic tech='MMX' rettype='__m64' name='_mm_add_pi16'>
	<CPUID>MMX</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m64'/>
	<parameter varname='b' type='__m64'/>
	<description>Add packed 16-bit integers in "a" and "b", and store the results in "dst".</description>
	<description code='true'>
FOR j := 0 to 3
	i := j*16
	dst[i+15:i] := a[i+15:i] + b[i+15:i]
ENDFOR
	</description>
	<mnemonic base='paddw' parameters="mm, mm"/>
	<header>mmintrin.h</header>
</intrinsic>


<!-- _mm_add_pi32 / paddd -->
<intrinsic tech='MMX' rettype='__m64' name='_mm_add_pi32'>
	<CPUID>MMX</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m64'/>
	<parameter varname='b' type='__m64'/>
	<description>Add packed 32-bit integers in "a" and "b", and store the results in "dst".</description>
	<description code='true'>
FOR j := 0 to 1
	i := j*32
	dst[i+31:i] := a[i+31:i] + b[i+31:i]
ENDFOR
	</description>
	<mnemonic base='paddd' parameters="mm, mm"/>
	<header>mmintrin.h</header>
</intrinsic>


<!-- _mm_adds_pi8 / paddsb -->
<intrinsic tech='MMX' rettype='__m64' name='_mm_adds_pi8'>
	<CPUID>MMX</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m64'/>
	<parameter varname='b' type='__m64'/>
	<description>Add packed 8-bit integers in "a" and "b" using saturation, and store the results in "dst".</description>
	<description code='true'>
FOR j := 0 to 7
	i := j*8
	dst[i+7:i] := Saturate_To_Int8( a[i+7:i] + b[i+7:i] )
ENDFOR
	</description>
	<mnemonic base='paddsb' parameters="mm, mm"/>
	<header>mmintrin.h</header>
</intrinsic>


<!-- _mm_adds_pi16 / paddsw -->
<intrinsic tech='MMX' rettype='__m64' name='_mm_adds_pi16'>
	<CPUID>MMX</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m64'/>
	<parameter varname='b' type='__m64'/>
	<description>Add packed 16-bit integers in "a" and "b" using saturation, and store the results in "dst".</description>
	<description code='true'>
FOR j := 0 to 3
	i := j*16
	dst[i+15:i] := Saturate_To_Int16( a[i+15:i] + b[i+15:i] )
ENDFOR
	</description>
	<mnemonic base='paddsw' parameters="mm, mm"/>
	<header>mmintrin.h</header>
</intrinsic>


<!-- _mm_adds_pu8 / paddusb -->
<intrinsic tech='MMX' rettype='__m64' name='_mm_adds_pu8'>
	<CPUID>MMX</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m64'/>
	<parameter varname='b' type='__m64'/>
	<description>Add packed unsigned 8-bit integers in "a" and "b" using saturation, and store the results in "dst".</description>
	<description code='true'>
FOR j := 0 to 7
	i := j*8
	dst[i+7:i] := Saturate_To_UnsignedInt8( a[i+7:i] + b[i+7:i] )
ENDFOR
	</description>
	<mnemonic base='paddusb' parameters="mm, mm"/>
	<header>mmintrin.h</header>
</intrinsic>


<!-- _mm_adds_pu16 / paddusw -->
<intrinsic tech='MMX' rettype='__m64' name='_mm_adds_pu16'>
	<CPUID>MMX</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m64'/>
	<parameter varname='b' type='__m64'/>
	<description>Add packed unsigned 16-bit integers in "a" and "b" using saturation, and store the results in "dst".</description>
	<description code='true'>
FOR j := 0 to 3
	i := j*16
	dst[i+15:i] := Saturate_To_UnsignedInt16( a[i+15:i] + b[i+15:i] )
ENDFOR
	</description>
	<mnemonic base='paddusw' parameters="mm, mm"/>
	<header>mmintrin.h</header>
</intrinsic>


<!-- _mm_sub_pi8 / psubb -->
<intrinsic tech='MMX' rettype='__m64' name='_mm_sub_pi8'>
	<CPUID>MMX</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m64'/>
	<parameter varname='b' type='__m64'/>
	<description>Subtract packed 8-bit integers in "b" from packed 8-bit integers in "a", and store the results in "dst".</description>
	<description code='true'>
FOR j := 0 to 7
	i := j*8
	dst[i+7:i] := a[i+7:i] - b[i+7:i]
ENDFOR
	</description>
	<mnemonic base='psubb' parameters="mm, mm"/>
	<header>mmintrin.h</header>
</intrinsic>


<!-- _mm_sub_pi16 / psubw -->
<intrinsic tech='MMX' rettype='__m64' name='_mm_sub_pi16'>
	<CPUID>MMX</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m64'/>
	<parameter varname='b' type='__m64'/>
	<description>Subtract packed 16-bit integers in "b" from packed 16-bit integers in "a", and store the results in "dst".</description>
	<description code='true'>
FOR j := 0 to 3
	i := j*16
	dst[i+15:i] := a[i+15:i] - b[i+15:i]
ENDFOR
	</description>
	<mnemonic base='psubw' parameters="mm, mm"/>
	<header>mmintrin.h</header>
</intrinsic>


<!-- _mm_sub_pi32 / psubd -->
<intrinsic tech='MMX' rettype='__m64' name='_mm_sub_pi32'>
	<CPUID>MMX</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m64'/>
	<parameter varname='b' type='__m64'/>
	<description>Subtract packed 32-bit integers in "b" from packed 32-bit integers in "a", and store the results in "dst".</description>
	<description code='true'>
FOR j := 0 to 1
	i := j*32
	dst[i+31:i] := a[i+31:i] - b[i+31:i]
ENDFOR
	</description>
	<mnemonic base='psubd' parameters="mm, mm"/>
	<header>mmintrin.h</header>
</intrinsic>


<!-- _mm_subs_pi8 / psubsb -->
<intrinsic tech='MMX' rettype='__m64' name='_mm_subs_pi8'>
	<CPUID>MMX</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m64'/>
	<parameter varname='b' type='__m64'/>
	<description>Subtract packed 8-bit integers in "b" from packed 8-bit integers in "a" using saturation, and store the results in "dst".</description>
	<description code='true'>
FOR j := 0 to 7
	i := j*8
	dst[i+7:i] := Saturate_To_Int8(a[i+7:i] - b[i+7:i])	
ENDFOR
	</description>
	<mnemonic base='psubsb' parameters="mm, mm"/>
	<header>mmintrin.h</header>
</intrinsic>


<!-- _mm_subs_pi16 / psubsw -->
<intrinsic tech='MMX' rettype='__m64' name='_mm_subs_pi16'>
	<CPUID>MMX</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m64'/>
	<parameter varname='b' type='__m64'/>
	<description>Subtract packed 16-bit integers in "b" from packed 16-bit integers in "a" using saturation, and store the results in "dst".</description>
	<description code='true'>
FOR j := 0 to 3
	i := j*16
	dst[i+15:i] := Saturate_To_Int16(a[i+15:i] - b[i+15:i])
ENDFOR
	</description>
	<mnemonic base='psubsw' parameters="mm, mm"/>
	<header>mmintrin.h</header>
</intrinsic>


<!-- _mm_subs_pu8 / psubusb -->
<intrinsic tech='MMX' rettype='__m64' name='_mm_subs_pu8'>
	<CPUID>MMX</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m64'/>
	<parameter varname='b' type='__m64'/>
	<description>Subtract packed unsigned 8-bit integers in "b" from packed unsigned 8-bit integers in "a" using saturation, and store the results in "dst".</description>
	<description code='true'>
FOR j := 0 to 7
	i := j*8
	dst[i+7:i] := Saturate_To_UnsignedInt8(a[i+7:i] - b[i+7:i])	
ENDFOR
	</description>
	<mnemonic base='psubusb' parameters="mm, mm"/>
	<header>mmintrin.h</header>
</intrinsic>


<!-- _mm_subs_pu16 / psubusw -->
<intrinsic tech='MMX' rettype='__m64' name='_mm_subs_pu16'>
	<CPUID>MMX</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m64'/>
	<parameter varname='b' type='__m64'/>
	<description>Subtract packed unsigned 16-bit integers in "b" from packed unsigned 16-bit integers in "a" using saturation, and store the results in "dst".</description>
	<description code='true'>
FOR j := 0 to 3
	i := j*16
	dst[i+15:i] := Saturate_To_UnsignedInt16(a[i+15:i] - b[i+15:i])	
ENDFOR
	</description>
	<mnemonic base='psubusw' parameters="mm, mm"/>
	<header>mmintrin.h</header>
</intrinsic>


<!-- _mm_madd_pi16 / pmaddwd -->
<intrinsic tech='MMX' rettype='__m64' name='_mm_madd_pi16'>
	<CPUID>MMX</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m64'/>
	<parameter varname='b' type='__m64'/>
	<description>Multiply packed 16-bit integers in "a" and "b", producing intermediate 32-bit integers. Horizontally add adjacent pairs of intermediate 32-bit integers, and pack the saturated results in "dst".
	</description>
	<description code='true'>
FOR j := 0 to 1
	i := j*32
	st[i+31:i] := Saturate_To_Int32( a[i+31:i+16]*b[i+31:i+16] + a[i+15:i]*b[i+15:i] )
ENDFOR
	</description>
	<mnemonic base='pmaddwd' parameters="mm, mm"/>
	<header>mmintrin.h</header>
</intrinsic>


<!-- _mm_mulhi_pi16 / pmulhw -->
<intrinsic tech='MMX' rettype='__m64' name='_mm_mulhi_pi16'>
	<CPUID>MMX</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m64'/>
	<parameter varname='b' type='__m64'/>
	<description>Multiply the packed 16-bit integers in "a" and "b", producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in "dst". </description>
	<description code='true'>
FOR j := 0 to 3
	i := j*16
	tmp[31:0] := a[i+15:i] * b[i+15:i]
	dst[i+15:i] := tmp[31:16]
ENDFOR
	</description>
	<mnemonic base='pmulhw' parameters="mm, mm"/>
	<header>mmintrin.h</header>
</intrinsic>


<!-- _mm_mullo_pi16 / pmullw -->
<intrinsic tech='MMX' rettype='__m64' name='_mm_mullo_pi16'>
	<CPUID>MMX</CPUID>
	<category>Arithmetic</category>
	<parameter varname='a' type='__m64'/>
	<parameter varname='b' type='__m64'/>
	<description>Multiply the packed 16-bit integers in "a" and "b", producing intermediate 32-bit integers, and store the low 16 bits of the intermediate integers in "dst". </description>
	<description code='true'>
FOR j := 0 to 3
	i := j*16
	tmp[31:0] := a[i+15:i] * b[i+15:i]
	dst[i+15:i] := tmp[15:0]
ENDFOR
	</description>
	<mnemonic base='pmullw' parameters="mm, mm"/>
	<header>mmintrin.h</header>
</intrinsic>


<!-- _mm_sll_pi16 / psllw -->
<intrinsic tech='MMX' rettype='__m64' name='_mm_sll_pi16'>
	<CPUID>MMX</CPUID>
	<category>Shift</category>
	<parameter varname='a' type='__m64'/>
	<parameter varname='count' type='__m64'/>
	<description>Shift packed 16-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst". </description>
	<description code='true'>
FOR j := 0 to 3
	i := j*16
	IF count[63:0] &gt; 15
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := ZeroExtend(a[i+15:i] &lt;&lt; count[63:0])
	FI
ENDFOR
	</description>
	<mnemonic base='psllw' parameters="mm, mm"/>
	<header>mmintrin.h</header>
</intrinsic>


<!-- _mm_slli_pi16 / psllw -->
<intrinsic tech='MMX' rettype='__m64' name='_mm_slli_pi16'>
	<CPUID>MMX</CPUID>
	<category>Shift</category>
	<parameter varname='a' type='__m64'/>
	<parameter varname='imm' type='int'/>
	<description>Shift packed 16-bit integers in "a" left by "imm" while shifting in zeros, and store the results in "dst". </description>
	<description code='true'>
FOR j := 0 to 3
	i := j*16
	IF imm &gt; 15
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := ZeroExtend(a[i+15:i] &lt;&lt; imm)
	FI
ENDFOR
	</description>
	<mnemonic base='psllw' parameters="mm, mm/imm8"/>
	<header>mmintrin.h</header>
</intrinsic>


<!-- _mm_sll_pi32 / pslld -->
<intrinsic tech='MMX' rettype='__m64' name='_mm_sll_pi32'>
	<CPUID>MMX</CPUID>
	<category>Shift</category>
	<parameter varname='a' type='__m64'/>
	<parameter varname='count' type='__m64'/>
	<description>Shift packed 32-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst". </description>
	<description code='true'>
FOR j := 0 to 1
	i := j*32
	IF count[63:0] &gt; 31
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := ZeroExtend(a[i+31:i] &lt;&lt; count[63:0])
	FI
ENDFOR
	</description>
	<mnemonic base='pslld'/>
	<header>mmintrin.h</header>
</intrinsic>


<!-- _mm_slli_pi32 / pslld -->
<intrinsic tech='MMX' rettype='__m64' name='_mm_slli_pi32'>
	<CPUID>MMX</CPUID>
	<category>Shift</category>
	<parameter varname='a' type='__m64'/>
	<parameter varname='imm' type='int'/>
	<description>Shift packed 32-bit integers in "a" left by "imm" while shifting in zeros, and store the results in "dst".</description>
	<description code='true'>
FOR j := 0 to 1
	i := j*32
	IF imm &gt; 31
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := ZeroExtend(a[i+31:i] &lt;&lt; imm)
	FI
ENDFOR
	</description>
	<mnemonic base='pslld'/>
	<header>mmintrin.h</header>
</intrinsic>


<!-- _mm_sll_si64 / psllq -->
<intrinsic tech='MMX' rettype='__m64' name='_mm_sll_si64'>
	<CPUID>MMX</CPUID>
	<category>Shift</category>
	<parameter varname='a' type='__m64'/>
	<parameter varname='count' type='__m64'/>
	<description>Shift 64-bit integer "a" left by "count" while shifting in zeros, and store the result in "dst". </description>
	<description code='true'>
IF count[63:0] &gt; 63
	dst[63:0] := 0
ELSE
	dst[63:0] := ZeroExtend(a[63:0] &lt;&lt; count[63:0])
FI
	</description>
	<mnemonic base='psllq' parameters="mm, mm"/>
	<header>mmintrin.h</header>
</intrinsic>


<!-- _mm_slli_si64 / psllq -->
<intrinsic tech='MMX' rettype='__m64' name='_mm_slli_si64'>
	<CPUID>MMX</CPUID>
	<category>Shift</category>
	<parameter varname='a' type='__m64'/>
	<parameter varname='imm' type='int'/>
	<description>Shift 64-bit integer "a" left by "imm" while shifting in zeros, and store the result in "dst". </description>
	<description code='true'>
IF imm &gt; 63
	dst[63:0] := 0
ELSE
	dst[63:0] := ZeroExtend(a[63:0] &lt;&lt; imm)
FI
	</description>
	<mnemonic base='psllq'/>
	<header>mmintrin.h</header>
</intrinsic>


<!-- _mm_sra_pi16 / psraw -->
<intrinsic tech='MMX' rettype='__m64' name='_mm_sra_pi16'>
	<CPUID>MMX</CPUID>
	<category>Shift</category>
	<parameter varname='a' type='__m64'/>
	<parameter varname='count' type='__m64'/>
	<description>Shift packed 16-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst". </description>
	<description code='true'>
FOR j := 0 to 3
	i := j*16
	IF count[63:0] &gt; 15
		dst[i+15:i] := SignBit
	ELSE
		dst[i+15:i] := SignExtend(a[i+15:i] &gt;&gt; count[63:0])
	FI
ENDFOR
	</description>
	<mnemonic base='psraw' parameters="mm, mm"/>
	<header>mmintrin.h</header>
</intrinsic>


<!-- _mm_srai_pi16 / psraw -->
<intrinsic tech='MMX' rettype='__m64' name='_mm_srai_pi16'>
	<CPUID>MMX</CPUID>
	<category>Shift</category>
	<parameter varname='a' type='__m64'/>
	<parameter varname='imm' type='int'/>
	<description>Shift packed 16-bit integers in "a" right by "imm" while shifting in sign bits, and store the results in "dst". </description>
	<description code='true'>
FOR j := 0 to 3
	i := j*16
	IF imm &gt; 15
		dst[i+15:i] := SignBit
	ELSE
		dst[i+15:i] := SignExtend(a[i+15:i] &gt;&gt; imm)
	FI
ENDFOR
	</description>
	<mnemonic base='psraw'/>
	<header>mmintrin.h</header>
</intrinsic>


<!-- _mm_sra_pi32 / psrad -->
<intrinsic tech='MMX' rettype='__m64' name='_mm_sra_pi32'>
	<CPUID>MMX</CPUID>
	<category>Shift</category>
	<parameter varname='a' type='__m64'/>
	<parameter varname='count' type='__m64'/>
	<description>Shift packed 32-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst". </description>
	<description code='true'>
FOR j := 0 to 1
	i := j*32
	IF count[63:0] &gt; 31
		dst[i+31:i] := SignBit
	ELSE
		dst[i+31:i] := SignExtend(a[i+31:i] &gt;&gt; count[63:0])
	FI
ENDFOR
	</description>
	<mnemonic base='psrad' parameters="mm, mm"/>
	<header>mmintrin.h</header>
</intrinsic>


<!-- _mm_srai_pi32 / psrad -->
<intrinsic tech='MMX' rettype='__m64' name='_mm_srai_pi32'>
	<CPUID>MMX</CPUID>
	<category>Shift</category>
	<parameter varname='a' type='__m64'/>
	<parameter varname='imm' type='int'/>
	<description>Shift packed 32-bit integers in "a" right by "imm" while shifting in sign bits, and store the results in "dst". </description>
	<description code='true'>
FOR j := 0 to 1
	i := j*32
	IF imm &gt; 31
		dst[i+31:i] := SignBit
	ELSE
		dst[i+31:i] := SignExtend(a[i+31:i] &gt;&gt; imm)
	FI
ENDFOR
	</description>
	<mnemonic base='psrad' parameters="mm, mm"/>
	<header>mmintrin.h</header>
</intrinsic>


<!-- _mm_srl_pi16 / psrlw -->
<intrinsic tech='MMX' rettype='__m64' name='_mm_srl_pi16'>
	<CPUID>MMX</CPUID>
	<category>Shift</category>
	<parameter varname='a' type='__m64'/>
	<parameter varname='count' type='__m64'/>
	<description>Shift packed 16-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst". </description>
	<description code='true'>
FOR j := 0 to 3
	i := j*16
	IF count[63:0] &gt; 15
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := ZeroExtend(a[i+15:i] &gt;&gt; count[63:0])
	FI
ENDFOR
	</description>
	<mnemonic base='psrlw' parameters="mm, mm/imm8"/>
	<header>mmintrin.h</header>
</intrinsic>


<!-- _mm_srli_pi16 / psrlw -->
<intrinsic tech='MMX' rettype='__m64' name='_mm_srli_pi16'>
	<CPUID>MMX</CPUID>
	<category>Shift</category>
	<parameter varname='a' type='__m64'/>
	<parameter varname='imm' type='int'/>
	<description>Shift packed 16-bit integers in "a" right by "imm" while shifting in zeros, and store the results in "dst". </description>
	<description code='true'>
FOR j := 0 to 3
	i := j*16
	IF imm &gt; 15
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := ZeroExtend(a[i+15:i] &gt;&gt; imm)
	FI
ENDFOR
	</description>
	<mnemonic base='psrlw'/>
	<header>mmintrin.h</header>
</intrinsic>


<!-- _mm_srl_pi32 / psrld -->
<intrinsic tech='MMX' rettype='__m64' name='_mm_srl_pi32'>
	<CPUID>MMX</CPUID>
	<category>Shift</category>
	<parameter varname='a' type='__m64'/>
	<parameter varname='count' type='__m64'/>
	<description>Shift packed 32-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst". </description>
	<description code='true'>
FOR j := 0 to 1
	i := j*32
	IF count[63:0] &gt; 31
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := ZeroExtend(a[i+31:i] &gt;&gt; count[63:0])
	FI
ENDFOR
	</description>
	<mnemonic base='psrld' parameters="mm, mm"/>
	<header>mmintrin.h</header>
</intrinsic>


<!-- _mm_srli_pi32 / psrld -->
<intrinsic tech='MMX' rettype='__m64' name='_mm_srli_pi32'>
	<CPUID>MMX</CPUID>
	<category>Shift</category>
	<parameter varname='a' type='__m64'/>
	<parameter varname='imm' type='int'/>
	<description>Shift packed 32-bit integers in "a" right by "imm" while shifting in zeros, and store the results in "dst".</description>
	<description code='true'>
FOR j := 0 to 1
	i := j*32
	IF imm &gt; 31
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := ZeroExtend(a[i+31:i] &gt;&gt; imm)
	FI
ENDFOR
	</description>
	<mnemonic base='psrld'/>
	<header>mmintrin.h</header>
</intrinsic>


<!-- _mm_srl_si64 / psrlq -->
<intrinsic tech='MMX' rettype='__m64' name='_mm_srl_si64'>
	<CPUID>MMX</CPUID>
	<category>Shift</category>
	<parameter varname='a' type='__m64'/>
	<parameter varname='count' type='__m64'/>
	<description>Shift 64-bit integer "a" right by "count" while shifting in zeros, and store the result in "dst". </description>
	<description code='true'>
IF count[63:0] &gt; 63
	dst[63:0] := 0
ELSE
	dst[63:0] := ZeroExtend(a[63:0] &gt;&gt; count[63:0])
FI
	</description>
	<mnemonic base='psrlq'/>
	<header>mmintrin.h</header>
</intrinsic>


<!-- _mm_srli_si64 / psrlq -->
<intrinsic tech='MMX' rettype='__m64' name='_mm_srli_si64'>
	<CPUID>MMX</CPUID>
	<category>Shift</category>
	<parameter varname='a' type='__m64'/>
	<parameter varname='imm' type='int'/>
	<description>Shift 64-bit integer "a" right by "imm" while shifting in zeros, and store the result in "dst". </description>
	<description code='true'>
IF imm &gt; 63
	dst[63:0] := 0
ELSE
	dst[63:0] := ZeroExtend(a[63:0] &gt;&gt; imm)
FI
	</description>
	<mnemonic base='psrlq'/>
	<header>mmintrin.h</header>
</intrinsic>


<!-- _mm_and_si64 / pand -->
<intrinsic tech='MMX' rettype='__m64' name='_mm_and_si64'>
	<CPUID>MMX</CPUID>
	<category>Logical</category>
	<parameter varname='a' type='__m64'/>
	<parameter varname='b' type='__m64'/>
	<description>Compute the bitwise AND of 64 bits (representing integer data) in "a" and "b", and store the result in "dst".</description>
	<description code='true'>
dst[63:0] := (a[63:0] AND b[63:0])
	</description>
	<mnemonic base='pand'/>
	<header>mmintrin.h</header>
</intrinsic>


<!-- _mm_andnot_si64 / pandn -->
<intrinsic tech='MMX' rettype='__m64' name='_mm_andnot_si64'>
	<CPUID>MMX</CPUID>
	<category>Logical</category>
	<parameter varname='a' type='__m64'/>
	<parameter varname='b' type='__m64'/>
	<description>Compute the bitwise AND NOT of 64 bits (representing integer data) in "a" and "b", and store the result in "dst".</description>
	<description code='true'>
dst[63:0] := ((NOT a[63:0]) AND b[63:0])
	</description>
	<mnemonic base='pandn'/>
	<header>mmintrin.h</header>
</intrinsic>


<!-- _mm_or_si64 / por -->
<intrinsic tech='MMX' rettype='__m64' name='_mm_or_si64'>
	<CPUID>MMX</CPUID>
	<category>Logical</category>
	<parameter varname='a' type='__m64'/>
	<parameter varname='b' type='__m64'/>
	<description>Compute the bitwise OR of 64 bits (representing integer data) in "a" and "b", and store the result in "dst".</description>
	<description code='true'>
dst[63:0] := (a[63:0] OR b[63:0])
	</description>
	<mnemonic base='por' parameters="mm, mm"/>
	<header>mmintrin.h</header>
</intrinsic>


<!-- _mm_xor_si64 / pxor -->
<intrinsic tech='MMX' rettype='__m64' name='_mm_xor_si64'>
	<CPUID>MMX</CPUID>
	<category>Logical</category>
	<parameter varname='a' type='__m64'/>
	<parameter varname='b' type='__m64'/>
	<description>Compute the bitwise OR of 64 bits (representing integer data) in "a" and "b", and store the result in "dst".</description>
	<description code='true'>
dst[63:0] := (a[63:0] XOR b[63:0])
	</description>
	<mnemonic base='pxor' parameters="mm, mm"/>
	<header>mmintrin.h</header>
</intrinsic>


<!-- _mm_cmpeq_pi8 / pcmpeqb -->
<intrinsic tech='MMX' rettype='__m64' name='_mm_cmpeq_pi8'>
	<CPUID>MMX</CPUID>
	<category>Compare</category>
	<parameter varname='a' type='__m64'/>
	<parameter varname='b' type='__m64'/>
	<description>Compare packed 8-bit integers in "a" and "b" for equality, and store the results in "dst".</description>
	<description code='true'>
FOR j := 0 to 7
  i := j*8
  dst[i+7:i] := ( a[i+7:i] == b[i+7:i] ) ? 0xFF : 0
ENDFOR
	</description>
	<mnemonic base='pcmpeqb' parameters="mm, mm"/>
	<header>mmintrin.h</header>
</intrinsic>


<!-- _mm_cmpeq_pi16 / pcmpeqw -->
<intrinsic tech='MMX' rettype='__m64' name='_mm_cmpeq_pi16'>
	<CPUID>MMX</CPUID>
	<category>Compare</category>
	<parameter varname='a' type='__m64'/>
	<parameter varname='b' type='__m64'/>
	<description>Compare packed 16-bit integers in "a" and "b" for equality, and store the results in "dst".</description>
	<description code='true'>
FOR j := 0 to 3
  i := j*16
  dst[i+15:i] := ( a[i+15:i] == b[i+15:i] ) ? 0xFFFF : 0
ENDFOR
	</description>
	<mnemonic base='pcmpeqw' parameters="mm, mm"/>
	<header>mmintrin.h</header>
</intrinsic>


<!-- _mm_cmpeq_pi32 / pcmpeqd -->
<intrinsic tech='MMX' rettype='__m64' name='_mm_cmpeq_pi32'>
	<CPUID>MMX</CPUID>
	<category>Compare</category>
	<parameter varname='a' type='__m64'/>
	<parameter varname='b' type='__m64'/>
	<description>Compare packed 32-bit integers in "a" and "b" for equality, and store the results in "dst".</description>
	<description code='true'>
FOR j := 0 to 1
  i := j*32
  dst[i+31:i] := ( a[i+31:i] == b[i+31:i] ) ? 0xFFFFFFFF : 0
ENDFOR
	</description>
	<mnemonic base='pcmpeqd' parameters="mm, mm"/>
	<header>mmintrin.h</header>
</intrinsic>


<!-- _mm_cmpgt_pi8 / pcmpgtb -->
<intrinsic tech='MMX' rettype='__m64' name='_mm_cmpgt_pi8'>
	<CPUID>MMX</CPUID>
	<category>Compare</category>
	<parameter varname='a' type='__m64'/>
	<parameter varname='b' type='__m64'/>
	<description>Compare packed 8-bit integers in "a" and "b" for greater-than, and store the results in "dst".</description>
	<description code='true'>
FOR j := 0 to 7
  i := j*8
  dst[i+7:i] := ( a[i+7:i] &gt; b[i+7:i] ) ? 0xFF : 0
ENDFOR
	</description>
	<mnemonic base='pcmpgtb'/>
	<header>mmintrin.h</header>
</intrinsic>


<!-- _mm_cmpgt_pi16 / pcmpgtw -->
<intrinsic tech='MMX' rettype='__m64' name='_mm_cmpgt_pi16'>
	<CPUID>MMX</CPUID>
	<category>Compare</category>
	<parameter varname='a' type='__m64'/>
	<parameter varname='b' type='__m64'/>
	<description>Compare packed 16-bit integers in "a" and "b" for greater-than, and store the results in "dst".</description>
	<description code='true'>
FOR j := 0 to 3
  i := j*16
  dst[i+15:i] := ( a[i+15:i] &gt; b[i+15:i] ) ? 0xFFFF : 0
ENDFOR
	</description>
	<mnemonic base='pcmpgtw' parameters="mm, mm"/>
	<header>mmintrin.h</header>
</intrinsic>


<!-- _mm_cmpgt_pi32 / pcmpgtd -->
<intrinsic tech='MMX' rettype='__m64' name='_mm_cmpgt_pi32'>
	<CPUID>MMX</CPUID>
	<category>Compare</category>
	<parameter varname='a' type='__m64'/>
	<parameter varname='b' type='__m64'/>
	<description>Compare packed 32-bit integers in "a" and "b" for greater-than, and store the results in "dst".</description>
	<description code='true'>
FOR j := 0 to 1
  i := j*32
  dst[i+31:i] := ( a[i+31:i] &gt; b[i+31:i] ) ? 0xFFFFFFFF : 0
ENDFOR
	</description>
	<mnemonic base='pcmpgtd'/>
	<header>mmintrin.h</header>
</intrinsic>


<!-- _mm_cvtsi32_si64 / movd -->
<intrinsic tech='MMX' rettype='__m64' name='_mm_cvtsi32_si64'>
	<CPUID>MMX</CPUID>
	<category>Convert</category>
	<parameter varname='a' type='int'/>
	<description>Copy 32-bit integer "a" to the lower elements of "dst", and zero the upper element of "dst".</description>
	<description code='true'>
dst[31:0] := a[31:0]
dst[63:32] := 0
	</description>
	<mnemonic base='movd' parameters="mm, r32"/>
	<header>mmintrin.h</header>
</intrinsic>


<!-- _mm_cvtsi64_si32 / movd -->
<intrinsic tech='MMX' rettype='int' name='_mm_cvtsi64_si32'>
	<CPUID>MMX</CPUID>
	<category>Convert</category>
	<parameter varname='a' type='__m64'/>
	<description>Copy the lower 32-bit integer in "a" to "dst".</description>
	<description code='true'>
dst[31:0] := a[31:0]
	</description>
	<mnemonic base='movd' parameters="r32, mm"/>
	<header>mmintrin.h</header>
</intrinsic>


<!-- _mm_cvtm64_si64 / movq -->
<intrinsic tech='MMX' rettype='__int64' name='_mm_cvtm64_si64'>
	<CPUID>MMX</CPUID>
	<category>Convert</category>
	<parameter varname='a' type='__m64'/>
	<description>Copy 64-bit integer "a" to "dst".</description>
	<description code='true'>
dst[63:0] := a[63:0]
	</description>
	<mnemonic base='movq' parameters="r64, mm"/>
	<header>mmintrin.h</header>
</intrinsic>


<!-- _mm_cvtsi64_m64 / movq -->
<intrinsic tech='MMX' rettype='__m64' name='_mm_cvtsi64_m64'>
	<CPUID>MMX</CPUID>
	<category>Convert</category>
	<parameter varname='a' type='__int64'/>
	<description>Copy 64-bit integer "a" to "dst".</description>
	<description code='true'>
dst[63:0] := a[63:0]
	</description>
	<mnemonic base='movq' parameters="mm, r64"/>
	<header>mmintrin.h</header>
</intrinsic>


<!-- _mm_setzero_si64 / pxor -->
<intrinsic tech='MMX' rettype='__m64' name='_mm_setzero_si64'>
	<CPUID>MMX</CPUID>
	<category>Set</category>
	<description>Return vector of type __m64 with all elements set to zero.</description>
	<description code='true'>
dst[MAX:0] := 0
	</description>
	<mnemonic base='pxor'/>
	<header>mmintrin.h</header>
</intrinsic>


<!-- _mm_set_pi32 / pxor -->
<intrinsic tech='MMX' sequence='true' rettype='__m64' name='_mm_set_pi32'>
	<CPUID>MMX</CPUID>
	<category>Set</category>
	<parameter varname='e1' type='int'/>
	<parameter varname='e0' type='int'/>
	<description>Set packed 32-bit integers in "dst" with the supplied values.</description>
	<description code='true'>
dst[31:0] := e1
dst[63:32] := e0
	</description>
	<header>mmintrin.h</header>
</intrinsic>


<!-- _mm_set_pi16 / pxor -->
<intrinsic tech='MMX' sequence='true' rettype='__m64' name='_mm_set_pi16'>
	<CPUID>MMX</CPUID>
	<category>Set</category>
	<parameter varname='e3' type='short'/>
	<parameter varname='e2' type='short'/>
	<parameter varname='e1' type='short'/>
	<parameter varname='e0' type='short'/>
	<description>Set packed 16-bit integers in "dst" with the supplied values.</description>
	<description code='true'>
dst[15:0] := e3
dst[31:16] := e2
dst[47:32] := e1
dst[63:48] := e0
	</description>
	<header>mmintrin.h</header>
</intrinsic>


<!-- _mm_set_pi8 / pxor -->
<intrinsic tech='MMX' sequence='true' rettype='__m64' name='_mm_set_pi8'>
	<CPUID>MMX</CPUID>
	<category>Set</category>
	<parameter varname='e7' type='char'/>
	<parameter varname='e6' type='char'/>
	<parameter varname='e5' type='char'/>
	<parameter varname='e4' type='char'/>
	<parameter varname='e3' type='char'/>
	<parameter varname='e2' type='char'/>
	<parameter varname='e1' type='char'/>
	<parameter varname='e0' type='char'/>
	<description>Set packed 8-bit integers in "dst" with the supplied values in reverse order.</description>
	<description code='true'>
dst[7:0] := e7
dst[15:8] := e6
dst[23:16] := e5
dst[31:24] := e4
dst[39:32] := e3
dst[47:40] := e2
dst[55:48] := e1
dst[63:56] := e0
	</description>
	<header>mmintrin.h</header>
</intrinsic>


<!-- _mm_set1_pi32 / pxor -->
<intrinsic tech='MMX' sequence='true' rettype='__m64' name='_mm_set1_pi32'>
	<CPUID>MMX</CPUID>
	<category>Set</category>
	<parameter varname='a' type='int'/>
	<description>Broadcast 32-bit integer "a" to all elements of "dst".</description>
	<description code='true'>
FOR j := 0 to 1
	i := j*32
	dst[i+31:i] := a[31:0]
ENDFOR
	</description>
	<header>mmintrin.h</header>
</intrinsic>


<!-- _mm_set1_pi16 / pxor -->
<intrinsic tech='MMX' sequence='true' rettype='__m64' name='_mm_set1_pi16'>
	<CPUID>MMX</CPUID>
	<category>Set</category>
	<parameter varname='a' type='short'/>
	<description>Broadcast 16-bit integer "a" to all all elements of "dst".</description>
	<description code='true'>
FOR j := 0 to 3
	i := j*16
	dst[i+15:i] := a[15:0]
ENDFOR
	</description>
	<header>mmintrin.h</header>
</intrinsic>


<!-- _mm_set1_pi8 / pxor -->
<intrinsic tech='MMX' sequence='true' rettype='__m64' name='_mm_set1_pi8'>
	<CPUID>MMX</CPUID>
	<category>Set</category>
	<parameter varname='a' type='char'/>
	<description>Broadcast 8-bit integer "a" to all elements of "dst".</description>
	<description code='true'>
FOR j := 0 to 7
	i := j*8
	dst[i+7:i] := a[7:0]
ENDFOR
	</description>
	<header>mmintrin.h</header>
</intrinsic>


<!-- _mm_setr_pi32 / pxor -->
<intrinsic tech='MMX' sequence='true' rettype='__m64' name='_mm_setr_pi32'>
	<CPUID>MMX</CPUID>
	<category>Set</category>
	<parameter varname='e1' type='int'/>
	<parameter varname='e0' type='int'/>
	<description>Set packed 32-bit integers in "dst" with the supplied values in reverse order.</description>
	<description code='true'>
dst[31:0] := e0
dst[63:32] := e1
	</description>
	<header>mmintrin.h</header>
</intrinsic>


<!-- _mm_setr_pi16 / pxor -->
<intrinsic tech='MMX' sequence='true' rettype='__m64' name='_mm_setr_pi16'>
	<CPUID>MMX</CPUID>
	<category>Set</category>
	<parameter varname='e3' type='short'/>
	<parameter varname='e2' type='short'/>
	<parameter varname='e1' type='short'/>
	<parameter varname='e0' type='short'/>
	<description>Set packed 16-bit integers in "dst" with the supplied values in reverse order.</description>
	<description code='true'>
dst[15:0] := e0
dst[31:16] := e1
dst[47:32] := e2
dst[63:48] := e3
	</description>
	<header>mmintrin.h</header>
</intrinsic>


<!-- _mm_setr_pi8 / pxor -->
<intrinsic tech='MMX' sequence='true' rettype='__m64' name='_mm_setr_pi8'>
	<CPUID>MMX</CPUID>
	<category>Set</category>
	<parameter varname='e7' type='char'/>
	<parameter varname='e6' type='char'/>
	<parameter varname='e5' type='char'/>
	<parameter varname='e4' type='char'/>
	<parameter varname='e3' type='char'/>
	<parameter varname='e2' type='char'/>
	<parameter varname='e1' type='char'/>
	<parameter varname='e0' type='char'/>
	<description>Set packed 8-bit integers in "dst" with the supplied values in reverse order.</description>
	<description code='true'>
dst[7:0] := e0
dst[15:8] := e1
dst[23:16] := e2
dst[31:24] := e3
dst[39:32] := e4
dst[47:40] := e5
dst[55:48] := e6
dst[63:56] := e7
	</description>
	<header>mmintrin.h</header>
</intrinsic>


<!-- _mm_packs_pi16 / packsswb -->
<intrinsic tech='MMX' rettype='__m64' name='_mm_packs_pi16'>
	<CPUID>MMX</CPUID>
	<category>Miscellaneous</category>
	<parameter varname='a' type='__m64'/>
	<parameter varname='b' type='__m64'/>
	<description>Convert packed 16-bit integers from "a" and "b" to packed 8-bit integers using signed saturation, and store the results in "dst".
	</description>
	<description code='true'>
dst[7:0] := Saturate_Int16_To_Int8 (a[15:0])
dst[15:8] := Saturate_Int16_To_Int8 (a[31:16])
dst[23:16] := Saturate_Int16_To_Int8 (a[47:32])
dst[31:24] := Saturate_Int16_To_Int8 (a[63:48])
dst[39:32] := Saturate_Int16_To_Int8 (b[15:0])
dst[47:40] := Saturate_Int16_To_Int8 (b[31:16])
dst[55:48] := Saturate_Int16_To_Int8 (b[47:32])
dst[63:56] := Saturate_Int16_To_Int8 (b[63:48])
	</description>
	<mnemonic base='packsswb' parameters="mm, mm"/>
	<header>mmintrin.h</header>
</intrinsic>


<!-- _mm_packs_pi32 / packssdw -->
<intrinsic tech='MMX' rettype='__m64' name='_mm_packs_pi32'>
	<CPUID>MMX</CPUID>
	<category>Miscellaneous</category>
	<parameter varname='a' type='__m64'/>
	<parameter varname='b' type='__m64'/>
	<description>Convert packed 32-bit integers from "a" and "b" to packed 16-bit integers using signed saturation, and store the results in "dst".</description>
	<description code='true'>
dst[15:0] := Saturate_Int32_To_Int16 (a[31:0])
dst[31:16] := Saturate_Int32_To_Int16 (a[63:32])
dst[47:32] := Saturate_Int32_To_Int16 (b[31:0])
dst[63:48] := Saturate_Int32_To_Int16 (b[63:32])
	</description>
	<mnemonic base='packssdw' parameters="mm, mm"/>
	<header>mmintrin.h</header>
</intrinsic>


<!-- _mm_packs_pu16 / packuswb -->
<intrinsic tech='MMX' rettype='__m64' name='_mm_packs_pu16'>
	<CPUID>MMX</CPUID>
	<category>Miscellaneous</category>
	<parameter varname='a' type='__m64'/>
	<parameter varname='b' type='__m64'/>	
	<description>Convert packed 16-bit integers from "a" and "b" to packed 8-bit integers using unsigned saturation, and store the results in "dst".</description>
	<description code='true'>
dst[7:0] := Saturate_Int16_To_UnsignedInt8 (a[15:0])
dst[15:8] := Saturate_Int16_To_UnsignedInt8 (a[31:16])
dst[23:16] := Saturate_Int16_To_UnsignedInt8 (a[47:32])
dst[31:24] := Saturate_Int16_To_UnsignedInt8 (a[63:48])
dst[39:32] := Saturate_Int16_To_UnsignedInt8 (b[15:0])
dst[47:40] := Saturate_Int16_To_UnsignedInt8 (b[31:16])
dst[55:48] := Saturate_Int16_To_UnsignedInt8 (b[47:32])
dst[63:56] := Saturate_Int16_To_UnsignedInt8 (b[63:48])
	</description>
	<mnemonic base='packuswb' parameters="mm, mm"/>
	<header>mmintrin.h</header>
</intrinsic>


<!-- _mm_unpackhi_pi8 / punpckhbw -->
<intrinsic tech='MMX' rettype='__m64' name='_mm_unpackhi_pi8'>
	<CPUID>MMX</CPUID>
	<category>Miscellaneous</category>
	<parameter varname='a' type='__m64'/>
	<parameter varname='b' type='__m64'/>
	<description>Unpack and interleave 8-bit integers from the high half of "a" and "b", and store the results in "dst". </description>
	<description code='true'>
INTERLEAVE_HIGH_BYTES(src1[63:0], src2[63:0]){
	dst[7:0] := src1[39:32]
	dst[15:8] := src2[39:32] 
	dst[23:16] := src1[47:40]
	dst[31:24] := src2[47:40]
	dst[39:32] := src1[55:48]
	dst[47:40] := src2[55:48]
	dst[55:48] := src1[63:56]
	dst[63:56] := src2[63:56]
	RETURN dst[63:0]
}	
	
dst[63:0] := INTERLEAVE_HIGH_BYTES(a[63:0], b[63:0])
	</description>
	<mnemonic base='punpckhbw' parameters="mm, mm"/>
	<header>mmintrin.h</header>
</intrinsic>


<!-- _mm_unpackhi_pi16 / punpcklbw -->
<intrinsic tech='MMX' rettype='__m64' name='_mm_unpackhi_pi16'>
	<CPUID>MMX</CPUID>
	<category>Miscellaneous</category>
	<parameter varname='a' type='__m64'/>
	<parameter varname='b' type='__m64'/>
	<description>Unpack and interleave 16-bit integers from the high half of "a" and "b", and store the results in "dst". </description>
	<description code='true'>
INTERLEAVE_HIGH_WORDS(src1[63:0], src2[63:0]){
	dst[15:0] := src1[47:32]
	dst[31:16] := src2[47:32]
	dst[47:32] := src1[63:48]
	dst[63:48] := src2[63:48]
	RETURN dst[63:0]
}

dst[63:0] := INTERLEAVE_HIGH_WORDS(a[63:0], b[63:0])
	</description>
	<mnemonic base='punpcklbw' parameters="mm, mm"/>
	<header>mmintrin.h</header>
</intrinsic>


<!-- _mm_unpackhi_pi32 / punpckhdq -->
<intrinsic tech='MMX' rettype='__m64' name='_mm_unpackhi_pi32'>
	<CPUID>MMX</CPUID>
	<category>Miscellaneous</category>
	<parameter varname='a' type='__m64'/>
	<parameter varname='b' type='__m64'/>
	<description>Unpack and interleave 32-bit integers from the high half of "a" and "b", and store the results in "dst".</description>
	<description code='true'>
dst[31:0] := a[63:32]
dst[63:32] := b[63:32]
	</description>
	<mnemonic base='punpckhdq' parameters="mm, mm"/>
	<header>mmintrin.h</header>
</intrinsic>


<!-- _mm_unpacklo_pi8 / punpcklbw -->
<intrinsic tech='MMX' rettype='__m64' name='_mm_unpacklo_pi8'>
	<CPUID>MMX</CPUID>
	<category>Miscellaneous</category>
	<parameter varname='a' type='__m64'/>
	<parameter varname='b' type='__m64'/>
	<description>Unpack and interleave 8-bit integers from the low half of "a" and "b", and store the results in "dst". </description>
	<description code='true'>
INTERLEAVE_BYTES(src1[63:0], src2[63:0]){
	dst[7:0] := src1[7:0] 
	dst[15:8] := src2[7:0] 
	dst[23:16] := src1[15:8] 
	dst[31:24] := src2[15:8] 
	dst[39:32] := src1[23:16] 
	dst[47:40] := src2[23:16] 
	dst[55:48] := src1[31:24] 
	dst[63:56] := src2[31:24] 
	RETURN dst[63:0]
}	

dst[63:0] := INTERLEAVE_BYTES(a[63:0], b[63:0])
	</description>
	<mnemonic base='punpcklbw' parameters="mm, mm"/>
	<header>mmintrin.h</header>
</intrinsic>


<!-- _mm_unpacklo_pi16 / punpcklwd -->
<intrinsic tech='MMX' rettype='__m64' name='_mm_unpacklo_pi16'>
	<CPUID>MMX</CPUID>
	<category>Miscellaneous</category>
	<parameter varname='a' type='__m64'/>
	<parameter varname='b' type='__m64'/>
	<description>Unpack and interleave 16-bit integers from the low half of "a" and "b", and store the results in "dst". </description>
	<description code='true'>
INTERLEAVE_WORDS(src1[63:0], src2[63:0]){
	dst[15:0] := src1[15:0] 
	dst[31:16] := src2[15:0] 
	dst[47:32] := src1[31:16] 
	dst[63:48] := src2[31:16] 
	RETURN dst[63:0]
}	

dst[63:0] := INTERLEAVE_WORDS(a[63:0], b[63:0])
	</description>
	<mnemonic base='punpcklwd' parameters="mm, mm"/>
	<header>mmintrin.h</header>
</intrinsic>


<!-- _mm_unpacklo_pi32 / punpckldq -->
<intrinsic tech='MMX' rettype='__m64' name='_mm_unpacklo_pi32'>
	<CPUID>MMX</CPUID>
	<category>Miscellaneous</category>
	<parameter varname='a' type='__m64'/>
	<parameter varname='b' type='__m64'/>
	<description>Unpack and interleave 32-bit integers from the low half of "a" and "b", and store the results in "dst". </description>
	<description code='true'>
dst[31:0] := a[31:0]
dst[63:32] := b[31:0]
	</description>
	<mnemonic base='punpckldq' parameters="mm, mm"/>
	<header>mmintrin.h</header>
</intrinsic>


</intrinsic_list>
