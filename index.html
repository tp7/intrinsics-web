

<html>
    <head>
        <meta charset="utf-8" />
        <title>Intel intrinsic functions</title>
        <link href="http://netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/css/bootstrap-combined.no-icons.min.css" rel="stylesheet">
        <link href="http://netdna.bootstrapcdn.com/font-awesome/3.2.1/css/font-awesome.min.css" rel="stylesheet">

        <style>
		body {
    margin: 15px;
    font-family: sans-serif;
}

.container {
    position: relative;
    width: 100%;
}

.left-column {
    position: absolute;
    top: 0;
    left: 0;
    width: 200px;
}

    .left-column input[type=text] {
        margin-bottom: 0;
        width: 184px;
        height: 30px;
    }

    .left-column i {
        vertical-align: middle;
        cursor: pointer;
    }

        .left-column i:hover {
            color: #962323;
        }

    .left-column button {
        margin-top: 10px;
        padding-right: 0;
        padding-left: 0;
        width: 92px;
    }

.right-column {
    margin-left: 250px;
    min-width: 420px;
}

.text-gray {
    color: #9f9f9f;
}

.type {
    color: #1919cb;
}

.item {
    margin: 5px 0;
    padding: 5px;
}

    .item h5 {
        margin-top: 0;
        margin-left: 5px;
        padding-top: 5px;
    }

    .item .header {
        padding: 2px 5px;
        border-top-left-radius: 5px;
        border-top-right-radius: 5px;
        background-color: #F8F8F8;
        font-family: Consolas, monospace;
        cursor: pointer;
    }

        .item .header.collapsed {
            border-radius: 5px;
        }

    .item p {
        margin: 0 12px;
    }

    .item .body {
        border-bottom-right-radius: 5px;
        border-bottom-left-radius: 5px;
        background-color: #FCFCFC;
    }

    .item .instruction {
        margin-right: 5px;
    }

    .item .code {
        padding: 5px;
        background-color: #F1F1F1;
        white-space: pre-wrap;
        font-family: Consolas, monospace;
    }

    .item .table {
        margin-left: 5px;
        width: 450px;
        font-size: 11px;
    }

        .item .table td,
        .item .table th {
            padding: 0 3px;
        }

		</style>
        <script>
            var FUNCTIONS_DATA = [{"name":"_m_from_int64","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Convert","description":"Copy 64-bit integer \"a\" to \"dst\".","code":"dst[63:0] := a[63:0]","header":"mmintrin.h","instruction":"movq","parameters":[{"type":"__int64","name":"a"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"6","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"6","throughput":"1"}]},{"name":"_m_to_int64","tech":"MMX","returnType":"__int64","cpuId":"MMX","category":"Convert","description":"Copy 64-bit integer \"a\" to \"dst\".","code":"dst[63:0] := a[63:0]","header":"mmintrin.h","instruction":"movq","parameters":[{"type":"__m64","name":"a"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"6","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"6","throughput":"1"}]},{"name":"_m_empty","tech":"MMX","returnType":"void","cpuId":"MMX","category":"General Support","description":"Empty the MMX state, which marks the x87 FPU registers as available for use by x87 instructions. This instruction must be used at the end of all MMX technology procedures.","code":null,"header":"mmintrin.h","instruction":"emms","parameters":[{"type":"void","name":""}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_17","parameters":"","latency":"","throughput":"6"},{"base":"06_0E","parameters":"","latency":"6","throughput":"5"},{"base":"06_0D","parameters":"","latency":"6","throughput":"5"},{"base":"0F_02","parameters":"","latency":"12","throughput":"12"}]},{"name":"_m_from_int","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Convert","description":"Copy 32-bit integer \"a\" to the lower elements of \"dst\", and zero the upper element of \"dst\".","code":"dst[31:0] := a[31:0]\ndst[63:32] := 0","header":"mmintrin.h","instruction":"movd","parameters":[{"type":"int","name":"a"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, r32","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, r32","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, r32","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, r32","latency":"1","throughput":"0.5"},{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, r64","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, r64","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, r64","latency":"1","throughput":"0.5"},{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"r32, xmm","latency":"2","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"r32, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"r32, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"r32, xmm","latency":"1","throughput":"0.33"},{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"r64, xmm","latency":"1","throughput":"0.33"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"r64, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"r64, xmm","latency":"1","throughput":"0.33"},{"base":"0F_03","parameters":"r32, xmm","latency":"10","throughput":"1"},{"base":"0F_02","parameters":"r32, xmm","latency":"10","throughput":"1"},{"base":"0F_03","parameters":"xmm, r32","latency":"6","throughput":"2"},{"base":"0F_02","parameters":"xmm, r32","latency":"6","throughput":"2"},{"base":"06_0F","parameters":"mm, r32","latency":"1","throughput":"0.5"},{"base":"06_0E","parameters":"mm, r32","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, r32","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"r32, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"r32, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"r32, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, r32","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, r32","latency":"2","throughput":"1"},{"base":"0F_03","parameters":"r32, mm","latency":"5","throughput":"1"},{"base":"0F_02","parameters":"r32, mm","latency":"5","throughput":"1"}]},{"name":"_m_to_int","tech":"MMX","returnType":"int","cpuId":"MMX","category":"Convert","description":"Copy the lower 32-bit integer in \"a\" to \"dst\".","code":"dst[31:0] := a[31:0]","header":"mmintrin.h","instruction":"movd","parameters":[{"type":"__m64","name":"a"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, r32","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, r32","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, r32","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, r32","latency":"1","throughput":"0.5"},{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, r64","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, r64","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, r64","latency":"1","throughput":"0.5"},{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"r32, xmm","latency":"2","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"r32, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"r32, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"r32, xmm","latency":"1","throughput":"0.33"},{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"r64, xmm","latency":"1","throughput":"0.33"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"r64, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"r64, xmm","latency":"1","throughput":"0.33"},{"base":"0F_03","parameters":"r32, xmm","latency":"10","throughput":"1"},{"base":"0F_02","parameters":"r32, xmm","latency":"10","throughput":"1"},{"base":"0F_03","parameters":"xmm, r32","latency":"6","throughput":"2"},{"base":"0F_02","parameters":"xmm, r32","latency":"6","throughput":"2"},{"base":"06_0F","parameters":"mm, r32","latency":"1","throughput":"0.5"},{"base":"06_0E","parameters":"mm, r32","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, r32","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"r32, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"r32, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"r32, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, r32","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, r32","latency":"2","throughput":"1"},{"base":"0F_03","parameters":"r32, mm","latency":"5","throughput":"1"},{"base":"0F_02","parameters":"r32, mm","latency":"5","throughput":"1"}]},{"name":"_m_packsswb","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Miscellaneous","description":"Convert packed 16-bit integers from \"a\" and \"b\" to packed 8-bit integers using signed saturation, and store the results in \"dst\".","code":"dst[7:0] := Saturate_Int16_To_Int8 (a[15:0])\ndst[15:8] := Saturate_Int16_To_Int8 (a[31:16])\ndst[23:16] := Saturate_Int16_To_Int8 (a[47:32])\ndst[31:24] := Saturate_Int16_To_Int8 (a[63:48])\ndst[39:32] := Saturate_Int16_To_Int8 (b[15:0])\ndst[47:40] := Saturate_Int16_To_Int8 (b[31:16])\ndst[55:48] := Saturate_Int16_To_Int8 (b[47:32])\ndst[63:56] := Saturate_Int16_To_Int8 (b[63:48])","header":"mmintrin.h","instruction":"packsswb","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_0E","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_m_packssdw","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Miscellaneous","description":"Convert packed 32-bit integers from \"a\" and \"b\" to packed 16-bit integers using signed saturation, and store the results in \"dst\".","code":"dst[15:0] := Saturate_Int32_To_Int16 (a[31:0])\ndst[31:16] := Saturate_Int32_To_Int16 (a[63:32])\ndst[47:32] := Saturate_Int32_To_Int16 (b[31:0])\ndst[63:48] := Saturate_Int32_To_Int16 (b[63:32])","header":"mmintrin.h","instruction":"packssdw","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_0E","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_m_packuswb","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Miscellaneous","description":"Convert packed 16-bit integers from \"a\" and \"b\" to packed 8-bit integers using unsigned saturation, and store the results in \"dst\".","code":"dst[7:0] := Saturate_Int16_To_UnsignedInt8 (a[15:0])\ndst[15:8] := Saturate_Int16_To_UnsignedInt8 (a[31:16])\ndst[23:16] := Saturate_Int16_To_UnsignedInt8 (a[47:32])\ndst[31:24] := Saturate_Int16_To_UnsignedInt8 (a[63:48])\ndst[39:32] := Saturate_Int16_To_UnsignedInt8 (b[15:0])\ndst[47:40] := Saturate_Int16_To_UnsignedInt8 (b[31:16])\ndst[55:48] := Saturate_Int16_To_UnsignedInt8 (b[47:32])\ndst[63:56] := Saturate_Int16_To_UnsignedInt8 (b[63:48])","header":"mmintrin.h","instruction":"packuswb","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_0E","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_m_punpckhbw","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Swizzle","description":"Unpack and interleave 8-bit integers from the high half of \"a\" and \"b\", and store the results in \"dst\".","code":"INTERLEAVE_HIGH_BYTES(src1[63:0], src2[63:0]){\n\tdst[7:0] := src1[39:32]\n\tdst[15:8] := src2[39:32] \n\tdst[23:16] := src1[47:40]\n\tdst[31:24] := src2[47:40]\n\tdst[39:32] := src1[55:48]\n\tdst[47:40] := src2[55:48]\n\tdst[55:48] := src1[63:56]\n\tdst[63:56] := src2[63:56]\n\tRETURN dst[63:0]\n}\t\n\t\ndst[63:0] := INTERLEAVE_HIGH_BYTES(a[63:0], b[63:0])","header":"mmintrin.h","instruction":"punpckhbw","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_0E","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_m_punpckhwd","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Swizzle","description":"Unpack and interleave 16-bit integers from the high half of \"a\" and \"b\", and store the results in \"dst\".","code":"INTERLEAVE_HIGH_WORDS(src1[63:0], src2[63:0]){\n\tdst[15:0] := src1[47:32]\n\tdst[31:16] := src2[47:32]\n\tdst[47:32] := src1[63:48]\n\tdst[63:48] := src2[63:48]\n\tRETURN dst[63:0]\n}\n\ndst[63:0] := INTERLEAVE_HIGH_WORDS(a[63:0], b[63:0])","header":"mmintrin.h","instruction":"punpcklbw","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_0E","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_m_punpckhdq","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Swizzle","description":"Unpack and interleave 32-bit integers from the high half of \"a\" and \"b\", and store the results in \"dst\".","code":"dst[31:0] := a[63:32]\ndst[63:32] := b[63:32]","header":"mmintrin.h","instruction":"punpckhdq","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_0E","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_m_punpcklbw","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Swizzle","description":"Unpack and interleave 8-bit integers from the low half of \"a\" and \"b\", and store the results in \"dst\".","code":"INTERLEAVE_BYTES(src1[63:0], src2[63:0]){\n\tdst[7:0] := src1[7:0] \n\tdst[15:8] := src2[7:0] \n\tdst[23:16] := src1[15:8] \n\tdst[31:24] := src2[15:8] \n\tdst[39:32] := src1[23:16] \n\tdst[47:40] := src2[23:16] \n\tdst[55:48] := src1[31:24] \n\tdst[63:56] := src2[31:24] \n\tRETURN dst[63:0]\n}\t\n\ndst[63:0] := INTERLEAVE_BYTES(a[63:0], b[63:0])","header":"mmintrin.h","instruction":"punpcklbw","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_0E","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_m_punpcklwd","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Swizzle","description":"Unpack and interleave 16-bit integers from the low half of \"a\" and \"b\", and store the results in \"dst\".","code":"INTERLEAVE_WORDS(src1[63:0], src2[63:0]){\n\tdst[15:0] := src1[15:0] \n\tdst[31:16] := src2[15:0] \n\tdst[47:32] := src1[31:16] \n\tdst[63:48] := src2[31:16] \n\tRETURN dst[63:0]\n}\t\n\ndst[63:0] := INTERLEAVE_WORDS(a[63:0], b[63:0])","header":"mmintrin.h","instruction":"punpcklwd","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_0E","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_m_punpckldq","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Swizzle","description":"Unpack and interleave 32-bit integers from the low half of \"a\" and \"b\", and store the results in \"dst\".","code":"dst[31:0] := a[31:0]\ndst[63:32] := b[31:0]","header":"mmintrin.h","instruction":"punpckldq","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_0E","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_m_paddb","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Arithmetic","description":"Add packed 8-bit integers in \"a\" and \"b\", and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*8\n\tdst[i+7:i] := a[i+7:i] + b[i+7:i]\nENDFOR","header":"mmintrin.h","instruction":"paddb","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_m_paddw","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Arithmetic","description":"Add packed 16-bit integers in \"a\" and \"b\", and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*16\n\tdst[i+15:i] := a[i+15:i] + b[i+15:i]\nENDFOR","header":"mmintrin.h","instruction":"paddw","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_m_paddd","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Arithmetic","description":"Add packed 32-bit integers in \"a\" and \"b\", and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*32\n\tdst[i+31:i] := a[i+31:i] + b[i+31:i]\nENDFOR","header":"mmintrin.h","instruction":"paddd","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_m_paddsb","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Arithmetic","description":"Add packed 8-bit integers in \"a\" and \"b\" using saturation, and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*8\n\tdst[i+7:i] := Saturate_To_Int8( a[i+7:i] + b[i+7:i] )\nENDFOR","header":"mmintrin.h","instruction":"paddsb","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_m_paddsw","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Arithmetic","description":"Add packed 16-bit integers in \"a\" and \"b\" using saturation, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*16\n\tdst[i+15:i] := Saturate_To_Int16( a[i+15:i] + b[i+15:i] )\nENDFOR","header":"mmintrin.h","instruction":"paddsw","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_m_paddusb","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Arithmetic","description":"Add packed unsigned 8-bit integers in \"a\" and \"b\" using saturation, and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*8\n\tdst[i+7:i] := Saturate_To_UnsignedInt8( a[i+7:i] + b[i+7:i] )\nENDFOR","header":"mmintrin.h","instruction":"paddusb","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_m_paddusw","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Arithmetic","description":"Add packed unsigned 16-bit integers in \"a\" and \"b\" using saturation, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*16\n\tdst[i+15:i] := Saturate_To_UnsignedInt16( a[i+15:i] + b[i+15:i] )\nENDFOR","header":"mmintrin.h","instruction":"paddusw","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_m_psubb","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Arithmetic","description":"Subtract packed 8-bit integers in \"b\" from packed 8-bit integers in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*8\n\tdst[i+7:i] := a[i+7:i] - b[i+7:i]\nENDFOR","header":"mmintrin.h","instruction":"psubb","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"BD xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"BD xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"BD xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"BD xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"0.5","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_m_psubw","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Arithmetic","description":"Subtract packed 16-bit integers in \"b\" from packed 16-bit integers in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*16\n\tdst[i+15:i] := a[i+15:i] - b[i+15:i]\nENDFOR","header":"mmintrin.h","instruction":"psubw","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"BD xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"BD xmm, xmm","latency":"1","throughput":"0.33"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"0.5","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_m_psubd","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Arithmetic","description":"Subtract packed 32-bit integers in \"b\" from packed 32-bit integers in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*32\n\tdst[i+31:i] := a[i+31:i] - b[i+31:i]\nENDFOR","header":"mmintrin.h","instruction":"psubd","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"BD xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"BD xmm, xmm","latency":"1","throughput":"0.33"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"0.5","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_m_psubsb","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Arithmetic","description":"Subtract packed 8-bit integers in \"b\" from packed 8-bit integers in \"a\" using saturation, and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*8\n\tdst[i+7:i] := Saturate_To_Int8(a[i+7:i] - b[i+7:i])\t\nENDFOR","header":"mmintrin.h","instruction":"psubsb","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"SUBUSB/PSUBUSW xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"SUBUSB/PSUBUSW xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"SUBUSB/PSUBUSW xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"SUBUSB/PSUBUSW xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"0.5","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_m_psubsw","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Arithmetic","description":"Subtract packed 16-bit integers in \"b\" from packed 16-bit integers in \"a\" using saturation, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*16\n\tdst[i+15:i] := Saturate_To_Int16(a[i+15:i] - b[i+15:i])\nENDFOR","header":"mmintrin.h","instruction":"psubsw","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"SUBUSB/PSUBUSW xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"SUBUSB/PSUBUSW xmm, xmm","latency":"1","throughput":"0.33"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"0.5","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_m_psubusb","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Arithmetic","description":"Subtract packed unsigned 8-bit integers in \"b\" from packed unsigned 8-bit integers in \"a\" using saturation, and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*8\n\tdst[i+7:i] := Saturate_To_UnsignedInt8(a[i+7:i] - b[i+7:i])\t\nENDFOR","header":"mmintrin.h","instruction":"psubusb","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"SUBUSB/PSUBUSW xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"SUBUSB/PSUBUSW xmm, xmm","latency":"1","throughput":"0.33"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"0.5","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_m_psubusw","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Arithmetic","description":"Subtract packed unsigned 16-bit integers in \"b\" from packed unsigned 16-bit integers in \"a\" using saturation, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*16\n\tdst[i+15:i] := Saturate_To_UnsignedInt16(a[i+15:i] - b[i+15:i])\t\nENDFOR","header":"mmintrin.h","instruction":"psubusw","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"SUBUSB/PSUBUSW xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"SUBUSB/PSUBUSW xmm, xmm","latency":"1","throughput":"0.33"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"0.5","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_m_pmaddwd","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Arithmetic","description":"Multiply packed 16-bit integers in \"a\" and \"b\", producing intermediate 32-bit integers. Horizontally add adjacent pairs of intermediate 32-bit integers, and pack the saturated results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*32\n\tst[i+31:i] := Saturate_To_Int32( a[i+31:i+16]*b[i+31:i+16] + a[i+15:i]*b[i+15:i] )\nENDFOR","header":"mmintrin.h","instruction":"pmaddwd","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"9","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"8","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"mm, mm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"mm, mm","latency":"3","throughput":"1"},{"base":"06_0D","parameters":"mm, mm","latency":"3","throughput":"1"},{"base":"0F_03","parameters":"mm, mm","latency":"9","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"8","throughput":"1"}]},{"name":"_m_pmulhw","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Arithmetic","description":"Multiply the packed 16-bit integers in \"a\" and \"b\", producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*16\n\ttmp[31:0] := a[i+15:i] * b[i+15:i]\n\tdst[i+15:i] := tmp[31:16]\nENDFOR","header":"mmintrin.h","instruction":"pmulhw","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"9","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"8","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"mm, mm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"mm, mm","latency":"3","throughput":"1"},{"base":"06_0D","parameters":"mm, mm","latency":"3","throughput":"1"},{"base":"0F_03","parameters":"mm, mm","latency":"9","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"8","throughput":"1"}]},{"name":"_m_pmullw","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Arithmetic","description":"Multiply the packed 16-bit integers in \"a\" and \"b\", producing intermediate 32-bit integers, and store the low 16 bits of the intermediate integers in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*16\n\ttmp[31:0] := a[i+15:i] * b[i+15:i]\n\tdst[i+15:i] := tmp[15:0]\nENDFOR","header":"mmintrin.h","instruction":"pmullw","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"9","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"8","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"mm, mm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"mm, mm","latency":"3","throughput":"1"},{"base":"06_0D","parameters":"mm, mm","latency":"3","throughput":"1"},{"base":"0F_03","parameters":"mm, mm","latency":"9","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"8","throughput":"1"}]},{"name":"_m_psllw","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Shift","description":"Shift packed 16-bit integers in \"a\" left by \"count\" while shifting in zeros, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*16\n\tIF count[63:0] > 15\n\t\tdst[i+15:i] := 0\n\tELSE\n\t\tdst[i+15:i] := ZeroExtend(a[i+15:i] << count[63:0])\n\tFI\nENDFOR","header":"mmintrin.h","instruction":"psllw","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"count"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"Q xmm, xmm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"Q xmm, xmm/imm8","latency":"2","throughput":"1"},{"base":"06_0E","parameters":"Q xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_0D","parameters":"Q xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm/imm8","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm/imm8","latency":"2","throughput":"1"}]},{"name":"_m_psllwi","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Shift","description":"Shift packed 16-bit integers in \"a\" left by \"imm\" while shifting in zeros, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*16\n\tIF imm > 15\n\t\tdst[i+15:i] := 0\n\tELSE\n\t\tdst[i+15:i] := ZeroExtend(a[i+15:i] << imm)\n\tFI\nENDFOR","header":"mmintrin.h","instruction":"psllw","parameters":[{"type":"__m64","name":"a"},{"type":"int","name":"imm"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"Q xmm, xmm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"Q xmm, xmm/imm8","latency":"2","throughput":"1"},{"base":"06_0E","parameters":"Q xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_0D","parameters":"Q xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm/imm8","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm/imm8","latency":"2","throughput":"1"}]},{"name":"_m_pslld","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Shift","description":"Shift packed 32-bit integers in \"a\" left by \"count\" while shifting in zeros, and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*32\n\tIF count[63:0] > 31\n\t\tdst[i+31:i] := 0\n\tELSE\n\t\tdst[i+31:i] := ZeroExtend(a[i+31:i] << count[63:0])\n\tFI\nENDFOR","header":"mmintrin.h","instruction":"pslld","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"count"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"Q xmm, xmm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"Q xmm, xmm/imm8","latency":"2","throughput":"1"},{"base":"06_0E","parameters":"Q xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_0D","parameters":"Q xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm/imm8","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm/imm8","latency":"2","throughput":"1"}]},{"name":"_m_pslldi","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Shift","description":"Shift packed 32-bit integers in \"a\" left by \"imm\" while shifting in zeros, and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*32\n\tIF imm > 31\n\t\tdst[i+31:i] := 0\n\tELSE\n\t\tdst[i+31:i] := ZeroExtend(a[i+31:i] << imm)\n\tFI\nENDFOR","header":"mmintrin.h","instruction":"pslld","parameters":[{"type":"__m64","name":"a"},{"type":"int","name":"imm"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"Q xmm, xmm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"Q xmm, xmm/imm8","latency":"2","throughput":"1"},{"base":"06_0E","parameters":"Q xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_0D","parameters":"Q xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm/imm8","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm/imm8","latency":"2","throughput":"1"}]},{"name":"_m_psllq","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Shift","description":"Shift 64-bit integer \"a\" left by \"count\" while shifting in zeros, and store the result in \"dst\".","code":"IF count[63:0] > 63\n\tdst[63:0] := 0\nELSE\n\tdst[63:0] := ZeroExtend(a[63:0] << count[63:0])\nFI","header":"mmintrin.h","instruction":"psllq","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"count"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm/imm8","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm/imm8","latency":"2","throughput":"1"}]},{"name":"_m_psllqi","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Shift","description":"Shift 64-bit integer \"a\" left by \"imm\" while shifting in zeros, and store the result in \"dst\".","code":"IF imm > 63\n\tdst[63:0] := 0\nELSE\n\tdst[63:0] := ZeroExtend(a[63:0] << imm)\nFI","header":"mmintrin.h","instruction":"psllq","parameters":[{"type":"__m64","name":"a"},{"type":"int","name":"imm"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm/imm8","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm/imm8","latency":"2","throughput":"1"}]},{"name":"_m_psraw","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Shift","description":"Shift packed 16-bit integers in \"a\" right by \"count\" while shifting in sign bits, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*16\n\tIF count[63:0] > 15\n\t\tdst[i+15:i] := SignBit\n\tELSE\n\t\tdst[i+15:i] := SignExtend(a[i+15:i] >> count[63:0])\n\tFI\nENDFOR","header":"mmintrin.h","instruction":"psraw","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"count"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"2","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"2","throughput":"1"},{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm/imm8","latency":"2","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm/imm8","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm/imm8","latency":"2","throughput":"1"}]},{"name":"_m_psrawi","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Shift","description":"Shift packed 16-bit integers in \"a\" right by \"imm\" while shifting in sign bits, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*16\n\tIF imm > 15\n\t\tdst[i+15:i] := SignBit\n\tELSE\n\t\tdst[i+15:i] := SignExtend(a[i+15:i] >> imm)\n\tFI\nENDFOR","header":"mmintrin.h","instruction":"psraw","parameters":[{"type":"__m64","name":"a"},{"type":"int","name":"imm"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"2","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"2","throughput":"1"},{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm/imm8","latency":"2","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm/imm8","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm/imm8","latency":"2","throughput":"1"}]},{"name":"_m_psrad","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Shift","description":"Shift packed 32-bit integers in \"a\" right by \"count\" while shifting in sign bits, and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*32\n\tIF count[63:0] > 31\n\t\tdst[i+31:i] := SignBit\n\tELSE\n\t\tdst[i+31:i] := SignExtend(a[i+31:i] >> count[63:0])\n\tFI\nENDFOR","header":"mmintrin.h","instruction":"psrad","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"count"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"2","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"2","throughput":"1"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm/imm8","latency":"2","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm/imm8","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm/imm8","latency":"2","throughput":"1"}]},{"name":"_m_psradi","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Shift","description":"Shift packed 32-bit integers in \"a\" right by \"imm\" while shifting in sign bits, and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*32\n\tIF imm > 31\n\t\tdst[i+31:i] := SignBit\n\tELSE\n\t\tdst[i+31:i] := SignExtend(a[i+31:i] >> imm)\n\tFI\nENDFOR","header":"mmintrin.h","instruction":"psrad","parameters":[{"type":"__m64","name":"a"},{"type":"int","name":"imm"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"2","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"2","throughput":"1"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm/imm8","latency":"2","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm/imm8","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm/imm8","latency":"2","throughput":"1"}]},{"name":"_m_psrlw","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Shift","description":"Shift packed 16-bit integers in \"a\" right by \"count\" while shifting in zeros, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*16\n\tIF count[63:0] > 15\n\t\tdst[i+15:i] := 0\n\tELSE\n\t\tdst[i+15:i] := ZeroExtend(a[i+15:i] >> count[63:0])\n\tFI\nENDFOR","header":"mmintrin.h","instruction":"psrlw","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"count"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"LQ xmm, xmm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"LQ xmm, xmm/imm8","latency":"2","throughput":"1"},{"base":"06_0E","parameters":"LQ xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_0D","parameters":"LQ xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm/imm8","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm/imm8","latency":"2","throughput":"1"}]},{"name":"_m_psrlwi","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Shift","description":"Shift packed 16-bit integers in \"a\" right by \"imm\" while shifting in zeros, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*16\n\tIF imm > 15\n\t\tdst[i+15:i] := 0\n\tELSE\n\t\tdst[i+15:i] := ZeroExtend(a[i+15:i] >> imm)\n\tFI\nENDFOR","header":"mmintrin.h","instruction":"psrlw","parameters":[{"type":"__m64","name":"a"},{"type":"int","name":"imm"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"LQ xmm, xmm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"LQ xmm, xmm/imm8","latency":"2","throughput":"1"},{"base":"06_0E","parameters":"LQ xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_0D","parameters":"LQ xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm/imm8","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm/imm8","latency":"2","throughput":"1"}]},{"name":"_m_psrld","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Shift","description":"Shift packed 32-bit integers in \"a\" right by \"count\" while shifting in zeros, and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*32\n\tIF count[63:0] > 31\n\t\tdst[i+31:i] := 0\n\tELSE\n\t\tdst[i+31:i] := ZeroExtend(a[i+31:i] >> count[63:0])\n\tFI\nENDFOR","header":"mmintrin.h","instruction":"psrld","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"count"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"LQ xmm, xmm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"LQ xmm, xmm/imm8","latency":"2","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm/imm8","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm/imm8","latency":"2","throughput":"1"}]},{"name":"_m_psrldi","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Shift","description":"Shift packed 32-bit integers in \"a\" right by \"imm\" while shifting in zeros, and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*32\n\tIF imm > 31\n\t\tdst[i+31:i] := 0\n\tELSE\n\t\tdst[i+31:i] := ZeroExtend(a[i+31:i] >> imm)\n\tFI\nENDFOR","header":"mmintrin.h","instruction":"psrld","parameters":[{"type":"__m64","name":"a"},{"type":"int","name":"imm"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"LQ xmm, xmm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"LQ xmm, xmm/imm8","latency":"2","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm/imm8","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm/imm8","latency":"2","throughput":"1"}]},{"name":"_m_psrlq","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Shift","description":"Shift 64-bit integer \"a\" right by \"count\" while shifting in zeros, and store the result in \"dst\".","code":"IF count[63:0] > 63\n\tdst[63:0] := 0\nELSE\n\tdst[63:0] := ZeroExtend(a[63:0] >> count[63:0])\nFI","header":"mmintrin.h","instruction":"psrlq","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"count"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"LQ xmm, xmm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"LQ xmm, xmm/imm8","latency":"2","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm/imm8","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm/imm8","latency":"2","throughput":"1"}]},{"name":"_m_psrlqi","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Shift","description":"Shift 64-bit integer \"a\" right by \"imm\" while shifting in zeros, and store the result in \"dst\".","code":"IF imm > 63\n\tdst[63:0] := 0\nELSE\n\tdst[63:0] := ZeroExtend(a[63:0] >> imm)\nFI","header":"mmintrin.h","instruction":"psrlq","parameters":[{"type":"__m64","name":"a"},{"type":"int","name":"imm"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"LQ xmm, xmm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"LQ xmm, xmm/imm8","latency":"2","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm/imm8","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm/imm8","latency":"2","throughput":"1"}]},{"name":"_m_pand","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Logical","description":"Compute the bitwise AND of 64 bits (representing integer data) in \"a\" and \"b\", and store the result in \"dst\".","code":"dst[63:0] := (a[63:0] AND b[63:0])","header":"mmintrin.h","instruction":"pand","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_m_pandn","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Logical","description":"Compute the bitwise AND NOT of 64 bits (representing integer data) in \"a\" and \"b\", and store the result in \"dst\".","code":"dst[63:0] := ((NOT a[63:0]) AND b[63:0])","header":"mmintrin.h","instruction":"pandn","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_m_por","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Logical","description":"Compute the bitwise OR of 64 bits (representing integer data) in \"a\" and \"b\", and store the result in \"dst\".","code":"dst[63:0] := (a[63:0] OR b[63:0])","header":"mmintrin.h","instruction":"por","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_m_pxor","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Logical","description":"Compute the bitwise OR of 64 bits (representing integer data) in \"a\" and \"b\", and store the result in \"dst\".","code":"dst[63:0] := (a[63:0] XOR b[63:0])","header":"mmintrin.h","instruction":"pxor","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"0.33","throughput":"0.33"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_m_pcmpeqb","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Compare","description":"Compare packed 8-bit integers in \"a\" and \"b\" for equality, and store the results in \"dst\".","code":"FOR j := 0 to 7\n  i := j*8\n  dst[i+7:i] := ( a[i+7:i] == b[i+7:i] ) ? 0xFF : 0\nENDFOR","header":"mmintrin.h","instruction":"pcmpeqb","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"0.5","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_m_pcmpeqw","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Compare","description":"Compare packed 16-bit integers in \"a\" and \"b\" for equality, and store the results in \"dst\".","code":"FOR j := 0 to 3\n  i := j*16\n  dst[i+15:i] := ( a[i+15:i] == b[i+15:i] ) ? 0xFFFF : 0\nENDFOR","header":"mmintrin.h","instruction":"pcmpeqw","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"0.5","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_m_pcmpeqd","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Compare","description":"Compare packed 32-bit integers in \"a\" and \"b\" for equality, and store the results in \"dst\".","code":"FOR j := 0 to 1\n  i := j*32\n  dst[i+31:i] := ( a[i+31:i] == b[i+31:i] ) ? 0xFFFFFFFF : 0\nENDFOR","header":"mmintrin.h","instruction":"pcmpeqd","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"0.5","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_m_pcmpgtb","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Compare","description":"Compare packed 8-bit integers in \"a\" and \"b\" for greater-than, and store the results in \"dst\".","code":"FOR j := 0 to 7\n  i := j*8\n  dst[i+7:i] := ( a[i+7:i] > b[i+7:i] ) ? 0xFF : 0\nENDFOR","header":"mmintrin.h","instruction":"pcmpgtb","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"0.5","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_m_pcmpgtw","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Compare","description":"Compare packed 16-bit integers in \"a\" and \"b\" for greater-than, and store the results in \"dst\".","code":"FOR j := 0 to 3\n  i := j*16\n  dst[i+15:i] := ( a[i+15:i] > b[i+15:i] ) ? 0xFFFF : 0\nENDFOR","header":"mmintrin.h","instruction":"pcmpgtw","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"0.5","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_m_pcmpgtd","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Compare","description":"Compare packed 32-bit integers in \"a\" and \"b\" for greater-than, and store the results in \"dst\".","code":"FOR j := 0 to 1\n  i := j*32\n  dst[i+31:i] := ( a[i+31:i] > b[i+31:i] ) ? 0xFFFFFFFF : 0\nENDFOR","header":"mmintrin.h","instruction":"pcmpgtd","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"0.5","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_empty","tech":"MMX","returnType":"void","cpuId":"MMX","category":"General Support","description":"Empty the MMX state, which marks the x87 FPU registers as available for use by x87 instructions. This instruction must be used at the end of all MMX technology procedures.","code":null,"header":"mmintrin.h","instruction":"emms","parameters":[{"type":"void","name":""}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_17","parameters":"","latency":"","throughput":"6"},{"base":"06_0E","parameters":"","latency":"6","throughput":"5"},{"base":"06_0D","parameters":"","latency":"6","throughput":"5"},{"base":"0F_02","parameters":"","latency":"12","throughput":"12"}]},{"name":"_mm_add_pi8","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Arithmetic","description":"Add packed 8-bit integers in \"a\" and \"b\", and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*8\n\tdst[i+7:i] := a[i+7:i] + b[i+7:i]\nENDFOR","header":"mmintrin.h","instruction":"paddb","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_add_pi16","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Arithmetic","description":"Add packed 16-bit integers in \"a\" and \"b\", and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*16\n\tdst[i+15:i] := a[i+15:i] + b[i+15:i]\nENDFOR","header":"mmintrin.h","instruction":"paddw","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_add_pi32","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Arithmetic","description":"Add packed 32-bit integers in \"a\" and \"b\", and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*32\n\tdst[i+31:i] := a[i+31:i] + b[i+31:i]\nENDFOR","header":"mmintrin.h","instruction":"paddd","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_adds_pi8","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Arithmetic","description":"Add packed 8-bit integers in \"a\" and \"b\" using saturation, and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*8\n\tdst[i+7:i] := Saturate_To_Int8( a[i+7:i] + b[i+7:i] )\nENDFOR","header":"mmintrin.h","instruction":"paddsb","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_adds_pi16","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Arithmetic","description":"Add packed 16-bit integers in \"a\" and \"b\" using saturation, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*16\n\tdst[i+15:i] := Saturate_To_Int16( a[i+15:i] + b[i+15:i] )\nENDFOR","header":"mmintrin.h","instruction":"paddsw","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_adds_pu8","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Arithmetic","description":"Add packed unsigned 8-bit integers in \"a\" and \"b\" using saturation, and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*8\n\tdst[i+7:i] := Saturate_To_UnsignedInt8( a[i+7:i] + b[i+7:i] )\nENDFOR","header":"mmintrin.h","instruction":"paddusb","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_adds_pu16","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Arithmetic","description":"Add packed unsigned 16-bit integers in \"a\" and \"b\" using saturation, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*16\n\tdst[i+15:i] := Saturate_To_UnsignedInt16( a[i+15:i] + b[i+15:i] )\nENDFOR","header":"mmintrin.h","instruction":"paddusw","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_sub_pi8","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Arithmetic","description":"Subtract packed 8-bit integers in \"b\" from packed 8-bit integers in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*8\n\tdst[i+7:i] := a[i+7:i] - b[i+7:i]\nENDFOR","header":"mmintrin.h","instruction":"psubb","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"BD xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"BD xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"BD xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"BD xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"0.5","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_sub_pi16","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Arithmetic","description":"Subtract packed 16-bit integers in \"b\" from packed 16-bit integers in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*16\n\tdst[i+15:i] := a[i+15:i] - b[i+15:i]\nENDFOR","header":"mmintrin.h","instruction":"psubw","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"BD xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"BD xmm, xmm","latency":"1","throughput":"0.33"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"0.5","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_sub_pi32","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Arithmetic","description":"Subtract packed 32-bit integers in \"b\" from packed 32-bit integers in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*32\n\tdst[i+31:i] := a[i+31:i] - b[i+31:i]\nENDFOR","header":"mmintrin.h","instruction":"psubd","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"BD xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"BD xmm, xmm","latency":"1","throughput":"0.33"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"0.5","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_subs_pi8","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Arithmetic","description":"Subtract packed 8-bit integers in \"b\" from packed 8-bit integers in \"a\" using saturation, and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*8\n\tdst[i+7:i] := Saturate_To_Int8(a[i+7:i] - b[i+7:i])\t\nENDFOR","header":"mmintrin.h","instruction":"psubsb","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"SUBUSB/PSUBUSW xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"SUBUSB/PSUBUSW xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"SUBUSB/PSUBUSW xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"SUBUSB/PSUBUSW xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"0.5","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_subs_pi16","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Arithmetic","description":"Subtract packed 16-bit integers in \"b\" from packed 16-bit integers in \"a\" using saturation, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*16\n\tdst[i+15:i] := Saturate_To_Int16(a[i+15:i] - b[i+15:i])\nENDFOR","header":"mmintrin.h","instruction":"psubsw","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"SUBUSB/PSUBUSW xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"SUBUSB/PSUBUSW xmm, xmm","latency":"1","throughput":"0.33"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"0.5","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_subs_pu8","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Arithmetic","description":"Subtract packed unsigned 8-bit integers in \"b\" from packed unsigned 8-bit integers in \"a\" using saturation, and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*8\n\tdst[i+7:i] := Saturate_To_UnsignedInt8(a[i+7:i] - b[i+7:i])\t\nENDFOR","header":"mmintrin.h","instruction":"psubusb","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"SUBUSB/PSUBUSW xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"SUBUSB/PSUBUSW xmm, xmm","latency":"1","throughput":"0.33"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"0.5","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_subs_pu16","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Arithmetic","description":"Subtract packed unsigned 16-bit integers in \"b\" from packed unsigned 16-bit integers in \"a\" using saturation, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*16\n\tdst[i+15:i] := Saturate_To_UnsignedInt16(a[i+15:i] - b[i+15:i])\t\nENDFOR","header":"mmintrin.h","instruction":"psubusw","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"SUBUSB/PSUBUSW xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"SUBUSB/PSUBUSW xmm, xmm","latency":"1","throughput":"0.33"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"0.5","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_madd_pi16","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Arithmetic","description":"Multiply packed 16-bit integers in \"a\" and \"b\", producing intermediate 32-bit integers. Horizontally add adjacent pairs of intermediate 32-bit integers, and pack the saturated results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*32\n\tst[i+31:i] := Saturate_To_Int32( a[i+31:i+16]*b[i+31:i+16] + a[i+15:i]*b[i+15:i] )\nENDFOR","header":"mmintrin.h","instruction":"pmaddwd","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"9","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"8","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"mm, mm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"mm, mm","latency":"3","throughput":"1"},{"base":"06_0D","parameters":"mm, mm","latency":"3","throughput":"1"},{"base":"0F_03","parameters":"mm, mm","latency":"9","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"8","throughput":"1"}]},{"name":"_mm_mulhi_pi16","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Arithmetic","description":"Multiply the packed 16-bit integers in \"a\" and \"b\", producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*16\n\ttmp[31:0] := a[i+15:i] * b[i+15:i]\n\tdst[i+15:i] := tmp[31:16]\nENDFOR","header":"mmintrin.h","instruction":"pmulhw","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"9","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"8","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"mm, mm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"mm, mm","latency":"3","throughput":"1"},{"base":"06_0D","parameters":"mm, mm","latency":"3","throughput":"1"},{"base":"0F_03","parameters":"mm, mm","latency":"9","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"8","throughput":"1"}]},{"name":"_mm_mullo_pi16","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Arithmetic","description":"Multiply the packed 16-bit integers in \"a\" and \"b\", producing intermediate 32-bit integers, and store the low 16 bits of the intermediate integers in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*16\n\ttmp[31:0] := a[i+15:i] * b[i+15:i]\n\tdst[i+15:i] := tmp[15:0]\nENDFOR","header":"mmintrin.h","instruction":"pmullw","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"9","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"8","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"mm, mm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"mm, mm","latency":"3","throughput":"1"},{"base":"06_0D","parameters":"mm, mm","latency":"3","throughput":"1"},{"base":"0F_03","parameters":"mm, mm","latency":"9","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"8","throughput":"1"}]},{"name":"_mm_sll_pi16","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Shift","description":"Shift packed 16-bit integers in \"a\" left by \"count\" while shifting in zeros, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*16\n\tIF count[63:0] > 15\n\t\tdst[i+15:i] := 0\n\tELSE\n\t\tdst[i+15:i] := ZeroExtend(a[i+15:i] << count[63:0])\n\tFI\nENDFOR","header":"mmintrin.h","instruction":"psllw","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"count"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"Q xmm, xmm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"Q xmm, xmm/imm8","latency":"2","throughput":"1"},{"base":"06_0E","parameters":"Q xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_0D","parameters":"Q xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm/imm8","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm/imm8","latency":"2","throughput":"1"}]},{"name":"_mm_slli_pi16","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Shift","description":"Shift packed 16-bit integers in \"a\" left by \"imm\" while shifting in zeros, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*16\n\tIF imm > 15\n\t\tdst[i+15:i] := 0\n\tELSE\n\t\tdst[i+15:i] := ZeroExtend(a[i+15:i] << imm)\n\tFI\nENDFOR","header":"mmintrin.h","instruction":"psllw","parameters":[{"type":"__m64","name":"a"},{"type":"int","name":"imm"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"Q xmm, xmm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"Q xmm, xmm/imm8","latency":"2","throughput":"1"},{"base":"06_0E","parameters":"Q xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_0D","parameters":"Q xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm/imm8","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm/imm8","latency":"2","throughput":"1"}]},{"name":"_mm_sll_pi32","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Shift","description":"Shift packed 32-bit integers in \"a\" left by \"count\" while shifting in zeros, and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*32\n\tIF count[63:0] > 31\n\t\tdst[i+31:i] := 0\n\tELSE\n\t\tdst[i+31:i] := ZeroExtend(a[i+31:i] << count[63:0])\n\tFI\nENDFOR","header":"mmintrin.h","instruction":"pslld","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"count"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"Q xmm, xmm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"Q xmm, xmm/imm8","latency":"2","throughput":"1"},{"base":"06_0E","parameters":"Q xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_0D","parameters":"Q xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm/imm8","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm/imm8","latency":"2","throughput":"1"}]},{"name":"_mm_slli_pi32","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Shift","description":"Shift packed 32-bit integers in \"a\" left by \"imm\" while shifting in zeros, and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*32\n\tIF imm > 31\n\t\tdst[i+31:i] := 0\n\tELSE\n\t\tdst[i+31:i] := ZeroExtend(a[i+31:i] << imm)\n\tFI\nENDFOR","header":"mmintrin.h","instruction":"pslld","parameters":[{"type":"__m64","name":"a"},{"type":"int","name":"imm"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"Q xmm, xmm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"Q xmm, xmm/imm8","latency":"2","throughput":"1"},{"base":"06_0E","parameters":"Q xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_0D","parameters":"Q xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm/imm8","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm/imm8","latency":"2","throughput":"1"}]},{"name":"_mm_sll_si64","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Shift","description":"Shift 64-bit integer \"a\" left by \"count\" while shifting in zeros, and store the result in \"dst\".","code":"IF count[63:0] > 63\n\tdst[63:0] := 0\nELSE\n\tdst[63:0] := ZeroExtend(a[63:0] << count[63:0])\nFI","header":"mmintrin.h","instruction":"psllq","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"count"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm/imm8","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm/imm8","latency":"2","throughput":"1"}]},{"name":"_mm_slli_si64","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Shift","description":"Shift 64-bit integer \"a\" left by \"imm\" while shifting in zeros, and store the result in \"dst\".","code":"IF imm > 63\n\tdst[63:0] := 0\nELSE\n\tdst[63:0] := ZeroExtend(a[63:0] << imm)\nFI","header":"mmintrin.h","instruction":"psllq","parameters":[{"type":"__m64","name":"a"},{"type":"int","name":"imm"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm/imm8","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm/imm8","latency":"2","throughput":"1"}]},{"name":"_mm_sra_pi16","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Shift","description":"Shift packed 16-bit integers in \"a\" right by \"count\" while shifting in sign bits, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*16\n\tIF count[63:0] > 15\n\t\tdst[i+15:i] := SignBit\n\tELSE\n\t\tdst[i+15:i] := SignExtend(a[i+15:i] >> count[63:0])\n\tFI\nENDFOR","header":"mmintrin.h","instruction":"psraw","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"count"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"2","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"2","throughput":"1"},{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm/imm8","latency":"2","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm/imm8","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm/imm8","latency":"2","throughput":"1"}]},{"name":"_mm_srai_pi16","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Shift","description":"Shift packed 16-bit integers in \"a\" right by \"imm\" while shifting in sign bits, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*16\n\tIF imm > 15\n\t\tdst[i+15:i] := SignBit\n\tELSE\n\t\tdst[i+15:i] := SignExtend(a[i+15:i] >> imm)\n\tFI\nENDFOR","header":"mmintrin.h","instruction":"psraw","parameters":[{"type":"__m64","name":"a"},{"type":"int","name":"imm"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"2","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"2","throughput":"1"},{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm/imm8","latency":"2","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm/imm8","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm/imm8","latency":"2","throughput":"1"}]},{"name":"_mm_sra_pi32","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Shift","description":"Shift packed 32-bit integers in \"a\" right by \"count\" while shifting in sign bits, and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*32\n\tIF count[63:0] > 31\n\t\tdst[i+31:i] := SignBit\n\tELSE\n\t\tdst[i+31:i] := SignExtend(a[i+31:i] >> count[63:0])\n\tFI\nENDFOR","header":"mmintrin.h","instruction":"psrad","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"count"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"2","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"2","throughput":"1"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm/imm8","latency":"2","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm/imm8","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm/imm8","latency":"2","throughput":"1"}]},{"name":"_mm_srai_pi32","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Shift","description":"Shift packed 32-bit integers in \"a\" right by \"imm\" while shifting in sign bits, and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*32\n\tIF imm > 31\n\t\tdst[i+31:i] := SignBit\n\tELSE\n\t\tdst[i+31:i] := SignExtend(a[i+31:i] >> imm)\n\tFI\nENDFOR","header":"mmintrin.h","instruction":"psrad","parameters":[{"type":"__m64","name":"a"},{"type":"int","name":"imm"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"2","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"2","throughput":"1"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm/imm8","latency":"2","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm/imm8","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm/imm8","latency":"2","throughput":"1"}]},{"name":"_mm_srl_pi16","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Shift","description":"Shift packed 16-bit integers in \"a\" right by \"count\" while shifting in zeros, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*16\n\tIF count[63:0] > 15\n\t\tdst[i+15:i] := 0\n\tELSE\n\t\tdst[i+15:i] := ZeroExtend(a[i+15:i] >> count[63:0])\n\tFI\nENDFOR","header":"mmintrin.h","instruction":"psrlw","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"count"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"LQ xmm, xmm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"LQ xmm, xmm/imm8","latency":"2","throughput":"1"},{"base":"06_0E","parameters":"LQ xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_0D","parameters":"LQ xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm/imm8","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm/imm8","latency":"2","throughput":"1"}]},{"name":"_mm_srli_pi16","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Shift","description":"Shift packed 16-bit integers in \"a\" right by \"imm\" while shifting in zeros, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*16\n\tIF imm > 15\n\t\tdst[i+15:i] := 0\n\tELSE\n\t\tdst[i+15:i] := ZeroExtend(a[i+15:i] >> imm)\n\tFI\nENDFOR","header":"mmintrin.h","instruction":"psrlw","parameters":[{"type":"__m64","name":"a"},{"type":"int","name":"imm"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"LQ xmm, xmm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"LQ xmm, xmm/imm8","latency":"2","throughput":"1"},{"base":"06_0E","parameters":"LQ xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_0D","parameters":"LQ xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm/imm8","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm/imm8","latency":"2","throughput":"1"}]},{"name":"_mm_srl_pi32","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Shift","description":"Shift packed 32-bit integers in \"a\" right by \"count\" while shifting in zeros, and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*32\n\tIF count[63:0] > 31\n\t\tdst[i+31:i] := 0\n\tELSE\n\t\tdst[i+31:i] := ZeroExtend(a[i+31:i] >> count[63:0])\n\tFI\nENDFOR","header":"mmintrin.h","instruction":"psrld","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"count"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"LQ xmm, xmm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"LQ xmm, xmm/imm8","latency":"2","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm/imm8","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm/imm8","latency":"2","throughput":"1"}]},{"name":"_mm_srli_pi32","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Shift","description":"Shift packed 32-bit integers in \"a\" right by \"imm\" while shifting in zeros, and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*32\n\tIF imm > 31\n\t\tdst[i+31:i] := 0\n\tELSE\n\t\tdst[i+31:i] := ZeroExtend(a[i+31:i] >> imm)\n\tFI\nENDFOR","header":"mmintrin.h","instruction":"psrld","parameters":[{"type":"__m64","name":"a"},{"type":"int","name":"imm"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"LQ xmm, xmm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"LQ xmm, xmm/imm8","latency":"2","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm/imm8","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm/imm8","latency":"2","throughput":"1"}]},{"name":"_mm_srl_si64","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Shift","description":"Shift 64-bit integer \"a\" right by \"count\" while shifting in zeros, and store the result in \"dst\".","code":"IF count[63:0] > 63\n\tdst[63:0] := 0\nELSE\n\tdst[63:0] := ZeroExtend(a[63:0] >> count[63:0])\nFI","header":"mmintrin.h","instruction":"psrlq","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"count"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"LQ xmm, xmm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"LQ xmm, xmm/imm8","latency":"2","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm/imm8","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm/imm8","latency":"2","throughput":"1"}]},{"name":"_mm_srli_si64","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Shift","description":"Shift 64-bit integer \"a\" right by \"imm\" while shifting in zeros, and store the result in \"dst\".","code":"IF imm > 63\n\tdst[63:0] := 0\nELSE\n\tdst[63:0] := ZeroExtend(a[63:0] >> imm)\nFI","header":"mmintrin.h","instruction":"psrlq","parameters":[{"type":"__m64","name":"a"},{"type":"int","name":"imm"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"LQ xmm, xmm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"LQ xmm, xmm/imm8","latency":"2","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm/imm8","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm/imm8","latency":"2","throughput":"1"}]},{"name":"_mm_and_si64","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Logical","description":"Compute the bitwise AND of 64 bits (representing integer data) in \"a\" and \"b\", and store the result in \"dst\".","code":"dst[63:0] := (a[63:0] AND b[63:0])","header":"mmintrin.h","instruction":"pand","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_andnot_si64","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Logical","description":"Compute the bitwise AND NOT of 64 bits (representing integer data) in \"a\" and \"b\", and store the result in \"dst\".","code":"dst[63:0] := ((NOT a[63:0]) AND b[63:0])","header":"mmintrin.h","instruction":"pandn","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_or_si64","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Logical","description":"Compute the bitwise OR of 64 bits (representing integer data) in \"a\" and \"b\", and store the result in \"dst\".","code":"dst[63:0] := (a[63:0] OR b[63:0])","header":"mmintrin.h","instruction":"por","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_xor_si64","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Logical","description":"Compute the bitwise OR of 64 bits (representing integer data) in \"a\" and \"b\", and store the result in \"dst\".","code":"dst[63:0] := (a[63:0] XOR b[63:0])","header":"mmintrin.h","instruction":"pxor","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"0.33","throughput":"0.33"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_cmpeq_pi8","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Compare","description":"Compare packed 8-bit integers in \"a\" and \"b\" for equality, and store the results in \"dst\".","code":"FOR j := 0 to 7\n  i := j*8\n  dst[i+7:i] := ( a[i+7:i] == b[i+7:i] ) ? 0xFF : 0\nENDFOR","header":"mmintrin.h","instruction":"pcmpeqb","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"0.5","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_cmpeq_pi16","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Compare","description":"Compare packed 16-bit integers in \"a\" and \"b\" for equality, and store the results in \"dst\".","code":"FOR j := 0 to 3\n  i := j*16\n  dst[i+15:i] := ( a[i+15:i] == b[i+15:i] ) ? 0xFFFF : 0\nENDFOR","header":"mmintrin.h","instruction":"pcmpeqw","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"0.5","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_cmpeq_pi32","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Compare","description":"Compare packed 32-bit integers in \"a\" and \"b\" for equality, and store the results in \"dst\".","code":"FOR j := 0 to 1\n  i := j*32\n  dst[i+31:i] := ( a[i+31:i] == b[i+31:i] ) ? 0xFFFFFFFF : 0\nENDFOR","header":"mmintrin.h","instruction":"pcmpeqd","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"0.5","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_cmpgt_pi8","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Compare","description":"Compare packed 8-bit integers in \"a\" and \"b\" for greater-than, and store the results in \"dst\".","code":"FOR j := 0 to 7\n  i := j*8\n  dst[i+7:i] := ( a[i+7:i] > b[i+7:i] ) ? 0xFF : 0\nENDFOR","header":"mmintrin.h","instruction":"pcmpgtb","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"0.5","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_cmpgt_pi16","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Compare","description":"Compare packed 16-bit integers in \"a\" and \"b\" for greater-than, and store the results in \"dst\".","code":"FOR j := 0 to 3\n  i := j*16\n  dst[i+15:i] := ( a[i+15:i] > b[i+15:i] ) ? 0xFFFF : 0\nENDFOR","header":"mmintrin.h","instruction":"pcmpgtw","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"0.5","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_cmpgt_pi32","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Compare","description":"Compare packed 32-bit integers in \"a\" and \"b\" for greater-than, and store the results in \"dst\".","code":"FOR j := 0 to 1\n  i := j*32\n  dst[i+31:i] := ( a[i+31:i] > b[i+31:i] ) ? 0xFFFFFFFF : 0\nENDFOR","header":"mmintrin.h","instruction":"pcmpgtd","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"0.5","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_cvtsi32_si64","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Convert","description":"Copy 32-bit integer \"a\" to the lower elements of \"dst\", and zero the upper element of \"dst\".","code":"dst[31:0] := a[31:0]\ndst[63:32] := 0","header":"mmintrin.h","instruction":"movd","parameters":[{"type":"int","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, r32","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, r32","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, r32","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, r32","latency":"1","throughput":"0.5"},{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, r64","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, r64","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, r64","latency":"1","throughput":"0.5"},{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"r32, xmm","latency":"2","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"r32, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"r32, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"r32, xmm","latency":"1","throughput":"0.33"},{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"r64, xmm","latency":"1","throughput":"0.33"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"r64, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"r64, xmm","latency":"1","throughput":"0.33"},{"base":"0F_03","parameters":"r32, xmm","latency":"10","throughput":"1"},{"base":"0F_02","parameters":"r32, xmm","latency":"10","throughput":"1"},{"base":"0F_03","parameters":"xmm, r32","latency":"6","throughput":"2"},{"base":"0F_02","parameters":"xmm, r32","latency":"6","throughput":"2"},{"base":"06_0F","parameters":"mm, r32","latency":"1","throughput":"0.5"},{"base":"06_0E","parameters":"mm, r32","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, r32","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"r32, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"r32, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"r32, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, r32","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, r32","latency":"2","throughput":"1"},{"base":"0F_03","parameters":"r32, mm","latency":"5","throughput":"1"},{"base":"0F_02","parameters":"r32, mm","latency":"5","throughput":"1"}]},{"name":"_mm_cvtsi64_si32","tech":"MMX","returnType":"int","cpuId":"MMX","category":"Convert","description":"Copy the lower 32-bit integer in \"a\" to \"dst\".","code":"dst[31:0] := a[31:0]","header":"mmintrin.h","instruction":"movd","parameters":[{"type":"__m64","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, r32","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, r32","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, r32","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, r32","latency":"1","throughput":"0.5"},{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, r64","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, r64","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, r64","latency":"1","throughput":"0.5"},{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"r32, xmm","latency":"2","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"r32, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"r32, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"r32, xmm","latency":"1","throughput":"0.33"},{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"r64, xmm","latency":"1","throughput":"0.33"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"r64, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"r64, xmm","latency":"1","throughput":"0.33"},{"base":"0F_03","parameters":"r32, xmm","latency":"10","throughput":"1"},{"base":"0F_02","parameters":"r32, xmm","latency":"10","throughput":"1"},{"base":"0F_03","parameters":"xmm, r32","latency":"6","throughput":"2"},{"base":"0F_02","parameters":"xmm, r32","latency":"6","throughput":"2"},{"base":"06_0F","parameters":"mm, r32","latency":"1","throughput":"0.5"},{"base":"06_0E","parameters":"mm, r32","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, r32","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"r32, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"r32, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"r32, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, r32","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, r32","latency":"2","throughput":"1"},{"base":"0F_03","parameters":"r32, mm","latency":"5","throughput":"1"},{"base":"0F_02","parameters":"r32, mm","latency":"5","throughput":"1"}]},{"name":"_mm_cvtm64_si64","tech":"MMX","returnType":"__int64","cpuId":"MMX","category":"Convert","description":"Copy 64-bit integer \"a\" to \"dst\".","code":"dst[63:0] := a[63:0]","header":"mmintrin.h","instruction":"movq","parameters":[{"type":"__m64","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"6","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"6","throughput":"1"}]},{"name":"_mm_cvtsi64_m64","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Convert","description":"Copy 64-bit integer \"a\" to \"dst\".","code":"dst[63:0] := a[63:0]","header":"mmintrin.h","instruction":"movq","parameters":[{"type":"__int64","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"6","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"6","throughput":"1"}]},{"name":"_mm_setzero_si64","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Set","description":"Return vector of type __m64 with all elements set to zero.","code":"dst[MAX:0] := 0","header":"mmintrin.h","instruction":"pxor","parameters":[{"type":"void","name":""}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"0.33","throughput":"0.33"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_set_pi32","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Set","description":"Set packed 32-bit integers in \"dst\" with the supplied values.","code":"dst[31:0] := e0\ndst[63:32] := e1","header":"mmintrin.h","instruction":null,"parameters":[{"type":"int","name":"e1"},{"type":"int","name":"e0"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_set_pi16","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Set","description":"Set packed 16-bit integers in \"dst\" with the supplied values.","code":"dst[15:0] := e0\ndst[31:16] := e1\ndst[47:32] := e2\ndst[63:48] := e3","header":"mmintrin.h","instruction":null,"parameters":[{"type":"short","name":"e3"},{"type":"short","name":"e2"},{"type":"short","name":"e1"},{"type":"short","name":"e0"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_set_pi8","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Set","description":"Set packed 8-bit integers in \"dst\" with the supplied values in reverse order.","code":"dst[7:0] := e0\ndst[15:8] := e1\ndst[23:16] := e2\ndst[31:24] := e3\ndst[39:32] := e4\ndst[47:40] := e5\ndst[55:48] := e6\ndst[63:56] := e7","header":"mmintrin.h","instruction":null,"parameters":[{"type":"char","name":"e7"},{"type":"char","name":"e6"},{"type":"char","name":"e5"},{"type":"char","name":"e4"},{"type":"char","name":"e3"},{"type":"char","name":"e2"},{"type":"char","name":"e1"},{"type":"char","name":"e0"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_set1_pi32","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Set","description":"Broadcast 32-bit integer \"a\" to all elements of \"dst\".","code":"FOR j := 0 to 1\n\ti := j*32\n\tdst[i+31:i] := a[31:0]\nENDFOR","header":"mmintrin.h","instruction":null,"parameters":[{"type":"int","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_set1_pi16","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Set","description":"Broadcast 16-bit integer \"a\" to all all elements of \"dst\".","code":"FOR j := 0 to 3\n\ti := j*16\n\tdst[i+15:i] := a[15:0]\nENDFOR","header":"mmintrin.h","instruction":null,"parameters":[{"type":"short","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_set1_pi8","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Set","description":"Broadcast 8-bit integer \"a\" to all elements of \"dst\".","code":"FOR j := 0 to 7\n\ti := j*8\n\tdst[i+7:i] := a[7:0]\nENDFOR","header":"mmintrin.h","instruction":null,"parameters":[{"type":"char","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_setr_pi32","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Set","description":"Set packed 32-bit integers in \"dst\" with the supplied values in reverse order.","code":"dst[31:0] := e1\ndst[63:32] := e0","header":"mmintrin.h","instruction":null,"parameters":[{"type":"int","name":"e1"},{"type":"int","name":"e0"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_setr_pi16","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Set","description":"Set packed 16-bit integers in \"dst\" with the supplied values in reverse order.","code":"dst[15:0] := e3\ndst[31:16] := e2\ndst[47:32] := e1\ndst[63:48] := e0","header":"mmintrin.h","instruction":null,"parameters":[{"type":"short","name":"e3"},{"type":"short","name":"e2"},{"type":"short","name":"e1"},{"type":"short","name":"e0"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_setr_pi8","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Set","description":"Set packed 8-bit integers in \"dst\" with the supplied values in reverse order.","code":"dst[7:0] := e7\ndst[15:8] := e6\ndst[23:16] := e5\ndst[31:24] := e4\ndst[39:32] := e3\ndst[47:40] := e2\ndst[55:48] := e1\ndst[63:56] := e0","header":"mmintrin.h","instruction":null,"parameters":[{"type":"char","name":"e7"},{"type":"char","name":"e6"},{"type":"char","name":"e5"},{"type":"char","name":"e4"},{"type":"char","name":"e3"},{"type":"char","name":"e2"},{"type":"char","name":"e1"},{"type":"char","name":"e0"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_packs_pi16","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Miscellaneous","description":"Convert packed 16-bit integers from \"a\" and \"b\" to packed 8-bit integers using signed saturation, and store the results in \"dst\".","code":"dst[7:0] := Saturate_Int16_To_Int8 (a[15:0])\ndst[15:8] := Saturate_Int16_To_Int8 (a[31:16])\ndst[23:16] := Saturate_Int16_To_Int8 (a[47:32])\ndst[31:24] := Saturate_Int16_To_Int8 (a[63:48])\ndst[39:32] := Saturate_Int16_To_Int8 (b[15:0])\ndst[47:40] := Saturate_Int16_To_Int8 (b[31:16])\ndst[55:48] := Saturate_Int16_To_Int8 (b[47:32])\ndst[63:56] := Saturate_Int16_To_Int8 (b[63:48])","header":"mmintrin.h","instruction":"packsswb","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_0E","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_packs_pi32","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Miscellaneous","description":"Convert packed 32-bit integers from \"a\" and \"b\" to packed 16-bit integers using signed saturation, and store the results in \"dst\".","code":"dst[15:0] := Saturate_Int32_To_Int16 (a[31:0])\ndst[31:16] := Saturate_Int32_To_Int16 (a[63:32])\ndst[47:32] := Saturate_Int32_To_Int16 (b[31:0])\ndst[63:48] := Saturate_Int32_To_Int16 (b[63:32])","header":"mmintrin.h","instruction":"packssdw","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_0E","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_packs_pu16","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Miscellaneous","description":"Convert packed 16-bit integers from \"a\" and \"b\" to packed 8-bit integers using unsigned saturation, and store the results in \"dst\".","code":"dst[7:0] := Saturate_Int16_To_UnsignedInt8 (a[15:0])\ndst[15:8] := Saturate_Int16_To_UnsignedInt8 (a[31:16])\ndst[23:16] := Saturate_Int16_To_UnsignedInt8 (a[47:32])\ndst[31:24] := Saturate_Int16_To_UnsignedInt8 (a[63:48])\ndst[39:32] := Saturate_Int16_To_UnsignedInt8 (b[15:0])\ndst[47:40] := Saturate_Int16_To_UnsignedInt8 (b[31:16])\ndst[55:48] := Saturate_Int16_To_UnsignedInt8 (b[47:32])\ndst[63:56] := Saturate_Int16_To_UnsignedInt8 (b[63:48])","header":"mmintrin.h","instruction":"packuswb","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_0E","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_unpackhi_pi8","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Swizzle","description":"Unpack and interleave 8-bit integers from the high half of \"a\" and \"b\", and store the results in \"dst\".","code":"INTERLEAVE_HIGH_BYTES(src1[63:0], src2[63:0]){\n\tdst[7:0] := src1[39:32]\n\tdst[15:8] := src2[39:32] \n\tdst[23:16] := src1[47:40]\n\tdst[31:24] := src2[47:40]\n\tdst[39:32] := src1[55:48]\n\tdst[47:40] := src2[55:48]\n\tdst[55:48] := src1[63:56]\n\tdst[63:56] := src2[63:56]\n\tRETURN dst[63:0]\n}\t\n\t\ndst[63:0] := INTERLEAVE_HIGH_BYTES(a[63:0], b[63:0])","header":"mmintrin.h","instruction":"punpckhbw","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_0E","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_unpackhi_pi16","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Swizzle","description":"Unpack and interleave 16-bit integers from the high half of \"a\" and \"b\", and store the results in \"dst\".","code":"INTERLEAVE_HIGH_WORDS(src1[63:0], src2[63:0]){\n\tdst[15:0] := src1[47:32]\n\tdst[31:16] := src2[47:32]\n\tdst[47:32] := src1[63:48]\n\tdst[63:48] := src2[63:48]\n\tRETURN dst[63:0]\n}\n\ndst[63:0] := INTERLEAVE_HIGH_WORDS(a[63:0], b[63:0])","header":"mmintrin.h","instruction":"punpcklbw","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_0E","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_unpackhi_pi32","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Swizzle","description":"Unpack and interleave 32-bit integers from the high half of \"a\" and \"b\", and store the results in \"dst\".","code":"dst[31:0] := a[63:32]\ndst[63:32] := b[63:32]","header":"mmintrin.h","instruction":"punpckhdq","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_0E","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_unpacklo_pi8","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Swizzle","description":"Unpack and interleave 8-bit integers from the low half of \"a\" and \"b\", and store the results in \"dst\".","code":"INTERLEAVE_BYTES(src1[63:0], src2[63:0]){\n\tdst[7:0] := src1[7:0] \n\tdst[15:8] := src2[7:0] \n\tdst[23:16] := src1[15:8] \n\tdst[31:24] := src2[15:8] \n\tdst[39:32] := src1[23:16] \n\tdst[47:40] := src2[23:16] \n\tdst[55:48] := src1[31:24] \n\tdst[63:56] := src2[31:24] \n\tRETURN dst[63:0]\n}\t\n\ndst[63:0] := INTERLEAVE_BYTES(a[63:0], b[63:0])","header":"mmintrin.h","instruction":"punpcklbw","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_0E","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_unpacklo_pi16","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Swizzle","description":"Unpack and interleave 16-bit integers from the low half of \"a\" and \"b\", and store the results in \"dst\".","code":"INTERLEAVE_WORDS(src1[63:0], src2[63:0]){\n\tdst[15:0] := src1[15:0] \n\tdst[31:16] := src2[15:0] \n\tdst[47:32] := src1[31:16] \n\tdst[63:48] := src2[31:16] \n\tRETURN dst[63:0]\n}\t\n\ndst[63:0] := INTERLEAVE_WORDS(a[63:0], b[63:0])","header":"mmintrin.h","instruction":"punpcklwd","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_0E","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_unpacklo_pi32","tech":"MMX","returnType":"__m64","cpuId":"MMX","category":"Swizzle","description":"Unpack and interleave 32-bit integers from the low half of \"a\" and \"b\", and store the results in \"dst\".","code":"dst[31:0] := a[31:0]\ndst[63:32] := b[31:0]","header":"mmintrin.h","instruction":"punpckldq","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_0E","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_MM_TRANSPOSE4_PS","tech":"SSE","returnType":"","cpuId":"SSE","category":"Swizzle","description":"Macro: Transpose the 4x4 matrix formed by the 4 rows of single-precision (32-bit) floating-point elements in \"row0\", \"row1\", \"row2\", and \"row3\", and store the transposed matrix in these vectors (\"row0\" now contains column 0, etc.).","code":"__m128 tmp3, tmp2, tmp1, tmp0;\ntmp0 = _mm_unpacklo_ps(row0, row1);\ntmp2 = _mm_unpacklo_ps(row2, row3);\ntmp1 = _mm_unpackhi_ps(row0, row1);\ntmp3 = _mm_unpackhi_ps(row2, row3);\nrow0 = _mm_movelh_ps(tmp0, tmp2);\nrow1 = _mm_movehl_ps(tmp2, tmp0);\nrow2 = _mm_movelh_ps(tmp1, tmp3);\nrow3 = _mm_movehl_ps(tmp3, tmp1);","header":"xmmintrin.h","instruction":null,"parameters":[{"type":"__m128","name":"row0"},{"type":"__m128","name":"row1"},{"type":"__m128","name":"row2"},{"type":"__m128","name":"row3"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_getcsr","tech":"SSE","returnType":"unsigned int","cpuId":"SSE","category":"General Support","description":"Get the unsigned 32-bit value of the MXCSR control and status register.","code":"dst[31:0] := MXCSR","header":"xmmintrin.h","instruction":"stmxcsr","parameters":[{"type":"void","name":""}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_setcsr","tech":"SSE","returnType":"void","cpuId":"SSE","category":"General Support","description":"Set the MXCSR control and status register with the value in unsigned 32-bit integer \"a\".","code":"MXCSR := a[31:0]","header":"xmmintrin.h","instruction":"ldmxcsr","parameters":[{"type":"unsigned int","name":"a"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_MM_GET_EXCEPTION_STATE","tech":"SSE","returnType":"unsigned int","cpuId":"SSE","category":"General Support","description":"Macro: Get the exception state bits from the MXCSR control and status register. The exception state may contain any of the following flags: _MM_EXCEPT_INVALID, _MM_EXCEPT_DIV_ZERO, _MM_EXCEPT_DENORM, _MM_EXCEPT_OVERFLOW, _MM_EXCEPT_UNDERFLOW, _MM_EXCEPT_INEXACT","code":"dst[31:0] := MXCSR & _MM_EXCEPT_MASK","header":"xmmintrin.h","instruction":null,"parameters":[],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_MM_SET_EXCEPTION_STATE","tech":"SSE","returnType":"void","cpuId":"SSE","category":"General Support","description":"Macro: Set the exception state bits of the MXCSR control and status register to the value in unsigned 32-bit integer \"a\". The exception state may contain any of the following flags: _MM_EXCEPT_INVALID, _MM_EXCEPT_DIV_ZERO, _MM_EXCEPT_DENORM, _MM_EXCEPT_OVERFLOW, _MM_EXCEPT_UNDERFLOW, _MM_EXCEPT_INEXACT","code":"MXCSR := a[31:0] AND ~_MM_EXCEPT_MASK","header":"xmmintrin.h","instruction":null,"parameters":[{"type":"unsigned int","name":"a"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_MM_GET_EXCEPTION_MASK","tech":"SSE","returnType":"unsigned int","cpuId":"SSE","category":"General Support","description":"Macro: Get the exception mask bits from the MXCSR control and status register. The exception mask may contain any of the following flags: _MM_MASK_INVALID, _MM_MASK_DIV_ZERO, _MM_MASK_DENORM, _MM_MASK_OVERFLOW, _MM_MASK_UNDERFLOW, _MM_MASK_INEXACT","code":"dst[31:0] := MXCSR & _MM_MASK_MASK","header":"xmmintrin.h","instruction":null,"parameters":[],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_MM_SET_EXCEPTION_MASK","tech":"SSE","returnType":"void","cpuId":"SSE","category":"General Support","description":"Macro: Set the exception mask bits of the MXCSR control and status register to the value in unsigned 32-bit integer \"a\". The exception mask may contain any of the following flags: _MM_MASK_INVALID, _MM_MASK_DIV_ZERO, _MM_MASK_DENORM, _MM_MASK_OVERFLOW, _MM_MASK_UNDERFLOW, _MM_MASK_INEXACT","code":"MXCSR := a[31:0] AND ~_MM_MASK_MASK","header":"xmmintrin.h","instruction":null,"parameters":[{"type":"unsigned int","name":"a"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_MM_GET_ROUNDING_MODE","tech":"SSE","returnType":"unsigned int","cpuId":"SSE","category":"General Support","description":"Macro: Get the rounding mode bits from the MXCSR control and status register. The rounding mode may contain any of the following flags: _MM_ROUND_NEAREST, _MM_ROUND_DOWN, _MM_ROUND_UP, _MM_ROUND_TOWARD_ZERO","code":"dst[31:0] := MXCSR & _MM_ROUND_MASK","header":"xmmintrin.h","instruction":null,"parameters":[],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_MM_SET_ROUNDING_MODE","tech":"SSE","returnType":"void","cpuId":"SSE","category":"General Support","description":"Macro: Set the rounding mode bits of the MXCSR control and status register to the value in unsigned 32-bit integer \"a\". The rounding mode may contain any of the following flags: _MM_ROUND_NEAREST, _MM_ROUND_DOWN, _MM_ROUND_UP, _MM_ROUND_TOWARD_ZERO","code":"MXCSR := a[31:0] AND ~_MM_ROUND_MASK","header":"xmmintrin.h","instruction":null,"parameters":[{"type":"unsigned int","name":"a"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_MM_GET_FLUSH_ZERO_MODE","tech":"SSE","returnType":"unsigned int","cpuId":"SSE","category":"General Support","description":"Macro: Get the flush zero bits from the MXCSR control and status register. The flush zero may contain any of the following flags: _MM_FLUSH_ZERO_ON or _MM_FLUSH_ZERO_OFF","code":"dst[31:0] := MXCSR & _MM_FLUSH_MASK","header":"xmmintrin.h","instruction":null,"parameters":[],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_MM_SET_FLUSH_ZERO_MODE","tech":"SSE","returnType":"void","cpuId":"SSE","category":"General Support","description":"Macro: Set the flush zero bits of the MXCSR control and status register to the value in unsigned 32-bit integer \"a\". The flush zero may contain any of the following flags: _MM_FLUSH_ZERO_ON or _MM_FLUSH_ZERO_OFF","code":"MXCSR := a[31:0] AND ~_MM_FLUSH_MASK","header":"xmmintrin.h","instruction":null,"parameters":[{"type":"unsigned int","name":"a"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_prefetch","tech":"SSE","returnType":"void","cpuId":"SSE","category":"General Support","description":"Fetch the line of data from memory that contains address \"p\" to a location in the cache heirarchy specified by the locality hint \"i\".","code":null,"header":"xmmintrin.h","instruction":"prefetchnta","parameters":[{"type":"char const*","name":"p"},{"type":"int","name":"i"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_sfence","tech":"SSE","returnType":"void","cpuId":"SSE","category":"General Support","description":"Perform a serializing operation on all store-to-memory instructions that were issued prior to this instruction. Guarantees that every store instruction that precedes, in program order, is globally visible before any store instruction which follows the fence in program order.","code":null,"header":"xmmintrin.h","instruction":"sfence","parameters":[{"type":"void","name":""}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_max_pi16","tech":"SSE","returnType":"__m64","cpuId":"SSE","category":"Special Math Functions","description":"Compare packed 16-bit integers in \"a\" and \"b\", and store packed maximum values in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*16\n\tIF a[i+15:i] > b[i+15:i]\n\t\tdst[i+15:i] := a[i+15:i]\n\tELSE\n\t\tdst[i+15:i] := b[i+15:i]\n\tFI\nENDFOR","header":"xmmintrin.h","instruction":"pmaxsw","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_m_pmaxsw","tech":"SSE","returnType":"__m64","cpuId":"SSE","category":"Special Math Functions","description":"Compare packed 16-bit integers in \"a\" and \"b\", and store packed maximum values in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*16\n\tIF a[i+15:i] > b[i+15:i]\n\t\tdst[i+15:i] := a[i+15:i]\n\tELSE\n\t\tdst[i+15:i] := b[i+15:i]\n\tFI\nENDFOR","header":"xmmintrin.h","instruction":"pmaxsw","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_max_pu8","tech":"SSE","returnType":"__m64","cpuId":"SSE","category":"Special Math Functions","description":"Compare packed unsigned 8-bit integers in \"a\" and \"b\", and store packed maximum values in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*8\n\tIF a[i+7:i] > b[i+7:i]\n\t\tdst[i+7:i] := a[i+7:i]\n\tELSE\n\t\tdst[i+7:i] := b[i+7:i]\n\tFI\nENDFOR","header":"xmmintrin.h","instruction":"pmaxub","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_m_pmaxub","tech":"SSE","returnType":"__m64","cpuId":"SSE","category":"Special Math Functions","description":"Compare packed unsigned 8-bit integers in \"a\" and \"b\", and store packed maximum values in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*8\n\tIF a[i+7:i] > b[i+7:i]\n\t\tdst[i+7:i] := a[i+7:i]\n\tELSE\n\t\tdst[i+7:i] := b[i+7:i]\n\tFI\nENDFOR","header":"xmmintrin.h","instruction":"pmaxub","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_min_pi16","tech":"SSE","returnType":"__m64","cpuId":"SSE","category":"Special Math Functions","description":"Compare packed 16-bit integers in \"a\" and \"b\", and store packed minimum values in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*16\n\tIF a[i+15:i] < b[i+15:i]\n\t\tdst[i+15:i] := a[i+15:i]\n\tELSE\n\t\tdst[i+15:i] := b[i+15:i]\n\tFI\nENDFOR","header":"xmmintrin.h","instruction":"pminsw","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_m_pminsw","tech":"SSE","returnType":"__m64","cpuId":"SSE","category":"Special Math Functions","description":"Compare packed 16-bit integers in \"a\" and \"b\", and store packed minimum values in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*16\n\tIF a[i+15:i] < b[i+15:i]\n\t\tdst[i+15:i] := a[i+15:i]\n\tELSE\n\t\tdst[i+15:i] := b[i+15:i]\n\tFI\nENDFOR","header":"xmmintrin.h","instruction":"pminsw","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_min_pu8","tech":"SSE","returnType":"__m64","cpuId":"SSE","category":"Special Math Functions","description":"Compare packed unsigned 8-bit integers in \"a\" and \"b\", and store packed minimum values in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*8\n\tIF a[i+7:i] < b[i+7:i]\n\t\tdst[i+7:i] := a[i+7:i]\n\tELSE\n\t\tdst[i+7:i] := b[i+7:i]\n\tFI\nENDFOR","header":"xmmintrin.h","instruction":"pminub","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_m_pminub","tech":"SSE","returnType":"__m64","cpuId":"SSE","category":"Special Math Functions","description":"Compare packed unsigned 8-bit integers in \"a\" and \"b\", and store packed minimum values in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*8\n\tIF a[i+7:i] < b[i+7:i]\n\t\tdst[i+7:i] := a[i+7:i]\n\tELSE\n\t\tdst[i+7:i] := b[i+7:i]\n\tFI\nENDFOR","header":"xmmintrin.h","instruction":"pminub","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_mulhi_pu16","tech":"SSE","returnType":"__m64","cpuId":"SSE","category":"Arithmetic","description":"Multiply the packed unsigned 16-bit integers in \"a\" and \"b\", producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*16\n\ttmp[31:0] := a[i+15:i] * b[i+15:i]\n\tdst[i+15:i] := tmp[31:16]\nENDFOR","header":"xmmintrin.h","instruction":"pmulhuw","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"9","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"8","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"mm, mm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"mm, mm","latency":"3","throughput":"1"},{"base":"06_0D","parameters":"mm, mm","latency":"3","throughput":"1"},{"base":"0F_03","parameters":"mm, mm","latency":"9","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"8","throughput":"1"}]},{"name":"_m_pmulhuw","tech":"SSE","returnType":"__m64","cpuId":"SSE","category":"Arithmetic","description":"Multiply the packed unsigned 16-bit integers in \"a\" and \"b\", producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*16\n\ttmp[31:0] := a[i+15:i] * b[i+15:i]\n\tdst[i+15:i] := tmp[31:16]\nENDFOR","header":"xmmintrin.h","instruction":"pmulhuw","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"9","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"8","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"mm, mm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"mm, mm","latency":"3","throughput":"1"},{"base":"06_0D","parameters":"mm, mm","latency":"3","throughput":"1"},{"base":"0F_03","parameters":"mm, mm","latency":"9","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"8","throughput":"1"}]},{"name":"_mm_avg_pu8","tech":"SSE","returnType":"__m64","cpuId":"SSE","category":"Probability/Statistics","description":"Average packed unsigned 8-bit integers in \"a\" and \"b\", and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*8\n\tdst[i+7:i] := (a[i+7:i] + b[i+7:i] + 1) >> 1\nENDFOR","header":"xmmintrin.h","instruction":"pavgb","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_m_pavgb","tech":"SSE","returnType":"__m64","cpuId":"SSE","category":"Probability/Statistics","description":"Average packed unsigned 8-bit integers in \"a\" and \"b\", and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*8\n\tdst[i+7:i] := (a[i+7:i] + b[i+7:i] + 1) >> 1\nENDFOR","header":"xmmintrin.h","instruction":"pavgb","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_avg_pu16","tech":"SSE","returnType":"__m64","cpuId":"SSE","category":"Probability/Statistics","description":"Average packed unsigned 16-bit integers in \"a\" and \"b\", and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*16\n\tdst[i+15:i] := (a[i+15:i] + b[i+15:i] + 1) >> 1\nENDFOR","header":"xmmintrin.h","instruction":"pavgw","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_m_pavgw","tech":"SSE","returnType":"__m64","cpuId":"SSE","category":"Probability/Statistics","description":"Average packed unsigned 16-bit integers in \"a\" and \"b\", and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*16\n\tdst[i+15:i] := (a[i+15:i] + b[i+15:i] + 1) >> 1\nENDFOR","header":"xmmintrin.h","instruction":"pavgw","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_sad_pu8","tech":"SSE","returnType":"__m64","cpuId":"SSE","category":"Arithmetic","description":"Compute the absolute differences of packed unsigned 8-bit integers in \"a\" and \"b\", then horizontally sum each consecutive 8 differences to produce four unsigned 16-bit integers, and pack these unsigned 16-bit integers in the low 16 bits of \"dst\".","code":"FOR j := 0 to 7\n\ti := j*8\n\ttmp[i+7:i] := ABS(a[i+7:i] - b[i+7:i])\nENDFOR\n\ndst[15:0] := tmp[7:0] + tmp[15:8] + tmp[23:16] + tmp[31:24]\n\t\t   + tmp[39:32] + tmp[47:40] + tmp[55:48] + tmp[63:56]\ndst[63:16] := 0","header":"xmmintrin.h","instruction":"psadbw","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"7","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"7","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"mm, mm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"mm, mm","latency":"5","throughput":"2"},{"base":"06_0D","parameters":"mm, mm","latency":"5","throughput":"2"},{"base":"0F_03","parameters":"mm, mm","latency":"4","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"4","throughput":"1"}]},{"name":"_m_psadbw","tech":"SSE","returnType":"__m64","cpuId":"SSE","category":"Arithmetic","description":"Compute the absolute differences of packed unsigned 8-bit integers in \"a\" and \"b\", then horizontally sum each consecutive 8 differences to produce four unsigned 16-bit integers, and pack these unsigned 16-bit integers in the low 16 bits of \"dst\".","code":"FOR j := 0 to 7\n\ti := j*8\n\ttmp[i+7:i] := ABS(a[i+7:i] - b[i+7:i])\nENDFOR\n\ndst[15:0] := tmp[7:0] + tmp[15:8] + tmp[23:16] + tmp[31:24]\n\t\t   + tmp[39:32] + tmp[47:40] + tmp[55:48] + tmp[63:56]\ndst[63:16] := 0","header":"xmmintrin.h","instruction":"psadbw","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"7","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"7","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"mm, mm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"mm, mm","latency":"5","throughput":"2"},{"base":"06_0D","parameters":"mm, mm","latency":"5","throughput":"2"},{"base":"0F_03","parameters":"mm, mm","latency":"4","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"4","throughput":"1"}]},{"name":"_mm_cvtsi32_ss","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Convert","description":"Convert the 32-bit integer \"b\" to a single-precision (32-bit) floating-point element, store the result in the lower element of \"dst\", and copy the upper 3 packed elements from \"a\" to the upper elements of \"dst\".","code":"dst[31:0] := Convert_Int32_To_FP32(b[31:0])\ndst[127:32] := a[127:32]","header":"xmmintrin.h","instruction":"cvtsi2ss","parameters":[{"type":"__m128","name":"a"},{"type":"int","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, r32","latency":"5","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, r32","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, r32","latency":"6","throughput":"3"},{"base":"06_0F","parameters":"xmm, r32","latency":"4","throughput":"1"},{"base":"0F_03","parameters":"xmm, r32","latency":"12","throughput":"2"},{"base":"0F_02","parameters":"xmm, r32","latency":"11","throughput":"2"}]},{"name":"_mm_cvt_si2ss","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Convert","description":"Convert the 32-bit integer \"b\" to a single-precision (32-bit) floating-point element, store the result in the lower element of \"dst\", and copy the upper 3 packed elements from \"a\" to the upper elements of \"dst\".","code":"dst[31:0] := Convert_Int32_To_FP32(b[31:0])\ndst[127:32] := a[127:32]","header":"xmmintrin.h","instruction":"cvtsi2ss","parameters":[{"type":"__m128","name":"a"},{"type":"int","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, r32","latency":"5","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, r32","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, r32","latency":"6","throughput":"3"},{"base":"06_0F","parameters":"xmm, r32","latency":"4","throughput":"1"},{"base":"0F_03","parameters":"xmm, r32","latency":"12","throughput":"2"},{"base":"0F_02","parameters":"xmm, r32","latency":"11","throughput":"2"}]},{"name":"_mm_cvtsi64_ss","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Convert","description":"Convert the 64-bit integer \"b\" to a single-precision (32-bit) floating-point element, store the result in the lower element of \"dst\", and copy the upper 3 packed elements from \"a\" to the upper elements of \"dst\".","code":"dst[31:0] := Convert_Int64_To_FP32(b[63:0])\ndst[127:32] := a[127:32]\ndst[MAX:128] := 0","header":"xmmintrin.h","instruction":"cvtsi2ss","parameters":[{"type":"__m128","name":"a"},{"type":"__int64","name":"b"}],"isFloat":true,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, r32","latency":"5","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, r32","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, r32","latency":"6","throughput":"3"},{"base":"06_0F","parameters":"xmm, r32","latency":"4","throughput":"1"},{"base":"0F_03","parameters":"xmm, r32","latency":"12","throughput":"2"},{"base":"0F_02","parameters":"xmm, r32","latency":"11","throughput":"2"}]},{"name":"_mm_cvtpi32_ps","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Convert","description":"Convert packed 32-bit integers in \"b\" to packed single-precision (32-bit) floating-point elements, store the results in the lower 2 elements of \"dst\", and copy the upper 2 packed elements from \"a\" to the upper elements of \"dst\".","code":"dst[31:0] := Convert_Int32_To_FP32(b[31:0])\ndst[63:32] := Convert_Int32_To_FP32(b[63:32])\ndst[95:64] := a[95:64]\ndst[127:96] := a[127:96]","header":"xmmintrin.h","instruction":"cvtpi2ps","parameters":[{"type":"__m128","name":"a"},{"type":"__m64","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, mm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, mm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, mm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, mm","latency":"3","throughput":"1"},{"base":"06_0D","parameters":"xmm, mm","latency":"3","throughput":"1"},{"base":"0F_03","parameters":"xmm, mm","latency":"12","throughput":"2"},{"base":"0F_02","parameters":"xmm, mm","latency":"11","throughput":"4"}]},{"name":"_mm_cvt_pi2ps","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Convert","description":"Convert packed 32-bit integers in \"b\" to packed single-precision (32-bit) floating-point elements, store the results in the lower 2 elements of \"dst\", and copy the upper 2 packed elements from \"a\" to the upper elements of \"dst\".","code":"dst[31:0] := Convert_Int32_To_FP32(b[31:0])\ndst[63:32] := Convert_Int32_To_FP32(b[63:32])\ndst[95:64] := a[95:64]\ndst[127:96] := a[127:96]","header":"xmmintrin.h","instruction":"cvtpi2ps","parameters":[{"type":"__m128","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, mm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, mm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, mm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, mm","latency":"3","throughput":"1"},{"base":"06_0D","parameters":"xmm, mm","latency":"3","throughput":"1"},{"base":"0F_03","parameters":"xmm, mm","latency":"12","throughput":"2"},{"base":"0F_02","parameters":"xmm, mm","latency":"11","throughput":"4"}]},{"name":"_mm_cvtpi16_ps","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Convert","description":"Convert packed 16-bit integers in \"a\" to packed single-precision (32-bit) floating-point elements, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*16\n\tm := j*32\n\tdst[m+31:m] := Convert_Int16_To_FP32(a[i+15:i])\nENDFOR","header":"xmmintrin.h","instruction":null,"parameters":[{"type":"__m64","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_cvtpu16_ps","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Convert","description":"Convert packed unsigned 16-bit integers in \"a\" to packed single-precision (32-bit) floating-point elements, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*16\n\tm := j*32\n\tdst[m+31:m] := Convert_UnsignedInt16_To_FP32(a[i+15:i])\nENDFOR","header":"xmmintrin.h","instruction":null,"parameters":[{"type":"__m64","name":"a"}],"isFloat":true,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_cvtpi8_ps","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Convert","description":"Convert the lower packed 8-bit integers in \"a\" to packed single-precision (32-bit) floating-point elements, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*8\n\tm := j*32\n\tdst[m+31:m] := Convert_Int8_To_FP32(a[i+7:i])\nENDFOR","header":"xmmintrin.h","instruction":null,"parameters":[{"type":"__m64","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_cvtpu8_ps","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Convert","description":"Convert the lower packed unsigned 8-bit integers in \"a\" to packed single-precision (32-bit) floating-point elements, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*8\n\tm := j*32\n\tdst[m+31:m] := Convert_UnsignedInt8_To_FP32(a[i+7:i])\nENDFOR","header":"xmmintrin.h","instruction":null,"parameters":[{"type":"__m64","name":"a"}],"isFloat":true,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_cvtpi32x2_ps","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Convert","description":"Convert packed 32-bit integers in \"a\" to packed single-precision (32-bit) floating-point elements, store the results in the lower 2 elements of \"dst\", then covert the packed 32-bit integers in \"a\" to single-precision (32-bit) floating-point element, and store the results in the upper 2 elements of \"dst\".","code":"dst[31:0] := Convert_Int32_To_FP32(a[31:0])\ndst[63:32] := Convert_Int32_To_FP32(a[63:32])\ndst[95:64] := Convert_Int32_To_FP32(b[31:0])\ndst[127:96] := Convert_Int32_To_FP32(b[63:32])","header":"xmmintrin.h","instruction":null,"parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_stream_pi","tech":"SSE","returnType":"void","cpuId":"SSE","category":"Store","description":"Store 64-bits of integer data from \"a\" into memory using a non-temporal memory hint.","code":"MEM[mem_addr+63:mem_addr] := a[63:0]","header":"xmmintrin.h","instruction":"movntq","parameters":[{"type":"__m64*","name":"mem_addr"},{"type":"__m64","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_maskmove_si64","tech":"SSE","returnType":"void","cpuId":"SSE","category":"Store","description":"Conditionally store 8-bit integer elements from \"a\" into memory using \"mask\" (elements are not stored when the highest bit is not set in the corresponding element).","code":"FOR j := 0 to 7\n\ti := j*8\n\tIF mask[i+7]\n\t\tMEM[mem_addr+i+7:mem_addr+i] := a[i+7:i]\n\tFI\nENDFOR","header":"xmmintrin.h","instruction":"maskmovq","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"mask"},{"type":"char*","name":"mem_addr"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_0F","parameters":"mm, mm","latency":"3","throughput":"1"}]},{"name":"_m_maskmovq","tech":"SSE","returnType":"void","cpuId":"SSE","category":"Store","description":"Conditionally store 8-bit integer elements from \"a\" into memory using \"mask\" (elements are not stored when the highest bit is not set in the corresponding element).","code":"FOR j := 0 to 7\n\ti := j*8\n\tIF mask[i+7]\n\t\tMEM[mem_addr+i+7:mem_addr+i] := a[i+7:i]\n\tFI\nENDFOR","header":"xmmintrin.h","instruction":"maskmovq","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"mask"},{"type":"char*","name":"mem_addr"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_0F","parameters":"mm, mm","latency":"3","throughput":"1"}]},{"name":"_mm_extract_pi16","tech":"SSE","returnType":"int","cpuId":"SSE","category":"Swizzle","description":"Extract a 16-bit integer from \"a\", selected with \"imm\", and store the result in the lower element of \"dst\".","code":"dst[15:0] := (a[63:0] >> (imm[1:0] * 16))[15:0]\ndst[31:16] := 0","header":"xmmintrin.h","instruction":"pextrw","parameters":[{"type":"__m64","name":"a"},{"type":"int","name":"imm"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3/3C/45/46E","parameters":"reg, xmm, imm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"reg, xmm, imm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"reg, xmm, imm","latency":"5","throughput":"1"},{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"r32, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"r32, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"r32, xmm, imm8","latency":"","throughput":"1"},{"base":"06_0F","parameters":"r32, xmm, imm8","latency":"2","throughput":"1"},{"base":"06_0E","parameters":"r32, xmm, imm8","latency":"3","throughput":"2"},{"base":"06_0D","parameters":"r32, xmm, imm8","latency":"3","throughput":"2"},{"base":"0F_03","parameters":"r32, xmm, imm8","latency":"7","throughput":"2"},{"base":"0F_02","parameters":"r32, xmm, imm8","latency":"7","throughput":"2"},{"base":"06_17","parameters":"r32, mm,imm8","latency":"","throughput":"1"},{"base":"06_0F","parameters":"r32, mm,imm8","latency":"2","throughput":"1"},{"base":"06_0E","parameters":"r32, mm,imm8","latency":"2","throughput":"1"},{"base":"06_0D","parameters":"r32, mm,imm8","latency":"2","throughput":"1"},{"base":"0F_03","parameters":"r32, mm, imm8","latency":"7","throughput":"2"},{"base":"0F_02","parameters":"r32, mm, imm8","latency":"7","throughput":"2"}]},{"name":"_m_pextrw","tech":"SSE","returnType":"int","cpuId":"SSE","category":"Swizzle","description":"Extract a 16-bit integer from \"a\", selected with \"imm\", and store the result in the lower element of \"dst\".","code":"dst[15:0] := (a[63:0] >> (imm[1:0] * 16))[15:0]\ndst[31:16] := 0","header":"xmmintrin.h","instruction":"pextrw","parameters":[{"type":"__m64","name":"a"},{"type":"int","name":"imm"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3/3C/45/46E","parameters":"reg, xmm, imm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"reg, xmm, imm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"reg, xmm, imm","latency":"5","throughput":"1"},{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"r32, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"r32, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"r32, xmm, imm8","latency":"","throughput":"1"},{"base":"06_0F","parameters":"r32, xmm, imm8","latency":"2","throughput":"1"},{"base":"06_0E","parameters":"r32, xmm, imm8","latency":"3","throughput":"2"},{"base":"06_0D","parameters":"r32, xmm, imm8","latency":"3","throughput":"2"},{"base":"0F_03","parameters":"r32, xmm, imm8","latency":"7","throughput":"2"},{"base":"0F_02","parameters":"r32, xmm, imm8","latency":"7","throughput":"2"},{"base":"06_17","parameters":"r32, mm,imm8","latency":"","throughput":"1"},{"base":"06_0F","parameters":"r32, mm,imm8","latency":"2","throughput":"1"},{"base":"06_0E","parameters":"r32, mm,imm8","latency":"2","throughput":"1"},{"base":"06_0D","parameters":"r32, mm,imm8","latency":"2","throughput":"1"},{"base":"0F_03","parameters":"r32, mm, imm8","latency":"7","throughput":"2"},{"base":"0F_02","parameters":"r32, mm, imm8","latency":"7","throughput":"2"}]},{"name":"_mm_insert_pi16","tech":"SSE","returnType":"__m64","cpuId":"SSE","category":"Swizzle","description":"Copy \"a\" to \"dst\", and insert the 16-bit integer \"i\" into \"dst\" at the location specified by \"imm\".","code":"dst[63:0] := a[63:0]\nsel := imm[1:0]*16\ndst[sel+15:sel] := i[15:0]","header":"xmmintrin.h","instruction":"pinsrw","parameters":[{"type":"__m64","name":"a"},{"type":"int","name":"i"},{"type":"int","name":"imm"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, reg, imm","latency":"2","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, reg, imm","latency":"2","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, reg, imm","latency":"4","throughput":"1"},{"base":"06_3C/45/46","parameters":"xmm, r32, imm8","latency":"2","throughput":"2"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, r32, imm8","latency":"2","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, r32, imm8","latency":"2","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, r32, imm8","latency":"","throughput":"1"},{"base":"06_0F","parameters":"xmm, r32, imm8","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, r32, imm8","latency":"2","throughput":"2"},{"base":"06_0D","parameters":"xmm, r32, imm8","latency":"2","throughput":"2"},{"base":"0F_03","parameters":"xmm, r32, imm8","latency":"4","throughput":"2"},{"base":"0F_02","parameters":"xmm, r32, imm8","latency":"4","throughput":"2"},{"base":"06_17","parameters":"mm, r32, imm8","latency":"0","throughput":"1"},{"base":"06_0F","parameters":"mm, r32, imm8","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, r32, imm8","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, r32, imm8","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, r32, imm8","latency":"4","throughput":"1"},{"base":"0F_02","parameters":"mm, r32, imm8","latency":"4","throughput":"1"}]},{"name":"_m_pinsrw","tech":"SSE","returnType":"__m64","cpuId":"SSE","category":"Swizzle","description":"Copy \"a\" to \"dst\", and insert the 16-bit integer \"i\" into \"dst\" at the location specified by \"imm\".","code":"dst[63:0] := a[63:0]\nsel := imm[1:0]*16\ndst[sel+15:sel] := i[15:0]","header":"xmmintrin.h","instruction":"pinsrw","parameters":[{"type":"__m64","name":"a"},{"type":"int","name":"i"},{"type":"int","name":"imm"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, reg, imm","latency":"2","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, reg, imm","latency":"2","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, reg, imm","latency":"4","throughput":"1"},{"base":"06_3C/45/46","parameters":"xmm, r32, imm8","latency":"2","throughput":"2"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, r32, imm8","latency":"2","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, r32, imm8","latency":"2","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, r32, imm8","latency":"","throughput":"1"},{"base":"06_0F","parameters":"xmm, r32, imm8","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, r32, imm8","latency":"2","throughput":"2"},{"base":"06_0D","parameters":"xmm, r32, imm8","latency":"2","throughput":"2"},{"base":"0F_03","parameters":"xmm, r32, imm8","latency":"4","throughput":"2"},{"base":"0F_02","parameters":"xmm, r32, imm8","latency":"4","throughput":"2"},{"base":"06_17","parameters":"mm, r32, imm8","latency":"0","throughput":"1"},{"base":"06_0F","parameters":"mm, r32, imm8","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, r32, imm8","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, r32, imm8","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, r32, imm8","latency":"4","throughput":"1"},{"base":"0F_02","parameters":"mm, r32, imm8","latency":"4","throughput":"1"}]},{"name":"_mm_movemask_pi8","tech":"SSE","returnType":"int","cpuId":"SSE","category":"Miscellaneous","description":"Create mask from the most significant bit of each 8-bit element in \"a\", and store the result in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*8\n\tdst[j] := a[i+7]\nENDFOR\ndst[MAX:8] := 0","header":"xmmintrin.h","instruction":"pmovmskb","parameters":[{"type":"__m64","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"r32, xmm","latency":"2","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"r32, xmm","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"r32, xmm","latency":"","throughput":"1"},{"base":"06_0F","parameters":"r32, xmm","latency":"","throughput":"1"},{"base":"06_0E","parameters":"r32, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"r32, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"r32, xmm","latency":"7","throughput":"2"},{"base":"0F_02","parameters":"r32, xmm","latency":"7","throughput":"2"},{"base":"06_17","parameters":"r32, mm","latency":"","throughput":"1"},{"base":"06_0F","parameters":"r32, mm","latency":"","throughput":"1"},{"base":"06_0E","parameters":"r32, mm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"r32, mm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"r32, mm","latency":"7","throughput":"2"},{"base":"0F_02","parameters":"r32, mm","latency":"7","throughput":"2"}]},{"name":"_m_pmovmskb","tech":"SSE","returnType":"int","cpuId":"SSE","category":"Miscellaneous","description":"Create mask from the most significant bit of each 8-bit element in \"a\", and store the result in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*8\n\tdst[j] := a[i+7]\nENDFOR\ndst[MAX:8] := 0","header":"xmmintrin.h","instruction":"pmovmskb","parameters":[{"type":"__m64","name":"a"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"r32, xmm","latency":"2","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"r32, xmm","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"r32, xmm","latency":"","throughput":"1"},{"base":"06_0F","parameters":"r32, xmm","latency":"","throughput":"1"},{"base":"06_0E","parameters":"r32, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"r32, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"r32, xmm","latency":"7","throughput":"2"},{"base":"0F_02","parameters":"r32, xmm","latency":"7","throughput":"2"},{"base":"06_17","parameters":"r32, mm","latency":"","throughput":"1"},{"base":"06_0F","parameters":"r32, mm","latency":"","throughput":"1"},{"base":"06_0E","parameters":"r32, mm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"r32, mm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"r32, mm","latency":"7","throughput":"2"},{"base":"0F_02","parameters":"r32, mm","latency":"7","throughput":"2"}]},{"name":"_mm_shuffle_pi16","tech":"SSE","returnType":"__m64","cpuId":"SSE","category":"Swizzle","description":"Shuffle 16-bit integers in \"a\" using the control in \"imm\", and store the results in \"dst\".","code":"SELECT4(src, control){\n\tCASE(control[1:0])\n\t\t0:\ttmp[15:0] := src[15:0]\n\t\t1:\ttmp[15:0] := src[31:16]\n\t\t2:\ttmp[15:0] := src[47:32]\n\t\t3:\ttmp[15:0] := src[63:48]\n\tESAC\n\tRETURN tmp[15:0]\n}\n\ndst[15:0] := SELECT4(a[63:0], imm[1:0])\ndst[31:16] := SELECT4(a[63:0], imm[3:2])\ndst[47:32] := SELECT4(a[63:0], imm[5:4])\ndst[63:48] := SELECT4(a[63:0], imm[7:6])","header":"xmmintrin.h","instruction":"pshufw","parameters":[{"type":"__m64","name":"a"},{"type":"int","name":"imm"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_17","parameters":"mm, mm, imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm, imm8","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm, imm8","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm, imm8","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm, imm8","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm, imm8","latency":"2","throughput":"1"}]},{"name":"_m_pshufw","tech":"SSE","returnType":"__m64","cpuId":"SSE","category":"Swizzle","description":"Shuffle 16-bit integers in \"a\" using the control in \"imm\", and store the results in \"dst\".","code":"SELECT4(src, control){\n\tCASE(control[1:0])\n\t\t0:\ttmp[15:0] := src[15:0]\n\t\t1:\ttmp[15:0] := src[31:16]\n\t\t2:\ttmp[15:0] := src[47:32]\n\t\t3:\ttmp[15:0] := src[63:48]\n\tESAC\n\tRETURN tmp[15:0]\n}\n\ndst[15:0] := SELECT4(a[63:0], imm[1:0])\ndst[31:16] := SELECT4(a[63:0], imm[3:2])\ndst[47:32] := SELECT4(a[63:0], imm[5:4])\ndst[63:48] := SELECT4(a[63:0], imm[7:6])","header":"xmmintrin.h","instruction":"pshufw","parameters":[{"type":"__m64","name":"a"},{"type":"int","name":"imm"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_17","parameters":"mm, mm, imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm, imm8","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm, imm8","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm, imm8","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm, imm8","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm, imm8","latency":"2","throughput":"1"}]},{"name":"_mm_add_ss","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Arithmetic","description":"Add the lower single-precision (32-bit) floating-point element in \"a\" and \"b\", store the result in the lower element of \"dst\", and copy the upper 3 packed elements from \"a\" to the upper elements of \"dst\".","code":"dst[31:0] := a[31:0] + b[31:0]\ndst[127:32] := a[127:32]","header":"xmmintrin.h","instruction":"addss","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"}]},{"name":"_mm_add_ps","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Arithmetic","description":"Add packed single-precision (32-bit) floating-point elements in \"a\" and \"b\", and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := a[i+31:i] + b[i+31:i]\nENDFOR","header":"xmmintrin.h","instruction":"addps","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"}]},{"name":"_mm_sub_ss","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Arithmetic","description":"Subtract the lower single-precision (32-bit) floating-point element in \"b\" from the lower single-precision (32-bit) floating-point element in \"a\", store the result in the lower element of \"dst\", and copy the upper 3 packed elements from \"a\" to the upper elements of \"dst\".","code":"dst[31:0] := a[31:0] - b[31:0]\ndst[127:32] := a[127:32]","header":"xmmintrin.h","instruction":"subss","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"}]},{"name":"_mm_sub_ps","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Arithmetic","description":"Subtract packed single-precision (32-bit) floating-point elements in \"b\" from packed single-precision (32-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := a[i+31:i] - b[i+31:i]\nENDFOR","header":"xmmintrin.h","instruction":"subps","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"}]},{"name":"_mm_mul_ss","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Arithmetic","description":"Multiply the lower single-precision (32-bit) floating-point element in \"a\" and \"b\", store the result in the lower element of \"dst\", and copy the upper 3 packed elements from \"a\" to the upper elements of \"dst\".","code":"dst[31:0] := a[31:0] * b[31:0]\ndst[127:32] := a[127:32]","header":"xmmintrin.h","instruction":"mulss","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"5","throughput":"0.5"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"5","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"4","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"4","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"4","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"4","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"4","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"7","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"6","throughput":"2"}]},{"name":"_mm_mul_ps","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Arithmetic","description":"Multiply packed single-precision (32-bit) floating-point elements in \"a\" and \"b\", and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := a[i+31:i] * b[i+31:i]\nENDFOR","header":"xmmintrin.h","instruction":"mulps","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"5","throughput":"0.5"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"5","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"4","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"4","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"4","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"5","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"5","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"7","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"6","throughput":"2"}]},{"name":"_mm_div_ss","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Arithmetic","description":"Divide the lower single-precision (32-bit) floating-point element in \"a\" by the lower single-precision (32-bit) floating-point element in \"b\", store the result in the lower element of \"dst\", and copy the upper 3 packed elements from \"a\" to the upper elements of \"dst\".","code":"dst[31:0] := a[31:0] / b[31:0]\ndst[127:32] := a[127:32]","header":"xmmintrin.h","instruction":"divss","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"10-12","throughput":"5"},{"base":"06_3A/3E","parameters":"xmm, xmm","latency":"10-14","throughput":"6"},{"base":"06_2A/2D","parameters":"xmm, xmm","latency":"10-14","throughput":"14"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"<16","throughput":"<12"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"<21","throughput":"<21"},{"base":"06_0F","parameters":"xmm, xmm","latency":"<21","throughput":"<21"},{"base":"06_0E","parameters":"xmm, xmm","latency":"18","throughput":"17"},{"base":"06_0D","parameters":"xmm, xmm","latency":"18","throughput":"17"},{"base":"0F_03","parameters":"xmm, xmm","latency":"32","throughput":"32"},{"base":"0F_02","parameters":"xmm, xmm","latency":"23","throughput":"23"}]},{"name":"_mm_div_ps","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Arithmetic","description":"Divide packed single-precision (32-bit) floating-point elements in \"a\" by packed elements in \"b\", and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := 32*j\n\tdst[i+31:i] := a[i+31:i] / b[i+31:i]\nENDFOR","header":"xmmintrin.h","instruction":"divps","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"10-12","throughput":"5"},{"base":"06_3A/3E","parameters":"xmm, xmm","latency":"10-14","throughput":"6"},{"base":"06_2A/2D","parameters":"xmm, xmm","latency":"10-14","throughput":"14"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"<16","throughput":"<12"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"<21","throughput":"<21"},{"base":"06_0F","parameters":"xmm, xmm","latency":"<21","throughput":"<21"},{"base":"06_0E","parameters":"xmm, xmm","latency":"35","throughput":"34"},{"base":"06_0D","parameters":"xmm, xmm","latency":"35","throughput":"34"},{"base":"0F_03","parameters":"xmm, xmm","latency":"40","throughput":"40"},{"base":"0F_02","parameters":"xmm, xmm","latency":"39","throughput":"39"}]},{"name":"_mm_sqrt_ss","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Elementary Math Functions","description":"Compute the square root of the lower single-precision (32-bit) floating-point element in \"a\", store the result in the lower element of \"dst\", and copy the upper 3 packed elements from \"a\" to the upper elements of \"dst\".","code":"dst[31:0] := SQRT(a[31:0])\ndst[127:32] := a[127:32]","header":"xmmintrin.h","instruction":"sqrtss","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"18","throughput":"7"},{"base":"06_3A/3E","parameters":"xmm, xmm","latency":"20","throughput":"7"},{"base":"06_2A/2D","parameters":"xmm, xmm","latency":"22","throughput":"14"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"25","throughput":"<16"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"<21","throughput":"<14"},{"base":"06_0F","parameters":"xmm, xmm","latency":"<32","throughput":"<27"},{"base":"0F_03","parameters":"xmm, xmm","latency":"32","throughput":"32"},{"base":"0F_02","parameters":"xmm, xmm","latency":"23","throughput":"23"}]},{"name":"_mm_sqrt_ps","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Elementary Math Functions","description":"Compute the square root of packed single-precision (32-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := SQRT(a[i+31:i])\nENDFOR","header":"xmmintrin.h","instruction":"sqrtps","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"18","throughput":"7"},{"base":"06_3A/3E","parameters":"xmm, xmm","latency":"20","throughput":"7"},{"base":"06_2A/2D","parameters":"xmm, xmm","latency":"22","throughput":"14"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"25","throughput":"<16"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"<21","throughput":"<14"},{"base":"06_0F","parameters":"xmm, xmm","latency":"<32","throughput":"<27"},{"base":"0F_03","parameters":"xmm, xmm","latency":"40","throughput":"40"},{"base":"0F_02","parameters":"xmm, xmm","latency":"39","throughput":"39"}]},{"name":"_mm_rcp_ss","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Elementary Math Functions","description":"Compute the approximate reciprocal of the lower single-precision (32-bit) floating-point element in \"a\", store the result in the lower element of \"dst\", and copy the upper 3 packed elements from \"a\" to the upper elements of \"dst\". The maximum relative error for this approximation is less than 1.5*2^-12.","code":"dst[31:0] := APPROXIMATE(1.0/a[31:0])\ndst[127:32] := a[127:32]","header":"xmmintrin.h","instruction":"rcpss","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"5","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"3"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"3","throughput":"3"},{"base":"06_0F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"6","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"6","throughput":"2"}]},{"name":"_mm_rcp_ps","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Elementary Math Functions","description":"Compute the approximate reciprocal of packed single-precision (32-bit) floating-point elements in \"a\", and store the results in \"dst\". The maximum relative error for this approximation is less than 1.5*2^-12.","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := APPROXIMATE(1.0/a[i+31:i])\nENDFOR","header":"xmmintrin.h","instruction":"rcpps","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"5","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"2"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"3","throughput":"2"},{"base":"06_0F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"6","throughput":"4"},{"base":"0F_02","parameters":"xmm, xmm","latency":"6","throughput":"4"}]},{"name":"_mm_rsqrt_ss","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Elementary Math Functions","description":"Compute the approximate reciprocal square root of the lower single-precision (32-bit) floating-point element in \"a\", store the result in the lower element of \"dst\", and copy the upper 3 packed elements from \"a\" to the upper elements of \"dst\". The maximum relative error for this approximation is less than 1.5*2^-12.","code":"dst[31:0] := APPROXIMATE(1.0 / SQRT(a[31:0]))\ndst[127:32] := a[127:32]","header":"xmmintrin.h","instruction":"rsqrtss","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"5","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"3"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"3","throughput":"3"},{"base":"06_0F","parameters":"xmm, xmm","latency":"3","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"6","throughput":"4"},{"base":"0F_02","parameters":"xmm, xmm","latency":"6","throughput":"4"}]},{"name":"_mm_rsqrt_ps","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Elementary Math Functions","description":"Compute the approximate reciprocal square root of packed single-precision (32-bit) floating-point elements in \"a\", and store the results in \"dst\". The maximum relative error for this approximation is less than 1.5*2^-12.","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := APPROXIMATE(1.0 / SQRT(a[i+31:i]))\nENDFOR","header":"xmmintrin.h","instruction":"rsqrtps","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"5","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"2"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"3","throughput":"2"},{"base":"06_0F","parameters":"xmm, xmm","latency":"3","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"6","throughput":"4"},{"base":"0F_02","parameters":"xmm, xmm","latency":"6","throughput":"4"}]},{"name":"_mm_min_ss","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Special Math Functions","description":"Compare the lower single-precision (32-bit) floating-point elements in \"a\" and \"b\", store the minimum value in the lower element of \"dst\", and copy the upper element from \"a\" to the upper element of \"dst\".","code":"dst[31:0] := MIN(a[31:0], b[31:0])\ndst[127:32] := a[127:32]","header":"xmmintrin.h","instruction":"minss","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"}]},{"name":"_mm_min_ps","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Special Math Functions","description":"Compare packed single-precision (32-bit) floating-point elements in \"a\" and \"b\", and store packed minimum values in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := MIN(a[i+31:i], b[i+31:i])\nENDFOR","header":"xmmintrin.h","instruction":"minps","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"}]},{"name":"_mm_max_ss","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Special Math Functions","description":"Compare the lower single-precision (32-bit) floating-point elements in \"a\" and \"b\", store the maximum value in the lower element of \"dst\", and copy the upper element from \"a\" to the upper element of \"dst\".","code":"dst[31:0] := MAX(a[31:0], b[31:0])\ndst[127:32] := a[127:32]","header":"xmmintrin.h","instruction":"maxss","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"}]},{"name":"_mm_max_ps","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Special Math Functions","description":"Compare packed single-precision (32-bit) floating-point elements in \"a\" and \"b\", and store packed maximum values in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := MAX(a[i+31:i], b[i+31:i])\nENDFOR","header":"xmmintrin.h","instruction":"maxps","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"}]},{"name":"_mm_and_ps","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Logical","description":"Compute the bitwise AND of packed single-precision (32-bit) floating-point elements in \"a\" and \"b\", and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := (a[i+31:i] AND b[i+31:i])\nENDFOR","header":"xmmintrin.h","instruction":"andps","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"}]},{"name":"_mm_andnot_ps","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Logical","description":"Compute the bitwise AND NOT of packed single-precision (32-bit) floating-point elements in \"a\" and \"b\", and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := ((NOT a[i+31:i]) AND b[i+31:i])\nENDFOR","header":"xmmintrin.h","instruction":"andnps","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"}]},{"name":"_mm_or_ps","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Logical","description":"Compute the bitwise OR of packed single-precision (32-bit) floating-point elements in \"a\" and \"b\", and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := a[i+31:i] BITWISE OR b[i+31:i]\nENDFOR","header":"xmmintrin.h","instruction":"orps","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"0F_03","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"}]},{"name":"_mm_xor_ps","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Logical","description":"Compute the bitwise XOR of packed single-precision (32-bit) floating-point elements in \"a\" and \"b\", and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := a[i+31:i] XOR b[i+31:i]\nENDFOR","header":"xmmintrin.h","instruction":"xorps","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"0F_03","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"}]},{"name":"_mm_cmpeq_ss","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Compare","description":"Compare the lower single-precision (32-bit) floating-point elements in \"a\" and \"b\" for equality, store the result in the lower element of \"dst\", and copy the upper 3 packed elements from \"a\" to the upper elements of \"dst\".","code":"dst[31:0] := ( a[31:0] == b[31:0] ) ? 0xffffffff : 0\ndst[127:32] := a[127:32]","header":"xmmintrin.h","instruction":"cmpss","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"}]},{"name":"_mm_cmpeq_ps","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Compare","description":"Compare packed single-precision (32-bit) floating-point elements in \"a\" and \"b\" for equality, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := ( a[i+31:i] == b[i+31:i] ) ? 0xffffffff : 0\nENDFOR","header":"xmmintrin.h","instruction":"cmpps","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"}]},{"name":"_mm_cmplt_ss","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Compare","description":"Compare the lower single-precision (32-bit) floating-point elements in \"a\" and \"b\" for less-than, store the result in the lower element of \"dst\", and copy the upper 3 packed elements from \"a\" to the upper elements of \"dst\".","code":"dst[31:0] := ( a[31:0] < b[31:0] ) ? 0xffffffff : 0\ndst[127:32] := a[127:32]","header":"xmmintrin.h","instruction":"cmpss","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"}]},{"name":"_mm_cmplt_ps","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Compare","description":"Compare packed single-precision (32-bit) floating-point elements in \"a\" and \"b\" for less-than, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := ( a[i+31:i] < b[i+31:i] ) ? 0xffffffff : 0\nENDFOR","header":"xmmintrin.h","instruction":"cmpps","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"}]},{"name":"_mm_cmple_ss","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Compare","description":"Compare the lower single-precision (32-bit) floating-point elements in \"a\" and \"b\" for less-than-or-equal, store the result in the lower element of \"dst\", and copy the upper 3 packed elements from \"a\" to the upper elements of \"dst\".","code":"dst[31:0] := ( a[31:0] <= b[31:0] ) ? 0xffffffff : 0\ndst[127:32] := a[127:32]","header":"xmmintrin.h","instruction":"cmpss","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"}]},{"name":"_mm_cmple_ps","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Compare","description":"Compare packed single-precision (32-bit) floating-point elements in \"a\" and \"b\" for less-than-or-equal, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := ( a[i+31:i] <= b[i+31:i] ) ? 0xffffffff : 0\nENDFOR","header":"xmmintrin.h","instruction":"cmpps","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"}]},{"name":"_mm_cmpgt_ss","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Compare","description":"Compare the lower single-precision (32-bit) floating-point elements in \"a\" and \"b\" for greater-than, store the result in the lower element of \"dst\", and copy the upper 3 packed elements from \"a\" to the upper elements of \"dst\".","code":"dst[31:0] := ( a[31:0] > b[31:0] ) ? 0xffffffff : 0\ndst[127:32] := a[127:32]","header":"xmmintrin.h","instruction":"cmpss","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"}]},{"name":"_mm_cmpgt_ps","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Compare","description":"Compare packed single-precision (32-bit) floating-point elements in \"a\" and \"b\" for greater-than, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := ( a[i+31:i] > b[i+31:i] ) ? 0xffffffff : 0\nENDFOR","header":"xmmintrin.h","instruction":"cmpps","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"}]},{"name":"_mm_cmpge_ss","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Compare","description":"Compare the lower single-precision (32-bit) floating-point elements in \"a\" and \"b\" for greater-than-or-equal, store the result in the lower element of \"dst\", and copy the upper 3 packed elements from \"a\" to the upper elements of \"dst\".","code":"dst[31:0] := ( a[31:0] >= b[31:0] ) ? 0xffffffff : 0\ndst[127:32] := a[127:32]","header":"xmmintrin.h","instruction":"cmpss","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"}]},{"name":"_mm_cmpge_ps","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Compare","description":"Compare packed single-precision (32-bit) floating-point elements in \"a\" and \"b\" for greater-than-or-equal, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := ( a[i+31:i] >= b[i+31:i] ) ? 0xffffffff : 0\nENDFOR","header":"xmmintrin.h","instruction":"cmpps","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"}]},{"name":"_mm_cmpneq_ss","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Compare","description":"Compare the lower single-precision (32-bit) floating-point elements in \"a\" and \"b\" for not-equal, store the result in the lower element of \"dst\", and copy the upper 3 packed elements from \"a\" to the upper elements of \"dst\".","code":"dst[31:0] := ( a[31:0] != b[31:0] ) ? 0xffffffff : 0\ndst[127:32] := a[127:32]","header":"xmmintrin.h","instruction":"cmpss","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"}]},{"name":"_mm_cmpneq_ps","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Compare","description":"Compare packed single-precision (32-bit) floating-point elements in \"a\" and \"b\" for not-equal, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := ( a[i+31:i] != b[i+31:i] ) ? 0xffffffff : 0\nENDFOR","header":"xmmintrin.h","instruction":"cmpps","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"}]},{"name":"_mm_cmpnlt_ss","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Compare","description":"Compare the lower single-precision (32-bit) floating-point elements in \"a\" and \"b\" for not-less-than, store the result in the lower element of \"dst\", and copy the upper 3 packed elements from \"a\" to the upper elements of \"dst\".","code":"dst[31:0] := !( a[31:0] < b[31:0] ) ? 0xffffffff : 0\ndst[127:32] := a[127:32]","header":"xmmintrin.h","instruction":"cmpss","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"}]},{"name":"_mm_cmpnlt_ps","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Compare","description":"Compare packed single-precision (32-bit) floating-point elements in \"a\" and \"b\" for not-less-than, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := !( a[i+31:i] < b[i+31:i] ) ? 0xffffffff : 0\nENDFOR","header":"xmmintrin.h","instruction":"cmpps","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"}]},{"name":"_mm_cmpnle_ss","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Compare","description":"Compare the lower single-precision (32-bit) floating-point elements in \"a\" and \"b\" for not-less-than-or-equal, store the result in the lower element of \"dst\", and copy the upper 3 packed elements from \"a\" to the upper elements of \"dst\".","code":"dst[31:0] := !( a[31:0] <= b[31:0] ) ? 0xffffffff : 0\ndst[127:32] := a[127:32]","header":"xmmintrin.h","instruction":"cmpss","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"}]},{"name":"_mm_cmpnle_ps","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Compare","description":"Compare packed single-precision (32-bit) floating-point elements in \"a\" and \"b\" for not-less-than-or-equal, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := !( a[i+31:i] <= b[i+31:i] ) ? 0xffffffff : 0\nENDFOR","header":"xmmintrin.h","instruction":"cmpps","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"}]},{"name":"_mm_cmpngt_ss","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Compare","description":"Compare the lower single-precision (32-bit) floating-point elements in \"a\" and \"b\" for not-greater-than, store the result in the lower element of \"dst\", and copy the upper 3 packed elements from \"a\" to the upper elements of \"dst\".","code":"dst[31:0] := !( a[31:0] > b[31:0] ) ? 0xffffffff : 0\ndst[127:32] := a[127:32]","header":"xmmintrin.h","instruction":"cmpss","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"}]},{"name":"_mm_cmpngt_ps","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Compare","description":"Compare packed single-precision (32-bit) floating-point elements in \"a\" and \"b\" for not-greater-than, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := !( a[i+31:i] > b[i+31:i] ) ? 0xffffffff : 0\nENDFOR","header":"xmmintrin.h","instruction":"cmpps","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"}]},{"name":"_mm_cmpnge_ss","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Compare","description":"Compare the lower single-precision (32-bit) floating-point elements in \"a\" and \"b\" for not-greater-than-or-equal, store the result in the lower element of \"dst\", and copy the upper 3 packed elements from \"a\" to the upper elements of \"dst\".","code":"dst[31:0] := !( a[31:0] >= b[31:0] ) ? 0xffffffff : 0\ndst[127:32] := a[127:32]","header":"xmmintrin.h","instruction":"cmpss","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"}]},{"name":"_mm_cmpnge_ps","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Compare","description":"Compare packed single-precision (32-bit) floating-point elements in \"a\" and \"b\" for not-greater-than-or-equal, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := !( a[i+31:i] >= b[i+31:i] ) ? 0xffffffff : 0\nENDFOR","header":"xmmintrin.h","instruction":"cmpps","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"}]},{"name":"_mm_cmpord_ss","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Compare","description":"Compare the lower single-precision (32-bit) floating-point elements in \"a\" and \"b\" to see if neither is NaN, store the result in the lower element of \"dst\", and copy the upper 3 packed elements from \"a\" to the upper elements of \"dst\".","code":"dst[31:0] := ( a[31:0] != NaN AND b[31:0] != NaN ) ? 0xffffffff : 0\ndst[127:32] := a[127:32]","header":"xmmintrin.h","instruction":"cmpss","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"}]},{"name":"_mm_cmpord_ps","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Compare","description":"Compare packed single-precision (32-bit) floating-point elements in \"a\" and \"b\" to see if neither is NaN, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := ( a[i+31:i] != NaN AND b[i+31:i] != NaN ) ? 0xffffffff : 0\nENDFOR","header":"xmmintrin.h","instruction":"cmpps","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"}]},{"name":"_mm_cmpunord_ss","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Compare","description":"Compare the lower single-precision (32-bit) floating-point elements in \"a\" and \"b\" to see if either is NaN, store the result in the lower element of \"dst\", and copy the upper 3 packed elements from \"a\" to the upper elements of \"dst\".","code":"dst[31:0] := ( a[31:0] != NaN OR b[31:0] != NaN ) ? 0xffffffff : 0\ndst[127:32] := a[127:32]","header":"xmmintrin.h","instruction":"cmpss","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"}]},{"name":"_mm_cmpunord_ps","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Compare","description":"Compare packed single-precision (32-bit) floating-point elements in \"a\" and \"b\" to see if either is NaN, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := ( a[i+31:i] != NaN OR b[i+31:i] != NaN ) ? 0xffffffff : 0\nENDFOR","header":"xmmintrin.h","instruction":"cmpps","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"}]},{"name":"_mm_comieq_ss","tech":"SSE","returnType":"int","cpuId":"SSE","category":"Compare","description":"Compare the lower single-precision (32-bit) floating-point element in \"a\" and \"b\" for equality, and return the boolean result (0 or 1).","code":"RETURN ( a[31:0] == b[31:0] ) ? 1 : 0","header":"xmmintrin.h","instruction":"comiss","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"2","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"7","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"6","throughput":"2"}]},{"name":"_mm_comilt_ss","tech":"SSE","returnType":"int","cpuId":"SSE","category":"Compare","description":"Compare the lower single-precision (32-bit) floating-point element in \"a\" and \"b\" for less-than, and return the boolean result (0 or 1).","code":"RETURN ( a[31:0] < b[31:0] ) ? 1 : 0","header":"xmmintrin.h","instruction":"comiss","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"2","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"7","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"6","throughput":"2"}]},{"name":"_mm_comile_ss","tech":"SSE","returnType":"int","cpuId":"SSE","category":"Compare","description":"Compare the lower single-precision (32-bit) floating-point element in \"a\" and \"b\" for less-than-or-equal, and return the boolean result (0 or 1).","code":"RETURN ( a[31:0] <= b[31:0] ) ? 1 : 0","header":"xmmintrin.h","instruction":"comiss","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"2","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"7","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"6","throughput":"2"}]},{"name":"_mm_comigt_ss","tech":"SSE","returnType":"int","cpuId":"SSE","category":"Compare","description":"Compare the lower single-precision (32-bit) floating-point element in \"a\" and \"b\" for greater-than, and return the boolean result (0 or 1).","code":"RETURN ( a[31:0] > b[31:0] ) ? 1 : 0","header":"xmmintrin.h","instruction":"comiss","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"2","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"7","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"6","throughput":"2"}]},{"name":"_mm_comige_ss","tech":"SSE","returnType":"int","cpuId":"SSE","category":"Compare","description":"Compare the lower single-precision (32-bit) floating-point element in \"a\" and \"b\" for greater-than-or-equal, and return the boolean result (0 or 1).","code":"RETURN ( a[31:0] >= b[31:0] ) ? 1 : 0","header":"xmmintrin.h","instruction":"comiss","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"2","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"7","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"6","throughput":"2"}]},{"name":"_mm_comineq_ss","tech":"SSE","returnType":"int","cpuId":"SSE","category":"Compare","description":"Compare the lower single-precision (32-bit) floating-point element in \"a\" and \"b\" for not-equal, and return the boolean result (0 or 1).","code":"RETURN ( a[31:0] != b[31:0] ) ? 1 : 0","header":"xmmintrin.h","instruction":"comiss","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"2","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"7","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"6","throughput":"2"}]},{"name":"_mm_ucomieq_ss","tech":"SSE","returnType":"int","cpuId":"SSE","category":"Compare","description":"Compare the lower single-precision (32-bit) floating-point element in \"a\" and \"b\" for equality, and return the boolean result (0 or 1). This instruction will not signal an exception for QNaNs.","code":"RETURN ( a[31:0] == b[31:0] ) ? 1 : 0","header":"xmmintrin.h","instruction":"ucomiss","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"7","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"6","throughput":"2"}]},{"name":"_mm_ucomilt_ss","tech":"SSE","returnType":"int","cpuId":"SSE","category":"Compare","description":"Compare the lower single-precision (32-bit) floating-point element in \"a\" and \"b\" for less-than, and return the boolean result (0 or 1). This instruction will not signal an exception for QNaNs.","code":"RETURN ( a[31:0] < b[31:0] ) ? 1 : 0","header":"xmmintrin.h","instruction":"ucomiss","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"7","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"6","throughput":"2"}]},{"name":"_mm_ucomile_ss","tech":"SSE","returnType":"int","cpuId":"SSE","category":"Compare","description":"Compare the lower single-precision (32-bit) floating-point element in \"a\" and \"b\" for less-than-or-equal, and return the boolean result (0 or 1). This instruction will not signal an exception for QNaNs.","code":"RETURN ( a[31:0] <= b[31:0] ) ? 1 : 0","header":"xmmintrin.h","instruction":"ucomiss","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"7","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"6","throughput":"2"}]},{"name":"_mm_ucomigt_ss","tech":"SSE","returnType":"int","cpuId":"SSE","category":"Compare","description":"Compare the lower single-precision (32-bit) floating-point element in \"a\" and \"b\" for greater-than, and return the boolean result (0 or 1). This instruction will not signal an exception for QNaNs.","code":"RETURN ( a[31:0] > b[31:0] ) ? 1 : 0","header":"xmmintrin.h","instruction":"ucomiss","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"7","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"6","throughput":"2"}]},{"name":"_mm_ucomige_ss","tech":"SSE","returnType":"int","cpuId":"SSE","category":"Compare","description":"Compare the lower single-precision (32-bit) floating-point element in \"a\" and \"b\" for greater-than-or-equal, and return the boolean result (0 or 1). This instruction will not signal an exception for QNaNs.","code":"RETURN ( a[31:0] >= b[31:0] ) ? 1 : 0","header":"xmmintrin.h","instruction":"ucomiss","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"7","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"6","throughput":"2"}]},{"name":"_mm_ucomineq_ss","tech":"SSE","returnType":"int","cpuId":"SSE","category":"Compare","description":"Compare the lower single-precision (32-bit) floating-point element in \"a\" and \"b\" for not-equal, and return the boolean result (0 or 1). This instruction will not signal an exception for QNaNs.","code":"RETURN ( a[31:0] != b[31:0] ) ? 1 : 0","header":"xmmintrin.h","instruction":"ucomiss","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"7","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"6","throughput":"2"}]},{"name":"_mm_cvtss_si32","tech":"SSE","returnType":"int","cpuId":"SSE","category":"Convert","description":"Convert the lower single-precision (32-bit) floating-point element in \"a\" to a 32-bit integer, and store the result in \"dst\".","code":"dst[31:0] := Convert_FP32_To_Int32(a[31:0])","header":"xmmintrin.h","instruction":"cvtss2si","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"r32, xmm","latency":"5","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"r32, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"r32, xmm","latency":"6","throughput":"1"},{"base":"06_0F","parameters":"r32, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"r32, xmm","latency":"4","throughput":"1"},{"base":"06_0D","parameters":"r32, xmm","latency":"4","throughput":"1"},{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"r64, xmm","latency":"5","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"r64, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"r64, xmm","latency":"4","throughput":"1"},{"base":"0F_03","parameters":"r32, xmm","latency":"9","throughput":"2"},{"base":"0F_02","parameters":"r32, xmm","latency":"8","throughput":"2"}]},{"name":"_mm_cvt_ss2si","tech":"SSE","returnType":"int","cpuId":"SSE","category":"Convert","description":"Convert the lower single-precision (32-bit) floating-point element in \"a\" to a 32-bit integer, and store the result in \"dst\".","code":"dst[31:0] := Convert_FP32_To_Int32(a[31:0])","header":"xmmintrin.h","instruction":"cvtss2si","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"r32, xmm","latency":"5","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"r32, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"r32, xmm","latency":"6","throughput":"1"},{"base":"06_0F","parameters":"r32, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"r32, xmm","latency":"4","throughput":"1"},{"base":"06_0D","parameters":"r32, xmm","latency":"4","throughput":"1"},{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"r64, xmm","latency":"5","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"r64, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"r64, xmm","latency":"4","throughput":"1"},{"base":"0F_03","parameters":"r32, xmm","latency":"9","throughput":"2"},{"base":"0F_02","parameters":"r32, xmm","latency":"8","throughput":"2"}]},{"name":"_mm_cvtss_si64","tech":"SSE","returnType":"__int64","cpuId":"SSE","category":"Convert","description":"Convert the lower single-precision (32-bit) floating-point element in \"a\" to a 64-bit integer, and store the result in \"dst\".","code":"dst[63:0] := Convert_FP32_To_Int64(a[31:0])","header":"xmmintrin.h","instruction":"cvtss2si","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"r32, xmm","latency":"5","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"r32, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"r32, xmm","latency":"6","throughput":"1"},{"base":"06_0F","parameters":"r32, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"r32, xmm","latency":"4","throughput":"1"},{"base":"06_0D","parameters":"r32, xmm","latency":"4","throughput":"1"},{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"r64, xmm","latency":"5","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"r64, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"r64, xmm","latency":"4","throughput":"1"},{"base":"0F_03","parameters":"r32, xmm","latency":"9","throughput":"2"},{"base":"0F_02","parameters":"r32, xmm","latency":"8","throughput":"2"}]},{"name":"_mm_cvtss_f32","tech":"SSE","returnType":"float","cpuId":"SSE","category":"Convert","description":"Copy the lower single-precision (32-bit) floating-point element of \"a\" to \"dst\".","code":"dst[31:0] := a[31:0]","header":"xmmintrin.h","instruction":"movss","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"}]},{"name":"_mm_cvtps_pi32","tech":"SSE","returnType":"__m64","cpuId":"SSE","category":"Convert","description":"Convert packed single-precision (32-bit) floating-point elements in \"a\" to packed 32-bit integers, and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := 32*j\n\tdst[i+31:i] := Convert_FP32_To_Int32(a[i+31:i])\nENDFOR","header":"xmmintrin.h","instruction":"cvtps2si","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_cvt_ps2pi","tech":"SSE","returnType":"__m64","cpuId":"SSE","category":"Convert","description":"Convert packed single-precision (32-bit) floating-point elements in \"a\" to packed 32-bit integers, and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := 32*j\n\tdst[i+31:i] := Convert_FP32_To_Int32(a[i+31:i])\nENDFOR","header":"xmmintrin.h","instruction":"cvtps2si","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_cvttss_si32","tech":"SSE","returnType":"int","cpuId":"SSE","category":"Convert","description":"Convert the lower single-precision (32-bit) floating-point element in \"a\" to a 32-bit integer with truncation, and store the result in \"dst\".","code":"dst[31:0] := Convert_FP32_To_Int32_Truncate(a[31:0])","header":"xmmintrin.h","instruction":"cvttss2si","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"r32, xmm","latency":"5","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"r32, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"r32, xmm","latency":"6","throughput":"1"},{"base":"06_0F","parameters":"r32, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"r32, xmm","latency":"4","throughput":"1"},{"base":"06_0D","parameters":"r32, xmm","latency":"4","throughput":"1"},{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"r64, xmm","latency":"5","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"r64, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"r64, xmm","latency":"4","throughput":"1"},{"base":"0F_03","parameters":"r32, xmm","latency":"9","throughput":"2"},{"base":"0F_02","parameters":"r32, xmm","latency":"8","throughput":"2"}]},{"name":"_mm_cvtt_ss2si","tech":"SSE","returnType":"int","cpuId":"SSE","category":"Convert","description":"Convert the lower single-precision (32-bit) floating-point element in \"a\" to a 32-bit integer with truncation, and store the result in \"dst\".","code":"dst[31:0] := Convert_FP32_To_Int32_Truncate(a[31:0])","header":"xmmintrin.h","instruction":"cvttss2si","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"r32, xmm","latency":"5","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"r32, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"r32, xmm","latency":"6","throughput":"1"},{"base":"06_0F","parameters":"r32, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"r32, xmm","latency":"4","throughput":"1"},{"base":"06_0D","parameters":"r32, xmm","latency":"4","throughput":"1"},{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"r64, xmm","latency":"5","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"r64, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"r64, xmm","latency":"4","throughput":"1"},{"base":"0F_03","parameters":"r32, xmm","latency":"9","throughput":"2"},{"base":"0F_02","parameters":"r32, xmm","latency":"8","throughput":"2"}]},{"name":"_mm_cvttss_si64","tech":"SSE","returnType":"__int64","cpuId":"SSE","category":"Convert","description":"Convert the lower single-precision (32-bit) floating-point element in \"a\" to a 64-bit integer with truncation, and store the result in \"dst\".","code":"dst[63:0] := Convert_FP64_To_Int32_Truncate(a[31:0])","header":"xmmintrin.h","instruction":"cvttss2si","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"r32, xmm","latency":"5","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"r32, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"r32, xmm","latency":"6","throughput":"1"},{"base":"06_0F","parameters":"r32, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"r32, xmm","latency":"4","throughput":"1"},{"base":"06_0D","parameters":"r32, xmm","latency":"4","throughput":"1"},{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"r64, xmm","latency":"5","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"r64, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"r64, xmm","latency":"4","throughput":"1"},{"base":"0F_03","parameters":"r32, xmm","latency":"9","throughput":"2"},{"base":"0F_02","parameters":"r32, xmm","latency":"8","throughput":"2"}]},{"name":"_mm_cvttps_pi32","tech":"SSE","returnType":"__m64","cpuId":"SSE","category":"Convert","description":"Convert packed single-precision (32-bit) floating-point elements in \"a\" to packed 32-bit integers with truncation, and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := 32*j\n\tdst[i+31:i] := Convert_FP32_To_Int32_Truncate(a[i+31:i])\nENDFOR","header":"xmmintrin.h","instruction":"cvttps2pi","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"mm, xmm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"mm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"mm, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"mm, xmm","latency":"3","throughput":"1"},{"base":"06_0D","parameters":"mm, xmm","latency":"3","throughput":"1"},{"base":"0F_03","parameters":"mm, xmm","latency":"8","throughput":"2"},{"base":"0F_02","parameters":"mm, xmm","latency":"7","throughput":"2"}]},{"name":"_mm_cvtt_ps2pi","tech":"SSE","returnType":"__m64","cpuId":"SSE","category":"Convert","description":"Convert packed single-precision (32-bit) floating-point elements in \"a\" to packed 32-bit integers with truncation, and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := 32*j\n\tdst[i+31:i] := Convert_FP32_To_Int32_Truncate(a[i+31:i])\nENDFOR","header":"xmmintrin.h","instruction":"cvttps2pi","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"mm, xmm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"mm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"mm, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"mm, xmm","latency":"3","throughput":"1"},{"base":"06_0D","parameters":"mm, xmm","latency":"3","throughput":"1"},{"base":"0F_03","parameters":"mm, xmm","latency":"8","throughput":"2"},{"base":"0F_02","parameters":"mm, xmm","latency":"7","throughput":"2"}]},{"name":"_mm_cvtps_pi16","tech":"SSE","returnType":"__m64","cpuId":"SSE","category":"Convert","description":"Convert packed single-precision (32-bit) floating-point elements in \"a\" to packed 16-bit integers, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := 16*j\n\tk := 32*j\n\tdst[i+15:i] := Convert_FP32_To_Int16(a[k+31:k])\nENDFOR","header":"xmmintrin.h","instruction":null,"parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_cvtps_pi8","tech":"SSE","returnType":"__m64","cpuId":"SSE","category":"Convert","description":"Convert packed single-precision (32-bit) floating-point elements in \"a\" to packed 8-bit integers, and store the results in lower 4 elements of \"dst\".","code":"FOR j := 0 to 3\n\ti := 8*j\n\tk := 32*j\n\tdst[i+7:i] := Convert_FP32_To_Int8(a[k+31:k])\nENDFOR","header":"xmmintrin.h","instruction":null,"parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_set_ss","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Set","description":"Copy single-precision (32-bit) floating-point element \"a\" to the lower element of \"dst\", and zero the upper 3 elements.","code":"dst[31:0] := a[31:0]\ndst[127:32] := 0","header":"xmmintrin.h","instruction":"movss","parameters":[{"type":"float","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"}]},{"name":"_mm_set1_ps","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Set","description":"Broadcast single-precision (32-bit) floating-point value \"a\" to all elements of \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := a[31:0]\nENDFOR","header":"xmmintrin.h","instruction":null,"parameters":[{"type":"float","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_set_ps1","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Set","description":"Broadcast single-precision (32-bit) floating-point value \"a\" to all elements of \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := a[31:0]\nENDFOR","header":"xmmintrin.h","instruction":null,"parameters":[{"type":"float","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_set_ps","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Set","description":"Set packed single-precision (32-bit) floating-point elements in \"dst\" with the supplied values.","code":"dst[31:0] := e0\ndst[63:32] := e1\ndst[95:64] := e2\ndst[127:96] := e3","header":"xmmintrin.h","instruction":null,"parameters":[{"type":"float","name":"e3"},{"type":"float","name":"e2"},{"type":"float","name":"e1"},{"type":"float","name":"e0"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_setr_ps","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Set","description":"Set packed single-precision (32-bit) floating-point elements in \"dst\" with the supplied values in reverse order.","code":"dst[31:0] := e3\ndst[63:32] := e2\ndst[95:64] := e1\ndst[127:96] := e0","header":"xmmintrin.h","instruction":null,"parameters":[{"type":"float","name":"e3"},{"type":"float","name":"e2"},{"type":"float","name":"e1"},{"type":"float","name":"e0"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_setzero_ps","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Set","description":"Return vector of type __m128 with all elements set to zero.","code":"dst[MAX:0] := 0","header":"xmmintrin.h","instruction":"xorps","parameters":[{"type":"void","name":""}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"0F_03","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"}]},{"name":"_mm_loadh_pi","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Load","description":"Load 2 single-precision (32-bit) floating-point elements from memory into the upper 2 elements of \"dst\", and copy the lower 2 elements from \"a\" to \"dst\". \"mem_addr\" does not need to be aligned on any particular boundary.","code":"dst[31:0] := a[31:0]\ndst[63:32] := a[63:32]\ndst[95:64] := MEM[mem_addr+31:mem_addr]\ndst[127:96] := MEM[mem_addr+63:mem_addr+32]","header":"xmmintrin.h","instruction":"movhps","parameters":[{"type":"__m128","name":"a"},{"type":"__m64 const*","name":"mem_addr"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_loadl_pi","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Load","description":"Load 2 single-precision (32-bit) floating-point elements from memory into the lower 2 elements of \"dst\", and copy the upper 2 elements from \"a\" to \"dst\". \"mem_addr\" does not need to be aligned on any particular boundary.","code":"dst[31:0] := MEM[mem_addr+31:mem_addr]\ndst[63:32] := MEM[mem_addr+63:mem_addr+32]\ndst[95:64] := a[95:64]\ndst[127:96] := a[127:96]","header":"xmmintrin.h","instruction":"movlps","parameters":[{"type":"__m128","name":"a"},{"type":"__m64 const*","name":"mem_addr"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_load_ss","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Load","description":"Load a single-precision (32-bit) floating-point element from memory into the lower of \"dst\", and zero the upper 3 elements. \"mem_addr\" does not need to be aligned on any particular boundary.","code":"dst[31:0] := MEM[mem_addr+31:mem_addr]\ndst[127:32] := 0","header":"xmmintrin.h","instruction":"movss","parameters":[{"type":"float const*","name":"mem_addr"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"}]},{"name":"_mm_load1_ps","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Load","description":"Load a single-precision (32-bit) floating-point element from memory into all elements of \"dst\".","code":"dst[31:0] := MEM[mem_addr+31:mem_addr]\ndst[63:32] := MEM[mem_addr+31:mem_addr]\ndst[95:64] := MEM[mem_addr+31:mem_addr]\ndst[127:96] := MEM[mem_addr+31:mem_addr]","header":"xmmintrin.h","instruction":null,"parameters":[{"type":"float const*","name":"mem_addr"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_load_ps1","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Load","description":"Load a single-precision (32-bit) floating-point element from memory into all elements of \"dst\".","code":"dst[31:0] := MEM[mem_addr+31:mem_addr]\ndst[63:32] := MEM[mem_addr+31:mem_addr]\ndst[95:64] := MEM[mem_addr+31:mem_addr]\ndst[127:96] := MEM[mem_addr+31:mem_addr]","header":"xmmintrin.h","instruction":null,"parameters":[{"type":"float const*","name":"mem_addr"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_load_ps","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Load","description":"Load 128-bits (composed of 4 packed single-precision (32-bit) floating-point elements) from memory into \"dst\".\n\t\"mem_addr\" must be aligned on a 16-byte boundary or a general-protection exception will be generated.","code":"dst[127:0] := MEM[mem_addr+127:mem_addr]","header":"xmmintrin.h","instruction":"movaps","parameters":[{"type":"float const*","name":"mem_addr"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"6","throughput":"1"},{"base":"0F_02","parameters":"xmm, xmm","latency":"6","throughput":"1"}]},{"name":"_mm_loadu_ps","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Load","description":"Load 128-bits (composed of 4 packed single-precision (32-bit) floating-point elements) from memory into \"dst\".\n\t\"mem_addr\" does not need to be aligned on any particular boundary.","code":"dst[127:0] := MEM[mem_addr+127:mem_addr]","header":"xmmintrin.h","instruction":"movups","parameters":[{"type":"float const*","name":"mem_addr"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"}]},{"name":"_mm_loadr_ps","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Load","description":"Load 4 single-precision (32-bit) floating-point elements from memory into \"dst\" in reverse order. mem_addr must be aligned on a 16-byte boundary or a general-protection exception will be generated.","code":"dst[31:0] := MEM[mem_addr+127:mem_addr+96]\ndst[63:32] := MEM[mem_addr+95:mem_addr+64]\ndst[95:64] := MEM[mem_addr+63:mem_addr+32]\ndst[127:96] := MEM[mem_addr+31:mem_addr]","header":"xmmintrin.h","instruction":null,"parameters":[{"type":"float const*","name":"mem_addr"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_stream_ps","tech":"SSE","returnType":"void","cpuId":"SSE","category":"Store","description":"Store 128-bits (composed of 4 packed single-precision (32-bit) floating-point elements) from \"a\" into memory using a non-temporal memory hint.\n\t\"mem_addr\" must be aligned on a 16-byte boundary or a general-protection exception will be generated.","code":"MEM[mem_addr+127:mem_addr] := a[127:0]","header":"xmmintrin.h","instruction":"movntps","parameters":[{"type":"float*","name":"mem_addr"},{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_storeh_pi","tech":"SSE","returnType":"void","cpuId":"SSE","category":"Store","description":"Store the upper 2 single-precision (32-bit) floating-point elements from \"a\" into memory.","code":"MEM[mem_addr+31:mem_addr] := a[95:64]\nMEM[mem_addr+63:mem_addr+32] := a[127:96]","header":"xmmintrin.h","instruction":"movhps","parameters":[{"type":"__m64*","name":"mem_addr"},{"type":"__m128","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_storel_pi","tech":"SSE","returnType":"void","cpuId":"SSE","category":"Store","description":"Store the lower 2 single-precision (32-bit) floating-point elements from \"a\" into memory.","code":"MEM[mem_addr+31:mem_addr] := a[31:0]\nMEM[mem_addr+63:mem_addr+32] := a[63:32]","header":"xmmintrin.h","instruction":"movlps","parameters":[{"type":"__m64*","name":"mem_addr"},{"type":"__m128","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_store_ss","tech":"SSE","returnType":"void","cpuId":"SSE","category":"Store","description":"Store the lower single-precision (32-bit) floating-point element from \"a\" into memory. \"mem_addr\" does not need to be aligned on any particular boundary.","code":"MEM[mem_addr+31:mem_addr] := a[31:0]","header":"xmmintrin.h","instruction":"movss","parameters":[{"type":"float*","name":"mem_addr"},{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"}]},{"name":"_mm_store1_ps","tech":"SSE","returnType":"void","cpuId":"SSE","category":"Store","description":"Store the lower single-precision (32-bit) floating-point element from \"a\" into 4 contiguous elements in memory. \"mem_addr\" must be aligned on a 16-byte boundary or a general-protection exception will be generated.","code":"MEM[mem_addr+31:mem_addr] := a[31:0]\nMEM[mem_addr+63:mem_addr+32] := a[31:0]\nMEM[mem_addr+95:mem_addr+64] := a[31:0]\nMEM[mem_addr+127:mem_addr+96] := a[31:0]","header":"xmmintrin.h","instruction":null,"parameters":[{"type":"float*","name":"mem_addr"},{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_store_ps1","tech":"SSE","returnType":"void","cpuId":"SSE","category":"Store","description":"Store the lower single-precision (32-bit) floating-point element from \"a\" into 4 contiguous elements in memory. \"mem_addr\" must be aligned on a 16-byte boundary or a general-protection exception will be generated.","code":"MEM[mem_addr+31:mem_addr] := a[31:0]\nMEM[mem_addr+63:mem_addr+32] := a[31:0]\nMEM[mem_addr+95:mem_addr+64] := a[31:0]\nMEM[mem_addr+127:mem_addr+96] := a[31:0]","header":"xmmintrin.h","instruction":null,"parameters":[{"type":"float*","name":"mem_addr"},{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_store_ps","tech":"SSE","returnType":"void","cpuId":"SSE","category":"Store","description":"Store 128-bits (composed of 4 packed single-precision (32-bit) floating-point elements) from \"a\" into memory.\n\t\"mem_addr\" must be aligned on a 16-byte boundary or a general-protection exception will be generated.","code":"MEM[mem_addr+127:mem_addr] := a[127:0]","header":"xmmintrin.h","instruction":"movaps","parameters":[{"type":"float*","name":"mem_addr"},{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"6","throughput":"1"},{"base":"0F_02","parameters":"xmm, xmm","latency":"6","throughput":"1"}]},{"name":"_mm_storeu_ps","tech":"SSE","returnType":"void","cpuId":"SSE","category":"Store","description":"Store 128-bits (composed of 4 packed single-precision (32-bit) floating-point elements) from \"a\" into memory.\n\t\"mem_addr\" does not need to be aligned on any particular boundary.","code":"MEM[mem_addr+127:mem_addr] := a[127:0]","header":"xmmintrin.h","instruction":"movups","parameters":[{"type":"float*","name":"mem_addr"},{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"}]},{"name":"_mm_storer_ps","tech":"SSE","returnType":"void","cpuId":"SSE","category":"Store","description":"Store 4 single-precision (32-bit) floating-point elements from \"a\" into memory in reverse order.\n\t\"mem_addr\" must be aligned on a 16-byte boundary or a general-protection exception will be generated.","code":"MEM[mem_addr+31:mem_addr] := a[127:96]\nMEM[mem_addr+63:mem_addr+32] := a[95:64]\nMEM[mem_addr+95:mem_addr+64] := a[63:32]\nMEM[mem_addr+127:mem_addr+96] := a[31:0]","header":"xmmintrin.h","instruction":null,"parameters":[{"type":"float*","name":"mem_addr"},{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_move_ss","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Move","description":"Move the lower single-precision (32-bit) floating-point element from \"b\" to the lower element of \"dst\", and copy the upper 3 elements from \"a\" to the upper elements of \"dst\".","code":"dst[31:0] := b[31:0]\ndst[63:32] := a[63:32]\ndst[95:64] := a[95:64]\ndst[127:96] := a[127:96]","header":"xmmintrin.h","instruction":"movss","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"}]},{"name":"_mm_shuffle_ps","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Swizzle","description":"Shuffle single-precision (32-bit) floating-point elements in \"a\" using the control in \"imm\", and store the results in \"dst\".","code":"SELECT4(src, control){\n\tCASE(control[1:0])\n\t\t0:\ttmp[31:0] := src[31:0]\n\t\t1:\ttmp[31:0] := src[63:32]\n\t\t2:\ttmp[31:0] := src[95:64]\n\t\t3:\ttmp[31:0] := src[127:96]\n\tESAC\n\tRETURN tmp[31:0]\n}\n\ndst[31:0] := SELECT4(a[127:0], imm[1:0])\ndst[63:32] := SELECT4(a[127:0], imm[3:2])\ndst[95:64] := SELECT4(b[127:0], imm[5:4])\ndst[127:96] := SELECT4(b[127:0], imm[7:6])","header":"xmmintrin.h","instruction":"shufps","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"},{"type":"unsigned int","name":"imm"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm, imm8","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm, imm8","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm, imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm, imm8","latency":"2","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm, imm8","latency":"6","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm, imm8","latency":"6","throughput":"2"}]},{"name":"_mm_unpackhi_ps","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Swizzle","description":"Unpack and interleave single-precision (32-bit) floating-point elements from the high half \"a\" and \"b\", and store the results in \"dst\".","code":"INTERLEAVE_HIGH_DWORDS(src1[127:0], src2[127:0]){\n\tdst[31:0] := src1[95:64] \n\tdst[63:32] := src2[95:64] \n\tdst[95:64] := src1[127:96] \n\tdst[127:96] := src2[127:96] \n\tRETURN dst[127:0]\n}\t\n\t\ndst[127:0] := INTERLEAVE_HIGH_DWORDS(a[127:0], b[127:0])","header":"xmmintrin.h","instruction":"unpckhps","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"2","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"6","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"6","throughput":"2"}]},{"name":"_mm_unpacklo_ps","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Swizzle","description":"Unpack and interleave single-precision (32-bit) floating-point elements from the low half of \"a\" and \"b\", and store the results in \"dst\".","code":"INTERLEAVE_DWORDS(src1[127:0], src2[127:0]){\n\tdst[31:0] := src1[31:0] \n\tdst[63:32] := src2[31:0] \n\tdst[95:64] := src1[63:32] \n\tdst[127:96] := src2[63:32] \n\tRETURN dst[127:0]\n}\t\n\ndst[127:0] := INTERLEAVE_DWORDS(a[127:0], b[127:0])","header":"xmmintrin.h","instruction":"unpcklps","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"2","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"}]},{"name":"_mm_movehl_ps","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Move","description":"Move the upper 2 single-precision (32-bit) floating-point elements from \"b\" to the lower 2 elements of \"dst\", and copy the upper 2 elements from \"a\" to the upper 2 elements of \"dst\".","code":"dst[31:0] := b[95:64]\ndst[63:32] := b[127:96]\ndst[95:64] := a[95:64]\ndst[127:96] := a[127:96]","header":"xmmintrin.h","instruction":"movhlps","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"xmm, xmm","latency":"6","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"6","throughput":"2"}]},{"name":"_mm_movelh_ps","tech":"SSE","returnType":"__m128","cpuId":"SSE","category":"Move","description":"Move the lower 2 single-precision (32-bit) floating-point elements from \"b\" to the upper 2 elements of \"dst\", and copy the lower 2 elements from \"a\" to the lower 2 elements of \"dst\".","code":"dst[31:0] := a[31:0]\ndst[63:32] := a[63:32]\ndst[95:64] := b[31:0]\ndst[127:96] := b[63:32]","header":"xmmintrin.h","instruction":"movlhps","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"}]},{"name":"_mm_movemask_ps","tech":"SSE","returnType":"int","cpuId":"SSE","category":"Miscellaneous","description":"Set each bit of mask \"dst\" based on the most significant bit of the corresponding packed single-precision (32-bit) floating-point element in \"a\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tIF a[i+31]\n\t\tdst[j] := 1\n\tELSE\n\t\tdst[j] := 0\n\tFI\nENDFOR\ndst[MAX:4] := 0","header":"xmmintrin.h","instruction":"movmskps","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"r32, xmm","latency":"2","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"r32, xmm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"r32, xmm ","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"r32, xmm ","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"r32, xmm ","latency":"1","throughput":"1"},{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"r64, xmm","latency":"2","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"r64, xmm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"r64, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"r32, xmm","latency":"6","throughput":"2"},{"base":"0F_02","parameters":"r32, xmm","latency":"6","throughput":"2"}]},{"name":"_mm_pause","tech":"SSE2","returnType":"void","cpuId":"SSE2","category":"General Support","description":"Provide a hint to the processor that the code sequence is a spin-wait loop. This can help improve the performance and power consumption of spin-wait loops.","code":null,"header":"emmintrin.h","instruction":"pause","parameters":[{"type":"void","name":""}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_clflush","tech":"SSE2","returnType":"void","cpuId":"SSE2","category":"General Support","description":"Invalidate and flush the cache line that contains \"p\" from all levels of the cache hierarchy.","code":null,"header":"emmintrin.h","instruction":"clflush","parameters":[{"type":"void const*","name":"p"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_lfence","tech":"SSE2","returnType":"void","cpuId":"SSE2","category":"General Support","description":"Perform a serializing operation on all load-from-memory instructions that were issued prior to this instruction. Guarantees that every load instruction that precedes, in program order, is globally visible before any load instruction which follows the fence in program order.","code":null,"header":"emmintrin.h","instruction":"lfence","parameters":[{"type":"void","name":""}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_mfence","tech":"SSE2","returnType":"void","cpuId":"SSE2","category":"General Support","description":"Perform a serializing operation on all load-from-memory and store-to-memory instructions that were issued prior to this instruction. Guarantees that every memory access that precedes, in program order, the memory fence instruction is globally visible before any memory instruction which follows the fence in program order.","code":null,"header":"emmintrin.h","instruction":"mfence","parameters":[{"type":"void","name":""}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_add_epi8","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Arithmetic","description":"Add packed 8-bit integers in \"a\" and \"b\", and store the results in \"dst\".","code":"FOR j := 0 to 15\n\ti := j*8\n\tdst[i+7:i] := a[i+7:i] + b[i+7:i]\nENDFOR","header":"emmintrin.h","instruction":"paddb","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_add_epi16","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Arithmetic","description":"Add packed 16-bit integers in \"a\" and \"b\", and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*16\n\tdst[i+15:i] := a[i+15:i] + b[i+15:i]\nENDFOR","header":"emmintrin.h","instruction":"paddw","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_add_epi32","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Arithmetic","description":"Add packed 32-bit integers in \"a\" and \"b\", and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := a[i+31:i] + b[i+31:i]\nENDFOR","header":"emmintrin.h","instruction":"paddd","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_add_si64","tech":"SSE2","returnType":"__m64","cpuId":"SSE2","category":"Arithmetic","description":"Add 64-bit integers \"a\" and \"b\", and store the result in \"dst\".","code":"dst[63:0] := a[63:0] + b[63:0]","header":"emmintrin.h","instruction":"paddq","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_17","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"06_0F","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"06_0E","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"06_0D","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"2","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"2","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"3","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"3","throughput":"2"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"6","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"6","throughput":"2"}]},{"name":"_mm_add_epi64","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Arithmetic","description":"Add packed 64-bit integers in \"a\" and \"b\", and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := a[i+63:i] + b[i+63:i]\nENDFOR","header":"emmintrin.h","instruction":"paddq","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_17","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"06_0F","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"06_0E","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"06_0D","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"2","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"2","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"3","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"3","throughput":"2"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"6","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"6","throughput":"2"}]},{"name":"_mm_adds_epi8","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Arithmetic","description":"Add packed 8-bit integers in \"a\" and \"b\" using saturation, and store the results in \"dst\".","code":"FOR j := 0 to 15\n\ti := j*8\n\tdst[i+7:i] := Saturate_To_Int8( a[i+7:i] + b[i+7:i] )\nENDFOR","header":"emmintrin.h","instruction":"paddsb","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_adds_epi16","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Arithmetic","description":"Add packed 16-bit integers in \"a\" and \"b\" using saturation, and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*16\n\tdst[i+15:i] := Saturate_To_Int16( a[i+15:i] + b[i+15:i] )\nENDFOR","header":"emmintrin.h","instruction":"paddsw","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_adds_epu8","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Arithmetic","description":"Add packed unsigned 8-bit integers in \"a\" and \"b\" using saturation, and store the results in \"dst\".","code":"FOR j := 0 to 15\n\ti := j*8\n\tdst[i+7:i] := Saturate_To_UnsignedInt8( a[i+7:i] + b[i+7:i] )\nENDFOR","header":"emmintrin.h","instruction":"paddusb","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_adds_epu16","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Arithmetic","description":"Add packed unsigned 16-bit integers in \"a\" and \"b\" using saturation, and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*16\n\tdst[i+15:i] := Saturate_To_UnsignedInt16( a[i+15:i] + b[i+15:i] )\nENDFOR","header":"emmintrin.h","instruction":"paddusw","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_avg_epu8","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Probability/Statistics","description":"Average packed unsigned 8-bit integers in \"a\" and \"b\", and store the results in \"dst\".","code":"FOR j := 0 to 15\n\ti := j*8\n\tdst[i+7:i] := (a[i+7:i] + b[i+7:i] + 1) >> 1\nENDFOR","header":"emmintrin.h","instruction":"pavgb","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_avg_epu16","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Probability/Statistics","description":"Average packed unsigned 16-bit integers in \"a\" and \"b\", and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*16\n\tdst[i+15:i] := (a[i+15:i] + b[i+15:i] + 1) >> 1\nENDFOR","header":"emmintrin.h","instruction":"pavgw","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_madd_epi16","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Arithmetic","description":"Multiply packed 16-bit integers in \"a\" and \"b\", producing intermediate 32-bit integers. Horizontally add adjacent pairs of intermediate 32-bit integers, and pack the saturated results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tst[i+31:i] := Saturate_To_Int32( a[i+31:i+16]*b[i+31:i+16] + a[i+15:i]*b[i+15:i] )\nENDFOR","header":"emmintrin.h","instruction":"pmaddwd","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"9","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"8","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"mm, mm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"mm, mm","latency":"3","throughput":"1"},{"base":"06_0D","parameters":"mm, mm","latency":"3","throughput":"1"},{"base":"0F_03","parameters":"mm, mm","latency":"9","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"8","throughput":"1"}]},{"name":"_mm_max_epi16","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Special Math Functions","description":"Compare packed 16-bit integers in \"a\" and \"b\", and store packed maximum values in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*16\n\tIF a[i+15:i] > b[i+15:i]\n\t\tdst[i+15:i] := a[i+15:i]\n\tELSE\n\t\tdst[i+15:i] := b[i+15:i]\n\tFI\nENDFOR","header":"emmintrin.h","instruction":"pmaxsw","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_max_epu8","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Special Math Functions","description":"Compare packed unsigned 8-bit integers in \"a\" and \"b\", and store packed maximum values in \"dst\".","code":"FOR j := 0 to 15\n\ti := j*8\n\tIF a[i+7:i] > b[i+7:i]\n\t\tdst[i+7:i] := a[i+7:i]\n\tELSE\n\t\tdst[i+7:i] := b[i+7:i]\n\tFI\nENDFOR","header":"emmintrin.h","instruction":"pmaxub","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_min_epi16","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Special Math Functions","description":"Compare packed 16-bit integers in \"a\" and \"b\", and store packed minimum values in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*16\n\tIF a[i+15:i] < b[i+15:i]\n\t\tdst[i+15:i] := a[i+15:i]\n\tELSE\n\t\tdst[i+15:i] := b[i+15:i]\n\tFI\nENDFOR","header":"emmintrin.h","instruction":"pminsw","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_min_epu8","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Special Math Functions","description":"Compare packed unsigned 8-bit integers in \"a\" and \"b\", and store packed minimum values in \"dst\".","code":"FOR j := 0 to 15\n\ti := j*8\n\tIF a[i+7:i] < b[i+7:i]\n\t\tdst[i+7:i] := a[i+7:i]\n\tELSE\n\t\tdst[i+7:i] := b[i+7:i]\n\tFI\nENDFOR","header":"emmintrin.h","instruction":"pminub","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_mulhi_epi16","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Arithmetic","description":"Multiply the packed 16-bit integers in \"a\" and \"b\", producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*16\n\ttmp[31:0] := a[i+15:i] * b[i+15:i]\n\tdst[i+15:i] := tmp[31:16]\nENDFOR","header":"emmintrin.h","instruction":"pmulhw","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"9","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"8","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"mm, mm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"mm, mm","latency":"3","throughput":"1"},{"base":"06_0D","parameters":"mm, mm","latency":"3","throughput":"1"},{"base":"0F_03","parameters":"mm, mm","latency":"9","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"8","throughput":"1"}]},{"name":"_mm_mulhi_epu16","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Arithmetic","description":"Multiply the packed unsigned 16-bit integers in \"a\" and \"b\", producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*16\n\ttmp[31:0] := a[i+15:i] * b[i+15:i]\n\tdst[i+15:i] := tmp[31:16]\nENDFOR","header":"emmintrin.h","instruction":"pmulhuw","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"9","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"8","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"mm, mm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"mm, mm","latency":"3","throughput":"1"},{"base":"06_0D","parameters":"mm, mm","latency":"3","throughput":"1"},{"base":"0F_03","parameters":"mm, mm","latency":"9","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"8","throughput":"1"}]},{"name":"_mm_mullo_epi16","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Arithmetic","description":"Multiply the packed 16-bit integers in \"a\" and \"b\", producing intermediate 32-bit integers, and store the low 16 bits of the intermediate integers in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*16\n\ttmp[31:0] := a[i+15:i] * b[i+15:i]\n\tdst[i+15:i] := tmp[15:0]\nENDFOR","header":"emmintrin.h","instruction":"pmullw","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"9","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"8","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"mm, mm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"mm, mm","latency":"3","throughput":"1"},{"base":"06_0D","parameters":"mm, mm","latency":"3","throughput":"1"},{"base":"0F_03","parameters":"mm, mm","latency":"9","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"8","throughput":"1"}]},{"name":"_mm_mul_su32","tech":"SSE2","returnType":"__m64","cpuId":"SSE2","category":"Arithmetic","description":"Multiply the low unsigned 32-bit integers from \"a\" and \"b\", and store the unsigned 64-bit result in \"dst\".","code":"dst[63:0] := a[31:0] * b[31:0]","header":"emmintrin.h","instruction":"pmuludq","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"mm, mm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"mm, mm","latency":"3","throughput":"1"},{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"mm, mm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"mm, mm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"mm, mm","latency":"4","throughput":"1"},{"base":"06_0D","parameters":"mm, mm","latency":"4","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"8","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"8","throughput":"2"},{"base":"0F_03","parameters":"mm, mm","latency":"9","throughput":""},{"base":"0F_02","parameters":"mm, mm","latency":"8","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"9","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"8","throughput":"2"}]},{"name":"_mm_mul_epu32","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Arithmetic","description":"Multiply the low unsigned 32-bit integers from each packed 64-bit element in \"a\" and \"b\", and store the unsigned 64-bit results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := a[i+31:i] * b[i+31:i]\nENDFOR","header":"emmintrin.h","instruction":"pmuludq","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"mm, mm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"mm, mm","latency":"3","throughput":"1"},{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"mm, mm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"mm, mm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"mm, mm","latency":"4","throughput":"1"},{"base":"06_0D","parameters":"mm, mm","latency":"4","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"8","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"8","throughput":"2"},{"base":"0F_03","parameters":"mm, mm","latency":"9","throughput":""},{"base":"0F_02","parameters":"mm, mm","latency":"8","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"9","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"8","throughput":"2"}]},{"name":"_mm_sad_epu8","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Arithmetic","description":"Compute the absolute differences of packed unsigned 8-bit integers in \"a\" and \"b\", then horizontally sum each consecutive 8 differences to produce four unsigned 16-bit integers, and pack these unsigned 16-bit integers in the low 16 bits of 64-bit elements in \"dst\".","code":"FOR j := 0 to 15\n\ti := j*8\n\ttmp[i+7:i] := ABS(a[i+7:i] - b[i+7:i])\nENDFOR\nFOR j := 0 to 1\n\ti := j*64\n\tdst[i+15:i] := tmp[i+7:i] + tmp[i+15:i+8] + tmp[i+23:i+16] + tmp[i+31:i+24] \n\t\t\t\t + tmp[i+39:i+32] + tmp[i+47:i+40] + tmp[i+55:i+48] + tmp[i+63:i+56]\n\tdst[i+63:i+16] := 0\nENDFOR","header":"emmintrin.h","instruction":"psadbw","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"7","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"7","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"mm, mm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"mm, mm","latency":"5","throughput":"2"},{"base":"06_0D","parameters":"mm, mm","latency":"5","throughput":"2"},{"base":"0F_03","parameters":"mm, mm","latency":"4","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"4","throughput":"1"}]},{"name":"_mm_sub_epi8","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Arithmetic","description":"Subtract packed 8-bit integers in \"b\" from packed 8-bit integers in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 15\n\ti := j*8\n\tdst[i+7:i] := a[i+7:i] - b[i+7:i]\nENDFOR","header":"emmintrin.h","instruction":"psubb","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"BD xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"BD xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"BD xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"BD xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"0.5","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_sub_epi16","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Arithmetic","description":"Subtract packed 16-bit integers in \"b\" from packed 16-bit integers in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*16\n\tdst[i+15:i] := a[i+15:i] - b[i+15:i]\nENDFOR","header":"emmintrin.h","instruction":null,"parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_sub_epi32","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Arithmetic","description":"Subtract packed 32-bit integers in \"b\" from packed 32-bit integers in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := a[i+31:i] - b[i+31:i]\nENDFOR","header":"emmintrin.h","instruction":"psubd","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"BD xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"BD xmm, xmm","latency":"1","throughput":"0.33"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"0.5","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_sub_si64","tech":"SSE2","returnType":"__m64","cpuId":"SSE2","category":"Arithmetic","description":"Subtract 64-bit integer \"b\" from 64-bit integer \"a\", and store the result in \"dst\".","code":"dst[63:0] := a[63:0] - b[63:0]","header":"emmintrin.h","instruction":"psubq","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"06_0F","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"06_0E","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"06_0D","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"2","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"2","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"3","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"3","throughput":"2"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"6","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"6","throughput":"2"}]},{"name":"_mm_sub_epi64","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Arithmetic","description":"Subtract packed 64-bit integers in \"b\" from packed 64-bit integers in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := a[i+63:i] - b[i+63:i]\nENDFOR","header":"emmintrin.h","instruction":"psubq","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"06_0F","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"06_0E","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"06_0D","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"2","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"2","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"3","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"3","throughput":"2"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"6","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"6","throughput":"2"}]},{"name":"_mm_subs_epi8","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Arithmetic","description":"Subtract packed 8-bit integers in \"b\" from packed 8-bit integers in \"a\" using saturation, and store the results in \"dst\".","code":"FOR j := 0 to 15\n\ti := j*8\n\tdst[i+7:i] := Saturate_To_Int8(a[i+7:i] - b[i+7:i])\t\nENDFOR","header":"emmintrin.h","instruction":"psubsb","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"SUBUSB/PSUBUSW xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"SUBUSB/PSUBUSW xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"SUBUSB/PSUBUSW xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"SUBUSB/PSUBUSW xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"0.5","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_subs_epi16","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Arithmetic","description":"Subtract packed 16-bit integers in \"b\" from packed 16-bit integers in \"a\" using saturation, and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*16\n\tdst[i+15:i] := Saturate_To_Int16(a[i+15:i] - b[i+15:i])\nENDFOR","header":"emmintrin.h","instruction":"psubsw","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"SUBUSB/PSUBUSW xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"SUBUSB/PSUBUSW xmm, xmm","latency":"1","throughput":"0.33"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"0.5","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_subs_epu8","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Arithmetic","description":"Subtract packed unsigned 8-bit integers in \"b\" from packed unsigned 8-bit integers in \"a\" using saturation, and store the results in \"dst\".","code":"FOR j := 0 to 15\n\ti := j*8\n\tdst[i+7:i] := Saturate_To_UnsignedInt8(a[i+7:i] - b[i+7:i])\t\nENDFOR","header":"emmintrin.h","instruction":"psubusb","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"SUBUSB/PSUBUSW xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"SUBUSB/PSUBUSW xmm, xmm","latency":"1","throughput":"0.33"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"0.5","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_subs_epu16","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Arithmetic","description":"Subtract packed unsigned 16-bit integers in \"b\" from packed unsigned 16-bit integers in \"a\" using saturation, and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*16\n\tdst[i+15:i] := Saturate_To_UnsignedInt16(a[i+15:i] - b[i+15:i])\t\nENDFOR","header":"emmintrin.h","instruction":"psubusw","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"SUBUSB/PSUBUSW xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"SUBUSB/PSUBUSW xmm, xmm","latency":"1","throughput":"0.33"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"0.5","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_slli_si128","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Shift","description":"Shift \"a\" left by \"imm\" bytes while shifting in zeros, and store the results in \"dst\".","code":"dst[127:0] := a[127:0] << (imm*8)","header":"emmintrin.h","instruction":"pslldq","parameters":[{"type":"__m128i","name":"a"},{"type":"int","name":"imm"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, imm8","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, imm8","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, imm8","latency":"3","throughput":"2"},{"base":"06_0E","parameters":"xmm, imm8","latency":"4","throughput":"3"},{"base":"06_0D","parameters":"xmm, imm8","latency":"4","throughput":"3"},{"base":"0F_03","parameters":"xmm, imm8","latency":"4","throughput":"2"},{"base":"0F_02","parameters":"xmm, imm8","latency":"4","throughput":"2"}]},{"name":"_mm_bslli_si128","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Shift","description":"Shift \"a\" left by \"imm\" bytes while shifting in zeros, and store the results in \"dst\".","code":"dst[127:0] := a[127:0] << (imm*8)","header":"emmintrin.h","instruction":"pslldq","parameters":[{"type":"__m128i","name":"a"},{"type":"int","name":"imm"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, imm8","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, imm8","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, imm8","latency":"3","throughput":"2"},{"base":"06_0E","parameters":"xmm, imm8","latency":"4","throughput":"3"},{"base":"06_0D","parameters":"xmm, imm8","latency":"4","throughput":"3"},{"base":"0F_03","parameters":"xmm, imm8","latency":"4","throughput":"2"},{"base":"0F_02","parameters":"xmm, imm8","latency":"4","throughput":"2"}]},{"name":"_mm_bsrli_si128","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Shift","description":"Shift \"a\" right by \"imm\" bytes while shifting in zeros, and store the results in \"dst\".","code":"dst[127:0] := a[127:0] >> (imm*8)","header":"emmintrin.h","instruction":"psrldq","parameters":[{"type":"__m128i","name":"a"},{"type":"int","name":"imm"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, imm8","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, imm8","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, imm8","latency":"2","throughput":"1"},{"base":"06_0D","parameters":"xmm, imm8","latency":"4","throughput":"4"},{"base":"0F_03","parameters":"xmm, imm8","latency":"4","throughput":"2"},{"base":"0F_02","parameters":"xmm, imm8","latency":"4","throughput":"2"}]},{"name":"_mm_slli_epi16","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Shift","description":"Shift packed 16-bit integers in \"a\" left by \"imm\" while shifting in zeros, and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*16\n\tIF imm > 15\n\t\tdst[i+15:i] := 0\n\tELSE\n\t\tdst[i+15:i] := ZeroExtend(a[i+15:i] << imm)\n\tFI\nENDFOR","header":"emmintrin.h","instruction":"psllw","parameters":[{"type":"__m128i","name":"a"},{"type":"int","name":"imm"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"Q xmm, xmm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"Q xmm, xmm/imm8","latency":"2","throughput":"1"},{"base":"06_0E","parameters":"Q xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_0D","parameters":"Q xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm/imm8","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm/imm8","latency":"2","throughput":"1"}]},{"name":"_mm_sll_epi16","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Shift","description":"Shift packed 16-bit integers in \"a\" left by \"count\" while shifting in zeros, and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*16\n\tIF count[63:0] > 15\n\t\tdst[i+15:i] := 0\n\tELSE\n\t\tdst[i+15:i] := ZeroExtend(a[i+15:i] << count[63:0])\n\tFI\nENDFOR","header":"emmintrin.h","instruction":"psllw","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"count"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"Q xmm, xmm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"Q xmm, xmm/imm8","latency":"2","throughput":"1"},{"base":"06_0E","parameters":"Q xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_0D","parameters":"Q xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm/imm8","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm/imm8","latency":"2","throughput":"1"}]},{"name":"_mm_slli_epi32","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Shift","description":"Shift packed 32-bit integers in \"a\" left by \"imm\" while shifting in zeros, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tIF imm > 31\n\t\tdst[i+31:i] := 0\n\tELSE\n\t\tdst[i+31:i] := ZeroExtend(a[i+31:i] << imm)\n\tFI\nENDFOR","header":"emmintrin.h","instruction":"pslld","parameters":[{"type":"__m128i","name":"a"},{"type":"int","name":"imm"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"Q xmm, xmm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"Q xmm, xmm/imm8","latency":"2","throughput":"1"},{"base":"06_0E","parameters":"Q xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_0D","parameters":"Q xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm/imm8","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm/imm8","latency":"2","throughput":"1"}]},{"name":"_mm_sll_epi32","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Shift","description":"Shift packed 32-bit integers in \"a\" left by \"count\" while shifting in zeros, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tIF count[63:0] > 31\n\t\tdst[i+31:i] := 0\n\tELSE\n\t\tdst[i+31:i] := ZeroExtend(a[i+31:i] << count[63:0])\n\tFI\nENDFOR","header":"emmintrin.h","instruction":"pslld","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"count"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"Q xmm, xmm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"Q xmm, xmm/imm8","latency":"2","throughput":"1"},{"base":"06_0E","parameters":"Q xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_0D","parameters":"Q xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm/imm8","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm/imm8","latency":"2","throughput":"1"}]},{"name":"_mm_slli_epi64","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Shift","description":"Shift packed 64-bit integers in \"a\" left by \"imm\" while shifting in zeros, and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tIF imm > 63\n\t\tdst[i+63:i] := 0\n\tELSE\n\t\tdst[i+63:i] := ZeroExtend(a[i+63:i] << imm)\n\tFI\nENDFOR","header":"emmintrin.h","instruction":"psllq","parameters":[{"type":"__m128i","name":"a"},{"type":"int","name":"imm"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm/imm8","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm/imm8","latency":"2","throughput":"1"}]},{"name":"_mm_sll_epi64","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Shift","description":"Shift packed 64-bit integers in \"a\" left by \"count\" while shifting in zeros, and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tIF count[63:0] > 63\n\t\tdst[i+63:i] := 0\n\tELSE\n\t\tdst[i+63:i] := ZeroExtend(a[i+63:i] << count[63:0])\n\tFI\nENDFOR","header":"emmintrin.h","instruction":"psllq","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"count"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm/imm8","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm/imm8","latency":"2","throughput":"1"}]},{"name":"_mm_srai_epi16","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Shift","description":"Shift packed 16-bit integers in \"a\" right by \"imm\" while shifting in sign bits, and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*16\n\tIF imm > 15\n\t\tdst[i+15:i] := SignBit\n\tELSE\n\t\tdst[i+15:i] := SignExtend(a[i+15:i] >> imm)\n\tFI\nENDFOR","header":"emmintrin.h","instruction":"psraw","parameters":[{"type":"__m128i","name":"a"},{"type":"int","name":"imm"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"2","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"2","throughput":"1"},{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm/imm8","latency":"2","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm/imm8","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm/imm8","latency":"2","throughput":"1"}]},{"name":"_mm_sra_epi16","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Shift","description":"Shift packed 16-bit integers in \"a\" right by \"count\" while shifting in sign bits, and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*16\n\tIF count[63:0] > 15\n\t\tdst[i+15:i] := SignBit\n\tELSE\n\t\tdst[i+15:i] := SignExtend(a[i+15:i] >> count[63:0])\n\tFI\nENDFOR","header":"emmintrin.h","instruction":"psraw","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"count"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"2","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"2","throughput":"1"},{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm/imm8","latency":"2","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm/imm8","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm/imm8","latency":"2","throughput":"1"}]},{"name":"_mm_srai_epi32","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Shift","description":"Shift packed 32-bit integers in \"a\" right by \"imm\" while shifting in sign bits, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tIF imm > 31\n\t\tdst[i+31:i] := SignBit\n\tELSE\n\t\tdst[i+31:i] := SignExtend(a[i+31:i] >> imm)\n\tFI\nENDFOR","header":"emmintrin.h","instruction":"psrad","parameters":[{"type":"__m128i","name":"a"},{"type":"int","name":"imm"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"2","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"2","throughput":"1"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm/imm8","latency":"2","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm/imm8","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm/imm8","latency":"2","throughput":"1"}]},{"name":"_mm_sra_epi32","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Shift","description":"Shift packed 32-bit integers in \"a\" right by \"count\" while shifting in sign bits, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tIF count[63:0] > 31\n\t\tdst[i+31:i] := SignBit\n\tELSE\n\t\tdst[i+31:i] := SignExtend(a[i+31:i] >> count[63:0])\n\tFI\nENDFOR","header":"emmintrin.h","instruction":"psrad","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"count"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"2","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"2","throughput":"1"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm/imm8","latency":"2","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm/imm8","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm/imm8","latency":"2","throughput":"1"}]},{"name":"_mm_srli_si128","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Shift","description":"Shift \"a\" right by \"imm\" bytes while shifting in zeros, and store the results in \"dst\".","code":"dst[127:0] := a[127:0] >> (imm*8)","header":"emmintrin.h","instruction":"psrldq","parameters":[{"type":"__m128i","name":"a"},{"type":"int","name":"imm"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, imm8","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, imm8","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, imm8","latency":"2","throughput":"1"},{"base":"06_0D","parameters":"xmm, imm8","latency":"4","throughput":"4"},{"base":"0F_03","parameters":"xmm, imm8","latency":"4","throughput":"2"},{"base":"0F_02","parameters":"xmm, imm8","latency":"4","throughput":"2"}]},{"name":"_mm_srli_epi16","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Shift","description":"Shift packed 16-bit integers in \"a\" right by \"imm\" while shifting in zeros, and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*16\n\tIF imm > 15\n\t\tdst[i+15:i] := 0\n\tELSE\n\t\tdst[i+15:i] := ZeroExtend(a[i+15:i] >> imm)\n\tFI\nENDFOR","header":"emmintrin.h","instruction":"psrlw","parameters":[{"type":"__m128i","name":"a"},{"type":"int","name":"imm"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"LQ xmm, xmm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"LQ xmm, xmm/imm8","latency":"2","throughput":"1"},{"base":"06_0E","parameters":"LQ xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_0D","parameters":"LQ xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm/imm8","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm/imm8","latency":"2","throughput":"1"}]},{"name":"_mm_srl_epi16","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Shift","description":"Shift packed 16-bit integers in \"a\" right by \"count\" while shifting in zeros, and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*16\n\tIF count[63:0] > 15\n\t\tdst[i+15:i] := 0\n\tELSE\n\t\tdst[i+15:i] := ZeroExtend(a[i+15:i] >> count[63:0])\n\tFI\nENDFOR","header":"emmintrin.h","instruction":"psrlw","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"count"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"LQ xmm, xmm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"LQ xmm, xmm/imm8","latency":"2","throughput":"1"},{"base":"06_0E","parameters":"LQ xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_0D","parameters":"LQ xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm/imm8","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm/imm8","latency":"2","throughput":"1"}]},{"name":"_mm_srli_epi32","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Shift","description":"Shift packed 32-bit integers in \"a\" right by \"imm\" while shifting in zeros, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tIF imm > 31\n\t\tdst[i+31:i] := 0\n\tELSE\n\t\tdst[i+31:i] := ZeroExtend(a[i+31:i] >> imm)\n\tFI\nENDFOR","header":"emmintrin.h","instruction":"psrld","parameters":[{"type":"__m128i","name":"a"},{"type":"int","name":"imm"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"LQ xmm, xmm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"LQ xmm, xmm/imm8","latency":"2","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm/imm8","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm/imm8","latency":"2","throughput":"1"}]},{"name":"_mm_srl_epi32","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Shift","description":"Shift packed 32-bit integers in \"a\" right by \"count\" while shifting in zeros, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tIF count[63:0] > 31\n\t\tdst[i+31:i] := 0\n\tELSE\n\t\tdst[i+31:i] := ZeroExtend(a[i+31:i] >> count[63:0])\n\tFI\nENDFOR","header":"emmintrin.h","instruction":"psrld","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"count"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"LQ xmm, xmm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"LQ xmm, xmm/imm8","latency":"2","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm/imm8","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm/imm8","latency":"2","throughput":"1"}]},{"name":"_mm_srli_epi64","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Shift","description":"Shift packed 64-bit integers in \"a\" right by \"imm\" while shifting in zeros, and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tIF imm > 63\n\t\tdst[i+63:i] := 0\n\tELSE\n\t\tdst[i+63:i] := ZeroExtend(a[i+63:i] >> imm)\n\tFI\nENDFOR","header":"emmintrin.h","instruction":"psrlq","parameters":[{"type":"__m128i","name":"a"},{"type":"int","name":"imm"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"LQ xmm, xmm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"LQ xmm, xmm/imm8","latency":"2","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm/imm8","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm/imm8","latency":"2","throughput":"1"}]},{"name":"_mm_srl_epi64","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Shift","description":"Shift packed 64-bit integers in \"a\" right by \"count\" while shifting in zeros, and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tIF count[63:0] > 63\n\t\tdst[i+63:i] := 0\n\tELSE\n\t\tdst[i+63:i] := ZeroExtend(a[i+63:i] >> count[63:0])\n\tFI\nENDFOR","header":"emmintrin.h","instruction":"psrlq","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"count"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, imm8","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"LQ xmm, xmm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"LQ xmm, xmm/imm8","latency":"2","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm/imm8","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm/imm8","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm/imm8","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm/imm8","latency":"2","throughput":"1"}]},{"name":"_mm_and_si128","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Logical","description":"Compute the bitwise AND of 128 bits (representing integer data) in \"a\" and \"b\", and store the result in \"dst\".","code":"dst[127:0] := (a[127:0] AND b[127:0])","header":"emmintrin.h","instruction":"pand","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_andnot_si128","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Logical","description":"Compute the bitwise AND NOT of 128 bits (representing integer data) in \"a\" and \"b\", and store the result in \"dst\".","code":"dst[127:0] := ((NOT a[127:0]) AND b[127:0])","header":"emmintrin.h","instruction":"pandn","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_or_si128","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Logical","description":"Compute the bitwise OR of 128 bits (representing integer data) in \"a\" and \"b\", and store the result in \"dst\".","code":"dst[127:0] := (a[127:0] OR b[127:0])","header":"emmintrin.h","instruction":"por","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_xor_si128","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Logical","description":"Compute the bitwise OR of 128 bits (representing integer data) in \"a\" and \"b\", and store the result in \"dst\".","code":"dst[127:0] := (a[127:0] XOR b[127:0])","header":"emmintrin.h","instruction":"pxor","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"0.33","throughput":"0.33"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_cmpeq_epi8","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Compare","description":"Compare packed 8-bit integers in \"a\" and \"b\" for equality, and store the results in \"dst\".","code":"FOR j := 0 to 15\n  i := j*8\n  dst[i+7:i] := ( a[i+7:i] == b[i+7:i] ) ? 0xFF : 0\nENDFOR","header":"emmintrin.h","instruction":"pcmpeqb","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"0.5","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_cmpeq_epi16","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Compare","description":"Compare packed 16-bit integers in \"a\" and \"b\" for equality, and store the results in \"dst\".","code":"FOR j := 0 to 7\n  i := j*16\n  dst[i+15:i] := ( a[i+15:i] == b[i+15:i] ) ? 0xFFFF : 0\nENDFOR","header":"emmintrin.h","instruction":"pcmpeqw","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"0.5","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_cmpeq_epi32","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Compare","description":"Compare packed 32-bit integers in \"a\" and \"b\" for equality, and store the results in \"dst\".","code":"FOR j := 0 to 3\n  i := j*32\n  dst[i+31:i] := ( a[i+31:i] == b[i+31:i] ) ? 0xFFFFFFFF : 0\nENDFOR","header":"emmintrin.h","instruction":"pcmpeqd","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"0.5","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_cmpgt_epi8","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Compare","description":"Compare packed 8-bit integers in \"a\" and \"b\" for greater-than, and store the results in \"dst\".","code":"FOR j := 0 to 15\n  i := j*8\n  dst[i+7:i] := ( a[i+7:i] > b[i+7:i] ) ? 0xFF : 0\nENDFOR","header":"emmintrin.h","instruction":"pcmpgtb","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"0.5","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_cmpgt_epi16","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Compare","description":"Compare packed 16-bit integers in \"a\" and \"b\" for greater-than, and store the results in \"dst\".","code":"FOR j := 0 to 7\n  i := j*16\n  dst[i+15:i] := ( a[i+15:i] > b[i+15:i] ) ? 0xFFFF : 0\nENDFOR","header":"emmintrin.h","instruction":"pcmpgtw","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"0.5","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_cmpgt_epi32","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Compare","description":"Compare packed 32-bit integers in \"a\" and \"b\" for greater-than, and store the results in \"dst\".","code":"FOR j := 0 to 3\n  i := j*32\n  dst[i+31:i] := ( a[i+31:i] > b[i+31:i] ) ? 0xFFFFFFFF : 0\nENDFOR","header":"emmintrin.h","instruction":"pcmpgtd","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"0.5","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_cmplt_epi8","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Compare","description":"Compare packed 8-bit integers in \"a\" and \"b\" for less-than, and store the results in \"dst\". Note: This intrinsic emits the pcmpgtb instruction with the order of the operands switched.","code":"FOR j := 0 to 15\n  i := j*8\n  dst[i+7:i] := ( a[i+7:i] < b[i+7:i] ) ? 0xFF : 0\nENDFOR","header":"emmintrin.h","instruction":"pcmpgtb","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"0.5","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_cmplt_epi16","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Compare","description":"Compare packed 16-bit integers in \"a\" and \"b\" for less-than, and store the results in \"dst\". Note: This intrinsic emits the pcmpgtw instruction with the order of the operands switched.","code":"FOR j := 0 to 7\n\ti := j*16\n\tdst[i+15:i] := ( a[i+15:i] < b[i+15:i] ) ? 0xFFFF : 0\nENDFOR","header":"emmintrin.h","instruction":"pcmpgtw","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"0.5","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_cmplt_epi32","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Compare","description":"Compare packed 32-bit integers in \"a\" and \"b\" for less-than, and store the results in \"dst\". Note: This intrinsic emits the pcmpgtd instruction with the order of the operands switched.","code":"FOR j := 0 to 3\n  i := j*32\n  dst[i+31:i] := ( a[i+31:i] < b[i+31:i] ) ? 0xFFFFFFFF : 0\nENDFOR","header":"emmintrin.h","instruction":"pcmpgtd","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"0.5","throughput":"0.5"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_cvtepi32_pd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Convert","description":"Convert packed 32-bit integers in \"a\" to packed double-precision (64-bit) floating-point elements, and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*32\n\tm := j*64\n\tdst[m+63:m] := Convert_Int32_To_FP64(a[i+31:i])\nENDFOR","header":"emmintrin.h","instruction":"cvtdq2pd","parameters":[{"type":"__m128i","name":"a"}],"isFloat":true,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"4","throughput":"0.8"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"4","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"4","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"4","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"8","throughput":"3"},{"base":"0F_02","parameters":"xmm, xmm","latency":"8","throughput":"3"}]},{"name":"_mm_cvtsi32_sd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Convert","description":"Convert the 32-bit integer \"b\" to a double-precision (64-bit) floating-point element, store the result in the lower element of \"dst\", and copy the upper element from \"a\" to the upper element of \"dst\".","code":"dst[63:0] := Convert_Int32_To_FP64(b[31:0])\ndst[127:64] := a[127:64]\ndst[MAX:128] := 0","header":"emmintrin.h","instruction":"cvtsi2sd","parameters":[{"type":"__m128d","name":"a"},{"type":"int","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E3C/45/46","parameters":"xmm, r32","latency":"4","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, r32","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, r32","latency":"","throughput":"3"},{"base":"06_0F","parameters":"xmm, r32","latency":"","throughput":"1"},{"base":"06_0E","parameters":"xmm, r32","latency":"4","throughput":"1"},{"base":"06_0D","parameters":"xmm, r32","latency":"4","throughput":"1"},{"base":"06_3C/45/46","parameters":"xmm, r64","latency":"4","throughput":"0.8"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, r64","latency":"4","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, r64","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, r64","latency":"4","throughput":"1"},{"base":"0F_03","parameters":"xmm, r32","latency":"16","throughput":"2"},{"base":"0F_02","parameters":"xmm, r32","latency":"15","throughput":"3"}]},{"name":"_mm_cvtsi64_sd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Convert","description":"Convert the 64-bit integer \"b\" to a double-precision (64-bit) floating-point element, store the result in the lower element of \"dst\", and copy the upper element from \"a\" to the upper element of \"dst\".","code":"dst[63:0] := Convert_Int64_To_FP64(b[63:0])\ndst[127:64] := a[127:64]\ndst[MAX:128] := 0","header":"emmintrin.h","instruction":"cvtsi2sd","parameters":[{"type":"__m128d","name":"a"},{"type":"__int64","name":"b"}],"isFloat":true,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E3C/45/46","parameters":"xmm, r32","latency":"4","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, r32","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, r32","latency":"","throughput":"3"},{"base":"06_0F","parameters":"xmm, r32","latency":"","throughput":"1"},{"base":"06_0E","parameters":"xmm, r32","latency":"4","throughput":"1"},{"base":"06_0D","parameters":"xmm, r32","latency":"4","throughput":"1"},{"base":"06_3C/45/46","parameters":"xmm, r64","latency":"4","throughput":"0.8"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, r64","latency":"4","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, r64","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, r64","latency":"4","throughput":"1"},{"base":"0F_03","parameters":"xmm, r32","latency":"16","throughput":"2"},{"base":"0F_02","parameters":"xmm, r32","latency":"15","throughput":"3"}]},{"name":"_mm_cvtsi64x_sd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Convert","description":"Convert the 64-bit integer \"b\" to a double-precision (64-bit) floating-point element, store the result in the lower element of \"dst\", and copy the upper element from \"a\" to the upper element of \"dst\".","code":"dst[63:0] := Convert_Int64_To_FP64(b[63:0])\ndst[127:64] := a[127:64]\ndst[MAX:128] := 0","header":"emmintrin.h","instruction":"cvtsi2sd","parameters":[{"type":"__m128d","name":"a"},{"type":"__int64","name":"b"}],"isFloat":true,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E3C/45/46","parameters":"xmm, r32","latency":"4","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, r32","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, r32","latency":"","throughput":"3"},{"base":"06_0F","parameters":"xmm, r32","latency":"","throughput":"1"},{"base":"06_0E","parameters":"xmm, r32","latency":"4","throughput":"1"},{"base":"06_0D","parameters":"xmm, r32","latency":"4","throughput":"1"},{"base":"06_3C/45/46","parameters":"xmm, r64","latency":"4","throughput":"0.8"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, r64","latency":"4","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, r64","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, r64","latency":"4","throughput":"1"},{"base":"0F_03","parameters":"xmm, r32","latency":"16","throughput":"2"},{"base":"0F_02","parameters":"xmm, r32","latency":"15","throughput":"3"}]},{"name":"_mm_cvtepi32_ps","tech":"SSE2","returnType":"__m128","cpuId":"SSE2","category":"Convert","description":"Convert packed 32-bit integers in \"a\" to packed single-precision (32-bit) floating-point elements, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := 32*j\n\tdst[i+31:i] := Convert_Int32_To_FP32(a[i+31:i])\nENDFOR","header":"emmintrin.h","instruction":"cvtdq2ps","parameters":[{"type":"__m128i","name":"a"}],"isFloat":true,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_17/1D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm ,xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"5","throughput":"2"},{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"0.8"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"4","throughput":"1"}]},{"name":"_mm_cvtpi32_pd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Convert","description":"Convert packed 32-bit integers in \"a\" to packed double-precision (64-bit) floating-point elements, and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*32\n\tm := j*64\n\tdst[m+63:m] := Convert_Int32_To_FP64(a[i+31:i])\nENDFOR","header":"emmintrin.h","instruction":"cvtpi2pd","parameters":[{"type":"__m64","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"4","throughput":""},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"4","throughput":""},{"base":"06_0F","parameters":"xmm, mm","latency":"4","throughput":"1"},{"base":"06_0E","parameters":"xmm, mm","latency":"5","throughput":""},{"base":"06_0D","parameters":"xmm, mm","latency":"5","throughput":""},{"base":"0F_03","parameters":"xmm, mm","latency":"12","throughput":"2"},{"base":"0F_02","parameters":"xmm, mm","latency":"11","throughput":"4"}]},{"name":"_mm_cvtsi32_si128","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Convert","description":"Copy 32-bit integer \"a\" to the lower elements of \"dst\", and zero the upper elements of \"dst\".","code":"dst[31:0] := a[31:0]\ndst[127:32] := 0","header":"emmintrin.h","instruction":"movd","parameters":[{"type":"int","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, r32","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, r32","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, r32","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, r32","latency":"1","throughput":"0.5"},{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, r64","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, r64","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, r64","latency":"1","throughput":"0.5"},{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"r32, xmm","latency":"2","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"r32, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"r32, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"r32, xmm","latency":"1","throughput":"0.33"},{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"r64, xmm","latency":"1","throughput":"0.33"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"r64, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"r64, xmm","latency":"1","throughput":"0.33"},{"base":"0F_03","parameters":"r32, xmm","latency":"10","throughput":"1"},{"base":"0F_02","parameters":"r32, xmm","latency":"10","throughput":"1"},{"base":"0F_03","parameters":"xmm, r32","latency":"6","throughput":"2"},{"base":"0F_02","parameters":"xmm, r32","latency":"6","throughput":"2"},{"base":"06_0F","parameters":"mm, r32","latency":"1","throughput":"0.5"},{"base":"06_0E","parameters":"mm, r32","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, r32","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"r32, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"r32, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"r32, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, r32","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, r32","latency":"2","throughput":"1"},{"base":"0F_03","parameters":"r32, mm","latency":"5","throughput":"1"},{"base":"0F_02","parameters":"r32, mm","latency":"5","throughput":"1"}]},{"name":"_mm_cvtsi64_si128","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Convert","description":"Copy 64-bit integer \"a\" to the lower element of \"dst\", and zero the upper element.","code":"dst[63:0] := a[63:0]\ndst[127:64] := 0","header":"emmintrin.h","instruction":"movq","parameters":[{"type":"__int64","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"6","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"6","throughput":"1"}]},{"name":"_mm_cvtsi64x_si128","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Convert","description":"Copy 64-bit integer \"a\" to the lower element of \"dst\", and zero the upper element.","code":"dst[63:0] := a[63:0]\ndst[127:64] := 0","header":"emmintrin.h","instruction":"movq","parameters":[{"type":"__int64","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"6","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"6","throughput":"1"}]},{"name":"_mm_cvtsi128_si32","tech":"SSE2","returnType":"int","cpuId":"SSE2","category":"Convert","description":"Copy the lower 32-bit integer in \"a\" to \"dst\".","code":"dst[31:0] := a[31:0]","header":"emmintrin.h","instruction":"movd","parameters":[{"type":"__m128i","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, r32","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, r32","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, r32","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, r32","latency":"1","throughput":"0.5"},{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, r64","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, r64","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, r64","latency":"1","throughput":"0.5"},{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"r32, xmm","latency":"2","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"r32, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"r32, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"r32, xmm","latency":"1","throughput":"0.33"},{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"r64, xmm","latency":"1","throughput":"0.33"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"r64, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"r64, xmm","latency":"1","throughput":"0.33"},{"base":"0F_03","parameters":"r32, xmm","latency":"10","throughput":"1"},{"base":"0F_02","parameters":"r32, xmm","latency":"10","throughput":"1"},{"base":"0F_03","parameters":"xmm, r32","latency":"6","throughput":"2"},{"base":"0F_02","parameters":"xmm, r32","latency":"6","throughput":"2"},{"base":"06_0F","parameters":"mm, r32","latency":"1","throughput":"0.5"},{"base":"06_0E","parameters":"mm, r32","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, r32","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"r32, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"r32, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"r32, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, r32","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, r32","latency":"2","throughput":"1"},{"base":"0F_03","parameters":"r32, mm","latency":"5","throughput":"1"},{"base":"0F_02","parameters":"r32, mm","latency":"5","throughput":"1"}]},{"name":"_mm_cvtsi128_si64","tech":"SSE2","returnType":"__int64","cpuId":"SSE2","category":"Convert","description":"Copy the lower 64-bit integer in \"a\" to \"dst\".","code":"dst[63:0] := a[63:0]","header":"emmintrin.h","instruction":"movq","parameters":[{"type":"__m128i","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"6","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"6","throughput":"1"}]},{"name":"_mm_cvtsi128_si64x","tech":"SSE2","returnType":"__int64","cpuId":"SSE2","category":"Convert","description":"Copy the lower 64-bit integer in \"a\" to \"dst\".","code":"dst[63:0] := a[63:0]","header":"emmintrin.h","instruction":"movq","parameters":[{"type":"__m128i","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"6","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"6","throughput":"1"}]},{"name":"_mm_set_epi64","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Set","description":"Set packed 64-bit integers in \"dst\" with the supplied values.","code":"dst[63:0] := e0\ndst[127:64] := e1","header":"emmintrin.h","instruction":null,"parameters":[{"type":"__m64","name":"e1"},{"type":"__m64","name":"e0"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_set_epi64x","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Set","description":"Set packed 64-bit integers in \"dst\" with the supplied values.","code":"dst[63:0] := e0\ndst[127:64] := e1","header":"emmintrin.h","instruction":null,"parameters":[{"type":"__int64","name":"e1"},{"type":"__int64","name":"e0"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_set_epi32","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Set","description":"Set packed 32-bit integers in \"dst\" with the supplied values.","code":"dst[31:0] := e0\ndst[63:32] := e1\ndst[95:64] := e2\ndst[127:96] := e3","header":"emmintrin.h","instruction":null,"parameters":[{"type":"int","name":"e3"},{"type":"int","name":"e2"},{"type":"int","name":"e1"},{"type":"int","name":"e0"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_set_epi16","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Set","description":"Set packed 16-bit integers in \"dst\" with the supplied values.","code":"dst[15:0] := e0\ndst[31:16] := e1\ndst[47:32] := e2\ndst[63:48] := e3\ndst[79:64] := e4\ndst[95:80] := e5\ndst[111:96] := e6\ndst[127:112] := e7","header":"emmintrin.h","instruction":null,"parameters":[{"type":"short","name":"e7"},{"type":"short","name":"e6"},{"type":"short","name":"e5"},{"type":"short","name":"e4"},{"type":"short","name":"e3"},{"type":"short","name":"e2"},{"type":"short","name":"e1"},{"type":"short","name":"e0"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_set_epi8","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Set","description":"Set packed 8-bit integers in \"dst\" with the supplied values in reverse order.","code":"dst[7:0] := e0\ndst[15:8] := e1\ndst[23:16] := e2\ndst[31:24] := e3\ndst[39:32] := e4\ndst[47:40] := e5\ndst[55:48] := e6\ndst[63:56] := e7\ndst[71:64] := e8\ndst[79:72] := e9\ndst[87:80] := e10\ndst[95:88] := e11\ndst[103:96] := e12\ndst[111:104] := e13\ndst[119:112] := e14\ndst[127:120] := e15","header":"emmintrin.h","instruction":null,"parameters":[{"type":"char","name":"e15"},{"type":"char","name":"e14"},{"type":"char","name":"e13"},{"type":"char","name":"e12"},{"type":"char","name":"e11"},{"type":"char","name":"e10"},{"type":"char","name":"e9"},{"type":"char","name":"e8"},{"type":"char","name":"e7"},{"type":"char","name":"e6"},{"type":"char","name":"e5"},{"type":"char","name":"e4"},{"type":"char","name":"e3"},{"type":"char","name":"e2"},{"type":"char","name":"e1"},{"type":"char","name":"e0"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_set1_epi64","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Set","description":"Broadcast 64-bit integer \"a\" to all elements of \"dst\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := a[63:0]\nENDFOR","header":"emmintrin.h","instruction":null,"parameters":[{"type":"__m64","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_set1_epi64x","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Set","description":"Broadcast 64-bit integer \"a\" to all elements of \"dst\". This intrinsic may generate the \"vpbroadcastq\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := a[63:0]\nENDFOR","header":"emmintrin.h","instruction":null,"parameters":[{"type":"__int64","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_set1_epi32","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Set","description":"Broadcast 32-bit integer \"a\" to all elements of \"dst\". This intrinsic may generate \"vpbroadcastd\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := a[31:0]\nENDFOR","header":"emmintrin.h","instruction":null,"parameters":[{"type":"int","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_set1_epi16","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Set","description":"Broadcast 16-bit integer \"a\" to all all elements of \"dst\". This intrinsic may generate \"vpbroadcastw\".","code":"FOR j := 0 to 7\n\ti := j*16\n\tdst[i+15:i] := a[15:0]\nENDFOR","header":"emmintrin.h","instruction":null,"parameters":[{"type":"short","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_set1_epi8","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Set","description":"Broadcast 8-bit integer \"a\" to all elements of \"dst\". This intrinsic may generate \"vpbroadcastb\".","code":"FOR j := 0 to 15\n\ti := j*8\n\tdst[i+7:i] := a[7:0]\nENDFOR","header":"emmintrin.h","instruction":null,"parameters":[{"type":"char","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_setr_epi64","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Set","description":"Set packed 64-bit integers in \"dst\" with the supplied values in reverse order.","code":"dst[63:0] := e1\ndst[127:64] := e0","header":"emmintrin.h","instruction":null,"parameters":[{"type":"__m64","name":"e1"},{"type":"__m64","name":"e0"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_setr_epi32","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Set","description":"Set packed 32-bit integers in \"dst\" with the supplied values in reverse order.","code":"dst[31:0] := e3\ndst[63:32] := e2\ndst[95:64] := e1\ndst[127:96] := e0","header":"emmintrin.h","instruction":null,"parameters":[{"type":"int","name":"e3"},{"type":"int","name":"e2"},{"type":"int","name":"e1"},{"type":"int","name":"e0"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_setr_epi16","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Set","description":"Set packed 16-bit integers in \"dst\" with the supplied values in reverse order.","code":"dst[15:0] := e7\ndst[31:16] := e6\ndst[47:32] := e5\ndst[63:48] := e4\ndst[79:64] := e3\ndst[95:80] := e2\ndst[111:96] := e1\ndst[127:112] := e0","header":"emmintrin.h","instruction":null,"parameters":[{"type":"short","name":"e7"},{"type":"short","name":"e6"},{"type":"short","name":"e5"},{"type":"short","name":"e4"},{"type":"short","name":"e3"},{"type":"short","name":"e2"},{"type":"short","name":"e1"},{"type":"short","name":"e0"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_setr_epi8","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Set","description":"Set packed 8-bit integers in \"dst\" with the supplied values in reverse order.","code":"dst[7:0] := e15\ndst[15:8] := e14\ndst[23:16] := e13\ndst[31:24] := e12\ndst[39:32] := e11\ndst[47:40] := e10\ndst[55:48] := e9\ndst[63:56] := e8\ndst[71:64] := e7\ndst[79:72] := e6\ndst[87:80] := e5\ndst[95:88] := e4\ndst[103:96] := e3\ndst[111:104] := e2\ndst[119:112] := e1\ndst[127:120] := e0","header":"emmintrin.h","instruction":null,"parameters":[{"type":"char","name":"e15"},{"type":"char","name":"e14"},{"type":"char","name":"e13"},{"type":"char","name":"e12"},{"type":"char","name":"e11"},{"type":"char","name":"e10"},{"type":"char","name":"e9"},{"type":"char","name":"e8"},{"type":"char","name":"e7"},{"type":"char","name":"e6"},{"type":"char","name":"e5"},{"type":"char","name":"e4"},{"type":"char","name":"e3"},{"type":"char","name":"e2"},{"type":"char","name":"e1"},{"type":"char","name":"e0"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_setzero_si128","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Set","description":"Return vector of type __m128i with all elements set to zero.","code":"dst[MAX:0] := 0","header":"emmintrin.h","instruction":"pxor","parameters":[],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"0.33","throughput":"0.33"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_loadl_epi64","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Load","description":"Load 64-bit integer from memory into the first element of \"dst\".","code":"dst[63:0] := MEM[mem_addr+63:mem_addr]\ndst[MAX:64] := 0","header":"emmintrin.h","instruction":"movq","parameters":[{"type":"__m128i const*","name":"mem_addr"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"6","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"6","throughput":"1"}]},{"name":"_mm_load_si128","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Load","description":"Load 128-bits of integer data from memory into \"dst\". \n\t\"mem_addr\" must be aligned on a 16-byte boundary or a general-protection exception will be generated.","code":"dst[127:0] := MEM[mem_addr+127:mem_addr]","header":"emmintrin.h","instruction":"movdqa","parameters":[{"type":"__m128i const*","name":"mem_addr"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"6","throughput":"1"},{"base":"0F_02","parameters":"xmm, xmm","latency":"6","throughput":"1"}]},{"name":"_mm_loadu_si128","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Load","description":"Load 128-bits of integer data from memory into \"dst\".\n\t\"mem_addr\" does not need to be aligned on any particular boundary.","code":"dst[127:0] := MEM[mem_addr+127:mem_addr]","header":"emmintrin.h","instruction":"movdqu","parameters":[{"type":"__m128i const*","name":"mem_addr"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"6","throughput":"1"},{"base":"0F_02","parameters":"xmm, xmm","latency":"6","throughput":"1"}]},{"name":"_mm_maskmoveu_si128","tech":"SSE2","returnType":"void","cpuId":"SSE2","category":"Store","description":"Conditionally store 8-bit integer elements from \"a\" into memory using \"mask\" (elements are not stored when the highest bit is not set in the corresponding element). \"mem_addr\" does not need to be aligned on any particular boundary.","code":"FOR j := 0 to 15\n\ti := j*8\n\tIF mask[i+7]\n\t\tMEM[mem_addr+i+7:mem_addr+i] := a[i+7:i]\n\tFI\nENDFOR","header":"emmintrin.h","instruction":"maskmovdqu","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"mask"},{"type":"char*","name":"mem_addr"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_0F","parameters":"xmm, xmm","latency":"8","throughput":"2"},{"base":"06_0F","parameters":"r32, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"r32, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"r32, xmm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"r64, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, r32","latency":"1","throughput":"0.5"},{"base":"06_0E","parameters":"xmm, r32","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"xmm, r32","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"xmm, r64","latency":"1","throughput":"0.5"}]},{"name":"_mm_store_si128","tech":"SSE2","returnType":"void","cpuId":"SSE2","category":"Store","description":"Store 128-bits of integer data from \"a\" into memory. \n\t\"mem_addr\" must be aligned on a 16-byte boundary or a general-protection exception will be generated.","code":"MEM[mem_addr+127:mem_addr] := a[127:0]","header":"emmintrin.h","instruction":"movdqa","parameters":[{"type":"__m128i*","name":"mem_addr"},{"type":"__m128i","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"6","throughput":"1"},{"base":"0F_02","parameters":"xmm, xmm","latency":"6","throughput":"1"}]},{"name":"_mm_storeu_si128","tech":"SSE2","returnType":"void","cpuId":"SSE2","category":"Store","description":"Store 128-bits of integer data from \"a\" into memory.\n\t\"mem_addr\" does not need to be aligned on any particular boundary.","code":"MEM[mem_addr+127:mem_addr] := a[127:0]","header":"emmintrin.h","instruction":"movdqu","parameters":[{"type":"__m128i*","name":"mem_addr"},{"type":"__m128i","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"6","throughput":"1"},{"base":"0F_02","parameters":"xmm, xmm","latency":"6","throughput":"1"}]},{"name":"_mm_storel_epi64","tech":"SSE2","returnType":"void","cpuId":"SSE2","category":"Store","description":"Store 64-bit integer from the first element of \"a\" into memory.","code":"MEM[mem_addr+63:mem_addr] := a[63:0]","header":"emmintrin.h","instruction":"movq","parameters":[{"type":"__m128i*","name":"mem_addr"},{"type":"__m128i","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"6","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"6","throughput":"1"}]},{"name":"_mm_stream_si128","tech":"SSE2","returnType":"void","cpuId":"SSE2","category":"Store","description":"Store 128-bits of integer data from \"a\" into memory using a non-temporal memory hint. \n\t\"mem_addr\" must be aligned on a 16-byte boundary or a general-protection exception will be generated.","code":"MEM[mem_addr+127:mem_addr] := a[127:0]","header":"emmintrin.h","instruction":"movntdq","parameters":[{"type":"__m128i*","name":"mem_addr"},{"type":"__m128i","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_stream_si32","tech":"SSE2","returnType":"void","cpuId":"SSE2","category":"Store","description":"Store 32-bit integer \"a\" into memory using a non-temporal hint to minimize cache pollution. If the cache line containing address \"mem_addr\" is already in the cache, the cache will be updated.","code":"MEM[mem_addr+31:mem_addr] := a[31:0]","header":"emmintrin.h","instruction":"movnti","parameters":[{"type":"int*","name":"mem_addr"},{"type":"int","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_stream_si64","tech":"SSE2","returnType":"void","cpuId":"SSE2","category":"Store","description":"Store 64-bit integer \"a\" into memory using a non-temporal hint to minimize cache pollution. If the cache line containing address \"mem_addr\" is already in the cache, the cache will be updated.","code":"MEM[mem_addr+63:mem_addr] := a[63:0]","header":"emmintrin.h","instruction":"movnti","parameters":[{"type":"__int64*","name":"mem_addr"},{"type":"__int64","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_movepi64_pi64","tech":"SSE2","returnType":"__m64","cpuId":"SSE2","category":"Miscellaneous","description":"Copy the lower 64-bit integer in \"a\" to \"dst\".","code":"dst[63:0] := a[63:0]","header":"emmintrin.h","instruction":"movdq2q","parameters":[{"type":"__m128i","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"2","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"","throughput":"0.33"},{"base":"06_0F","parameters":"mm, xmm","latency":"1","throughput":""},{"base":"06_0E","parameters":"mm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, xmm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, xmm","latency":"8","throughput":"2"},{"base":"0F_02","parameters":"mm, xmm","latency":"8","throughput":"2"}]},{"name":"_mm_movpi64_epi64","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Move","description":"Copy the 64-bit integer \"a\" to the lower element of \"dst\", and zero the upper element.","code":"dst[63:0] := a[63:0]\ndst[127:64] := 0","header":"emmintrin.h","instruction":"movq2dq","parameters":[{"type":"__m64","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, mm","latency":"","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, mm","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"xmm, mm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, mm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, mm","latency":"8","throughput":"2"},{"base":"0F_02","parameters":"xmm, mm","latency":"8","throughput":"2"}]},{"name":"_mm_move_epi64","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Move","description":"Copy the lower 64-bit integer in \"a\" to the lower element of \"dst\", and zero the upper element.","code":"dst[63:0] := a[63:0]\ndst[127:64] := 0","header":"emmintrin.h","instruction":"movq","parameters":[{"type":"__m128i","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"6","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"6","throughput":"1"}]},{"name":"_mm_packs_epi16","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Miscellaneous","description":"Convert packed 16-bit integers from \"a\" and \"b\" to packed 8-bit integers using signed saturation, and store the results in \"dst\".","code":"dst[7:0] := Saturate_Int16_To_Int8 (a[15:0])\ndst[15:8] := Saturate_Int16_To_Int8 (a[31:16])\ndst[23:16] := Saturate_Int16_To_Int8 (a[47:32])\ndst[31:24] := Saturate_Int16_To_Int8 (a[63:48])\ndst[39:32] := Saturate_Int16_To_Int8 (a[79:64])\ndst[47:40] := Saturate_Int16_To_Int8 (a[95:80])\ndst[55:48] := Saturate_Int16_To_Int8 (a[111:96])\ndst[63:56] := Saturate_Int16_To_Int8 (a[127:112])\ndst[71:64] := Saturate_Int16_To_Int8 (b[15:0])\ndst[79:72] := Saturate_Int16_To_Int8 (b[31:16])\ndst[87:80] := Saturate_Int16_To_Int8 (b[47:32])\ndst[95:88] := Saturate_Int16_To_Int8 (b[63:48])\ndst[103:96] := Saturate_Int16_To_Int8 (b[79:64])\ndst[111:104] := Saturate_Int16_To_Int8 (b[95:80])\ndst[119:112] := Saturate_Int16_To_Int8 (b[111:96])\ndst[127:120] := Saturate_Int16_To_Int8 (b[127:112])","header":"emmintrin.h","instruction":"packsswb","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_0E","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_packs_epi32","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Miscellaneous","description":"Convert packed 32-bit integers from \"a\" and \"b\" to packed 16-bit integers using signed saturation, and store the results in \"dst\".","code":"dst[15:0] := Saturate_Int32_To_Int16 (a[31:0])\ndst[31:16] := Saturate_Int32_To_Int16 (a[63:32])\ndst[47:32] := Saturate_Int32_To_Int16 (a[95:64])\ndst[63:48] := Saturate_Int32_To_Int16 (a[127:96])\ndst[79:64] := Saturate_Int32_To_Int16 (b[31:0])\ndst[95:80] := Saturate_Int32_To_Int16 (b[63:32])\ndst[111:96] := Saturate_Int32_To_Int16 (b[95:64])\ndst[127:112] := Saturate_Int32_To_Int16 (b[127:96])","header":"emmintrin.h","instruction":"packssdw","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_0E","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_packus_epi16","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Miscellaneous","description":"Convert packed 16-bit integers from \"a\" and \"b\" to packed 8-bit integers using unsigned saturation, and store the results in \"dst\".","code":"dst[7:0] := Saturate_Int16_To_UnsignedInt8 (a[15:0])\ndst[15:8] := Saturate_Int16_To_UnsignedInt8 (a[31:16])\ndst[23:16] := Saturate_Int16_To_UnsignedInt8 (a[47:32])\ndst[31:24] := Saturate_Int16_To_UnsignedInt8 (a[63:48])\ndst[39:32] := Saturate_Int16_To_UnsignedInt8 (a[79:64])\ndst[47:40] := Saturate_Int16_To_UnsignedInt8 (a[95:80])\ndst[55:48] := Saturate_Int16_To_UnsignedInt8 (a[111:96])\ndst[63:56] := Saturate_Int16_To_UnsignedInt8 (a[127:112])\ndst[71:64] := Saturate_Int16_To_UnsignedInt8 (b[15:0])\ndst[79:72] := Saturate_Int16_To_UnsignedInt8 (b[31:16])\ndst[87:80] := Saturate_Int16_To_UnsignedInt8 (b[47:32])\ndst[95:88] := Saturate_Int16_To_UnsignedInt8 (b[63:48])\ndst[103:96] := Saturate_Int16_To_UnsignedInt8 (b[79:64])\ndst[111:104] := Saturate_Int16_To_UnsignedInt8 (b[95:80])\ndst[119:112] := Saturate_Int16_To_UnsignedInt8 (b[111:96])\ndst[127:120] := Saturate_Int16_To_UnsignedInt8 (b[127:112])","header":"emmintrin.h","instruction":"packuswb","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_0E","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_extract_epi16","tech":"SSE2","returnType":"int","cpuId":"SSE2","category":"Swizzle","description":"Extract a 16-bit integer from \"a\", selected with \"imm\", and store the result in the lower element of \"dst\".","code":"dst[15:0] := (a[127:0] >> (imm[2:0] * 16))[15:0]\ndst[31:16] := 0","header":"emmintrin.h","instruction":"pextrw","parameters":[{"type":"__m128i","name":"a"},{"type":"int","name":"imm"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3/3C/45/46E","parameters":"reg, xmm, imm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"reg, xmm, imm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"reg, xmm, imm","latency":"5","throughput":"1"},{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"r32, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"r32, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"r32, xmm, imm8","latency":"","throughput":"1"},{"base":"06_0F","parameters":"r32, xmm, imm8","latency":"2","throughput":"1"},{"base":"06_0E","parameters":"r32, xmm, imm8","latency":"3","throughput":"2"},{"base":"06_0D","parameters":"r32, xmm, imm8","latency":"3","throughput":"2"},{"base":"0F_03","parameters":"r32, xmm, imm8","latency":"7","throughput":"2"},{"base":"0F_02","parameters":"r32, xmm, imm8","latency":"7","throughput":"2"},{"base":"06_17","parameters":"r32, mm,imm8","latency":"","throughput":"1"},{"base":"06_0F","parameters":"r32, mm,imm8","latency":"2","throughput":"1"},{"base":"06_0E","parameters":"r32, mm,imm8","latency":"2","throughput":"1"},{"base":"06_0D","parameters":"r32, mm,imm8","latency":"2","throughput":"1"},{"base":"0F_03","parameters":"r32, mm, imm8","latency":"7","throughput":"2"},{"base":"0F_02","parameters":"r32, mm, imm8","latency":"7","throughput":"2"}]},{"name":"_mm_insert_epi16","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Swizzle","description":"Copy \"a\" to \"dst\", and insert the 16-bit integer \"i\" into \"dst\" at the location specified by \"imm\".","code":"dst[127:0] := a[127:0]\nsel := imm[2:0]*16\ndst[sel+15:sel] := i[15:0]","header":"emmintrin.h","instruction":"pinsrw","parameters":[{"type":"__m128i","name":"a"},{"type":"int","name":"i"},{"type":"int","name":"imm"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, reg, imm","latency":"2","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, reg, imm","latency":"2","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, reg, imm","latency":"4","throughput":"1"},{"base":"06_3C/45/46","parameters":"xmm, r32, imm8","latency":"2","throughput":"2"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, r32, imm8","latency":"2","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, r32, imm8","latency":"2","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, r32, imm8","latency":"","throughput":"1"},{"base":"06_0F","parameters":"xmm, r32, imm8","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, r32, imm8","latency":"2","throughput":"2"},{"base":"06_0D","parameters":"xmm, r32, imm8","latency":"2","throughput":"2"},{"base":"0F_03","parameters":"xmm, r32, imm8","latency":"4","throughput":"2"},{"base":"0F_02","parameters":"xmm, r32, imm8","latency":"4","throughput":"2"},{"base":"06_17","parameters":"mm, r32, imm8","latency":"0","throughput":"1"},{"base":"06_0F","parameters":"mm, r32, imm8","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, r32, imm8","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, r32, imm8","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, r32, imm8","latency":"4","throughput":"1"},{"base":"0F_02","parameters":"mm, r32, imm8","latency":"4","throughput":"1"}]},{"name":"_mm_movemask_epi8","tech":"SSE2","returnType":"int","cpuId":"SSE2","category":"Miscellaneous","description":"Create mask from the most significant bit of each 8-bit element in \"a\", and store the result in \"dst\".","code":"FOR j := 0 to 15\n\ti := j*8\n\tdst[j] := a[i+7]\nENDFOR\ndst[MAX:16] := 0","header":"emmintrin.h","instruction":"pmovmskb","parameters":[{"type":"__m128i","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"r32, xmm","latency":"2","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"r32, xmm","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"r32, xmm","latency":"","throughput":"1"},{"base":"06_0F","parameters":"r32, xmm","latency":"","throughput":"1"},{"base":"06_0E","parameters":"r32, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"r32, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"r32, xmm","latency":"7","throughput":"2"},{"base":"0F_02","parameters":"r32, xmm","latency":"7","throughput":"2"},{"base":"06_17","parameters":"r32, mm","latency":"","throughput":"1"},{"base":"06_0F","parameters":"r32, mm","latency":"","throughput":"1"},{"base":"06_0E","parameters":"r32, mm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"r32, mm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"r32, mm","latency":"7","throughput":"2"},{"base":"0F_02","parameters":"r32, mm","latency":"7","throughput":"2"}]},{"name":"_mm_shuffle_epi32","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Swizzle","description":"Shuffle 32-bit integers in \"a\" using the control in \"imm\", and store the results in \"dst\".","code":"SELECT4(src, control){\n\tCASE(control[1:0])\n\t\t0:\ttmp[31:0] := src[31:0]\n\t\t1:\ttmp[31:0] := src[63:32]\n\t\t2:\ttmp[31:0] := src[95:64]\n\t\t3:\ttmp[31:0] := src[127:96]\n\tESAC\n\tRETURN tmp[31:0]\n}\n\ndst[31:0] := SELECT4(a[127:0], imm[1:0])\ndst[63:32] := SELECT4(a[127:0], imm[3:2])\ndst[95:64] := SELECT4(a[127:0], imm[5:4])\ndst[127:96] := SELECT4(a[127:0], imm[7:6])","header":"emmintrin.h","instruction":"pshufd","parameters":[{"type":"__m128i","name":"a"},{"type":"int","name":"imm"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm, imm8","latency":"1","throughput":"1"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm, imm8","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm, imm8","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm, imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm, imm8","latency":"2","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm, imm8","latency":"2","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm, imm8","latency":"2","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm, imm8","latency":"4","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm, imm8","latency":"4","throughput":"2"}]},{"name":"_mm_shufflehi_epi16","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Swizzle","description":"Shuffle 16-bit integers in the high 64 bits of \"a\" using the control in \"imm\". Store the results in the high 64 bits of \"dst\", with the low 64 bits being copied from from \"a\" to \"dst\".","code":"dst[63:0] := a[63:0]\ndst[79:64] := (a >> (imm[1:0] * 16))[79:64]\ndst[95:80] := (a >> (imm[3:2] * 16))[79:64]\ndst[111:96] := (a >> (imm[5:4] * 16))[79:64]\ndst[127:112] := (a >> (imm[7:6] * 16))[79:64]","header":"emmintrin.h","instruction":"pshufhw","parameters":[{"type":"__m128i","name":"a"},{"type":"int","name":"imm"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm, imm8","latency":"1","throughput":"1"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm, imm8","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm, imm8","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm, imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm, imm8","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm, imm8","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm, imm8","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm, imm8","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm, imm8","latency":"2","throughput":"2"}]},{"name":"_mm_shufflelo_epi16","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Swizzle","description":"Shuffle 16-bit integers in the low 64 bits of \"a\" using the control in \"imm\". Store the results in the low 64 bits of \"dst\", with the high 64 bits being copied from from \"a\" to \"dst\".","code":"dst[15:0] := (a >> (imm[1:0] * 16))[15:0]\ndst[31:16] := (a >> (imm[3:2] * 16))[15:0]\ndst[47:32] := (a >> (imm[5:4] * 16))[15:0]\ndst[63:48] := (a >> (imm[7:6] * 16))[15:0]\ndst[127:64] := a[127:64]","header":"emmintrin.h","instruction":"pshuflw","parameters":[{"type":"__m128i","name":"a"},{"type":"int","name":"imm"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm, imm8","latency":"1","throughput":"1"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm, imm8","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm, imm8","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm, imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm, imm8","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm, imm8","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm, imm8","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm, imm8","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm, imm8","latency":"2","throughput":"2"}]},{"name":"_mm_unpackhi_epi8","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Swizzle","description":"Unpack and interleave 8-bit integers from the high half of \"a\" and \"b\", and store the results in \"dst\".","code":"INTERLEAVE_HIGH_BYTES(src1[127:0], src2[127:0]){\n\tdst[7:0] := src1[71:64] \n\tdst[15:8] := src2[71:64] \n\tdst[23:16] := src1[79:72] \n\tdst[31:24] := src2[79:72] \n\tdst[39:32] := src1[87:80] \n\tdst[47:40] := src2[87:80] \n\tdst[55:48] := src1[95:88] \n\tdst[63:56] := src2[95:88] \n\tdst[71:64] := src1[103:96] \n\tdst[79:72] := src2[103:96] \n\tdst[87:80] := src1[111:104] \n\tdst[95:88] := src2[111:104] \n\tdst[103:96] := src1[119:112] \n\tdst[111:104] := src2[119:112] \n\tdst[119:112] := src1[127:120] \n\tdst[127:120] := src2[127:120] \n\tRETURN dst[127:0]\n}\t\n\t\ndst[127:0] := INTERLEAVE_HIGH_BYTES(a[127:0], b[127:0])","header":"emmintrin.h","instruction":"punpckhbw","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_0E","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_unpackhi_epi16","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Swizzle","description":"Unpack and interleave 16-bit integers from the high half of \"a\" and \"b\", and store the results in \"dst\".","code":"INTERLEAVE_HIGH_WORDS(src1[127:0], src2[127:0]){\n\tdst[15:0] := src1[79:64]\n\tdst[31:16] := src2[79:64] \n\tdst[47:32] := src1[95:80] \n\tdst[63:48] := src2[95:80] \n\tdst[79:64] := src1[111:96] \n\tdst[95:80] := src2[111:96] \n\tdst[111:96] := src1[127:112] \n\tdst[127:112] := src2[127:112] \n\tRETURN dst[127:0]\n}\n\ndst[127:0] := INTERLEAVE_HIGH_WORDS(a[127:0], b[127:0])","header":"emmintrin.h","instruction":"punpckhwd","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_0E","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_unpackhi_epi32","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Swizzle","description":"Unpack and interleave 32-bit integers from the high half of \"a\" and \"b\", and store the results in \"dst\".","code":"INTERLEAVE_HIGH_DWORDS(src1[127:0], src2[127:0]){\n\tdst[31:0] := src1[95:64] \n\tdst[63:32] := src2[95:64] \n\tdst[95:64] := src1[127:96] \n\tdst[127:96] := src2[127:96] \n\tRETURN dst[127:0]\n}\t\n\t\ndst[127:0] := INTERLEAVE_HIGH_DWORDS(a[127:0], b[127:0])","header":"emmintrin.h","instruction":"punpckhdq","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_0E","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_unpackhi_epi64","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Swizzle","description":"Unpack and interleave 64-bit integers from the high half of \"a\" and \"b\", and store the results in \"dst\".","code":"INTERLEAVE_HIGH_QWORDS(src1[127:0], src2[127:0]){\n\tdst[63:0] := src1[127:64] \n\tdst[127:64] := src2[127:64] \n\tRETURN dst[127:0]\n}\t\n\t\ndst[127:0] := INTERLEAVE_HIGH_QWORDS(a[127:0], b[127:0])","header":"emmintrin.h","instruction":"punpckhqdq","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"}]},{"name":"_mm_unpacklo_epi8","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Swizzle","description":"Unpack and interleave 8-bit integers from the low half of \"a\" and \"b\", and store the results in \"dst\".","code":"INTERLEAVE_BYTES(src1[127:0], src2[127:0]){\n\tdst[7:0] := src1[7:0] \n\tdst[15:8] := src2[7:0] \n\tdst[23:16] := src1[15:8] \n\tdst[31:24] := src2[15:8] \n\tdst[39:32] := src1[23:16] \n\tdst[47:40] := src2[23:16] \n\tdst[55:48] := src1[31:24] \n\tdst[63:56] := src2[31:24] \n\tdst[71:64] := src1[39:32]\n\tdst[79:72] := src2[39:32] \n\tdst[87:80] := src1[47:40] \n\tdst[95:88] := src2[47:40] \n\tdst[103:96] := src1[55:48] \n\tdst[111:104] := src2[55:48] \n\tdst[119:112] := src1[63:56] \n\tdst[127:120] := src2[63:56] \n\tRETURN dst[127:0]\n}\t\n\ndst[127:0] := INTERLEAVE_BYTES(a[127:0], b[127:0])","header":"emmintrin.h","instruction":"punpcklbw","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_0E","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_unpacklo_epi16","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Swizzle","description":"Unpack and interleave 16-bit integers from the low half of \"a\" and \"b\", and store the results in \"dst\".","code":"INTERLEAVE_WORDS(src1[127:0], src2[127:0]){\n\tdst[15:0] := src1[15:0] \n\tdst[31:16] := src2[15:0] \n\tdst[47:32] := src1[31:16] \n\tdst[63:48] := src2[31:16] \n\tdst[79:64] := src1[47:32] \n\tdst[95:80] := src2[47:32] \n\tdst[111:96] := src1[63:48] \n\tdst[127:112] := src2[63:48] \n\tRETURN dst[127:0]\n}\t\n\ndst[127:0] := INTERLEAVE_WORDS(a[127:0], b[127:0])","header":"emmintrin.h","instruction":"punpcklwd","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_0E","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_unpacklo_epi32","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Swizzle","description":"Unpack and interleave 32-bit integers from the low half of \"a\" and \"b\", and store the results in \"dst\".","code":"INTERLEAVE_DWORDS(src1[127:0], src2[127:0]){\n\tdst[31:0] := src1[31:0] \n\tdst[63:32] := src2[31:0] \n\tdst[95:64] := src1[63:32] \n\tdst[127:96] := src2[63:32] \n\tRETURN dst[127:0]\n}\t\n\ndst[127:0] := INTERLEAVE_DWORDS(a[127:0], b[127:0])","header":"emmintrin.h","instruction":"punpckldq","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_0E","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"mm, mm","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"2","throughput":"1"}]},{"name":"_mm_unpacklo_epi64","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Swizzle","description":"Unpack and interleave 64-bit integers from the low half of \"a\" and \"b\", and store the results in \"dst\".","code":"INTERLEAVE_QWORDS(src1[127:0], src2[127:0]){\n\tdst[63:0] := src1[63:0] \n\tdst[127:64] := src2[63:0] \n\tRETURN dst[127:0]\n}\n\ndst[127:0] := INTERLEAVE_QWORDS(a[127:0], b[127:0])","header":"emmintrin.h","instruction":"punpcklqdq","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"4","throughput":"1"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"1"}]},{"name":"_mm_add_sd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Arithmetic","description":"Add the lower double-precision (64-bit) floating-point element in \"a\" and \"b\", store the result in the lower element of \"dst\", and copy the upper element from \"a\" to the upper element of \"dst\".","code":"dst[63:0] := a[63:0] + b[63:0]\ndst[127:64] := a[127:64]","header":"emmintrin.h","instruction":"addsd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"0.8"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"}]},{"name":"_mm_add_pd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Arithmetic","description":"Add packed double-precision (64-bit) floating-point elements in \"a\" and \"b\", and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := a[i+63:i] + b[i+63:i]\nENDFOR","header":"emmintrin.h","instruction":"addpd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"0.8"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"}]},{"name":"_mm_div_sd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Arithmetic","description":">Divide the lower double-precision (64-bit) floating-point element in \"a\" by the lower double-precision (64-bit) floating-point element in \"b\", store the result in the lower element of \"dst\", and copy the upper element from \"a\" to the upper element of \"dst\".","code":"dst[63:0] := a[63:0] 0 b[63:0]\ndst[127:64] := a[127:64]","header":"emmintrin.h","instruction":"divsd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"14-18","throughput":"12"},{"base":"06_3A/3E","parameters":"xmm, xmm","latency":"15-20","throughput":"14"},{"base":"06_2A/2D","parameters":"xmm, xmm","latency":"16-22","throughput":"22"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"<24","throughput":"<20"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"<32","throughput":"<26"},{"base":"06_0F","parameters":"xmm, xmm","latency":"<35","throughput":"<30"},{"base":"06_0E","parameters":"xmm, xmm","latency":"32","throughput":"31"},{"base":"06_0D","parameters":"xmm, xmm","latency":"32","throughput":"31"},{"base":"0F_03","parameters":"xmm, xmm","latency":"39","throughput":"39"},{"base":"0F_02","parameters":"xmm, xmm","latency":"38","throughput":"38"}]},{"name":"_mm_div_pd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Arithmetic","description":"Divide packed double-precision (64-bit) floating-point elements in \"a\" by packed elements in \"b\", and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := 64*j\n\tdst[i+63:i] := a[i+63:i] / b[i+63:i]\nENDFOR","header":"emmintrin.h","instruction":"divpd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"14-18","throughput":"12"},{"base":"06_3A/3E","parameters":"xmm, xmm","latency":"15-20","throughput":"14"},{"base":"06_2A/2D","parameters":"xmm, xmm","latency":"16-22","throughput":"22"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"<24","throughput":"<20"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"<32","throughput":"<26"},{"base":"06_0F","parameters":"xmm, xmm","latency":"<35","throughput":"<30"},{"base":"06_0E","parameters":"xmm, xmm","latency":"63","throughput":"62"},{"base":"06_0D","parameters":"xmm, xmm","latency":"63","throughput":"62"},{"base":"0F_03","parameters":"xmm, xmm","latency":"70","throughput":"70"},{"base":"0F_02","parameters":"xmm, xmm","latency":"69","throughput":"69"}]},{"name":"_mm_max_sd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Special Math Functions","description":"Compare the lower double-precision (64-bit) floating-point elements in \"a\" and \"b\", store the maximum value in the lower element of \"dst\", and copy the upper element from \"a\" to the upper element of \"dst\".","code":"dst[63:0] := MAX(a[63:0], b[63:0])\ndst[127:64] := a[127:64]","header":"emmintrin.h","instruction":"maxsd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"0.8"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"}]},{"name":"_mm_max_pd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Special Math Functions","description":"Compare packed double-precision (64-bit) floating-point elements in \"a\" and \"b\", and store packed maximum values in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := MAX(a[i+63:i], b[i+63:i])\nENDFOR","header":"emmintrin.h","instruction":"maxpd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"0.8"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"}]},{"name":"_mm_min_sd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Special Math Functions","description":"Compare the lower double-precision (64-bit) floating-point elements in \"a\" and \"b\", store the minimum value in the lower element of \"dst\", and copy the upper element from \"a\" to the upper element of \"dst\".","code":"dst[63:0] := MIN(a[63:0], b[63:0])\ndst[127:64] := a[127:64]","header":"emmintrin.h","instruction":"minsd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"0.8"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"}]},{"name":"_mm_min_pd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Special Math Functions","description":"Compare packed double-precision (64-bit) floating-point elements in \"a\" and \"b\", and store packed minimum values in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := MIN(a[i+63:i], b[i+63:i])\nENDFOR","header":"emmintrin.h","instruction":"minpd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"0.8"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"}]},{"name":"_mm_mul_sd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Arithmetic","description":"Multiply the lower double-precision (64-bit) floating-point element in \"a\" and \"b\", store the result in the lower element of \"dst\", and copy the upper element from \"a\" to the upper element of \"dst\".","code":"dst[63:0] := a[63:0] * b[63:0]\ndst[127:64] := a[127:64]","header":"emmintrin.h","instruction":"mulsd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"5","throughput":"0.5"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"5","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"5","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"5","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"5","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"5","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"5","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"7","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"6","throughput":"2"}]},{"name":"_mm_mul_pd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Arithmetic","description":"Multiply packed double-precision (64-bit) floating-point elements in \"a\" and \"b\", and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := a[i+63:i] * b[i+63:i]\nENDFOR","header":"emmintrin.h","instruction":"mulpd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"5","throughput":"0.5"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"5","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"5","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"5","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"5","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"7","throughput":"4"},{"base":"06_0D","parameters":"xmm, xmm","latency":"7","throughput":"4"},{"base":"0F_03","parameters":"xmm, xmm","latency":"7","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"6","throughput":"2"}]},{"name":"_mm_sqrt_sd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Elementary Math Functions","description":"Compute the square root of the lower double-precision (64-bit) floating-point element in \"a\", store the result in the lower element of \"dst\", and copy the upper element from \"b\" to the upper element of \"dst\".","code":"dst[63:0] := SQRT(a[63:0])\ndst[127:64] := b[127:64]","header":"emmintrin.h","instruction":"sqrtsd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"22","throughput":"13"},{"base":"06_3A/3E","parameters":"xmm, xmm","latency":"25","throughput":"14"},{"base":"06_2A/2D","parameters":"xmm, xmm","latency":"29","throughput":"22"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"<34","throughput":"<30"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"<31","throughput":"<25"},{"base":"06_0F","parameters":"xmm, xmm","latency":"<60","throughput":"<57"},{"base":"06_0E","parameters":"xmm, xmm","latency":"58","throughput":"57"},{"base":"06_0D","parameters":"xmm, xmm","latency":"58","throughput":"57"},{"base":"0F_03","parameters":"xmm, xmm","latency":"39","throughput":"39"},{"base":"0F_02","parameters":"xmm, xmm","latency":"38","throughput":"38"}]},{"name":"_mm_sqrt_pd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Elementary Math Functions","description":"Compute the square root of packed double-precision (64-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := SQRT(a[i+63:i])\nENDFOR","header":"emmintrin.h","instruction":"sqrtpd","parameters":[{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"22","throughput":"13"},{"base":"06_3A/3E","parameters":"xmm, xmm","latency":"25","throughput":"14"},{"base":"06_2A/2D","parameters":"xmm, xmm","latency":"29","throughput":"22"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"<34","throughput":"<30"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"<31","throughput":"<25"},{"base":"06_0F","parameters":"xmm, xmm","latency":"<60","throughput":"<57"},{"base":"06_0E","parameters":"xmm, xmm","latency":"115","throughput":"114"},{"base":"06_0D","parameters":"xmm, xmm","latency":"115","throughput":"114"},{"base":"0F_03","parameters":"xmm, xmm","latency":"70","throughput":"70"},{"base":"0F_02","parameters":"xmm, xmm","latency":"69","throughput":"69"}]},{"name":"_mm_sub_sd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Arithmetic","description":"Subtract the lower double-precision (64-bit) floating-point element in \"b\" from the lower double-precision (64-bit) floating-point element in \"a\", store the result in the lower element of \"dst\", and copy the upper element from \"a\" to the upper element of \"dst\".","code":"dst[63:0] := a[63:0] - b[63:0]\ndst[127:64] := a[127:64]","header":"emmintrin.h","instruction":"subsd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"}]},{"name":"_mm_sub_pd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Arithmetic","description":"Subtract packed double-precision (64-bit) floating-point elements in \"b\" from packed double-precision (64-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := a[i+63:i] - b[i+63:i]\nENDFOR","header":"emmintrin.h","instruction":"subpd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"}]},{"name":"_mm_and_pd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Logical","description":"Compute the bitwise AND of packed double-precision (64-bit) floating-point elements in \"a\" and \"b\", and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := (a[i+63:i] AND b[i+63:i])\nENDFOR","header":"emmintrin.h","instruction":"andpd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.8"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"}]},{"name":"_mm_andnot_pd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Logical","description":"Compute the bitwise AND NOT of packed double-precision (64-bit) floating-point elements in \"a\" and \"b\", and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := ((NOT a[i+63:i]) AND b[i+63:i])\nENDFOR","header":"emmintrin.h","instruction":"andnpd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.8"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"}]},{"name":"_mm_or_pd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Logical","description":"Compute the bitwise OR of packed double-precision (64-bit) floating-point elements in \"a\" and \"b\", and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := a[i+63:i] BITWISE OR b[i+63:i]\nENDFOR","header":"emmintrin.h","instruction":"orpd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.8"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"}]},{"name":"_mm_xor_pd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Logical","description":"Compute the bitwise XOR of packed double-precision (64-bit) floating-point elements in \"a\" and \"b\", and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := a[i+63:i] XOR b[i+63:i]\nENDFOR","header":"emmintrin.h","instruction":"xorpd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.8"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"}]},{"name":"_mm_cmpeq_sd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Compare","description":"Compare the lower double-precision (64-bit) floating-point elements in \"a\" and \"b\" for equality, store the result in the lower element of \"dst\", and copy the upper element from \"a\" to the upper element of \"dst\".","code":"dst[63:0] := (a[63:0] == b[63:0]) ? 0xFFFFFFFFFFFFFFFF : 0\ndst[127:64] := a[127:64]","header":"emmintrin.h","instruction":"cmpsd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"0.8"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm, imm8","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm, imm8","latency":"4","throughput":"2"}]},{"name":"_mm_cmplt_sd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Compare","description":"Compare the lower double-precision (64-bit) floating-point elements in \"a\" and \"b\" for less-than, store the result in the lower element of \"dst\", and copy the upper element from \"a\" to the upper element of \"dst\".","code":"dst[63:0] := (a[63:0] < b[63:0]) ? 0xFFFFFFFFFFFFFFFF : 0\ndst[127:64] := a[127:64]","header":"emmintrin.h","instruction":"cmpsd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"0.8"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm, imm8","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm, imm8","latency":"4","throughput":"2"}]},{"name":"_mm_cmple_sd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Compare","description":"Compare the lower double-precision (64-bit) floating-point elements in \"a\" and \"b\" for less-than-or-equal, store the result in the lower element of \"dst\", and copy the upper element from \"a\" to the upper element of \"dst\".","code":"dst[63:0] := (a[63:0] <= b[63:0]) ? 0xFFFFFFFFFFFFFFFF : 0\ndst[127:64] := a[127:64]","header":"emmintrin.h","instruction":"cmpsd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"0.8"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm, imm8","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm, imm8","latency":"4","throughput":"2"}]},{"name":"_mm_cmpgt_sd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Compare","description":"Compare the lower double-precision (64-bit) floating-point elements in \"a\" and \"b\" for greater-than, store the result in the lower element of \"dst\", and copy the upper element from \"a\" to the upper element of \"dst\".","code":"dst[63:0] := (a[63:0] > b[63:0]) ? 0xFFFFFFFFFFFFFFFF : 0\ndst[127:64] := a[127:64]","header":"emmintrin.h","instruction":"cmpsd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"0.8"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm, imm8","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm, imm8","latency":"4","throughput":"2"}]},{"name":"_mm_cmpge_sd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Compare","description":"Compare the lower double-precision (64-bit) floating-point elements in \"a\" and \"b\" for greater-than-or-equal, store the result in the lower element of \"dst\", and copy the upper element from \"a\" to the upper element of \"dst\".","code":"dst[63:0] := (a[63:0] >= b[63:0]) ? 0xFFFFFFFFFFFFFFFF : 0\ndst[127:64] := a[127:64]","header":"emmintrin.h","instruction":"cmpsd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"0.8"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm, imm8","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm, imm8","latency":"4","throughput":"2"}]},{"name":"_mm_cmpord_sd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Compare","description":"Compare the lower double-precision (64-bit) floating-point elements in \"a\" and \"b\" to see if neither is NaN, store the result in the lower element of \"dst\", and copy the upper element from \"a\" to the upper element of \"dst\".","code":"dst[63:0] := (a[63:0] != NaN AND b[63:0] != NaN) ? 0xFFFFFFFFFFFFFFFF : 0\ndst[127:64] := a[127:64]","header":"emmintrin.h","instruction":"cmpsd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"0.8"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm, imm8","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm, imm8","latency":"4","throughput":"2"}]},{"name":"_mm_cmpunord_sd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Compare","description":"Compare the lower double-precision (64-bit) floating-point elements in \"a\" and \"b\" to see if either is NaN, store the result in the lower element of \"dst\", and copy the upper element from \"a\" to the upper element of \"dst\".","code":"dst[63:0] := (a[63:0] != NaN OR b[63:0] != NaN) ? 0xFFFFFFFFFFFFFFFF : 0\ndst[127:64] := a[127:64]","header":"emmintrin.h","instruction":"cmpsd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"0.8"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm, imm8","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm, imm8","latency":"4","throughput":"2"}]},{"name":"_mm_cmpneq_sd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Compare","description":"Compare the lower double-precision (64-bit) floating-point elements in \"a\" and \"b\" for not-equal, store the result in the lower element of \"dst\", and copy the upper element from \"a\" to the upper element of \"dst\".","code":"dst[63:0] := (a[63:0] != b[63:0]) ? 0xFFFFFFFFFFFFFFFF : 0\ndst[127:64] := a[127:64]","header":"emmintrin.h","instruction":"cmpsd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"0.8"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm, imm8","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm, imm8","latency":"4","throughput":"2"}]},{"name":"_mm_cmpnlt_sd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Compare","description":"Compare the lower double-precision (64-bit) floating-point elements in \"a\" and \"b\" for not-less-than, store the result in the lower element of \"dst\", and copy the upper element from \"a\" to the upper element of \"dst\".","code":"dst[63:0] := !(a[63:0] < b[63:0]) ? 0xFFFFFFFFFFFFFFFF : 0\ndst[127:64] := a[127:64]","header":"emmintrin.h","instruction":"cmpsd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"0.8"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm, imm8","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm, imm8","latency":"4","throughput":"2"}]},{"name":"_mm_cmpnle_sd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Compare","description":"Compare the lower double-precision (64-bit) floating-point elements in \"a\" and \"b\" for not-less-than-or-equal, store the result in the lower element of \"dst\", and copy the upper element from \"a\" to the upper element of \"dst\".","code":"dst[63:0] := !(a[63:0] <= b[63:0]) ? 0xFFFFFFFFFFFFFFFF : 0\ndst[127:64] := a[127:64]","header":"emmintrin.h","instruction":"cmpsd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"0.8"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm, imm8","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm, imm8","latency":"4","throughput":"2"}]},{"name":"_mm_cmpngt_sd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Compare","description":"Compare the lower double-precision (64-bit) floating-point elements in \"a\" and \"b\" for not-greater-than, store the result in the lower element of \"dst\", and copy the upper element from \"a\" to the upper element of \"dst\".","code":"dst[63:0] := !(a[63:0] > b[63:0]) ? 0xFFFFFFFFFFFFFFFF : 0\ndst[127:64] := a[127:64]","header":"emmintrin.h","instruction":"cmpsd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"0.8"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm, imm8","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm, imm8","latency":"4","throughput":"2"}]},{"name":"_mm_cmpnge_sd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Compare","description":"Compare the lower double-precision (64-bit) floating-point elements in \"a\" and \"b\" for not-greater-than-or-equal, store the result in the lower element of \"dst\", and copy the upper element from \"a\" to the upper element of \"dst\".","code":"dst[63:0] := !(a[63:0] >= b[63:0]) ? 0xFFFFFFFFFFFFFFFF : 0\ndst[127:64] := a[127:64]","header":"emmintrin.h","instruction":"cmpsd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"0.8"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm, imm8","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm, imm8","latency":"4","throughput":"2"}]},{"name":"_mm_cmpeq_pd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Compare","description":"Compare packed double-precision (64-bit) floating-point elements in \"a\" and \"b\" for equality, and store the results in \"dst\".","code":"FOR j := 0 to 1\n  i := j*64\n  dst[i+63:i] := (a[i+63:i] == b[i+63:i]) ? 0xFFFFFFFFFFFFFFFF : 0\nENDFOR","header":"emmintrin.h","instruction":"cmppd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"0.8"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm, imm8","latency":"4","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm, imm8","latency":"4","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm, imm8","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm, imm8","latency":"4","throughput":"2"}]},{"name":"_mm_cmplt_pd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Compare","description":"Compare packed double-precision (64-bit) floating-point elements in \"a\" and \"b\" for less-than, and store the results in \"dst\".","code":"FOR j := 0 to 1\n  i := j*64\n  dst[i+63:i] := (a[i+63:i] < b[i+63:i]) ? 0xFFFFFFFFFFFFFFFF : 0\nENDFOR","header":"emmintrin.h","instruction":"cmppd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"0.8"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm, imm8","latency":"4","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm, imm8","latency":"4","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm, imm8","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm, imm8","latency":"4","throughput":"2"}]},{"name":"_mm_cmple_pd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Compare","description":"Compare packed double-precision (64-bit) floating-point elements in \"a\" and \"b\" for less-than-or-equal, and store the results in \"dst\".","code":"FOR j := 0 to 1\n  i := j*64\n  dst[i+63:i] := (a[i+63:i] <= b[i+63:i]) ? 0xFFFFFFFFFFFFFFFF : 0\nENDFOR","header":"emmintrin.h","instruction":"cmppd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"0.8"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm, imm8","latency":"4","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm, imm8","latency":"4","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm, imm8","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm, imm8","latency":"4","throughput":"2"}]},{"name":"_mm_cmpgt_pd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Compare","description":"Compare packed double-precision (64-bit) floating-point elements in \"a\" and \"b\" for greater-than, and store the results in \"dst\".","code":"FOR j := 0 to 1\n  i := j*64\n  dst[i+63:i] := (a[i+63:i] > b[i+63:i]) ? 0xFFFFFFFFFFFFFFFF : 0\nENDFOR","header":"emmintrin.h","instruction":"cmppd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"0.8"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm, imm8","latency":"4","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm, imm8","latency":"4","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm, imm8","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm, imm8","latency":"4","throughput":"2"}]},{"name":"_mm_cmpge_pd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Compare","description":"Compare packed double-precision (64-bit) floating-point elements in \"a\" and \"b\" for greater-than-or-equal, and store the results in \"dst\".","code":"FOR j := 0 to 1\n  i := j*64\n  dst[i+63:i] := (a[i+63:i] >= b[i+63:i]) ? 0xFFFFFFFFFFFFFFFF : 0\nENDFOR","header":"emmintrin.h","instruction":"cmppd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"0.8"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm, imm8","latency":"4","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm, imm8","latency":"4","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm, imm8","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm, imm8","latency":"4","throughput":"2"}]},{"name":"_mm_cmpord_pd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Compare","description":"Compare packed double-precision (64-bit) floating-point elements in \"a\" and \"b\" to see if neither is NaN, and store the results in \"dst\".","code":"FOR j := 0 to 1\n  i := j*64\n  dst[i+63:i] := (a[i+63:i] != NaN AND b[i+63:i] != NaN) ? 0xFFFFFFFFFFFFFFFF : 0\nENDFOR","header":"emmintrin.h","instruction":"cmppd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"0.8"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm, imm8","latency":"4","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm, imm8","latency":"4","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm, imm8","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm, imm8","latency":"4","throughput":"2"}]},{"name":"_mm_cmpunord_pd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Compare","description":"Compare packed double-precision (64-bit) floating-point elements in \"a\" and \"b\" to see if either is NaN, and store the results in \"dst\".","code":"FOR j := 0 to 1\n  i := j*64\n  dst[i+63:i] := (a[i+63:i] != NaN OR b[i+63:i] != NaN) ? 0xFFFFFFFFFFFFFFFF : 0\nENDFOR","header":"emmintrin.h","instruction":"cmppd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"0.8"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm, imm8","latency":"4","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm, imm8","latency":"4","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm, imm8","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm, imm8","latency":"4","throughput":"2"}]},{"name":"_mm_cmpneq_pd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Compare","description":"Compare packed double-precision (64-bit) floating-point elements in \"a\" and \"b\" for not-equal, and store the results in \"dst\".","code":"FOR j := 0 to 1\n  i := j*64\n  dst[i+63:i] := (a[i+63:i] != b[i+63:i]) ? 0xFFFFFFFFFFFFFFFF : 0\nENDFOR","header":"emmintrin.h","instruction":"cmppd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"0.8"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm, imm8","latency":"4","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm, imm8","latency":"4","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm, imm8","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm, imm8","latency":"4","throughput":"2"}]},{"name":"_mm_cmpnlt_pd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Compare","description":"Compare packed double-precision (64-bit) floating-point elements in \"a\" and \"b\" for not-less-than, and store the results in \"dst\".","code":"FOR j := 0 to 1\n  i := j*64\n  dst[i+63:i] := !(a[i+63:i] < b[i+63:i]) ? 0xFFFFFFFFFFFFFFFF : 0\nENDFOR","header":"emmintrin.h","instruction":"cmppd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"0.8"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm, imm8","latency":"4","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm, imm8","latency":"4","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm, imm8","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm, imm8","latency":"4","throughput":"2"}]},{"name":"_mm_cmpnle_pd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Compare","description":"Compare packed double-precision (64-bit) floating-point elements in \"a\" and \"b\" for not-less-than-or-equal, and store the results in \"dst\".","code":"FOR j := 0 to 1\n  i := j*64\n  dst[i+63:i] := !(a[i+63:i] <= b[i+63:i]) ? 0xFFFFFFFFFFFFFFFF : 0\nENDFOR","header":"emmintrin.h","instruction":"cmppd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"0.8"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm, imm8","latency":"4","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm, imm8","latency":"4","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm, imm8","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm, imm8","latency":"4","throughput":"2"}]},{"name":"_mm_cmpngt_pd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Compare","description":"Compare packed double-precision (64-bit) floating-point elements in \"a\" and \"b\" for not-greater-than, and store the results in \"dst\".","code":"FOR j := 0 to 1\n  i := j*64\n  dst[i+63:i] := !(a[i+63:i] > b[i+63:i]) ? 0xFFFFFFFFFFFFFFFF : 0\nENDFOR","header":"emmintrin.h","instruction":"cmppd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"0.8"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm, imm8","latency":"4","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm, imm8","latency":"4","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm, imm8","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm, imm8","latency":"4","throughput":"2"}]},{"name":"_mm_cmpnge_pd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Compare","description":"Compare packed double-precision (64-bit) floating-point elements in \"a\" and \"b\" for not-greater-than-or-equal, and store the results in \"dst\".","code":"FOR j := 0 to 1\n  i := j*64\n  dst[i+63:i] := !(a[i+63:i] >= b[i+63:i]) ? 0xFFFFFFFFFFFFFFFF : 0\nENDFOR","header":"emmintrin.h","instruction":"cmppd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"0.8"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm, imm8","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm, imm8","latency":"4","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm, imm8","latency":"4","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm, imm8","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm, imm8","latency":"4","throughput":"2"}]},{"name":"_mm_comieq_sd","tech":"SSE2","returnType":"int","cpuId":"SSE2","category":"Compare","description":"Compare the lower double-precision (64-bit) floating-point element in \"a\" and \"b\" for equality, and return the boolean result (0 or 1).","code":"RETURN ( a[63:0] == b[63:0] ) ? 1 : 0","header":"emmintrin.h","instruction":"comisd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"0.8"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"2","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"7","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"6","throughput":"2"}]},{"name":"_mm_comilt_sd","tech":"SSE2","returnType":"int","cpuId":"SSE2","category":"Compare","description":"Compare the lower double-precision (64-bit) floating-point element in \"a\" and \"b\" for less-than, and return the boolean result (0 or 1).","code":"RETURN ( a[63:0] < b[63:0] ) ? 1 : 0","header":"emmintrin.h","instruction":"comisd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"0.8"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"2","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"7","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"6","throughput":"2"}]},{"name":"_mm_comile_sd","tech":"SSE2","returnType":"int","cpuId":"SSE2","category":"Compare","description":"Compare the lower double-precision (64-bit) floating-point element in \"a\" and \"b\" for less-than-or-equal, and return the boolean result (0 or 1).","code":"RETURN ( a[63:0] <= b[63:0] ) ? 1 : 0","header":"emmintrin.h","instruction":"comisd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"0.8"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"2","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"7","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"6","throughput":"2"}]},{"name":"_mm_comigt_sd","tech":"SSE2","returnType":"int","cpuId":"SSE2","category":"Compare","description":"Compare the lower double-precision (64-bit) floating-point element in \"a\" and \"b\" for greater-than, and return the boolean result (0 or 1).","code":"RETURN ( a[63:0] > b[63:0] ) ? 1 : 0","header":"emmintrin.h","instruction":"comisd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"0.8"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"2","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"7","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"6","throughput":"2"}]},{"name":"_mm_comige_sd","tech":"SSE2","returnType":"int","cpuId":"SSE2","category":"Compare","description":"Compare the lower double-precision (64-bit) floating-point element in \"a\" and \"b\" for greater-than-or-equal, and return the boolean result (0 or 1).","code":"RETURN ( a[63:0] >= b[63:0] ) ? 1 : 0","header":"emmintrin.h","instruction":"comisd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"0.8"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"2","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"7","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"6","throughput":"2"}]},{"name":"_mm_comineq_sd","tech":"SSE2","returnType":"int","cpuId":"SSE2","category":"Compare","description":"Compare the lower double-precision (64-bit) floating-point element in \"a\" and \"b\" for not-equal, and return the boolean result (0 or 1).","code":"RETURN ( a[63:0] != b[63:0] ) ? 1 : 0","header":"emmintrin.h","instruction":"comisd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"0.8"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"2","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"7","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"6","throughput":"2"}]},{"name":"_mm_ucomieq_sd","tech":"SSE2","returnType":"int","cpuId":"SSE2","category":"Compare","description":"Compare the lower double-precision (64-bit) floating-point element in \"a\" and \"b\" for equality, and return the boolean result (0 or 1). This instruction will not signal an exception for QNaNs.","code":"RETURN ( a[63:0] == b[63:0] ) ? 1 : 0","header":"emmintrin.h","instruction":"ucomisd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"2","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"7","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"6","throughput":"2"}]},{"name":"_mm_ucomilt_sd","tech":"SSE2","returnType":"int","cpuId":"SSE2","category":"Compare","description":"Compare the lower double-precision (64-bit) floating-point element in \"a\" and \"b\" for less-than, and return the boolean result (0 or 1). This instruction will not signal an exception for QNaNs.","code":"RETURN ( a[63:0] < b[63:0] ) ? 1 : 0","header":"emmintrin.h","instruction":"ucomisd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"2","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"7","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"6","throughput":"2"}]},{"name":"_mm_ucomile_sd","tech":"SSE2","returnType":"int","cpuId":"SSE2","category":"Compare","description":"Compare the lower double-precision (64-bit) floating-point element in \"a\" and \"b\" for less-than-or-equal, and return the boolean result (0 or 1). This instruction will not signal an exception for QNaNs.","code":"RETURN ( a[63:0] <= b[63:0] ) ? 1 : 0","header":"emmintrin.h","instruction":"ucomisd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"2","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"7","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"6","throughput":"2"}]},{"name":"_mm_ucomigt_sd","tech":"SSE2","returnType":"int","cpuId":"SSE2","category":"Compare","description":"Compare the lower double-precision (64-bit) floating-point element in \"a\" and \"b\" for greater-than, and return the boolean result (0 or 1). This instruction will not signal an exception for QNaNs.","code":"RETURN ( a[63:0] > b[63:0] ) ? 1 : 0","header":"emmintrin.h","instruction":"ucomisd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"2","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"7","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"6","throughput":"2"}]},{"name":"_mm_ucomige_sd","tech":"SSE2","returnType":"int","cpuId":"SSE2","category":"Compare","description":"Compare the lower double-precision (64-bit) floating-point element in \"a\" and \"b\" for greater-than-or-equal, and return the boolean result (0 or 1). This instruction will not signal an exception for QNaNs.","code":"RETURN ( a[63:0] >= b[63:0] ) ? 1 : 0","header":"emmintrin.h","instruction":"ucomisd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"2","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"7","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"6","throughput":"2"}]},{"name":"_mm_ucomineq_sd","tech":"SSE2","returnType":"int","cpuId":"SSE2","category":"Compare","description":"Compare the lower double-precision (64-bit) floating-point element in \"a\" and \"b\" for not-equal, and return the boolean result (0 or 1). This instruction will not signal an exception for QNaNs.","code":"RETURN ( a[63:0] != b[63:0] ) ? 1 : 0","header":"emmintrin.h","instruction":"ucomisd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"2","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"7","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"6","throughput":"2"}]},{"name":"_mm_cvtpd_ps","tech":"SSE2","returnType":"__m128","cpuId":"SSE2","category":"Convert","description":"Convert packed double-precision (64-bit) floating-point elements in \"a\" to packed single-precision (32-bit) floating-point elements, and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := 32*j\n\tk := 64*j\n\tdst[i+31:i] := Convert_FP64_To_FP32(a[k+63:k])\nENDFOR","header":"emmintrin.h","instruction":"cvtpd2ps","parameters":[{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"4","throughput":"0.8"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"4","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"4","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"4","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"4","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"5","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"3","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"11","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"10","throughput":"2"}]},{"name":"_mm_cvtps_pd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Convert","description":"Convert packed single-precision (32-bit) floating-point elements in \"a\" to packed double-precision (64-bit) floating-point elements, and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := 64*j\n\tk := 32*j\n\tdst[i+63:i] := Convert_FP32_To_FP64(a[k+31:k])\nENDFOR","header":"emmintrin.h","instruction":"cvtps2pd","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"2","throughput":"0.8"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"2","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"2","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_0F","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_0E","parameters":"xmm, xmm","latency":"3","throughput":"3"},{"base":"06_0D","parameters":"xmm, xmm","latency":"3","throughput":"3"},{"base":"0F_03","parameters":"xmm, xmm","latency":"3","throughput":""},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"}]},{"name":"_mm_cvtpd_epi32","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Convert","description":"Convert packed double-precision (64-bit) floating-point elements in \"a\" to packed 32-bit integers, and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := 32*j\n\tk := 64*j\n\tdst[i+31:i] := Convert_FP64_To_Int32(a[k+63:k])\nENDFOR","header":"emmintrin.h","instruction":"cvtpd2dq","parameters":[{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"4","throughput":"0.8"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"4","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"4","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"4","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"4","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"10","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"9","throughput":"2"}]},{"name":"_mm_cvtsd_si32","tech":"SSE2","returnType":"int","cpuId":"SSE2","category":"Convert","description":"Convert the lower double-precision (64-bit) floating-point element in \"a\" to a 32-bit integer, and store the result in \"dst\".","code":"dst[31:0] := Convert_FP64_To_Int32(a[63:0])","header":"emmintrin.h","instruction":"cvtsd2si","parameters":[{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"r32, xmm","latency":"5","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"r32, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"r32, xmm","latency":"","throughput":"1"},{"base":"06_0F","parameters":"r32, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"r32, xmm","latency":"4","throughput":"1"},{"base":"06_0D","parameters":"r32, xmm","latency":"4","throughput":"1"},{"base":"06_3C/45/46","parameters":"r64, xmm","latency":"5","throughput":"0.8"},{"base":"06_2A/2D/3A/3E","parameters":"r64, xmm","latency":"5","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"r64, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"r64, xmm","latency":"3","throughput":"1"},{"base":"0F_03","parameters":"r32, xmm","latency":"9","throughput":"2"},{"base":"0F_02","parameters":"r32, xmm","latency":"8","throughput":"2"}]},{"name":"_mm_cvtsd_si64","tech":"SSE2","returnType":"__int64","cpuId":"SSE2","category":"Convert","description":"Convert the lower double-precision (64-bit) floating-point element in \"a\" to a 64-bit integer, and store the result in \"dst\".","code":"dst[63:0] := Convert_FP64_To_Int64(a[63:0])","header":"emmintrin.h","instruction":"cvtsd2si","parameters":[{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"r32, xmm","latency":"5","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"r32, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"r32, xmm","latency":"","throughput":"1"},{"base":"06_0F","parameters":"r32, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"r32, xmm","latency":"4","throughput":"1"},{"base":"06_0D","parameters":"r32, xmm","latency":"4","throughput":"1"},{"base":"06_3C/45/46","parameters":"r64, xmm","latency":"5","throughput":"0.8"},{"base":"06_2A/2D/3A/3E","parameters":"r64, xmm","latency":"5","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"r64, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"r64, xmm","latency":"3","throughput":"1"},{"base":"0F_03","parameters":"r32, xmm","latency":"9","throughput":"2"},{"base":"0F_02","parameters":"r32, xmm","latency":"8","throughput":"2"}]},{"name":"_mm_cvtsd_si64x","tech":"SSE2","returnType":"__int64","cpuId":"SSE2","category":"Convert","description":"Convert the lower double-precision (64-bit) floating-point element in \"a\" to a 64-bit integer, and store the result in \"dst\".","code":"dst[63:0] := Convert_FP64_To_Int64(a[63:0])","header":"emmintrin.h","instruction":"cvtsd2si","parameters":[{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"r32, xmm","latency":"5","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"r32, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"r32, xmm","latency":"","throughput":"1"},{"base":"06_0F","parameters":"r32, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"r32, xmm","latency":"4","throughput":"1"},{"base":"06_0D","parameters":"r32, xmm","latency":"4","throughput":"1"},{"base":"06_3C/45/46","parameters":"r64, xmm","latency":"5","throughput":"0.8"},{"base":"06_2A/2D/3A/3E","parameters":"r64, xmm","latency":"5","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"r64, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"r64, xmm","latency":"3","throughput":"1"},{"base":"0F_03","parameters":"r32, xmm","latency":"9","throughput":"2"},{"base":"0F_02","parameters":"r32, xmm","latency":"8","throughput":"2"}]},{"name":"_mm_cvtsd_ss","tech":"SSE2","returnType":"__m128","cpuId":"SSE2","category":"Convert","description":"Convert the lower double-precision (64-bit) floating-point element in \"b\" to a single-precision (32-bit) floating-point element, store the result in the lower element of \"dst\", and copy the upper element from \"a\" to the upper element of \"dst\".","code":"dst[31:0] := Convert_FP64_To_FP32(b[63:0])\ndst[127:32] := a[127:31]\ndst[MAX:64] := 0","header":"emmintrin.h","instruction":"cvtsd2ss","parameters":[{"type":"__m128","name":"a"},{"type":"__m128d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"4","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"4","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"4","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"4","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"4","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"4","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"17","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"16","throughput":"4"}]},{"name":"_mm_cvtsd_f64","tech":"SSE2","returnType":"double","cpuId":"SSE2","category":"Convert","description":"Copy the lower double-precision (64-bit) floating-point element of \"a\" to \"dst\".","code":"dst[63:0] := a[63:0]","header":"emmintrin.h","instruction":"movsd","parameters":[{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.8"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"xmm, xmm","latency":"6","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"6","throughput":"2"}]},{"name":"_mm_cvtss_sd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Convert","description":"Convert the lower single-precision (32-bit) floating-point element in \"b\" to a double-precision (64-bit) floating-point element, store the result in the lower element of \"dst\", and copy the upper element from \"a\" to the upper element of \"dst\".","code":"dst[63:0] := Convert_FP32_To_FP64(b[31:0])\ndst[127:64] := a[127:64]\ndst[MAX:64] := 0","header":"emmintrin.h","instruction":"cvtss2sd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.8"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_0F","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_0E","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"9","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"8","throughput":"2"}]},{"name":"_mm_cvttpd_epi32","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Convert","description":"Convert packed double-precision (64-bit) floating-point elements in \"a\" to packed 32-bit integers with truncation, and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := 32*j\n\tk := 64*j\n\tdst[i+31:i] := Convert_FP64_To_Int32_Truncate(a[k+63:k])\nENDFOR","header":"emmintrin.h","instruction":"cvttpd2dq","parameters":[{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.8"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"4","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"4","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"4","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"4","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"10","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"9","throughput":"2"}]},{"name":"_mm_cvttsd_si32","tech":"SSE2","returnType":"int","cpuId":"SSE2","category":"Convert","description":"Convert the lower double-precision (64-bit) floating-point element in \"a\" to a 32-bit integer with truncation, and store the result in \"dst\".","code":"dst[31:0] := Convert_FP64_To_Int32_Truncate(a[63:0])","header":"emmintrin.h","instruction":"cvttsd2si","parameters":[{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E","parameters":"r32, xmm","latency":"5","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"r32, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"r32, xmm","latency":"","throughput":"1"},{"base":"06_0F","parameters":"r32, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"r32, xmm","latency":"4","throughput":"1"},{"base":"06_0D","parameters":"r32, xmm","latency":"4","throughput":"1"},{"base":"06_3C/45/46","parameters":"r64, xmm","latency":"5","throughput":"0.8"},{"base":"06_2A/2D/3A/3E","parameters":"r64, xmm","latency":"5","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"r64, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"r64, xmm","latency":"3","throughput":"1"},{"base":"0F_03","parameters":"r32, xmm","latency":"8","throughput":"2"},{"base":"0F_02","parameters":"r32, xmm","latency":"8","throughput":"2"}]},{"name":"_mm_cvttsd_si64","tech":"SSE2","returnType":"__int64","cpuId":"SSE2","category":"Convert","description":"Convert the lower double-precision (64-bit) floating-point element in \"a\" to a 64-bit integer with truncation, and store the result in \"dst\".","code":"dst[63:0] := Convert_FP64_To_Int64_Truncate(a[63:0])","header":"emmintrin.h","instruction":"cvttsd2si","parameters":[{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E","parameters":"r32, xmm","latency":"5","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"r32, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"r32, xmm","latency":"","throughput":"1"},{"base":"06_0F","parameters":"r32, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"r32, xmm","latency":"4","throughput":"1"},{"base":"06_0D","parameters":"r32, xmm","latency":"4","throughput":"1"},{"base":"06_3C/45/46","parameters":"r64, xmm","latency":"5","throughput":"0.8"},{"base":"06_2A/2D/3A/3E","parameters":"r64, xmm","latency":"5","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"r64, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"r64, xmm","latency":"3","throughput":"1"},{"base":"0F_03","parameters":"r32, xmm","latency":"8","throughput":"2"},{"base":"0F_02","parameters":"r32, xmm","latency":"8","throughput":"2"}]},{"name":"_mm_cvttsd_si64x","tech":"SSE2","returnType":"__int64","cpuId":"SSE2","category":"Convert","description":"Convert the lower double-precision (64-bit) floating-point element in \"a\" to a 64-bit integer with truncation, and store the result in \"dst\".","code":"dst[63:0] := Convert_FP64_To_Int64_Truncate(a[63:0])","header":"emmintrin.h","instruction":"cvttsd2si","parameters":[{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E","parameters":"r32, xmm","latency":"5","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"r32, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"r32, xmm","latency":"","throughput":"1"},{"base":"06_0F","parameters":"r32, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"r32, xmm","latency":"4","throughput":"1"},{"base":"06_0D","parameters":"r32, xmm","latency":"4","throughput":"1"},{"base":"06_3C/45/46","parameters":"r64, xmm","latency":"5","throughput":"0.8"},{"base":"06_2A/2D/3A/3E","parameters":"r64, xmm","latency":"5","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"r64, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"r64, xmm","latency":"3","throughput":"1"},{"base":"0F_03","parameters":"r32, xmm","latency":"8","throughput":"2"},{"base":"0F_02","parameters":"r32, xmm","latency":"8","throughput":"2"}]},{"name":"_mm_cvtps_epi32","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Convert","description":"Convert packed single-precision (32-bit) floating-point elements in \"a\" to packed 32-bit integers, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := 32*j\n\tdst[i+31:i] := Convert_FP32_To_Int32(a[i+31:i])\nENDFOR","header":"emmintrin.h","instruction":"cvtps2dq","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"0.8"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"5","throughput":"2"},{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"0.8"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"3","throughput":""},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":""},{"base":"06_0F","parameters":"xmm, xmm","latency":"3","throughput":"1"}]},{"name":"_mm_cvttps_epi32","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Convert","description":"Convert packed single-precision (32-bit) floating-point elements in \"a\" to packed 32-bit integers with truncation, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := 32*j\n\tdst[i+31:i] := Convert_FP32_To_Int32_Truncate(a[i+31:i])\nENDFOR","header":"emmintrin.h","instruction":"cvttps2dq","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"0.8"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm","latency":"5","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"5","throughput":"2"},{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"3","throughput":"0.8"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"3","throughput":""},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":""},{"base":"06_0F","parameters":"xmm, xmm","latency":"3","throughput":"1"}]},{"name":"_mm_cvtpd_pi32","tech":"SSE2","returnType":"__m64","cpuId":"SSE2","category":"Convert","description":"Convert packed double-precision (64-bit) floating-point elements in \"a\" to packed 32-bit integers, and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := 32*j\n\tk := 64*j\n\tdst[i+31:i] := Convert_FP64_To_Int32(a[k+63:k])\nENDFOR","header":"emmintrin.h","instruction":"cvtpd2pi","parameters":[{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"4","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"9","throughput":"1"},{"base":"06_17/1D","parameters":"mm, xmm 0","latency":"7","throughput":"1"},{"base":"06_0F","parameters":"mm, xmm 0","latency":"","throughput":"1"},{"base":"0F_03","parameters":"mm, xmm","latency":"12","throughput":"3"},{"base":"0F_02","parameters":"mm, xmm","latency":"11","throughput":"3"}]},{"name":"_mm_cvttpd_pi32","tech":"SSE2","returnType":"__m64","cpuId":"SSE2","category":"Convert","description":"Convert packed double-precision (64-bit) floating-point elements in \"a\" to packed 32-bit integers with truncation, and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := 32*j\n\tk := 64*j\n\tdst[i+31:i] := Convert_FP64_To_Int32_Truncate(a[k+63:k])\nENDFOR","header":"emmintrin.h","instruction":"cvttpd2pi","parameters":[{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"mm, xmm","latency":"4","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"mm, xmm","latency":"4","throughput":"1"},{"base":"06_0F","parameters":"mm, xmm","latency":"","throughput":"1"},{"base":"06_0E","parameters":"mm, xmm","latency":"5","throughput":""},{"base":"06_0D","parameters":"mm, xmm","latency":"5","throughput":""},{"base":"0F_03","parameters":"mm, xmm","latency":"12","throughput":"3"},{"base":"0F_02","parameters":"mm, xmm","latency":"11","throughput":"3"}]},{"name":"_mm_set_sd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Set","description":"Copy double-precision (64-bit) floating-point element \"a\" to the lower element of \"dst\", and zero the upper element.","code":"dst[63:0] := a[63:0]\ndst[127:64] := 0","header":"emmintrin.h","instruction":"movsd","parameters":[{"type":"double","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.8"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"xmm, xmm","latency":"6","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"6","throughput":"2"}]},{"name":"_mm_set1_pd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Set","description":"Broadcast double-precision (64-bit) floating-point value \"a\" to all elements of \"dst\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := a[63:0]\nENDFOR","header":"emmintrin.h","instruction":null,"parameters":[{"type":"double","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_set_pd1","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Set","description":"Broadcast double-precision (64-bit) floating-point value \"a\" to all elements of \"dst\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := a[63:0]\nENDFOR","header":"emmintrin.h","instruction":null,"parameters":[{"type":"double","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_set_pd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Set","description":"Set packed double-precision (64-bit) floating-point elements in \"dst\" with the supplied values.","code":"dst[63:0] := e0\ndst[127:64] := e1","header":"emmintrin.h","instruction":null,"parameters":[{"type":"double","name":"e1"},{"type":"double","name":"e0"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_setr_pd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Set","description":"Set packed double-precision (64-bit) floating-point elements in \"dst\" with the supplied values in reverse order.","code":"dst[63:0] := e1\ndst[127:64] := e0","header":"emmintrin.h","instruction":null,"parameters":[{"type":"double","name":"e1"},{"type":"double","name":"e0"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_setzero_pd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Set","description":"Return vector of type __m128d with all elements set to zero.","code":"dst[MAX:0] := 0","header":"emmintrin.h","instruction":"xorpd","parameters":[{"type":"void","name":""}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.8"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"}]},{"name":"_mm_load_pd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Load","description":"Load 128-bits (composed of 2 packed double-precision (64-bit) floating-point elements) from memory into \"dst\".\n\t\"mem_addr\" must be aligned on a 16-byte boundary or a general-protection exception will be generated.","code":"dst[127:0] := MEM[mem_addr+127:mem_addr]","header":"emmintrin.h","instruction":"movapd","parameters":[{"type":"double const*","name":"mem_addr"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"6","throughput":"1"},{"base":"0F_02","parameters":"xmm, xmm","latency":"6","throughput":"1"}]},{"name":"_mm_load1_pd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Load","description":"Load a double-precision (64-bit) floating-point element from memory into both elements of \"dst\".","code":"dst[63:0] := MEM[mem_addr+63:mem_addr]\ndst[127:64] := MEM[mem_addr+63:mem_addr]","header":"emmintrin.h","instruction":null,"parameters":[{"type":"double const*","name":"mem_addr"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_load_pd1","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Load","description":"Load a double-precision (64-bit) floating-point element from memory into both elements of \"dst\".","code":"dst[63:0] := MEM[mem_addr+63:mem_addr]\ndst[127:64] := MEM[mem_addr+63:mem_addr]","header":"emmintrin.h","instruction":null,"parameters":[{"type":"double const*","name":"mem_addr"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_loadr_pd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Load","description":"Load 2 double-precision (64-bit) floating-point elements from memory into \"dst\" in reverse order. mem_addr must be aligned on a 16-byte boundary or a general-protection exception will be generated.","code":"dst[63:0] := MEM[mem_addr+127:mem_addr+64]\ndst[127:64] := MEM[mem_addr+63:mem_addr]","header":"emmintrin.h","instruction":null,"parameters":[{"type":"double const*","name":"mem_addr"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_loadu_pd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Load","description":"Load 128-bits (composed of 2 packed double-precision (64-bit) floating-point elements) from memory into \"dst\".\n\t\"mem_addr\" does not need to be aligned on any particular boundary.","code":"dst[127:0] := MEM[mem_addr+127:mem_addr]","header":"emmintrin.h","instruction":"movupd","parameters":[{"type":"double const*","name":"mem_addr"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"6","throughput":"1"},{"base":"0F_02","parameters":"xmm, xmm","latency":"6","throughput":"1"}]},{"name":"_mm_load_sd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Load","description":"Load a double-precision (64-bit) floating-point element from memory into the lower of \"dst\", and zero the upper element. \"mem_addr\" does not need to be aligned on any particular boundary.","code":"dst[63:0] := MEM[mem_addr+63:mem_addr]\ndst[127:64] := 0","header":"emmintrin.h","instruction":"movsd","parameters":[{"type":"double const*","name":"mem_addr"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.8"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"xmm, xmm","latency":"6","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"6","throughput":"2"}]},{"name":"_mm_loadh_pd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Load","description":"Load a double-precision (64-bit) floating-point element from memory into the upper element of \"dst\", and copy the lower element from \"a\" to \"dst\". \"mem_addr\" does not need to be aligned on any particular boundary.","code":"dst[63:0] := a[63:0]\ndst[127:64] := MEM[mem_addr+63:mem_addr]","header":"emmintrin.h","instruction":"movhpd","parameters":[{"type":"__m128d","name":"a"},{"type":"double const*","name":"mem_addr"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_loadl_pd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Load","description":"Load a double-precision (64-bit) floating-point element from memory into the lower element of \"dst\", and copy the upper element from \"a\" to \"dst\". \"mem_addr\" does not need to be aligned on any particular boundary.","code":"dst[63:0] := MEM[mem_addr+63:mem_addr]\ndst[127:64] := a[127:64]","header":"emmintrin.h","instruction":"movlpd","parameters":[{"type":"__m128d","name":"a"},{"type":"double const*","name":"mem_addr"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_stream_pd","tech":"SSE2","returnType":"void","cpuId":"SSE2","category":"Store","description":"Store 128-bits (composed of 2 packed double-precision (64-bit) floating-point elements) from \"a\" into memory using a non-temporal memory hint.\n\t\"mem_addr\" must be aligned on a 16-byte boundary or a general-protection exception will be generated.","code":"MEM[mem_addr+127:mem_addr] := a[127:0]","header":"emmintrin.h","instruction":"movntpd","parameters":[{"type":"double*","name":"mem_addr"},{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_store_sd","tech":"SSE2","returnType":"void","cpuId":"SSE2","category":"Store","description":"Store the lower double-precision (64-bit) floating-point element from \"a\" into memory. \"mem_addr\" does not need to be aligned on any particular boundary.","code":"MEM[mem_addr+63:mem_addr] := a[63:0]","header":"emmintrin.h","instruction":"movsd","parameters":[{"type":"double*","name":"mem_addr"},{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.8"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"xmm, xmm","latency":"6","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"6","throughput":"2"}]},{"name":"_mm_store1_pd","tech":"SSE2","returnType":"void","cpuId":"SSE2","category":"Store","description":"Store the lower double-precision (64-bit) floating-point element from \"a\" into 2 contiguous elements in memory. \"mem_addr\" must be aligned on a 16-byte boundary or a general-protection exception will be generated.","code":"MEM[mem_addr+63:mem_addr] := a[63:0]\nMEM[mem_addr+127:mem_addr+64] := a[63:0]","header":"emmintrin.h","instruction":null,"parameters":[{"type":"double*","name":"mem_addr"},{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_store_pd1","tech":"SSE2","returnType":"void","cpuId":"SSE2","category":"Store","description":"Store the lower double-precision (64-bit) floating-point element from \"a\" into 2 contiguous elements in memory. \"mem_addr\" must be aligned on a 16-byte boundary or a general-protection exception will be generated.","code":"MEM[mem_addr+63:mem_addr] := a[63:0]\nMEM[mem_addr+127:mem_addr+64] := a[63:0]","header":"emmintrin.h","instruction":null,"parameters":[{"type":"double*","name":"mem_addr"},{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_store_pd","tech":"SSE2","returnType":"void","cpuId":"SSE2","category":"Store","description":"Store 128-bits (composed of 2 packed double-precision (64-bit) floating-point elements) from \"a\" into memory.\n\t\"mem_addr\" must be aligned on a 16-byte boundary or a general-protection exception will be generated.","code":"MEM[mem_addr+127:mem_addr] := a[127:0]","header":"emmintrin.h","instruction":"movapd","parameters":[{"type":"double*","name":"mem_addr"},{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"6","throughput":"1"},{"base":"0F_02","parameters":"xmm, xmm","latency":"6","throughput":"1"}]},{"name":"_mm_storeu_pd","tech":"SSE2","returnType":"void","cpuId":"SSE2","category":"Store","description":"Store 128-bits (composed of 2 packed double-precision (64-bit) floating-point elements) from \"a\" into memory.\n\t\"mem_addr\" does not need to be aligned on any particular boundary.","code":"MEM[mem_addr+127:mem_addr] := a[127:0]","header":"emmintrin.h","instruction":"movupd","parameters":[{"type":"double*","name":"mem_addr"},{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"6","throughput":"1"},{"base":"0F_02","parameters":"xmm, xmm","latency":"6","throughput":"1"}]},{"name":"_mm_storer_pd","tech":"SSE2","returnType":"void","cpuId":"SSE2","category":"Store","description":"Store 2 double-precision (64-bit) floating-point elements from \"a\" into memory in reverse order.\n\t\"mem_addr\" must be aligned on a 16-byte boundary or a general-protection exception will be generated.","code":"MEM[mem_addr+63:mem_addr] := a[127:64]\nMEM[mem_addr+127:mem_addr+64] := a[63:0]","header":"emmintrin.h","instruction":null,"parameters":[{"type":"double*","name":"mem_addr"},{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_storeh_pd","tech":"SSE2","returnType":"void","cpuId":"SSE2","category":"Store","description":"Store the upper double-precision (64-bit) floating-point element from \"a\" into memory.","code":"MEM[mem_addr+63:mem_addr] := a[127:64]","header":"emmintrin.h","instruction":"movhpd","parameters":[{"type":"double*","name":"mem_addr"},{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_storel_pd","tech":"SSE2","returnType":"void","cpuId":"SSE2","category":"Store","description":"Store the lower double-precision (64-bit) floating-point element from \"a\" into memory.","code":"MEM[mem_addr+63:mem_addr] := a[63:0]","header":"emmintrin.h","instruction":"movlpd","parameters":[{"type":"double*","name":"mem_addr"},{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_unpackhi_pd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Swizzle","description":"Unpack and interleave double-precision (64-bit) floating-point elements from the high half of \"a\" and \"b\", and store the results in \"dst\".","code":"INTERLEAVE_HIGH_QWORDS(src1[127:0], src2[127:0]){\n\tdst[63:0] := src1[127:64] \n\tdst[127:64] := src2[127:64] \n\tRETURN dst[127:0]\n}\t\n\t\ndst[127:0] := INTERLEAVE_HIGH_QWORDS(a[127:0], b[127:0])","header":"emmintrin.h","instruction":"unpckhpd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"6","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"6","throughput":"2"}]},{"name":"_mm_unpacklo_pd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Swizzle","description":"Unpack and interleave double-precision (64-bit) floating-point elements from the low half of \"a\" and \"b\", and store the results in \"dst\".","code":"INTERLEAVE_QWORDS(src1[127:0], src2[127:0]){\n\tdst[63:0] := src1[63:0] \n\tdst[127:64] := src2[63:0] \n\tRETURN dst[127:0]\n}\n\ndst[127:0] := INTERLEAVE_QWORDS(a[127:0], b[127:0])","header":"emmintrin.h","instruction":"unpcklpd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm","latency":"","throughput":"1"},{"base":"06_0D","parameters":"xmm, xmm","latency":"","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"4","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"4","throughput":"2"}]},{"name":"_mm_movemask_pd","tech":"SSE2","returnType":"int","cpuId":"SSE2","category":"Miscellaneous","description":"Set each bit of mask \"dst\" based on the most significant bit of the corresponding packed double-precision (64-bit) floating-point element in \"a\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tIF a[i+63]\n\t\tdst[j] := 1\n\tELSE\n\t\tdst[j] := 0\n\tFI\nENDFOR\ndst[MAX:2] := 0","header":"emmintrin.h","instruction":"movmskpd","parameters":[{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"r32, xmm","latency":"2","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"r32, xmm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"r32, xmm","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"r32, xmm","latency":"1","throughput":"1"},{"base":"06_0D","parameters":"r32, xmm","latency":"1","throughput":"1"},{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"r64, xmm","latency":"2","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"r64, xmm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"r64, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"r32, xmm","latency":"6","throughput":"2"},{"base":"0F_02","parameters":"r32, xmm","latency":"6","throughput":"2"}]},{"name":"_mm_shuffle_pd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Swizzle","description":"Shuffle double-precision (64-bit) floating-point elements using the control in \"imm\", and store the results in \"dst\".","code":"dst[63:0] := (imm[0] == 0) ? a[63:0] : a[127:64]\ndst[127:64] := (imm[1] == 0) ? b[63:0] : b[127:64]","header":"emmintrin.h","instruction":"shufpd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"},{"type":"int","name":"imm"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, xmm, imm8","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm, xmm, imm8","latency":"1","throughput":"1"},{"base":"06_0E","parameters":"xmm, xmm, imm8","latency":"2","throughput":"2"},{"base":"06_0D","parameters":"xmm, xmm, imm8","latency":"2","throughput":"2"},{"base":"0F_03","parameters":"xmm, xmm,imm8","latency":"6","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm,imm8","latency":"6","throughput":"2"}]},{"name":"_mm_move_sd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Move","description":"Move the lower double-precision (64-bit) floating-point element from \"b\" to the lower element of \"dst\", and copy the upper element from \"a\" to the upper element of \"dst\".","code":"dst[63:0] := b[63:0]\ndst[127:64] := a[127:64]","header":"emmintrin.h","instruction":"movsd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.8"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"xmm, xmm","latency":"6","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"6","throughput":"2"}]},{"name":"_mm_castpd_ps","tech":"SSE2","returnType":"__m128","cpuId":"SSE2","category":"Cast","description":"Cast vector of type __m128d to type __m128. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.","code":null,"header":"emmintrin.h","instruction":"","parameters":[{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_castpd_si128","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Cast","description":"Cast vector of type __m128d to type __m128i. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.","code":null,"header":"emmintrin.h","instruction":"","parameters":[{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_castps_pd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Cast","description":"Cast vector of type __m128 to type __m128d. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.","code":null,"header":"emmintrin.h","instruction":"","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_castps_si128","tech":"SSE2","returnType":"__m128i","cpuId":"SSE2","category":"Cast","description":"Cast vector of type __m128 to type __m128i. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.","code":null,"header":"emmintrin.h","instruction":"","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_castsi128_pd","tech":"SSE2","returnType":"__m128d","cpuId":"SSE2","category":"Cast","description":"Cast vector of type __m128i to type __m128d. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.","code":null,"header":"emmintrin.h","instruction":"","parameters":[{"type":"__m128i","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_castsi128_ps","tech":"SSE2","returnType":"__m128","cpuId":"SSE2","category":"Cast","description":"Cast vector of type __m128i to type __m128. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.","code":null,"header":"emmintrin.h","instruction":"","parameters":[{"type":"__m128i","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_addsub_ps","tech":"SSE3","returnType":"__m128","cpuId":"SSE3","category":"Arithmetic","description":"Alternatively add and subtract packed single-precision (32-bit) floating-point elements in \"a\" to/from packed elements in \"b\", and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tIF (j is even) \n\t\tdst[i+31:i] := a[i+31:i] - b[i+31:i]\n\tELSE\n\t\tdst[i+31:i] := a[i+31:i] + b[i+31:i]\n\tFI\nENDFOR","header":"pmmintrin.h","instruction":"addsubps","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E","parameters":"","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"","latency":"3","throughput":"1"},{"base":"0F_03","parameters":"","latency":"5","throughput":"2"}]},{"name":"_mm_addsub_pd","tech":"SSE3","returnType":"__m128d","cpuId":"SSE3","category":"Arithmetic","description":"Alternatively add and subtract packed double-precision (64-bit) floating-point elements in \"a\" to/from packed elements in \"b\", and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tIF (j is even) \n\t\tdst[i+63:i] := a[i+63:i] - b[i+63:i]\n\tELSE\n\t\tdst[i+63:i] := a[i+63:i] + b[i+63:i]\n\tFI\nENDFOR","header":"pmmintrin.h","instruction":"addsubpd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E","parameters":"","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"","latency":"3","throughput":"1"},{"base":"0F_03","parameters":"","latency":"5","throughput":"2"}]},{"name":"_mm_hadd_pd","tech":"SSE3","returnType":"__m128d","cpuId":"SSE3","category":"Arithmetic","description":"Horizontally add adjacent pairs of double-precision (64-bit) floating-point elements in \"a\" and \"b\", and pack the results in \"dst\".","code":"dst[63:0] := a[127:64] + a[63:0]\ndst[127:64] := b[127:64] + b[63:0]","header":"pmmintrin.h","instruction":"haddpd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm1, xmm2","latency":"5","throughput":"2"},{"base":"06_25/2C/1A/1E/1F/2E","parameters":"xmm1, xmm2","latency":"5","throughput":"2"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"6","throughput":"1"},{"base":"06_0F","parameters":"xmm1, xmm2","latency":"5","throughput":"2"},{"base":"0F_03","parameters":"","latency":"13","throughput":"4"}]},{"name":"_mm_hadd_ps","tech":"SSE3","returnType":"__m128","cpuId":"SSE3","category":"Arithmetic","description":"Horizontally add adjacent pairs of single-precision (32-bit) floating-point elements in \"a\" and \"b\", and pack the results in \"dst\".","code":"dst[31:0] := a[63:32] + a[31:0]\ndst[63:32] := a[127:96] + a[95:64]\ndst[95:64] := b[63:32] + b[31:0]\ndst[127:96] := b[127:96] + b[95:64]","header":"pmmintrin.h","instruction":"haddps","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm1, xmm2","latency":"5","throughput":"2"},{"base":"06_25/2C/1A/1E/1F/2E","parameters":"xmm1, xmm2","latency":"5","throughput":"2"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"7","throughput":"2"},{"base":"06_0F","parameters":"xmm1, xmm2","latency":"9","throughput":"4"},{"base":"0F_03","parameters":"","latency":"13","throughput":"4"}]},{"name":"_mm_hsub_pd","tech":"SSE3","returnType":"__m128d","cpuId":"SSE3","category":"Arithmetic","description":"Horizontally subtract adjacent pairs of double-precision (64-bit) floating-point elements in \"a\" and \"b\", and pack the results in \"dst\".","code":"dst[63:0] := a[127:64] - a[63:0]\ndst[127:64] := b[127:64] - b[63:0]","header":"pmmintrin.h","instruction":null,"parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_hsub_ps","tech":"SSE3","returnType":"__m128","cpuId":"SSE3","category":"Arithmetic","description":"Horizontally add adjacent pairs of single-precision (32-bit) floating-point elements in \"a\" and \"b\", and pack the results in \"dst\".","code":"dst[31:0] := a[63:32] - a[31:0]\ndst[63:32] := a[127:96] - a[95:64]\ndst[95:64] := b[63:32] - b[31:0]\ndst[127:96] := b[127:96] - b[95:64]","header":"pmmintrin.h","instruction":"hsubps","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm1, xmm2","latency":"5","throughput":"2"},{"base":"06_25/2C/1A/1E/1F/2E","parameters":"xmm1, xmm2","latency":"5","throughput":"2"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"7","throughput":"2"},{"base":"06_0F","parameters":"xmm1, xmm2","latency":"9","throughput":"4"},{"base":"0F_03","parameters":"","latency":"13","throughput":"4"}]},{"name":"_mm_lddqu_si128","tech":"SSE3","returnType":"__m128i","cpuId":"SSE3","category":"Load","description":"Load 128-bits of integer data from unaligned memory into \"dst\". This intrinsic may perform better than \"_mm_loadu_si128\" when the data crosses a cache line boundary.","code":"dst[127:0] := MEM[mem_addr+127:mem_addr]","header":"pmmintrin.h","instruction":"lddqu","parameters":[{"type":"__m128i const*","name":"mem_addr"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_monitor","tech":"SSE3","returnType":"void","cpuId":"SSE3","category":"General Support","description":"Arm address monitoring hardware using the address specified in \"p\". A store to an address within the specified address range triggers the monitoring hardware. Specify optional extensions in \"extensions\", and optional hints in \"hints\".","code":null,"header":"pmmintrin.h","instruction":"monitor","parameters":[{"type":"void const*","name":"p"},{"type":"unsigned","name":"extensions"},{"type":"unsigned","name":"hints"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_movedup_pd","tech":"SSE3","returnType":"__m128d","cpuId":"SSE3","category":"Move","description":"Duplicate the low double-precision (64-bit) floating-point element from \"a\", and store the results in \"dst\".","code":"tmp[63:0] := a[63:0]\ntmp[127:64] := a[63:0]","header":"pmmintrin.h","instruction":"movddup","parameters":[{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm1, xmm2","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E","parameters":"xmm1, xmm2","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm1, xmm2","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm1, xmm2","latency":"4","throughput":"2"}]},{"name":"_mm_loaddup_pd","tech":"SSE3","returnType":"__m128d","cpuId":"SSE3","category":"Load","description":"Load a double-precision (64-bit) floating-point element from memory into both elements of \"dst\".","code":"tmp[63:0] := MEM[mem_addr+63:mem_addr]\ntmp[127:64] := MEM[mem_addr+63:mem_addr]","header":"pmmintrin.h","instruction":"movddup","parameters":[{"type":"double const*","name":"mem_addr"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm1, xmm2","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E","parameters":"xmm1, xmm2","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm1, xmm2","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm1, xmm2","latency":"4","throughput":"2"}]},{"name":"_mm_movehdup_ps","tech":"SSE3","returnType":"__m128","cpuId":"SSE3","category":"Move","description":"Duplicate the high single-precision (32-bit) floating-point element from \"a\", and store the results in \"dst\".","code":"dst[31:0] := a[63:32] \ndst[63:32] := a[63:32]","header":"pmmintrin.h","instruction":"movshdup","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm1, xmm2","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm1, xmm2","latency":"2","throughput":"1"},{"base":"0F_03","parameters":"xmm1, xmm2","latency":"6","throughput":"2"}]},{"name":"_mm_moveldup_ps","tech":"SSE3","returnType":"__m128","cpuId":"SSE3","category":"Move","description":"Duplicate the low single-precision (32-bit) floating-point element from \"a\", and store the results in \"dst\".","code":"dst[31:0] := a[31:0] \ndst[63:32] := a[31:0]","header":"pmmintrin.h","instruction":"movsldup","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm1, xmm2","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm1, xmm2","latency":"6","throughput":"2"}]},{"name":"_mm_mwait","tech":"SSE3","returnType":"void","cpuId":"SSE3","category":"General Support","description":"Hint to the processor that it can enter an implementation-dependent-optimized state while waiting for an event or store operation to the address range specified by MONITOR.","code":null,"header":"pmmintrin.h","instruction":"mwait","parameters":[{"type":"unsigned","name":"extensions"},{"type":"unsigned","name":"hints"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_abs_pi8","tech":"SSSE3","returnType":"__m64","cpuId":"SSSE3","category":"Special Math Functions","description":"Compute the absolute value of packed 8-bit integers in \"a\", and store the unsigned results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*8\n\tdst[i+7:i] := ABS(a[i+7:i])\nENDFOR","header":"tmmintrin.h","instruction":"pabsb","parameters":[{"type":"__m64","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"}]},{"name":"_mm_abs_epi8","tech":"SSSE3","returnType":"__m128i","cpuId":"SSSE3","category":"Special Math Functions","description":"Compute the absolute value of packed 8-bit integers in \"a\", and store the unsigned results in \"dst\".","code":"FOR j := 0 to 15\n\ti := j*8\n\tdst[i+7:i] := ABS(a[i+7:i])\nENDFOR","header":"tmmintrin.h","instruction":"pabsb","parameters":[{"type":"__m128i","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"}]},{"name":"_mm_abs_pi16","tech":"SSSE3","returnType":"__m64","cpuId":"SSSE3","category":"Special Math Functions","description":"Compute the absolute value of packed 16-bit integers in \"a\", and store the unsigned results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*16\n\tdst[i+15:i] := ABS(a[i+15:i])\nENDFOR","header":"tmmintrin.h","instruction":"pabsw","parameters":[{"type":"__m64","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"}]},{"name":"_mm_abs_epi16","tech":"SSSE3","returnType":"__m128i","cpuId":"SSSE3","category":"Special Math Functions","description":"Compute the absolute value of packed 16-bit integers in \"a\", and store the unsigned results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*16\n\tdst[i+15:i] := ABS(a[i+15:i])\nENDFOR","header":"tmmintrin.h","instruction":"pabsw","parameters":[{"type":"__m128i","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"}]},{"name":"_mm_abs_pi32","tech":"SSSE3","returnType":"__m64","cpuId":"SSSE3","category":"Special Math Functions","description":"Compute the absolute value of packed 32-bit integers in \"a\", and store the unsigned results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*32\n\tdst[i+31:i] := ABS(a[i+31:i])\nENDFOR","header":"tmmintrin.h","instruction":"pabsd","parameters":[{"type":"__m64","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"}]},{"name":"_mm_abs_epi32","tech":"SSSE3","returnType":"__m128i","cpuId":"SSSE3","category":"Special Math Functions","description":"Compute the absolute value of packed 32-bit integers in \"a\", and store the unsigned results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := ABS(a[i+31:i])\nENDFOR","header":"tmmintrin.h","instruction":"pabsd","parameters":[{"type":"__m128i","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"}]},{"name":"_mm_shuffle_epi8","tech":"SSSE3","returnType":"__m128i","cpuId":"SSSE3","category":"Swizzle","description":"Shuffle packed 8-bit integers in \"a\" according to shuffle control mask in the corresponding 8-bit element of \"b\", and store the results in \"dst\".","code":"FOR j := 0 to 15\n\ti := j*8\n\tIF b[i+7] == 1\n\t\tdst[i+7:i] := 0\n\tELSE\n\t\tindex[3:0] := b[i+3:i]\n\t\tdst[i+7:i] := a[index*8+7:index*8]\n\tFI\nENDFOR","header":"tmmintrin.h","instruction":"pshufb","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm1, xmm2","latency":"3","throughput":"2"},{"base":"06_17","parameters":"mm1, mm2","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm1, mm2","latency":"1","throughput":"1"}]},{"name":"_mm_shuffle_pi8","tech":"SSSE3","returnType":"__m64","cpuId":"SSSE3","category":"Swizzle","description":"Shuffle packed 8-bit integers in \"a\" according to shuffle control mask in the corresponding 8-bit element of \"b\", and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*8\n\tIF b[i+7] == 1\n\t\tdst[i+7:i] := 0\n\tELSE\n\t\tindex[2:0] := b[i+2:i]\n\t\tdst[i+7:i] := a[index*8+7:index*8]\n\tFI\nENDFOR","header":"tmmintrin.h","instruction":"pshufb","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm1, xmm2","latency":"3","throughput":"2"},{"base":"06_17","parameters":"mm1, mm2","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm1, mm2","latency":"1","throughput":"1"}]},{"name":"_mm_alignr_epi8","tech":"SSSE3","returnType":"__m128i","cpuId":"SSSE3","category":"Miscellaneous","description":"Concatenate 16-byte blocks in \"a\" and \"b\" into a 32-byte temporary result, shift the result right by \"count\" bytes, and store the low 16 bytes in \"dst\".","code":"tmp[255:0] := ((a[127:0] << 128) OR b[127:0]) >> (count[7:0]*8)\ndst[127:0] := tmp[127:0]","header":"tmmintrin.h","instruction":"palignr","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"},{"type":"int","name":"count"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm1, xmm2, imm","latency":"1","throughput":"1"},{"base":"06_2A/2D/3A/3E","parameters":"xmm1, xmm2, imm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2, imm","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"xmm1, xmm2, imm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm1, xmm2, imm","latency":"2","throughput":"1"},{"base":"06_17","parameters":"mm1, mm2, imm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm1, mm2, imm","latency":"2","throughput":"1"}]},{"name":"_mm_alignr_pi8","tech":"SSSE3","returnType":"__m64","cpuId":"SSSE3","category":"Miscellaneous","description":"Concatenate 8-byte blocks in \"a\" and \"b\" into a 16-byte temporary result, shift the result right by \"count\" bytes, and store the low 16 bytes in \"dst\".","code":"tmp[127:0] := ((a[63:0] << 64) OR b[63:0]) >> (count[7:0]*8)\ndst[63:0] := tmp[63:0]","header":"tmmintrin.h","instruction":"palignr","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"},{"type":"int","name":"count"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm1, xmm2, imm","latency":"1","throughput":"1"},{"base":"06_2A/2D/3A/3E","parameters":"xmm1, xmm2, imm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2, imm","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"xmm1, xmm2, imm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"xmm1, xmm2, imm","latency":"2","throughput":"1"},{"base":"06_17","parameters":"mm1, mm2, imm","latency":"1","throughput":"1"},{"base":"06_0F","parameters":"mm1, mm2, imm","latency":"2","throughput":"1"}]},{"name":"_mm_hadd_epi16","tech":"SSSE3","returnType":"__m128i","cpuId":"SSSE3","category":"Arithmetic","description":"Horizontally add adjacent pairs of 16-bit integers in \"a\" and \"b\", and pack the signed 16-bit results in \"dst\".","code":"dst[15:0] := a[31:16] + a[15:0]\ndst[31:16] := a[63:48] + a[47:32]\ndst[47:32] := a[95:80] + a[79:64]\ndst[63:48] := a[127:112] + a[111:96]\ndst[79:64] := b[31:16] + b[15:0]\ndst[95:80] := b[63:48] + b[47:32]\ndst[111:96] := b[95:80] + b[79:64]\ndst[127:112] := b[127:112] + b[111:96]","header":"tmmintrin.h","instruction":"phaddw","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm1, xmm2","latency":"3","throughput":"1.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2","latency":"3","throughput":"1.5"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"3","throughput":"2"},{"base":"06_0F","parameters":"xmm1, xmm2","latency":"6","throughput":"4"},{"base":"06_17","parameters":"mm1, mm2","latency":"3","throughput":"2"},{"base":"06_0F","parameters":"mm1, mm2","latency":"5","throughput":"4"}]},{"name":"_mm_hadds_epi16","tech":"SSSE3","returnType":"__m128i","cpuId":"SSSE3","category":"Arithmetic","description":"Horizontally add adjacent pairs of 16-bit integers in \"a\" and \"b\" using saturation, and pack the signed 16-bit results in \"dst\".","code":"dst[15:0]= Saturate_To_Int16(a[31:16] + a[15:0])\ndst[31:16] = Saturate_To_Int16(a[63:48] + a[47:32])\ndst[47:32] = Saturate_To_Int16(a[95:80] + a[79:64])\ndst[63:48] = Saturate_To_Int16(a[127:112] + a[111:96])\ndst[79:64] = Saturate_To_Int16(b[31:16] + b[15:0])\ndst[95:80] = Saturate_To_Int16(b[63:48] + b[47:32])\ndst[111:96] = Saturate_To_Int16(b[95:80] + b[79:64])\ndst[127:112] = Saturate_To_Int16(b[127:112] + b[111:96])","header":"tmmintrin.h","instruction":"phaddsw","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm1, xmm2","latency":"3","throughput":"1.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2","latency":"3","throughput":"1.5"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"3","throughput":"2"},{"base":"06_0F","parameters":"xmm1, xmm2","latency":"6","throughput":"4"},{"base":"06_17","parameters":"mm1, mm2","latency":"3","throughput":"2"},{"base":"06_0F","parameters":"mm1, mm2","latency":"5","throughput":"4"}]},{"name":"_mm_hadd_epi32","tech":"SSSE3","returnType":"__m128i","cpuId":"SSSE3","category":"Arithmetic","description":"Horizontally add adjacent pairs of 32-bit integers in \"a\" and \"b\", and pack the signed 32-bit results in \"dst\".","code":"dst[31:0] := a[63:32] + a[31:0]\ndst[63:32] := a[127:96] + a[95:64]\ndst[95:64] := b[63:32] + b[31:0]\ndst[127:96] := b[127:96] + b[95:64]","header":"tmmintrin.h","instruction":"phaddd","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm1, xmm2","latency":"3","throughput":"1.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2","latency":"3","throughput":"1.5"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"3","throughput":"2"},{"base":"06_0F","parameters":"xmm1, xmm2","latency":"5","throughput":"3"},{"base":"06_17","parameters":"mm1, mm2","latency":"3","throughput":"2"},{"base":"06_0F","parameters":"mm1, mm2","latency":"3","throughput":"2"}]},{"name":"_mm_hadd_pi16","tech":"SSSE3","returnType":"__m64","cpuId":"SSSE3","category":"Arithmetic","description":"Horizontally add adjacent pairs of 16-bit integers in \"a\" and \"b\", and pack the signed 16-bit results in \"dst\".","code":"dst[15:0] := a[31:16] + a[15:0]\ndst[31:16] := a[63:48] + a[47:32]\ndst[47:32] := b[31:16] + b[15:0]\ndst[63:48] := b[63:48] + b[47:32]","header":"tmmintrin.h","instruction":"phaddw","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm1, xmm2","latency":"3","throughput":"1.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2","latency":"3","throughput":"1.5"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"3","throughput":"2"},{"base":"06_0F","parameters":"xmm1, xmm2","latency":"6","throughput":"4"},{"base":"06_17","parameters":"mm1, mm2","latency":"3","throughput":"2"},{"base":"06_0F","parameters":"mm1, mm2","latency":"5","throughput":"4"}]},{"name":"_mm_hadd_pi32","tech":"SSSE3","returnType":"__m64","cpuId":"SSSE3","category":"Arithmetic","description":"Horizontally add adjacent pairs of 32-bit integers in \"a\" and \"b\", and pack the signed 32-bit results in \"dst\".","code":"dst[31:0] := a[63:32] + a[31:0]\ndst[63:32] := b[63:32] + b[31:0]","header":"tmmintrin.h","instruction":"phadd","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_hadds_pi16","tech":"SSSE3","returnType":"__m64","cpuId":"SSSE3","category":"Arithmetic","description":"Horizontally add adjacent pairs of 16-bit integers in \"a\" and \"b\" using saturation, and pack the signed 16-bit results in \"dst\".","code":"dst[15:0]= Saturate_To_Int16(a[31:16] + a[15:0])\ndst[31:16] = Saturate_To_Int16(a[63:48] + a[47:32])\ndst[47:32] = Saturate_To_Int16(b[31:16] + b[15:0])\ndst[63:48] = Saturate_To_Int16(b[63:48] + b[47:32])","header":"tmmintrin.h","instruction":"phaddsw","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm1, xmm2","latency":"3","throughput":"1.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2","latency":"3","throughput":"1.5"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"3","throughput":"2"},{"base":"06_0F","parameters":"xmm1, xmm2","latency":"6","throughput":"4"},{"base":"06_17","parameters":"mm1, mm2","latency":"3","throughput":"2"},{"base":"06_0F","parameters":"mm1, mm2","latency":"5","throughput":"4"}]},{"name":"_mm_hsub_epi16","tech":"SSSE3","returnType":"__m128i","cpuId":"SSSE3","category":"Arithmetic","description":"Horizontally subtract adjacent pairs of 16-bit integers in \"a\" and \"b\", and pack the signed 16-bit results in \"dst\".","code":"dst[15:0] := a[15:0] - a[31:16]\ndst[31:16] := a[47:32] - a[63:48]\ndst[47:32] := a[79:64] - a[95:80]\ndst[63:48] := a[111:96] - a[127:112]\ndst[79:64] := b[15:0] - b[31:16]\ndst[95:80] := b[47:32] - b[63:48]\ndst[111:96] := b[79:64] - b[95:80]\ndst[127:112] := b[111:96] - b[127:112]","header":"tmmintrin.h","instruction":"phsubw","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm1, xmm2","latency":"3","throughput":"1.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2","latency":"3","throughput":"1.5"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"3","throughput":"2"},{"base":"06_0F","parameters":"xmm1, xmm2","latency":"6","throughput":"4"},{"base":"06_17","parameters":"mm1, mm2","latency":"3","throughput":"2"},{"base":"06_0F","parameters":"mm1, mm2","latency":"5","throughput":"4"}]},{"name":"_mm_hsubs_epi16","tech":"SSSE3","returnType":"__m128i","cpuId":"SSSE3","category":"Arithmetic","description":"Horizontally subtract adjacent pairs of 16-bit integers in \"a\" and \"b\" using saturation, and pack the signed 16-bit results in \"dst\".","code":"dst[15:0]= Saturate_To_Int16(a[15:0] - a[31:16])\ndst[31:16] = Saturate_To_Int16(a[47:32] - a[63:48])\ndst[47:32] = Saturate_To_Int16(a[79:64] - a[95:80])\ndst[63:48] = Saturate_To_Int16(a[111:96] - a[127:112])\ndst[79:64] = Saturate_To_Int16(b[15:0] - b[31:16])\ndst[95:80] = Saturate_To_Int16(b[47:32] - b[63:48])\ndst[111:96] = Saturate_To_Int16(b[79:64] - b[95:80])\ndst[127:112] = Saturate_To_Int16(b[111:96] - b[127:112])","header":"tmmintrin.h","instruction":"phsubsw","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm1, xmm2","latency":"3","throughput":"1.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2","latency":"3","throughput":"1.5"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"3","throughput":"2"},{"base":"06_0F","parameters":"xmm1, xmm2","latency":"6","throughput":"4"},{"base":"06_17","parameters":"mm1, mm2","latency":"3","throughput":"2"},{"base":"06_0F","parameters":"mm1, mm2","latency":"5","throughput":"4"}]},{"name":"_mm_hsub_epi32","tech":"SSSE3","returnType":"__m128i","cpuId":"SSSE3","category":"Arithmetic","description":"Horizontally subtract adjacent pairs of 32-bit integers in \"a\" and \"b\", and pack the signed 32-bit results in \"dst\".","code":"dst[31:0] := a[31:0] - a[63:32]\ndst[63:32] := a[95:64] - a[127:96]\ndst[95:64] := b[31:0] - b[63:32]\ndst[127:96] := b[95:64] - b[127:96]","header":"tmmintrin.h","instruction":"phsubd","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm1, xmm2","latency":"3","throughput":"1.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2","latency":"3","throughput":"1.5"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"3","throughput":"2"},{"base":"06_0F","parameters":"xmm1, xmm2","latency":"5","throughput":"3"},{"base":"06_17","parameters":"mm1, mm2","latency":"3","throughput":"2"},{"base":"06_0F","parameters":"mm1, mm2","latency":"3","throughput":"2"}]},{"name":"_mm_hsub_pi16","tech":"SSSE3","returnType":"__m64","cpuId":"SSSE3","category":"Arithmetic","description":"Horizontally subtract adjacent pairs of 16-bit integers in \"a\" and \"b\", and pack the signed 16-bit results in \"dst\".","code":"dst[15:0] := a[15:0] - a[31:16]\ndst[31:16] := a[47:32] - a[63:48]\ndst[47:32] := b[15:0] - b[31:16]\ndst[63:48] := b[47:32] - b[63:48]","header":"tmmintrin.h","instruction":"phsubw","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm1, xmm2","latency":"3","throughput":"1.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2","latency":"3","throughput":"1.5"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"3","throughput":"2"},{"base":"06_0F","parameters":"xmm1, xmm2","latency":"6","throughput":"4"},{"base":"06_17","parameters":"mm1, mm2","latency":"3","throughput":"2"},{"base":"06_0F","parameters":"mm1, mm2","latency":"5","throughput":"4"}]},{"name":"_mm_hsub_pi32","tech":"SSSE3","returnType":"__m64","cpuId":"SSSE3","category":"Arithmetic","description":"Horizontally subtract adjacent pairs of 32-bit integers in \"a\" and \"b\", and pack the signed 32-bit results in \"dst\".","code":"dst[31:0] := a[31:0] - a[63:32]\ndst[63:32] := b[31:0] - b[63:32]","header":"tmmintrin.h","instruction":"phsubd","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm1, xmm2","latency":"3","throughput":"1.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2","latency":"3","throughput":"1.5"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"3","throughput":"2"},{"base":"06_0F","parameters":"xmm1, xmm2","latency":"5","throughput":"3"},{"base":"06_17","parameters":"mm1, mm2","latency":"3","throughput":"2"},{"base":"06_0F","parameters":"mm1, mm2","latency":"3","throughput":"2"}]},{"name":"_mm_hsubs_pi16","tech":"SSSE3","returnType":"__m64","cpuId":"SSSE3","category":"Arithmetic","description":"Horizontally subtract adjacent pairs of 16-bit integers in \"a\" and \"b\" using saturation, and pack the signed 16-bit results in \"dst\".","code":"dst[15:0]= Saturate_To_Int16(a[15:0] - a[31:16])\ndst[31:16] = Saturate_To_Int16(a[47:32] - a[63:48])\ndst[47:32] = Saturate_To_Int16(b[15:0] - b[31:16])\ndst[63:48] = Saturate_To_Int16(b[47:32] - b[63:48])","header":"tmmintrin.h","instruction":"phsubsw","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm1, xmm2","latency":"3","throughput":"1.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2","latency":"3","throughput":"1.5"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"3","throughput":"2"},{"base":"06_0F","parameters":"xmm1, xmm2","latency":"6","throughput":"4"},{"base":"06_17","parameters":"mm1, mm2","latency":"3","throughput":"2"},{"base":"06_0F","parameters":"mm1, mm2","latency":"5","throughput":"4"}]},{"name":"_mm_maddubs_epi16","tech":"SSSE3","returnType":"__m128i","cpuId":"SSSE3","category":"Arithmetic","description":"Vertically multiply each unsigned 8-bit integer from \"a\" with the corresponding signed 8-bit integer from \"b\", producing intermediate signed 16-bit integers. Horizontally add adjacent pairs of intermediate signed 16-bit integers, and pack the saturated results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*16\n\tdst[i+15:i] := Saturate_To_Int16( a[i+15:i+8]*b[i+15:i+8] + a[i+7:i]*b[i+7:i] )\nENDFOR","header":"tmmintrin.h","instruction":"pmaddubsw","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm1, xmm2","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm1, xmm2","latency":"3","throughput":"1"},{"base":"06_17","parameters":"mm1, mm2","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"mm1, mm2","latency":"3","throughput":"1"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"1"}]},{"name":"_mm_maddubs_pi16","tech":"SSSE3","returnType":"__m64","cpuId":"SSSE3","category":"Arithmetic","description":"Vertically multiply each unsigned 8-bit integer from \"a\" with the corresponding signed 8-bit integer from \"b\", producing intermediate signed 16-bit integers. Horizontally add adjacent pairs of intermediate signed 16-bit integers, and pack the saturated results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*16\n\tdst[i+15:i] := Saturate_To_Int16( a[i+15:i+8]*b[i+15:i+8] + a[i+7:i]*b[i+7:i] )\nENDFOR","header":"tmmintrin.h","instruction":"pmaddubsw","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm1, xmm2","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm1, xmm2","latency":"3","throughput":"1"},{"base":"06_17","parameters":"mm1, mm2","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"mm1, mm2","latency":"3","throughput":"1"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"1"}]},{"name":"_mm_mulhrs_epi16","tech":"SSSE3","returnType":"__m128i","cpuId":"SSSE3","category":"Arithmetic","description":"Multiply packed 16-bit integers in \"a\" and \"b\", producing intermediate signed 32-bit integers. Truncate each intermediate integer to the 18 most significant bits, round by adding 1, and store bits [16:1] to \"dst\".","code":"FOR j := 0 to 7\n\ti := j*16\n\ttmp[31:0] := ((a[i+15:i] * b[i+15:i]) >> 14) + 1\n\tdst[i+15:i] := tmp[16:1]\nENDFOR","header":"tmmintrin.h","instruction":"pmulhrsw","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm1, xmm2","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm1, xmm2","latency":"3","throughput":"1"},{"base":"06_17","parameters":"mm1, mm2","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"mm1, mm2","latency":"3","throughput":"1"}]},{"name":"_mm_mulhrs_pi16","tech":"SSSE3","returnType":"__m64","cpuId":"SSSE3","category":"Arithmetic","description":"Multiply packed 16-bit integers in \"a\" and \"b\", producing intermediate signed 32-bit integers. Truncate each intermediate integer to the 18 most significant bits, round by adding 1, and store bits [16:1] to \"dst\".","code":"FOR j := 0 to 3\n\ti := j*16\n\ttmp[31:0] := ((a[i+15:i] * b[i+15:i]) >> 14) + 1\n\tdst[i+15:i] := tmp[16:1]\nENDFOR","header":"tmmintrin.h","instruction":"pmulhrsw","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm1, xmm2","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"xmm1, xmm2","latency":"3","throughput":"1"},{"base":"06_17","parameters":"mm1, mm2","latency":"3","throughput":"1"},{"base":"06_0F","parameters":"mm1, mm2","latency":"3","throughput":"1"}]},{"name":"_mm_sign_epi8","tech":"SSSE3","returnType":"__m128i","cpuId":"SSSE3","category":"Arithmetic","description":"Negate packed 8-bit integers in \"a\" when the corresponding signed 8-bit integer in \"b\" is negative, and store the results in \"dst\". Element in \"dst\" are zeroed out when the corresponding element in \"b\" is zero.","code":"FOR j := 0 to 15\n\ti := j*8\n\tIF b[i+7:i] < 0\n\t\tdst[i+7:i] := NEG(a[i+7:i])\n\tELSE IF b[i+7:i] = 0\n\t\tdst[i+7:i] := 0\n\tELSE\n\t\tdst[i+7:i] := a[i+7:i]\n\tFI\nENDFOR","header":"tmmintrin.h","instruction":"psignb","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_17","parameters":"mm1, mm2","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"mm1, mm2","latency":"1","throughput":"1"}]},{"name":"_mm_sign_epi16","tech":"SSSE3","returnType":"__m128i","cpuId":"SSSE3","category":"Arithmetic","description":"Negate packed 16-bit integers in \"a\" when the corresponding signed 16-bit integer in \"b\" is negative, and store the results in \"dst\". Element in \"dst\" are zeroed out when the corresponding element in \"b\" is zero.","code":"FOR j := 0 to 7\n\ti := j*16\n\tIF b[i+15:i] < 0\n\t\tdst[i+15:i] := NEG(a[i+15:i])\n\tELSE IF b[i+15:i] = 0\n\t\tdst[i+15:i] := 0\n\tELSE\n\t\tdst[i+15:i] := a[i+15:i]\n\tFI\nENDFOR","header":"tmmintrin.h","instruction":"psignw","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_17","parameters":"mm1, mm2","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"mm1, mm2","latency":"1","throughput":"1"}]},{"name":"_mm_sign_epi32","tech":"SSSE3","returnType":"__m128i","cpuId":"SSSE3","category":"Arithmetic","description":"Negate packed 32-bit integers in \"a\" when the corresponding signed 32-bit integer in \"b\" is negative, and store the results in \"dst\". Element in \"dst\" are zeroed out when the corresponding element in \"b\" is zero.","code":"FOR j := 0 to 3\n\ti := j*32\n\tIF b[i+31:i] < 0\n\t\tdst[i+31:i] := NEG(a[i+31:i])\n\tELSE IF b[i+31:i] = 0\n\t\tdst[i+31:i] := 0\n\tELSE\n\t\tdst[i+31:i] := a[i+31:i]\n\tFI\nENDFOR","header":"tmmintrin.h","instruction":"psignd","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_17","parameters":"mm1, mm2","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"mm1, mm2","latency":"1","throughput":"1"}]},{"name":"_mm_sign_pi8","tech":"SSSE3","returnType":"__m64","cpuId":"SSSE3","category":"Arithmetic","description":"Negate packed 8-bit integers in \"a\" when the corresponding signed 8-bit integer in \"b\" is negative, and store the results in \"dst\". Element in \"dst\" are zeroed out when the corresponding element in \"b\" is zero.","code":"FOR j := 0 to 7\n\ti := j*8\n\tIF b[i+7:i] < 0\n\t\tdst[i+7:i] := NEG(a[i+7:i])\n\tELSE IF b[i+7:i] = 0\n\t\tdst[i+7:i] := 0\n\tELSE\n\t\tdst[i+7:i] := a[i+7:i]\n\tFI\nENDFOR","header":"tmmintrin.h","instruction":"psignb","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_17","parameters":"mm1, mm2","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"mm1, mm2","latency":"1","throughput":"1"}]},{"name":"_mm_sign_pi16","tech":"SSSE3","returnType":"__m64","cpuId":"SSSE3","category":"Arithmetic","description":"Negate packed 16-bit integers in \"a\" when the corresponding signed 16-bit integer in \"b\" is negative, and store the results in \"dst\". Element in \"dst\" are zeroed out when the corresponding element in \"b\" is zero.","code":"FOR j := 0 to 3\n\ti := j*16\n\tIF b[i+15:i] < 0\n\t\tdst[i+15:i] := NEG(a[i+15:i])\n\tELSE IF b[i+15:i] = 0\n\t\tdst[i+15:i] := 0\n\tELSE\n\t\tdst[i+15:i] := a[i+15:i]\n\tFI\nENDFOR","header":"tmmintrin.h","instruction":"psignw","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_17","parameters":"mm1, mm2","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"mm1, mm2","latency":"1","throughput":"1"}]},{"name":"_mm_sign_pi32","tech":"SSSE3","returnType":"__m64","cpuId":"SSSE3","category":"Arithmetic","description":"Negate packed 32-bit integers in \"a\" when the corresponding signed 32-bit integer in \"b\" is negative, and store the results in \"dst\". Element in \"dst\" are zeroed out when the corresponding element in \"b\" is zero.","code":"FOR j := 0 to 1\n\ti := j*32\n\tIF b[i+31:i] < 0\n\t\tdst[i+31:i] := NEG(a[i+31:i])\n\tELSE IF b[i+31:i] = 0\n\t\tdst[i+31:i] := 0\n\tELSE\n\t\tdst[i+31:i] := a[i+31:i]\n\tFI\nENDFOR","header":"tmmintrin.h","instruction":"psignd","parameters":[{"type":"__m64","name":"a"},{"type":"__m64","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_17","parameters":"mm1, mm2","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"mm1, mm2","latency":"1","throughput":"1"}]},{"name":"_mm_blend_pd","tech":"SSE4.1","returnType":"__m128d","cpuId":"SSE4.1","category":"Swizzle","description":"Blend packed double-precision (64-bit) floating-point elements from \"a\" and \"b\" using control mask \"imm\", and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tIF imm[j]\n\t\tdst[i+63:i] := b[i+63:i]\n\tELSE\n\t\tdst[i+63:i] := a[i+63:i]\n\tFI\nENDFOR","header":"smmintrin.h","instruction":"blendpd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"},{"type":"const int","name":"imm"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm1, xmm2, imm","latency":"1","throughput":"0.33"},{"base":"06_2A/2D/3A/3E","parameters":"xmm1, xmm2, imm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2, imm","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"xmm1, xmm2, imm","latency":"1","throughput":"1"}]},{"name":"_mm_blend_ps","tech":"SSE4.1","returnType":"__m128","cpuId":"SSE4.1","category":"Swizzle","description":"Blend packed single-precision (32-bit) floating-point elements from \"a\" and \"b\" using control mask \"imm\", and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tIF imm[j]\n\t\tdst[i+31:i] := b[i+31:i]\n\tELSE\n\t\tdst[i+31:i] := a[i+31:i]\n\tFI\nENDFOR","header":"smmintrin.h","instruction":"blendps","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"},{"type":"const int","name":"imm"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm1, xmm2, imm","latency":"1","throughput":"0.33"},{"base":"06_2A/2D/3A/3E","parameters":"xmm1, xmm2, imm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2, imm","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"xmm1, xmm2, imm","latency":"1","throughput":"1"}]},{"name":"_mm_blendv_pd","tech":"SSE4.1","returnType":"__m128d","cpuId":"SSE4.1","category":"Swizzle","description":"Blend packed double-precision (64-bit) floating-point elements from \"a\" and \"b\" using \"mask\", and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tIF mask[i+63]\n\t\tdst[i+63:i] := b[i+63:i]\n\tELSE\n\t\tdst[i+63:i] := a[i+63:i]\n\tFI\nENDFOR","header":"smmintrin.h","instruction":"blendvpd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"},{"type":"__m128d","name":"mask"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm1, xmm2","latency":"2","throughput":"2"},{"base":"06_2A/2D/3A/3E","parameters":"xmm1, xmm2","latency":"2","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2","latency":"2","throughput":"2"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"2","throughput":"2"}]},{"name":"_mm_blendv_ps","tech":"SSE4.1","returnType":"__m128","cpuId":"SSE4.1","category":"Swizzle","description":"Blend packed single-precision (32-bit) floating-point elements from \"a\" and \"b\" using \"mask\", and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tIF mask[i+31]\n\t\tdst[i+31:i] := b[i+31:i]\n\tELSE\n\t\tdst[i+31:i] := a[i+31:i]\n\tFI\nENDFOR","header":"smmintrin.h","instruction":"blendvps","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"},{"type":"__m128","name":"mask"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm1, xmm2","latency":"2","throughput":"2"},{"base":"06_2A/2D/3A/3E","parameters":"xmm1, xmm2","latency":"2","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2","latency":"2","throughput":"2"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"2","throughput":"2"}]},{"name":"_mm_blendv_epi8","tech":"SSE4.1","returnType":"__m128i","cpuId":"SSE4.1","category":"Swizzle","description":"Blend packed 8-bit integers from \"a\" and \"b\" using \"mask\", and store the results in \"dst\".","code":"FOR j := 0 to 15\n\ti := j*8\n\tIF mask[i+7]\n\t\tdst[i+7:i] := b[i+7:i]\n\tELSE\n\t\tdst[i+7:i] := a[i+7:i]\n\tFI\nENDFOR","header":"smmintrin.h","instruction":"pblendvb","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"},{"type":"__m128i","name":"mask"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_blend_epi16","tech":"SSE4.1","returnType":"__m128i","cpuId":"SSE4.1","category":"Swizzle","description":"Blend packed 16-bit integers from \"a\" and \"b\" using control mask \"imm\", and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*16\n\tIF imm[j]\n\t\tdst[i+15:i] := b[i+15:i]\n\tELSE\n\t\tdst[i+15:i] := a[i+15:i]\n\tFI\nENDFOR","header":"smmintrin.h","instruction":"pblendw","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"},{"type":"const int","name":"imm"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm1, xmm2, imm","latency":"1","throughput":"1"},{"base":"06_2A/2D/3A/3E","parameters":"xmm1, xmm2, imm","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2, imm","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"xmm1, xmm2, imm","latency":"1","throughput":"1"}]},{"name":"_mm_dp_pd","tech":"SSE4.1","returnType":"__m128d","cpuId":"SSE4.1","category":"Arithmetic","description":"Conditionally multiply the packed double-precision (64-bit) floating-point elements in \"a\" and \"b\" using the high 4 bits in \"imm\", sum the four products, and conditionally store the sum in \"dst\" using the low 4 bits of \"imm\".","code":"DP(a[127:0], b[127:0], imm[7:0]) {\n\tFOR j := 0 to 1\n\t\tIF imm[4+j]\n\t\t\ttemp[i+63:i] := a[i+63:i] * b[i+63:i]\n\t\tELSE\n\t\t\ttemp[i+63:i] := 0\n\t\tFI\n\tENDFOR\n\n\tsum[63:0] := temp[127:64] + temp[63:0]\n\n\tFOR j := 0 to 1\n\t\tIF imm[j]\n\t\t\ttmpdst[i+63:i] := temp[63:0]\n\t\tELSE\n\t\t\ttmpdst[i+63:i] := 0\n\t\tFI\n\tENDFOR\n\tRETURN tmpdst[127:0]\n}\n\ndst[127:0] := DP(a[127:0], b[127:0], imm[7:0])","header":"smmintrin.h","instruction":"dppd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"},{"type":"const int","name":"imm"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm1, xmm2","latency":"9","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2","latency":"9","throughput":"2"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"9","throughput":"2"}]},{"name":"_mm_dp_ps","tech":"SSE4.1","returnType":"__m128","cpuId":"SSE4.1","category":"Arithmetic","description":"Conditionally multiply the packed single-precision (32-bit) floating-point elements in \"a\" and \"b\" using the high 4 bits in \"imm\", sum the four products, and conditionally store the sum in \"dst\" using the low 4 bits of \"imm\".","code":"DP(a[127:0], b[127:0], imm[7:0]) {\n\tFOR j := 0 to 3\n\t\tIF imm[4+j]\n\t\t\ttemp[i+31:i] := a[i+31:i] * b[i+31:i]\n\t\tELSE\n\t\t\ttemp[i+31:i] := 0\n\t\tFI\n\tENDFOR\n\n\tsum[31:0] := temp[127:96] + temp[95:64] + temp[63:32] + temp[31:0]\n\n\tFOR j := 0 to 3\n\t\tIF imm[j]\n\t\t\ttmpdst[i+31:i] := temp[31:0]\n\t\tELSE\n\t\t\ttmpdst[i+31:i] := 0\n\t\tFI\n\tENDFOR\n\tRETURN tmpdst[127:0]\n}\n\ndst[127:0] := DP(a[127:0], b[127:0], imm[7:0])","header":"smmintrin.h","instruction":"dpps","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"},{"type":"const int","name":"imm"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E3C/45/46","parameters":"xmm1, xmm2","latency":"12","throughput":"2"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2","latency":"11","throughput":"2"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"11","throughput":"2"}]},{"name":"_mm_extract_ps","tech":"SSE4.1","returnType":"int","cpuId":"SSE4.1","category":"Swizzle","description":"Extract a single-precision (32-bit) floating-point element from \"a\", selected with \"imm\", and store the result in the lower element of \"dst\".","code":"dst[31:0] := (a[127:0] >> (imm[1:0] * 32))[31:0]","header":"smmintrin.h","instruction":"extractps","parameters":[{"type":"__m128","name":"a"},{"type":"const int","name":"imm"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E3C/45/46","parameters":"xmm1, xmm2, imm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2, imm","latency":"2","throughput":"1"},{"base":"06_17/1D","parameters":"xmm1, xmm2, imm","latency":"5","throughput":"1"}]},{"name":"_mm_extract_epi8","tech":"SSE4.1","returnType":"int","cpuId":"SSE4.1","category":"Swizzle","description":"Extract an 8-bit integer from \"a\", selected with \"imm\", and store the result in the lower element of \"dst\".","code":"dst[7:0] := (a[127:0] >> (imm[3:0] * 8))[7:0]\ndst[31:8] := 0","header":"smmintrin.h","instruction":"pextrb","parameters":[{"type":"__m128i","name":"a"},{"type":"const int","name":"imm"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"reg, xmm, imm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"reg, xmm, imm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"reg, xmm, imm","latency":"5","throughput":"1"}]},{"name":"_mm_extract_epi32","tech":"SSE4.1","returnType":"int","cpuId":"SSE4.1","category":"Swizzle","description":"Extract a 32-bit integer from \"a\", selected with \"imm\", and store the result in \"dst\".","code":"dst[31:0] := (a[127:0] >> (imm[1:0] * 32))[31:0]","header":"smmintrin.h","instruction":"pextrd","parameters":[{"type":"__m128i","name":"a"},{"type":"const int","name":"imm"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"reg, xmm, imm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"reg, xmm, imm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"reg, xmm, imm","latency":"5","throughput":"1"}]},{"name":"_mm_extract_epi64","tech":"SSE4.1","returnType":"__int64","cpuId":"SSE4.1","category":"Swizzle","description":"Extract a 64-bit integer from \"a\", selected with \"imm\", and store the result in \"dst\".","code":"dst[63:0] := (a[127:0] >> (imm[0] * 64))[63:0]","header":"smmintrin.h","instruction":"pextrq","parameters":[{"type":"__m128i","name":"a"},{"type":"const int","name":"imm"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_insert_ps","tech":"SSE4.1","returnType":"__m128","cpuId":"SSE4.1","category":"Swizzle","description":"Copy \"a\" to \"tmp\", then insert a single-precision (32-bit) floating-point element from \"b\" into \"tmp\" using the control in \"imm\".  Store \"tmp\" to \"dst\" using the mask in \"imm\" (elements are zeroed out when the corresponding bit is set).","code":"tmp2[127:0] := a[127:0]\nCASE (imm[7:6]) of\n\t0: tmp1[31:0] := b[31:0]\n\t1: tmp1[31:0] := b[63:32]\n\t2: tmp1[31:0] := b[95:64]\n\t3: tmp1[31:0] := b[127:96]\nESAC\nCASE (imm[5:4]) of\n\t0: tmp2[31:0] := tmp1[31:0]\n\t1: tmp2[63:32] := tmp1[31:0]\n\t2: tmp2[95:64] := tmp1[31:0]\n\t3: tmp2[127:96] := tmp1[31:0]\nESAC\nFOR j := 0 to 3\n\ti := j*32\n\tIF imm[j]\n\t\tdst[i+31:i] := 0\n\tELSE\n\t\tdst[i+31:i] := tmp2[i+31:i]\n\tFI\nENDFOR","header":"smmintrin.h","instruction":"insertps","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"},{"type":"const int","name":"imm"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E3C/45/46","parameters":"xmm1, xmm2, imm","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2, imm","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"xmm1, xmm2, imm","latency":"1","throughput":"1"}]},{"name":"_mm_insert_epi8","tech":"SSE4.1","returnType":"__m128i","cpuId":"SSE4.1","category":"Swizzle","description":"Copy \"a\" to \"dst\", and insert the lower 8-bit integer from \"i\" into \"dst\" at the location specified by \"imm\".","code":"dst[127:0] := a[127:0]\nsel := imm[3:0]*8\ndst[sel+7:sel] := i[7:0]","header":"smmintrin.h","instruction":"pinsrb","parameters":[{"type":"__m128i","name":"a"},{"type":"int","name":"i"},{"type":"const int","name":"imm"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E","parameters":"xmm, reg, imm","latency":"2","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, reg, imm","latency":"2","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, reg, imm","latency":"4","throughput":"1"}]},{"name":"_mm_insert_epi32","tech":"SSE4.1","returnType":"__m128i","cpuId":"SSE4.1","category":"Swizzle","description":"Copy \"a\" to \"dst\", and insert the 32-bit integer \"i\" into \"dst\" at the location specified by \"imm\".","code":"dst[127:0] := a[127:0]\nsel := imm[1:0]*32\ndst[sel+31:sel] := i[31:0]","header":"smmintrin.h","instruction":"pinsrd","parameters":[{"type":"__m128i","name":"a"},{"type":"int","name":"i"},{"type":"const int","name":"imm"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, reg, imm","latency":"2","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, reg, imm","latency":"2","throughput":"1"},{"base":"06_17/1D","parameters":"xmm, reg, imm","latency":"4","throughput":"1"}]},{"name":"_mm_insert_epi64","tech":"SSE4.1","returnType":"__m128i","cpuId":"SSE4.1","category":"Swizzle","description":"Copy \"a\" to \"dst\", and insert the 64-bit integer \"i\" into \"dst\" at the location specified by \"imm\".","code":"dst[127:0] := a[127:0]\nsel := imm[0]*64\ndst[sel+63:sel] := i[63:0]","header":"smmintrin.h","instruction":"pinsrq","parameters":[{"type":"__m128i","name":"a"},{"type":"__int64","name":"i"},{"type":"const int","name":"imm"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_max_epi8","tech":"SSE4.1","returnType":"__m128i","cpuId":"SSE4.1","category":"Special Math Functions","description":"Compare packed 8-bit integers in \"a\" and \"b\", and store packed maximum values in \"dst\".","code":"FOR j := 0 to 15\n\ti := j*8\n\tIF a[i+7:i] > b[i+7:i]\n\t\tdst[i+7:i] := a[i+7:i]\n\tELSE\n\t\tdst[i+7:i] := b[i+7:i]\n\tFI\nENDFOR","header":"smmintrin.h","instruction":"pmaxsb","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"1","throughput":"1"}]},{"name":"_mm_max_epi32","tech":"SSE4.1","returnType":"__m128i","cpuId":"SSE4.1","category":"Special Math Functions","description":"Compare packed 32-bit integers in \"a\" and \"b\", and store packed maximum values in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tIF a[i+31:i] > b[i+31:i]\n\t\tdst[i+31:i] := a[i+31:i]\n\tELSE\n\t\tdst[i+31:i] := b[i+31:i]\n\tFI\nENDFOR","header":"smmintrin.h","instruction":"pmaxsd","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"1","throughput":"1"}]},{"name":"_mm_max_epu32","tech":"SSE4.1","returnType":"__m128i","cpuId":"SSE4.1","category":"Special Math Functions","description":"Compare packed unsigned 32-bit integers in \"a\" and \"b\", and store packed maximum values in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tIF a[i+31:i] > b[i+31:i]\n\t\tdst[i+31:i] := a[i+31:i]\n\tELSE\n\t\tdst[i+31:i] := b[i+31:i]\n\tFI\nENDFOR","header":"smmintrin.h","instruction":"pmaxud","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"1","throughput":"1"}]},{"name":"_mm_max_epu16","tech":"SSE4.1","returnType":"__m128i","cpuId":"SSE4.1","category":"Special Math Functions","description":"Compare packed unsigned 16-bit integers in \"a\" and \"b\", and store packed maximum values in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*16\n\tIF a[i+15:i] > b[i+15:i]\n\t\tdst[i+15:i] := a[i+15:i]\n\tELSE\n\t\tdst[i+15:i] := b[i+15:i]\n\tFI\nENDFOR","header":"smmintrin.h","instruction":"pmaxuw","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"1","throughput":"1"}]},{"name":"_mm_min_epi8","tech":"SSE4.1","returnType":"__m128i","cpuId":"SSE4.1","category":"Special Math Functions","description":"Compare packed 8-bit integers in \"a\" and \"b\", and store packed minimum values in \"dst\".","code":"FOR j := 0 to 15\n\ti := j*8\n\tIF a[i+7:i] < b[i+7:i]\n\t\tdst[i+7:i] := a[i+7:i]\n\tELSE\n\t\tdst[i+7:i] := b[i+7:i]\n\tFI\nENDFOR","header":"smmintrin.h","instruction":"pminsb","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"1","throughput":"1"}]},{"name":"_mm_min_epi32","tech":"SSE4.1","returnType":"__m128i","cpuId":"SSE4.1","category":"Special Math Functions","description":"Compare packed 32-bit integers in \"a\" and \"b\", and store packed minimum values in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tIF a[i+31:i] < b[i+31:i]\n\t\tdst[i+31:i] := a[i+31:i]\n\tELSE\n\t\tdst[i+31:i] := b[i+31:i]\n\tFI\nENDFOR","header":"smmintrin.h","instruction":"pminsd","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"1","throughput":"1"}]},{"name":"_mm_min_epu32","tech":"SSE4.1","returnType":"__m128i","cpuId":"SSE4.1","category":"Special Math Functions","description":"Compare packed unsigned 32-bit integers in \"a\" and \"b\", and store packed minimum values in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tIF a[i+31:i] < b[i+31:i]\n\t\tdst[i+31:i] := a[i+31:i]\n\tELSE\n\t\tdst[i+31:i] := b[i+31:i]\n\tFI\nENDFOR","header":"smmintrin.h","instruction":"pminud","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"1","throughput":"1"}]},{"name":"_mm_min_epu16","tech":"SSE4.1","returnType":"__m128i","cpuId":"SSE4.1","category":"Special Math Functions","description":"Compare packed unsigned 16-bit integers in \"a\" and \"b\", and store packed minimum values in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*16\n\tIF a[i+15:i] < b[i+15:i]\n\t\tdst[i+15:i] := a[i+15:i]\n\tELSE\n\t\tdst[i+15:i] := b[i+15:i]\n\tFI\nENDFOR","header":"smmintrin.h","instruction":"pminuw","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"1","throughput":"1"}]},{"name":"_mm_packus_epi32","tech":"SSE4.1","returnType":"__m128i","cpuId":"SSE4.1","category":"Convert","description":"Convert packed 32-bit integers from \"a\" and \"b\" to packed 16-bit integers using unsigned saturation, and store the results in \"dst\".","code":"dst[15:0] := Saturate_Int32_To_UnsignedInt16 (a[31:0])\ndst[31:16] := Saturate_Int32_To_UnsignedInt16 (a[63:32])\ndst[47:32] := Saturate_Int32_To_UnsignedInt16 (a[95:64])\ndst[63:48] := Saturate_Int32_To_UnsignedInt16 (a[127:96])\ndst[79:64] := Saturate_Int32_To_UnsignedInt16 (b[31:0])\ndst[95:80] := Saturate_Int32_To_UnsignedInt16 (b[63:32])\ndst[111:96] := Saturate_Int32_To_UnsignedInt16 (b[95:64])\ndst[127:112] := Saturate_Int32_To_UnsignedInt16 (b[127:96])","header":"smmintrin.h","instruction":"packusdw","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm1, xmm2","latency":"1","throughput":"1"},{"base":"06_2A/2D/3A/3E","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"1","throughput":"2"}]},{"name":"_mm_cmpeq_epi64","tech":"SSE4.1","returnType":"__m128i","cpuId":"SSE4.1","category":"Compare","description":"Compare packed 64-bit integers in \"a\" and \"b\" for equality, and store the results in \"dst\".","code":"FOR j := 0 to 1\n  i := j*64\n  dst[i+63:i] := ( a[i+63:i] == b[i+63:i] ) ? 0xFFFFFFFFFFFFFFFF : 0\nENDFOR","header":"smmintrin.h","instruction":"pcmpeqq","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"1","throughput":"1"}]},{"name":"_mm_cvtepi8_epi16","tech":"SSE4.1","returnType":"__m128i","cpuId":"SSE4.1","category":"Convert","description":"Sign extend packed 8-bit integers in \"a\" to packed 16-bit integers, and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*8\n\tl := j*16\n\tdst[l+15:l] := SignExtend(a[i+7:i])\nENDFOR","header":"smmintrin.h","instruction":"pmovsxbw","parameters":[{"type":"__m128i","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"1","throughput":"1"}]},{"name":"_mm_cvtepi8_epi32","tech":"SSE4.1","returnType":"__m128i","cpuId":"SSE4.1","category":"Convert","description":"Sign extend packed 8-bit integers in \"a\" to packed 32-bit integers, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := 32*j\n\tk := 8*j\n\tdst[i+31:i] := SignExtend(a[k+7:k])\nENDFOR","header":"smmintrin.h","instruction":"pmovsxbd","parameters":[{"type":"__m128i","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"1","throughput":"1"}]},{"name":"_mm_cvtepi8_epi64","tech":"SSE4.1","returnType":"__m128i","cpuId":"SSE4.1","category":"Convert","description":"Sign extend packed 8-bit integers in the low 8 bytes of \"a\" to packed 64-bit integers, and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := 64*j\n\tk := 8*j\n\tdst[i+63:i] := SignExtend(a[k+7:k])\nENDFOR","header":"smmintrin.h","instruction":"pmovsxbq","parameters":[{"type":"__m128i","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"1","throughput":"1"}]},{"name":"_mm_cvtepi16_epi32","tech":"SSE4.1","returnType":"__m128i","cpuId":"SSE4.1","category":"Convert","description":"Sign extend packed 16-bit integers in \"a\" to packed 32-bit integers, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := 32*j\n\tk := 16*j\n\tdst[i+31:i] := SignExtend(a[k+15:k])\nENDFOR","header":"smmintrin.h","instruction":"pmovsxwd","parameters":[{"type":"__m128i","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"1","throughput":"1"}]},{"name":"_mm_cvtepi16_epi64","tech":"SSE4.1","returnType":"__m128i","cpuId":"SSE4.1","category":"Convert","description":"Sign extend packed 16-bit integers in \"a\" to packed 64-bit integers, and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := 64*j\n\tk := 16*j\n\tdst[i+63:i] := SignExtend(a[k+15:k])\nENDFOR","header":"smmintrin.h","instruction":"pmovsxwq","parameters":[{"type":"__m128i","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"1","throughput":"1"}]},{"name":"_mm_cvtepi32_epi64","tech":"SSE4.1","returnType":"__m128i","cpuId":"SSE4.1","category":"Convert","description":"Sign extend packed 32-bit integers in \"a\" to packed 64-bit integers, and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := 64*j\n\tk := 32*j\n\tdst[i+63:i] := SignExtend(a[k+31:k])\nENDFOR","header":"smmintrin.h","instruction":"pmovsxdq","parameters":[{"type":"__m128i","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"1","throughput":"1"}]},{"name":"_mm_cvtepu8_epi16","tech":"SSE4.1","returnType":"__m128i","cpuId":"SSE4.1","category":"Convert","description":"Zero extend packed unsigned 8-bit integers in \"a\" to packed 16-bit integers, and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*8\n\tl := j*16\n\tdst[l+15:l] := ZeroExtend(a[i+7:i])\nENDFOR","header":"smmintrin.h","instruction":"pmovzxbw","parameters":[{"type":"__m128i","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"1","throughput":"1"}]},{"name":"_mm_cvtepu8_epi32","tech":"SSE4.1","returnType":"__m128i","cpuId":"SSE4.1","category":"Convert","description":"Zero extend packed unsigned 8-bit integers in \"a\" to packed 32-bit integers, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := 32*j\n\tk := 8*j\n\tdst[i+31:i] := ZeroExtend(a[k+7:k])\nENDFOR","header":"smmintrin.h","instruction":"pmovzxbd","parameters":[{"type":"__m128i","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"1","throughput":"1"}]},{"name":"_mm_cvtepu8_epi64","tech":"SSE4.1","returnType":"__m128i","cpuId":"SSE4.1","category":"Convert","description":"Zero extend packed unsigned 8-bit integers in the low 8 byte sof \"a\" to packed 64-bit integers, and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := 64*j\n\tk := 8*j\n\tdst[i+63:i] := ZeroExtend(a[k+7:k])\nENDFOR","header":"smmintrin.h","instruction":"pmovzxbq","parameters":[{"type":"__m128i","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"1","throughput":"1"}]},{"name":"_mm_cvtepu16_epi32","tech":"SSE4.1","returnType":"__m128i","cpuId":"SSE4.1","category":"Convert","description":"Zero extend packed unsigned 16-bit integers in \"a\" to packed 32-bit integers, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := 32*j\n\tk := 16*j\n\tdst[i+31:i] := ZeroExtend(a[k+15:k])\nENDFOR","header":"smmintrin.h","instruction":"pmovzxwd","parameters":[{"type":"__m128i","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"1","throughput":"1"}]},{"name":"_mm_cvtepu16_epi64","tech":"SSE4.1","returnType":"__m128i","cpuId":"SSE4.1","category":"Convert","description":"Zero extend packed unsigned 16-bit integers in \"a\" to packed 64-bit integers, and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := 64*j\n\tk := 16*j\n\tdst[i+63:i] := ZeroExtend(a[k+15:k])\nENDFOR","header":"smmintrin.h","instruction":"pmovzxwq","parameters":[{"type":"__m128i","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"1","throughput":"1"}]},{"name":"_mm_cvtepu32_epi64","tech":"SSE4.1","returnType":"__m128i","cpuId":"SSE4.1","category":"Convert","description":"Zero extend packed unsigned 32-bit integers in \"a\" to packed 64-bit integers, and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := 64*j\n\tk := 32*j\n\tdst[i+63:i] := ZeroExtend(a[k+31:k])\nENDFOR","header":"smmintrin.h","instruction":"pmovzxdq","parameters":[{"type":"__m128i","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm1, xmm2","latency":"1","throughput":"0.5"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2","latency":"1","throughput":"1"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"1","throughput":"1"}]},{"name":"_mm_mul_epi32","tech":"SSE4.1","returnType":"__m128i","cpuId":"SSE4.1","category":"Arithmetic","description":"Multiply the low 32-bit integers from each packed 64-bit element in \"a\" and \"b\", and store the signed 64-bit results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := a[i+31:i] * b[i+31:i]\nENDFOR","header":"smmintrin.h","instruction":"pmuldq","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm1, xmm2","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"3","throughput":"1"}]},{"name":"_mm_mullo_epi32","tech":"SSE4.1","returnType":"__m128i","cpuId":"SSE4.1","category":"Arithmetic","description":"Multiply the packed 32-bit integers in \"a\" and \"b\", producing intermediate 64-bit integers, and store the low 32 bits of the intermediate integers in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\ttmp[63:0] := a[i+31:i] * b[i+31:i]\n\tdst[i+31:i] := tmp[31:0]\nENDFOR","header":"smmintrin.h","instruction":"pmulld","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm1, xmm2","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2","latency":"6","throughput":"2"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"5","throughput":"2"}]},{"name":"_mm_testz_si128","tech":"SSE4.1","returnType":"int","cpuId":"SSE4.1","category":"Logical","description":"Compute the bitwise AND of 128 bits (representing integer data) in \"a\" and \"b\", and set \"ZF\" to 1 if the result is zero, otherwise set \"ZF\" to 0. Compute the bitwise AND NOT of \"a\" and \"b\", and set \"CF\" to 1 if the result is zero, otherwise set \"CF\" to 0. Return the \"ZF\" value.","code":"IF (a[127:0] AND b[127:0] == 0)\n\tZF := 1\nELSE\n\tZF := 0\nFI\nIF (a[127:0] AND NOT b[127:0] == 0)\n\tCF := 1\nELSE\n\tCF := 0\nFI\nRETURN ZF","header":"smmintrin.h","instruction":"ptest","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm1, xmm2","latency":"2","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2","latency":"2","throughput":"1"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"2","throughput":"1"}]},{"name":"_mm_testc_si128","tech":"SSE4.1","returnType":"int","cpuId":"SSE4.1","category":"Logical","description":"Compute the bitwise AND of 128 bits (representing integer data) in \"a\" and \"b\", and set \"ZF\" to 1 if the result is zero, otherwise set \"ZF\" to 0. Compute the bitwise AND NOT of \"a\" and \"b\", and set \"CF\" to 1 if the result is zero, otherwise set \"CF\" to 0. Return the \"CF\" value.","code":"IF (a[127:0] AND b[127:0] == 0)\n\tZF := 1\nELSE\n\tZF := 0\nFI\nIF (a[127:0] AND NOT b[127:0] == 0)\n\tCF := 1\nELSE\n\tCF := 0\nFI\nRETURN CF","header":"smmintrin.h","instruction":"ptest","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm1, xmm2","latency":"2","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2","latency":"2","throughput":"1"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"2","throughput":"1"}]},{"name":"_mm_testnzc_si128","tech":"SSE4.1","returnType":"int","cpuId":"SSE4.1","category":"Logical","description":"Compute the bitwise AND of 128 bits (representing integer data) in \"a\" and \"b\", and set \"ZF\" to 1 if the result is zero, otherwise set \"ZF\" to 0. Compute the bitwise AND NOT of \"a\" and \"b\", and set \"CF\" to 1 if the result is zero, otherwise set \"CF\" to 0. Return 1 if both the \"ZF\" and \"CF\" values are zero, otherwise return 0.","code":"IF (a[127:0] AND b[127:0] == 0)\n\tZF := 1\nELSE\n\tZF := 0\nFI\nIF (a[127:0] AND NOT b[127:0] == 0)\n\tCF := 1\nELSE\n\tCF := 0\nFI\nIF (ZF == 0 && CF == 0)\n\tRETURN 1\nELSE\n\tRETURN 0\nFI","header":"smmintrin.h","instruction":"ptest","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm1, xmm2","latency":"2","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2","latency":"2","throughput":"1"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"2","throughput":"1"}]},{"name":"_mm_test_all_zeros","tech":"SSE4.1","returnType":"int","cpuId":"SSE4.1","category":"Logical","description":"Compute the bitwise AND of 128 bits (representing integer data) in \"a\" and \"mask\", and return 1 if the result is zero, otherwise return 0.","code":"IF (a[127:0] AND mask[127:0] == 0)\n\tZF := 1\nELSE\n\tZF := 0\nFI\nRETURN ZF","header":"smmintrin.h","instruction":"ptest","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"mask"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm1, xmm2","latency":"2","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2","latency":"2","throughput":"1"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"2","throughput":"1"}]},{"name":"_mm_test_mix_ones_zeros","tech":"SSE4.1","returnType":"int","cpuId":"SSE4.1","category":"Logical","description":"Compute the bitwise AND of 128 bits (representing integer data) in \"a\" and \"mask\", and set \"ZF\" to 1 if the result is zero, otherwise set \"ZF\" to 0. Compute the bitwise AND NOT of \"a\" and \"mask\", and set \"CF\" to 1 if the result is zero, otherwise set \"CF\" to 0. Return 1 if both the \"ZF\" and \"CF\" values are zero, otherwise return 0.","code":"IF (a[127:0] AND mask[127:0] == 0)\n\tZF := 1\nELSE\n\tZF := 0\nFI\nIF (a[127:0] AND NOT mask[127:0] == 0)\n\tCF := 1\nELSE\n\tCF := 0\nFI\nIF (ZF == 0 && CF == 0)\n\tRETURN 1\nELSE\n\tRETURN 0\nFI","header":"smmintrin.h","instruction":"ptest","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"mask"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm1, xmm2","latency":"2","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2","latency":"2","throughput":"1"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"2","throughput":"1"}]},{"name":"_mm_test_all_ones","tech":"SSE4.1","returnType":"int","cpuId":"SSE4.1","category":"Logical","description":"Compute the complement of \"a\" and 0xFFFFFFFF, and return 1 if the result is zero, otherwise return 0.","code":"IF (a[127:0] AND NOT 0xFFFFFFFF == 0)\n\tCF := 1\nELSE\n\tCF := 0\nFI\nRETURN CF","header":"smmintrin.h","instruction":"ptest","parameters":[{"type":"__m128i","name":"a"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm1, xmm2","latency":"2","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2","latency":"2","throughput":"1"},{"base":"06_17/1D","parameters":"xmm1, xmm2","latency":"2","throughput":"1"}]},{"name":"_mm_round_pd","tech":"SSE4.1","returnType":"__m128d","cpuId":"SSE4.1","category":"Special Math Functions","description":"Round the packed double-precision (64-bit) floating-point elements in \"a\" using the \"rounding\" parameter, and store the results as packed double-precision floating-point elements in \"dst\".\n\t[round_note]","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := ROUND(a[i+63:i])\nENDFOR","header":"smmintrin.h","instruction":"roundpd","parameters":[{"type":"__m128d","name":"a"},{"type":"int","name":"rounding"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm1, xmm2, imm","latency":"6","throughput":"2"},{"base":"06_2A/2D/3A/3E","parameters":"xmm1, xmm2, imm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2, imm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm1, xmm2, imm","latency":"1","throughput":"1"}]},{"name":"_mm_floor_pd","tech":"SSE4.1","returnType":"__m128d","cpuId":"SSE4.1","category":"Special Math Functions","description":"Round the packed double-precision (64-bit) floating-point elements in \"a\" down to an integer value, and store the results as packed double-precision floating-point elements in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := FLOOR(a[i+63:i])\nENDFOR","header":"smmintrin.h","instruction":"roundpd","parameters":[{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm1, xmm2, imm","latency":"6","throughput":"2"},{"base":"06_2A/2D/3A/3E","parameters":"xmm1, xmm2, imm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2, imm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm1, xmm2, imm","latency":"1","throughput":"1"}]},{"name":"_mm_ceil_pd","tech":"SSE4.1","returnType":"__m128d","cpuId":"SSE4.1","category":"Special Math Functions","description":"Round the packed double-precision (64-bit) floating-point elements in \"a\" up to an integer value, and store the results as packed double-precision floating-point elements in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := CEIL(a[i+63:i])\nENDFOR","header":"smmintrin.h","instruction":"roundpd","parameters":[{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm1, xmm2, imm","latency":"6","throughput":"2"},{"base":"06_2A/2D/3A/3E","parameters":"xmm1, xmm2, imm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2, imm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm1, xmm2, imm","latency":"1","throughput":"1"}]},{"name":"_mm_round_ps","tech":"SSE4.1","returnType":"__m128","cpuId":"SSE4.1","category":"Special Math Functions","description":"Round the packed single-precision (32-bit) floating-point elements in \"a\" using the \"rounding\" parameter, and store the results as packed single-precision floating-point elements in \"dst\".\n\t[round_note]","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := ROUND(a[i+31:i])\nENDFOR","header":"smmintrin.h","instruction":"roundps","parameters":[{"type":"__m128","name":"a"},{"type":"int","name":"rounding"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm1, xmm2, imm","latency":"6","throughput":"2"},{"base":"06_2A/2D/3A/3E","parameters":"xmm1, xmm2, imm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2, imm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm1, xmm2, imm","latency":"1","throughput":"1"}]},{"name":"_mm_floor_ps","tech":"SSE4.1","returnType":"__m128","cpuId":"SSE4.1","category":"Special Math Functions","description":"Round the packed single-precision (32-bit) floating-point elements in \"a\" down to an integer value, and store the results as packed single-precision floating-point elements in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := FLOOR(a[i+31:i])\nENDFOR","header":"smmintrin.h","instruction":"roundps","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm1, xmm2, imm","latency":"6","throughput":"2"},{"base":"06_2A/2D/3A/3E","parameters":"xmm1, xmm2, imm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2, imm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm1, xmm2, imm","latency":"1","throughput":"1"}]},{"name":"_mm_ceil_ps","tech":"SSE4.1","returnType":"__m128","cpuId":"SSE4.1","category":"Special Math Functions","description":"Round the packed single-precision (32-bit) floating-point elements in \"a\" up to an integer value, and store the results as packed single-precision floating-point elements in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := CEIL(a[i+31:i])\nENDFOR","header":"smmintrin.h","instruction":"roundps","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm1, xmm2, imm","latency":"6","throughput":"2"},{"base":"06_2A/2D/3A/3E","parameters":"xmm1, xmm2, imm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2, imm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm1, xmm2, imm","latency":"1","throughput":"1"}]},{"name":"_mm_round_sd","tech":"SSE4.1","returnType":"__m128d","cpuId":"SSE4.1","category":"Special Math Functions","description":"Round the lower double-precision (64-bit) floating-point element in \"b\" using the \"rounding\" parameter, store the result as a double-precision floating-point element in the lower element of \"dst\", and copy the upper element from \"a\" to the upper element of \"dst\".\n\t[round_note]","code":"dst[63:0] := ROUND(b[63:0])\ndst[127:64] := a[127:64]","header":"smmintrin.h","instruction":"roundsd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"},{"type":"int","name":"rounding"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm1, xmm2, imm","latency":"6","throughput":"2"},{"base":"06_2A/2D/3A/3E","parameters":"xmm1, xmm2, imm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2, imm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm1, xmm2, imm","latency":"1","throughput":"1"}]},{"name":"_mm_floor_sd","tech":"SSE4.1","returnType":"__m128d","cpuId":"SSE4.1","category":"Special Math Functions","description":"Round the lower double-precision (64-bit) floating-point element in \"b\" down to an integer value, store the result as a double-precision floating-point element in the lower element of \"dst\", and copy the upper element from \"a\" to the upper element of \"dst\".","code":"dst[63:0] := FLOOR(b[63:0])\ndst[127:64] := a[127:64]","header":"smmintrin.h","instruction":"roundsd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm1, xmm2, imm","latency":"6","throughput":"2"},{"base":"06_2A/2D/3A/3E","parameters":"xmm1, xmm2, imm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2, imm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm1, xmm2, imm","latency":"1","throughput":"1"}]},{"name":"_mm_ceil_sd","tech":"SSE4.1","returnType":"__m128d","cpuId":"SSE4.1","category":"Special Math Functions","description":"Round the lower double-precision (64-bit) floating-point element in \"b\" up to an integer value, store the result as a double-precision floating-point element in the lower element of \"dst\", and copy the upper element from \"a\" to the upper element of \"dst\".","code":"dst[63:0] := CEIL(b[63:0])\ndst[127:64] := a[127:64]","header":"smmintrin.h","instruction":"roundsd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm1, xmm2, imm","latency":"6","throughput":"2"},{"base":"06_2A/2D/3A/3E","parameters":"xmm1, xmm2, imm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2, imm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm1, xmm2, imm","latency":"1","throughput":"1"}]},{"name":"_mm_round_ss","tech":"SSE4.1","returnType":"__m128","cpuId":"SSE4.1","category":"Special Math Functions","description":"Round the lower single-precision (32-bit) floating-point element in \"b\" using the \"rounding\" parameter, store the result as a single-precision floating-point element in the lower element of \"dst\", and copy the upper 3 packed elements from \"a\" to the upper elements of \"dst\".\n\t[round_note]","code":"dst[31:0] := ROUND(b[31:0])\ndst[127:32] := a[127:32]","header":"smmintrin.h","instruction":"roundss","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"},{"type":"int","name":"rounding"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm1, xmm2, imm","latency":"6","throughput":"2"},{"base":"06_2A/2D/3A/3E","parameters":"xmm1, xmm2, imm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2, imm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm1, xmm2, imm","latency":"1","throughput":"1"}]},{"name":"_mm_floor_ss","tech":"SSE4.1","returnType":"__m128","cpuId":"SSE4.1","category":"Special Math Functions","description":"Round the lower single-precision (32-bit) floating-point element in \"b\" down to an integer value, store the result as a single-precision floating-point element in the lower element of \"dst\", and copy the upper 3 packed elements from \"a\" to the upper elements of \"dst\".","code":"dst[31:0] := FLOOR(b[31:0])\ndst[127:32] := a[127:32]","header":"smmintrin.h","instruction":"roundss","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm1, xmm2, imm","latency":"6","throughput":"2"},{"base":"06_2A/2D/3A/3E","parameters":"xmm1, xmm2, imm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2, imm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm1, xmm2, imm","latency":"1","throughput":"1"}]},{"name":"_mm_ceil_ss","tech":"SSE4.1","returnType":"__m128","cpuId":"SSE4.1","category":"Special Math Functions","description":"Round the lower single-precision (32-bit) floating-point element in \"b\" up to an integer value, store the result as a single-precision floating-point element in the lower element of \"dst\", and copy the upper 3 packed elements from \"a\" to the upper elements of \"dst\".","code":"dst[31:0] := CEIL(b[31:0])\ndst[127:32] := a[127:32]","header":"smmintrin.h","instruction":"roundss","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm1, xmm2, imm","latency":"6","throughput":"2"},{"base":"06_2A/2D/3A/3E","parameters":"xmm1, xmm2, imm","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2, imm","latency":"3","throughput":"1"},{"base":"06_17/1D","parameters":"xmm1, xmm2, imm","latency":"1","throughput":"1"}]},{"name":"_mm_minpos_epu16","tech":"SSE4.1","returnType":"__m128i","cpuId":"SSE4.1","category":"Miscellaneous","description":"Horizontally compute the minimum amongst the packed unsigned 16-bit integers in \"a\", store the minimum and index in \"dst\", and zero the remaining bits in \"dst\".","code":"index[2:0] := 0\nmin[15:0] := a[15:0]\nFOR j := 0 to 7\n\ti := j*16\n\tIF a[i+15:i] < min[15:0]\n\t\tindex[2:0] := j\n\t\tmin[15:0] := a[i+15:i]\n\tFI\nENDFOR\ndst[15:0] := min[15:0]\ndst[18:16] := index[2:0]\ndst[127:19] := 0","header":"smmintrin.h","instruction":"phminposuw","parameters":[{"type":"__m128i","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm1, xmm2","latency":"5","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2","latency":"3","throughput":"1"}]},{"name":"_mm_mpsadbw_epu8","tech":"SSE4.1","returnType":"__m128i","cpuId":"SSE4.1","category":"Arithmetic","description":"Compute the sum of absolute differences (SADs) of quadruplets of unsigned 8-bit integers in \"a\" compared to those in \"b\", and store the 16-bit results in \"dst\".\n\tEight SADs are performed using one quadruplet from \"b\" and eight quadruplets from \"a\". One quadruplet is selected from \"b\" starting at on the offset specified in \"imm\". Eight quadruplets are formed from sequential 8-bit integers selected from \"a\" starting at the offset specified in \"imm\".","code":"MPSADBW(a[127:0], b[127:0], imm[2:0]) {\n\ta_offset := imm[2]*32\n\tb_offset := imm[1:0]*32\n\tFOR j := 0 to 7\n\t\ti := j*8\n\t\tk := a_offset+i\n\t\tl := b_offset\n\t\ttmp[i+15:i] := ABS(a[k+7:k] - b[l+7:l]) +\n\t\t\t\t\t   ABS(a[k+15:k+8] - b[l+15:l+8]) +\n\t\t\t\t\t   ABS(a[k+23:k+16] - b[l+23:l+16]) +\n\t\t\t\t\t   ABS(a[k+31:k+24] - b[l+31:l+24])\n\tENDFOR\n\tRETURN tmp[127:0]\n}\n\ndst[127:0] := MPSADBW(a[127:0], b[127:0], imm[2:0])","header":"smmintrin.h","instruction":"mpsadbw","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"},{"type":"const int","name":"imm"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm1, xmm2, imm","latency":"5","throughput":"2"},{"base":"06_2A/2D/3A/3E","parameters":"xmm1, xmm2, imm","latency":"5","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm1, xmm2, imm","latency":"4","throughput":"1"},{"base":"06_17/1D","parameters":"xmm1, xmm2, imm","latency":"4","throughput":"2"}]},{"name":"_mm_stream_load_si128","tech":"SSE4.1","returnType":"__m128i","cpuId":"SSE4.1","category":"Load","description":"Load 128-bits of integer data from memory into \"dst\" using a non-temporal memory hint.\n\t\"mem_addr\" must be aligned on a 16-byte boundary or a general-protection exception will be generated.","code":"dst[127:0] := MEM[mem_addr+127:mem_addr]","header":"smmintrin.h","instruction":"movntdqa","parameters":[{"type":"__m128i*","name":"mem_addr"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_cmpistrm","tech":"SSE4.2","returnType":"__m128i","cpuId":"SSE4.2","category":"String Compare","description":"Compare packed strings with implicit lengths in \"a\" and \"b\" using the control in \"imm\", and store the generated mask in \"dst\".\n\t[strcmp_note]","code":"size := (imm[0] ? 16 : 8) // 8 or 16-bit characters\nUpperBound := (128 / size) - 1\n\n// compare all characters\naInvalid := 0\nbInvalid := 0\nFOR i := 0 to UpperBound\n\tm := i*size\n\tFOR j := 0 to UpperBound\n\t\tn := j*size\n\t\tBoolRes[i][j] := (a[m+size-1:m] == b[n+size-1:n])\n\t\t\n\t\t// invalidate characters after EOS\n\t\tIF a[m+size-1:m] == 0\n\t\t\taInvalid := 1\n\t\tFI\n\t\tIF b[n+size-1:n] == 0\n\t\t\tbInvalid := 1\n\t\tFI\n\t\t\n\t\t// override comparisons for invalid characters\n\t\tCASE (imm[3:2]) OF\n\t\t\t0:  // equal any\n\t\t\t\tIF (!aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE IF (aInvalid && !bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE If (aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tFI\n\t\t\t1:  // ranges\n\t\t\t\tIF (!aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE IF (aInvalid && !bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE If (aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tFI\n\t\t\t2:  // equal each\n\t\t\t\tIF (!aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE IF (aInvalid && !bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE If (aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 1\n\t\t\t\tFI\n\t\t\t3:  // equal ordered\n\t\t\t\tIF (!aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE IF (aInvalid && !bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 1\n\t\t\t\tELSE If (aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 1\n\t\t\t\tFI\n\t\tESAC\n\tENDFOR\nENDFOR\n\n// aggregate results\nCASE (imm[3:2]) OF\n\t0:  // equal any\n\t\tIntRes1 := 0\n\t\tFOR i := 0 to UpperBound\n\t\t\tFOR j := 0 to UpperBound\n\t\t\t\tIntRes1[i] := IntRes1[i] OR BoolRes[i][j]\n\t\t\tENDFOR\n\t\tENDFOR\n\t1:  // ranges\n\t\tIntRes1 := 0\n\t\tFOR i := 0 to UpperBound\n\t\t\tFOR j := 0 to UpperBound, j += 2\n\t\t\t\tIntRes1[i] := IntRes1[i] OR (BoolRes[i][j] AND BoolRes[i][j+1])\n\t\t\tENDFOR\n\t\tENDFOR\n\t2:  // equal each\n\t\tIntRes1 := 0\n\t\tFOR i := 0 to UpperBound\n\t\t\tIntRes1[i] := BoolRes[i][i]\n\t\tENDFOR\n\t3:  // equal ordered\n\t\tIntRes1 := (imm[0] ? 0xFF : 0xFFFF)\n\t\tFOR i := 0 to UpperBound\n\t\t\tk := i\n\t\t\tFOR j := 0 to UpperBound-i\n\t\t\t\tIntRes1[i] := IntRes1[i] AND BoolRes[k][j]\n\t\t\t\tk++\n\t\t\tENDFOR\n\t\tENDFOR\nESAC\n\n// optionally negate results\nbInvalid := 0\nFOR i := 0 to UpperBound\n\tIF imm[4]\n\t\tIF imm[5] // only negate valid\n\t\t\tIF b[n+size-1:n] == 0\n\t\t\t\tbInvalid := 1\n\t\t\tFI\n\t\t\tIF bInvalid // invalid, don't negate\n\t\t\t\tIntRes2[i] := IntRes1[i]\n\t\t\tELSE // valid, negate\n\t\t\t\tIntRes2[i] := -1 XOR IntRes1[i]\n\t\t\tFI\n\t\tELSE // negate all\n\t\t\tIntRes2[i] := -1 XOR IntRes1[i]\n\t\tFI\n\tELSE // don't negate\n\t\tIntRes2[i] := IntRes1[i]\n\tFI\nENDFOR\n\n// output\nIF imm[6] // byte / word mask\n\tFOR i := 0 to UpperBound\n\t\tj := i*size\n\t\tIF IntRes2[i]\n\t\t\tdst[j+size-1:j] := (imm[0] ? 0xFF : 0xFFFF)\n\t\tELSE\n\t\t\tdst[j+size-1:j] := 0\n\t\tFI\n\tENDFOR\nELSE // bit mask\n\tdst[UpperBound:0] := IntRes[UpperBound:0]\n\tdst[127:UpperBound+1] := 0\nFI","header":"nmmintrin.h","instruction":"pcmpistrm","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"},{"type":"const int","name":"imm"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm, imm","latency":"11","throughput":"3"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm, imm","latency":"8","throughput":"2"}]},{"name":"_mm_cmpistri","tech":"SSE4.2","returnType":"int","cpuId":"SSE4.2","category":"String Compare","description":"Compare packed strings with implicit lengths in \"a\" and \"b\" using the control in \"imm\", and store the generated index in \"dst\".\n\t[strcmp_note]","code":"size := (imm[0] ? 16 : 8) // 8 or 16-bit characters\nUpperBound := (128 / size) - 1\n\n// compare all characters\naInvalid := 0\nbInvalid := 0\nFOR i := 0 to UpperBound\n\tm := i*size\n\tFOR j := 0 to UpperBound\n\t\tn := j*size\n\t\tBoolRes[i][j] := (a[m+size-1:m] == b[n+size-1:n])\n\t\t\n\t\t// invalidate characters after EOS\n\t\tIF a[m+size-1:m] == 0\n\t\t\taInvalid := 1\n\t\tFI\n\t\tIF b[n+size-1:n] == 0\n\t\t\tbInvalid := 1\n\t\tFI\n\t\t\n\t\t// override comparisons for invalid characters\n\t\tCASE (imm[3:2]) OF\n\t\t\t0:  // equal any\n\t\t\t\tIF (!aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE IF (aInvalid && !bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE If (aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tFI\n\t\t\t1:  // ranges\n\t\t\t\tIF (!aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE IF (aInvalid && !bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE If (aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tFI\n\t\t\t2:  // equal each\n\t\t\t\tIF (!aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE IF (aInvalid && !bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE If (aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 1\n\t\t\t\tFI\n\t\t\t3:  // equal ordered\n\t\t\t\tIF (!aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE IF (aInvalid && !bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 1\n\t\t\t\tELSE If (aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 1\n\t\t\t\tFI\n\t\tESAC\n\tENDFOR\nENDFOR\n\n// aggregate results\nCASE (imm[3:2]) OF\n\t0:  // equal any\n\t\tIntRes1 := 0\n\t\tFOR i := 0 to UpperBound\n\t\t\tFOR j := 0 to UpperBound\n\t\t\t\tIntRes1[i] := IntRes1[i] OR BoolRes[i][j]\n\t\t\tENDFOR\n\t\tENDFOR\n\t1:  // ranges\n\t\tIntRes1 := 0\n\t\tFOR i := 0 to UpperBound\n\t\t\tFOR j := 0 to UpperBound, j += 2\n\t\t\t\tIntRes1[i] := IntRes1[i] OR (BoolRes[i][j] AND BoolRes[i][j+1])\n\t\t\tENDFOR\n\t\tENDFOR\n\t2:  // equal each\n\t\tIntRes1 := 0\n\t\tFOR i := 0 to UpperBound\n\t\t\tIntRes1[i] := BoolRes[i][i]\n\t\tENDFOR\n\t3:  // equal ordered\n\t\tIntRes1 := (imm[0] ? 0xFF : 0xFFFF)\n\t\tFOR i := 0 to UpperBound\n\t\t\tk := i\n\t\t\tFOR j := 0 to UpperBound-i\n\t\t\t\tIntRes1[i] := IntRes1[i] AND BoolRes[k][j]\n\t\t\t\tk++\n\t\t\tENDFOR\n\t\tENDFOR\nESAC\n\n// optionally negate results\nbInvalid := 0\nFOR i := 0 to UpperBound\n\tIF imm[4]\n\t\tIF imm[5] // only negate valid\n\t\t\tIF b[n+size-1:n] == 0\n\t\t\t\tbInvalid := 1\n\t\t\tFI\n\t\t\tIF bInvalid // invalid, don't negate\n\t\t\t\tIntRes2[i] := IntRes1[i]\n\t\t\tELSE // valid, negate\n\t\t\t\tIntRes2[i] := -1 XOR IntRes1[i]\n\t\t\tFI\n\t\tELSE // negate all\n\t\t\tIntRes2[i] := -1 XOR IntRes1[i]\n\t\tFI\n\tELSE // don't negate\n\t\tIntRes2[i] := IntRes1[i]\n\tFI\nENDFOR\n\n// output\nIF imm[6] // most significant bit\n\ttmp := UpperBound\n\tdst := tmp\n\tDO WHILE ((tmp >= 0) AND a[tmp] = 0)\n\t\ttmp := tmp - 1\n\t\tdst := tmp\n\tOD\nELSE // least significant bit\n\ttmp := 0\n\tdst := tmp\n\tDO WHILE ((tmp <= UpperBound) AND a[tmp] = 0)\n\t\ttmp := tmp + 1\n\t\tdst := tmp\n\tOD\nFI","header":"nmmintrin.h","instruction":"pcmpistri","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"},{"type":"const int","name":"imm"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm, imm","latency":"11","throughput":"3"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm, imm","latency":"7","throughput":"2"}]},{"name":"_mm_cmpistrz","tech":"SSE4.2","returnType":"int","cpuId":"SSE4.2","category":"String Compare","description":"Compare packed strings with implicit lengths in \"a\" and \"b\" using the control in \"imm\", and returns 1 if any character in \"b\" was null, and 0 otherwise.\n\t[strcmp_note]","code":"size := (imm[0] ? 16 : 8) // 8 or 16-bit characters\nUpperBound := (128 / size) - 1\n\nbInvalid := 0\nFOR j := 0 to UpperBound\n\tn := j*size\n\tIF b[n+size-1:n] == 0\n\t\tbInvalid := 1\n\tFI\nENDFOR\n\ndst := bInvalid","header":"nmmintrin.h","instruction":"pcmpistri","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"},{"type":"const int","name":"imm"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm, imm","latency":"11","throughput":"3"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm, imm","latency":"7","throughput":"2"}]},{"name":"_mm_cmpistrc","tech":"SSE4.2","returnType":"int","cpuId":"SSE4.2","category":"String Compare","description":"Compare packed strings with implicit lengths in \"a\" and \"b\" using the control in \"imm\", and returns 1 if the resulting mask was non-zero, and 0 otherwise.\n\t[strcmp_note]","code":"size := (imm[0] ? 16 : 8) // 8 or 16-bit characters\nUpperBound := (128 / size) - 1\n\n// compare all characters\naInvalid := 0\nbInvalid := 0\nFOR i := 0 to UpperBound\n\tm := i*size\n\tFOR j := 0 to UpperBound\n\t\tn := j*size\n\t\tBoolRes[i][j] := (a[m+size-1:m] == b[n+size-1:n])\n\t\t\n\t\t// invalidate characters after EOS\n\t\tIF a[m+size-1:m] == 0\n\t\t\taInvalid := 1\n\t\tFI\n\t\tIF b[n+size-1:n] == 0\n\t\t\tbInvalid := 1\n\t\tFI\n\t\t\n\t\t// override comparisons for invalid characters\n\t\tCASE (imm[3:2]) OF\n\t\t\t0:  // equal any\n\t\t\t\tIF (!aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE IF (aInvalid && !bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE If (aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tFI\n\t\t\t1:  // ranges\n\t\t\t\tIF (!aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE IF (aInvalid && !bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE If (aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tFI\n\t\t\t2:  // equal each\n\t\t\t\tIF (!aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE IF (aInvalid && !bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE If (aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 1\n\t\t\t\tFI\n\t\t\t3:  // equal ordered\n\t\t\t\tIF (!aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE IF (aInvalid && !bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 1\n\t\t\t\tELSE If (aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 1\n\t\t\t\tFI\n\t\tESAC\n\tENDFOR\nENDFOR\n\n// aggregate results\nCASE (imm[3:2]) OF\n\t0:  // equal any\n\t\tIntRes1 := 0\n\t\tFOR i := 0 to UpperBound\n\t\t\tFOR j := 0 to UpperBound\n\t\t\t\tIntRes1[i] := IntRes1[i] OR BoolRes[i][j]\n\t\t\tENDFOR\n\t\tENDFOR\n\t1:  // ranges\n\t\tIntRes1 := 0\n\t\tFOR i := 0 to UpperBound\n\t\t\tFOR j := 0 to UpperBound, j += 2\n\t\t\t\tIntRes1[i] := IntRes1[i] OR (BoolRes[i][j] AND BoolRes[i][j+1])\n\t\t\tENDFOR\n\t\tENDFOR\n\t2:  // equal each\n\t\tIntRes1 := 0\n\t\tFOR i := 0 to UpperBound\n\t\t\tIntRes1[i] := BoolRes[i][i]\n\t\tENDFOR\n\t3:  // equal ordered\n\t\tIntRes1 := (imm[0] ? 0xFF : 0xFFFF)\n\t\tFOR i := 0 to UpperBound\n\t\t\tk := i\n\t\t\tFOR j := 0 to UpperBound-i\n\t\t\t\tIntRes1[i] := IntRes1[i] AND BoolRes[k][j]\n\t\t\t\tk++\n\t\t\tENDFOR\n\t\tENDFOR\nESAC\n\n// optionally negate results\nbInvalid := 0\nFOR i := 0 to UpperBound\n\tIF imm[4]\n\t\tIF imm[5] // only negate valid\n\t\t\tIF b[n+size-1:n] == 0\n\t\t\t\tbInvalid := 1\n\t\t\tFI\n\t\t\tIF bInvalid // invalid, don't negate\n\t\t\t\tIntRes2[i] := IntRes1[i]\n\t\t\tELSE // valid, negate\n\t\t\t\tIntRes2[i] := -1 XOR IntRes1[i]\n\t\t\tFI\n\t\tELSE // negate all\n\t\t\tIntRes2[i] := -1 XOR IntRes1[i]\n\t\tFI\n\tELSE // don't negate\n\t\tIntRes2[i] := IntRes1[i]\n\tFI\nENDFOR\n\n// output\ndst := (IntRes2 != 0)","header":"nmmintrin.h","instruction":"pcmpistri","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"},{"type":"const int","name":"imm"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm, imm","latency":"11","throughput":"3"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm, imm","latency":"7","throughput":"2"}]},{"name":"_mm_cmpistrs","tech":"SSE4.2","returnType":"int","cpuId":"SSE4.2","category":"String Compare","description":"Compare packed strings with implicit lengths in \"a\" and \"b\" using the control in \"imm\", and returns 1 if any character in \"a\" was null, and 0 otherwise.\n\t[strcmp_note]","code":"size := (imm[0] ? 16 : 8) // 8 or 16-bit characters\nUpperBound := (128 / size) - 1\n\naInvalid := 0\nFOR i := 0 to UpperBound\n\tm := i*size\n\tIF b[m+size-1:m] == 0\n\t\taInvalid := 1\n\tFI\nENDFOR\n\ndst := aInvalid","header":"nmmintrin.h","instruction":"pcmpistri","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"},{"type":"const int","name":"imm"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm, imm","latency":"11","throughput":"3"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm, imm","latency":"7","throughput":"2"}]},{"name":"_mm_cmpistro","tech":"SSE4.2","returnType":"int","cpuId":"SSE4.2","category":"String Compare","description":"Compare packed strings with implicit lengths in \"a\" and \"b\" using the control in \"imm\", and returns bit 0 of the resulting bit mask.\n\t[strcmp_note]","code":"size := (imm[0] ? 16 : 8) // 8 or 16-bit characters\nUpperBound := (128 / size) - 1\n\n// compare all characters\naInvalid := 0\nbInvalid := 0\nFOR i := 0 to UpperBound\n\tm := i*size\n\tFOR j := 0 to UpperBound\n\t\tn := j*size\n\t\tBoolRes[i][j] := (a[m+size-1:m] == b[n+size-1:n])\n\t\t\n\t\t// invalidate characters after EOS\n\t\tIF a[m+size-1:m] == 0\n\t\t\taInvalid := 1\n\t\tFI\n\t\tIF b[n+size-1:n] == 0\n\t\t\tbInvalid := 1\n\t\tFI\n\t\t\n\t\t// override comparisons for invalid characters\n\t\tCASE (imm[3:2]) OF\n\t\t\t0:  // equal any\n\t\t\t\tIF (!aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE IF (aInvalid && !bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE If (aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tFI\n\t\t\t1:  // ranges\n\t\t\t\tIF (!aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE IF (aInvalid && !bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE If (aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tFI\n\t\t\t2:  // equal each\n\t\t\t\tIF (!aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE IF (aInvalid && !bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE If (aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 1\n\t\t\t\tFI\n\t\t\t3:  // equal ordered\n\t\t\t\tIF (!aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE IF (aInvalid && !bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 1\n\t\t\t\tELSE If (aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 1\n\t\t\t\tFI\n\t\tESAC\n\tENDFOR\nENDFOR\n\n// aggregate results\nCASE (imm[3:2]) OF\n\t0:  // equal any\n\t\tIntRes1 := 0\n\t\tFOR i := 0 to UpperBound\n\t\t\tFOR j := 0 to UpperBound\n\t\t\t\tIntRes1[i] := IntRes1[i] OR BoolRes[i][j]\n\t\t\tENDFOR\n\t\tENDFOR\n\t1:  // ranges\n\t\tIntRes1 := 0\n\t\tFOR i := 0 to UpperBound\n\t\t\tFOR j := 0 to UpperBound, j += 2\n\t\t\t\tIntRes1[i] := IntRes1[i] OR (BoolRes[i][j] AND BoolRes[i][j+1])\n\t\t\tENDFOR\n\t\tENDFOR\n\t2:  // equal each\n\t\tIntRes1 := 0\n\t\tFOR i := 0 to UpperBound\n\t\t\tIntRes1[i] := BoolRes[i][i]\n\t\tENDFOR\n\t3:  // equal ordered\n\t\tIntRes1 := (imm[0] ? 0xFF : 0xFFFF)\n\t\tFOR i := 0 to UpperBound\n\t\t\tk := i\n\t\t\tFOR j := 0 to UpperBound-i\n\t\t\t\tIntRes1[i] := IntRes1[i] AND BoolRes[k][j]\n\t\t\t\tk++\n\t\t\tENDFOR\n\t\tENDFOR\nESAC\n\n// optionally negate results\nbInvalid := 0\nFOR i := 0 to UpperBound\n\tIF imm[4]\n\t\tIF imm[5] // only negate valid\n\t\t\tIF b[n+size-1:n] == 0\n\t\t\t\tbInvalid := 1\n\t\t\tFI\n\t\t\tIF bInvalid // invalid, don't negate\n\t\t\t\tIntRes2[i] := IntRes1[i]\n\t\t\tELSE // valid, negate\n\t\t\t\tIntRes2[i] := -1 XOR IntRes1[i]\n\t\t\tFI\n\t\tELSE // negate all\n\t\t\tIntRes2[i] := -1 XOR IntRes1[i]\n\t\tFI\n\tELSE // don't negate\n\t\tIntRes2[i] := IntRes1[i]\n\tFI\nENDFOR\n\n// output\ndst := IntRes2[0]","header":"nmmintrin.h","instruction":"pcmpistri","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"},{"type":"const int","name":"imm"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm, imm","latency":"11","throughput":"3"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm, imm","latency":"7","throughput":"2"}]},{"name":"_mm_cmpistra","tech":"SSE4.2","returnType":"int","cpuId":"SSE4.2","category":"String Compare","description":"Compare packed strings with implicit lengths in \"a\" and \"b\" using the control in \"imm\", and returns 1 if \"b\" did not contain a null character and the resulting mask was zero, and 0 otherwise.\n\t[strcmp_note]","code":"size := (imm[0] ? 16 : 8) // 8 or 16-bit characters\nUpperBound := (128 / size) - 1\n\n// compare all characters\naInvalid := 0\nbInvalid := 0\nFOR i := 0 to UpperBound\n\tm := i*size\n\tFOR j := 0 to UpperBound\n\t\tn := j*size\n\t\tBoolRes[i][j] := (a[m+size-1:m] == b[n+size-1:n])\n\t\t\n\t\t// invalidate characters after EOS\n\t\tIF a[m+size-1:m] == 0\n\t\t\taInvalid := 1\n\t\tFI\n\t\tIF b[n+size-1:n] == 0\n\t\t\tbInvalid := 1\n\t\tFI\n\t\t\n\t\t// override comparisons for invalid characters\n\t\tCASE (imm[3:2]) OF\n\t\t\t0:  // equal any\n\t\t\t\tIF (!aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE IF (aInvalid && !bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE If (aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tFI\n\t\t\t1:  // ranges\n\t\t\t\tIF (!aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE IF (aInvalid && !bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE If (aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tFI\n\t\t\t2:  // equal each\n\t\t\t\tIF (!aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE IF (aInvalid && !bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE If (aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 1\n\t\t\t\tFI\n\t\t\t3:  // equal ordered\n\t\t\t\tIF (!aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE IF (aInvalid && !bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 1\n\t\t\t\tELSE If (aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 1\n\t\t\t\tFI\n\t\tESAC\n\tENDFOR\nENDFOR\n\n// aggregate results\nCASE (imm[3:2]) OF\n\t0:  // equal any\n\t\tIntRes1 := 0\n\t\tFOR i := 0 to UpperBound\n\t\t\tFOR j := 0 to UpperBound\n\t\t\t\tIntRes1[i] := IntRes1[i] OR BoolRes[i][j]\n\t\t\tENDFOR\n\t\tENDFOR\n\t1:  // ranges\n\t\tIntRes1 := 0\n\t\tFOR i := 0 to UpperBound\n\t\t\tFOR j := 0 to UpperBound, j += 2\n\t\t\t\tIntRes1[i] := IntRes1[i] OR (BoolRes[i][j] AND BoolRes[i][j+1])\n\t\t\tENDFOR\n\t\tENDFOR\n\t2:  // equal each\n\t\tIntRes1 := 0\n\t\tFOR i := 0 to UpperBound\n\t\t\tIntRes1[i] := BoolRes[i][i]\n\t\tENDFOR\n\t3:  // equal ordered\n\t\tIntRes1 := (imm[0] ? 0xFF : 0xFFFF)\n\t\tFOR i := 0 to UpperBound\n\t\t\tk := i\n\t\t\tFOR j := 0 to UpperBound-i\n\t\t\t\tIntRes1[i] := IntRes1[i] AND BoolRes[k][j]\n\t\t\t\tk++\n\t\t\tENDFOR\n\t\tENDFOR\nESAC\n\n// optionally negate results\nbInvalid := 0\nFOR i := 0 to UpperBound\n\tIF imm[4]\n\t\tIF imm[5] // only negate valid\n\t\t\tIF b[n+size-1:n] == 0\n\t\t\t\tbInvalid := 1\n\t\t\tFI\n\t\t\tIF bInvalid // invalid, don't negate\n\t\t\t\tIntRes2[i] := IntRes1[i]\n\t\t\tELSE // valid, negate\n\t\t\t\tIntRes2[i] := -1 XOR IntRes1[i]\n\t\t\tFI\n\t\tELSE // negate all\n\t\t\tIntRes2[i] := -1 XOR IntRes1[i]\n\t\tFI\n\tELSE // don't negate\n\t\tIntRes2[i] := IntRes1[i]\n\tFI\nENDFOR\n\n// output\ndst := (IntRes2 == 0) AND bInvalid","header":"nmmintrin.h","instruction":"pcmpistri","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"},{"type":"const int","name":"imm"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm, imm","latency":"11","throughput":"3"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm, imm","latency":"7","throughput":"2"}]},{"name":"_mm_cmpestrm","tech":"SSE4.2","returnType":"__m128i","cpuId":"SSE4.2","category":"String Compare","description":"Compare packed strings in \"a\" and \"b\" with lengths \"la\" and \"lb\" using the control in \"imm\", and store the generated mask in \"dst\".\n\t[strcmp_note]","code":"size := (imm[0] ? 16 : 8) // 8 or 16-bit characters\nUpperBound := (128 / size) - 1\n\n// compare all characters\naInvalid := 0\nbInvalid := 0\nFOR i := 0 to UpperBound\n\tm := i*size\n\tFOR j := 0 to UpperBound\n\t\tn := j*size\n\t\tBoolRes[i][j] := (a[m+size-1:m] == b[n+size-1:n])\n\t\t\n\t\t// invalidate characters after EOS\n\t\tIF i == la\n\t\t\taInvalid := 1\n\t\tFI\n\t\tIF j == lb\n\t\t\tbInvalid := 1\n\t\tFI\n\t\t\n\t\t// override comparisons for invalid characters\n\t\tCASE (imm[3:2]) OF\n\t\t\t0:  // equal any\n\t\t\t\tIF (!aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE IF (aInvalid && !bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE If (aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tFI\n\t\t\t1:  // ranges\n\t\t\t\tIF (!aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE IF (aInvalid && !bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE If (aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tFI\n\t\t\t2:  // equal each\n\t\t\t\tIF (!aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE IF (aInvalid && !bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE If (aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 1\n\t\t\t\tFI\n\t\t\t3:  // equal ordered\n\t\t\t\tIF (!aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE IF (aInvalid && !bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 1\n\t\t\t\tELSE If (aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 1\n\t\t\t\tFI\n\t\tESAC\n\tENDFOR\nENDFOR\n\n// aggregate results\nCASE (imm[3:2]) OF\n\t0:  // equal any\n\t\tIntRes1 := 0\n\t\tFOR i := 0 to UpperBound\n\t\t\tFOR j := 0 to UpperBound\n\t\t\t\tIntRes1[i] := IntRes1[i] OR BoolRes[i][j]\n\t\t\tENDFOR\n\t\tENDFOR\n\t1:  // ranges\n\t\tIntRes1 := 0\n\t\tFOR i := 0 to UpperBound\n\t\t\tFOR j := 0 to UpperBound, j += 2\n\t\t\t\tIntRes1[i] := IntRes1[i] OR (BoolRes[i][j] AND BoolRes[i][j+1])\n\t\t\tENDFOR\n\t\tENDFOR\n\t2:  // equal each\n\t\tIntRes1 := 0\n\t\tFOR i := 0 to UpperBound\n\t\t\tIntRes1[i] := BoolRes[i][i]\n\t\tENDFOR\n\t3:  // equal ordered\n\t\tIntRes1 := (imm[0] ? 0xFF : 0xFFFF)\n\t\tFOR i := 0 to UpperBound\n\t\t\tk := i\n\t\t\tFOR j := 0 to UpperBound-i\n\t\t\t\tIntRes1[i] := IntRes1[i] AND BoolRes[k][j]\n\t\t\t\tk++\n\t\t\tENDFOR\n\t\tENDFOR\nESAC\n\n// optionally negate results\nFOR i := 0 to UpperBound\n\tIF imm[4]\n\t\tIF imm[5] // only negate valid\n\t\t\tIF i >= lb // invalid, don't negate\n\t\t\t\tIntRes2[i] := IntRes1[i]\n\t\t\tELSE // valid, negate\n\t\t\t\tIntRes2[i] := -1 XOR IntRes1[i]\n\t\t\tFI\n\t\tELSE // negate all\n\t\t\tIntRes2[i] := -1 XOR IntRes1[i]\n\t\tFI\n\tELSE // don't negate\n\t\tIntRes2[i] := IntRes1[i]\n\tFI\nENDFOR\n\n// output\nIF imm[6] // byte / word mask\n\tFOR i := 0 to UpperBound\n\t\tj := i*size\n\t\tIF IntRes2[i]\n\t\t\tdst[j+size-1:j] := (imm[0] ? 0xFF : 0xFFFF)\n\t\tELSE\n\t\t\tdst[j+size-1:j] := 0\n\t\tFI\n\tENDFOR\nELSE // bit mask\n\tdst[UpperBound:0] := IntRes[UpperBound:0]\n\tdst[127:UpperBound+1] := 0\nFI","header":"nmmintrin.h","instruction":"pcmpestrm","parameters":[{"type":"__m128i","name":"a"},{"type":"int","name":"la"},{"type":"__m128i","name":"b"},{"type":"int","name":"lb"},{"type":"const int","name":"imm"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm, imm","latency":"11","throughput":"3"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm, imm","latency":"8","throughput":"2"}]},{"name":"_mm_cmpestri","tech":"SSE4.2","returnType":"int","cpuId":"SSE4.2","category":"String Compare","description":"Compare packed strings in \"a\" and \"b\" with lengths \"la\" and \"lb\" using the control in \"imm\", and store the generated index in \"dst\".\n\t[strcmp_note]","code":"size := (imm[0] ? 16 : 8) // 8 or 16-bit characters\nUpperBound := (128 / size) - 1\n\n// compare all characters\naInvalid := 0\nbInvalid := 0\nFOR i := 0 to UpperBound\n\tm := i*size\n\tFOR j := 0 to UpperBound\n\t\tn := j*size\n\t\tBoolRes[i][j] := (a[m+size-1:m] == b[n+size-1:n])\n\t\t\n\t\t// invalidate characters after EOS\n\t\tIF i == la\n\t\t\taInvalid := 1\n\t\tFI\n\t\tIF j == lb\n\t\t\tbInvalid := 1\n\t\tFI\n\t\t\n\t\t// override comparisons for invalid characters\n\t\tCASE (imm[3:2]) OF\n\t\t\t0:  // equal any\n\t\t\t\tIF (!aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE IF (aInvalid && !bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE If (aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tFI\n\t\t\t1:  // ranges\n\t\t\t\tIF (!aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE IF (aInvalid && !bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE If (aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tFI\n\t\t\t2:  // equal each\n\t\t\t\tIF (!aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE IF (aInvalid && !bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE If (aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 1\n\t\t\t\tFI\n\t\t\t3:  // equal ordered\n\t\t\t\tIF (!aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE IF (aInvalid && !bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 1\n\t\t\t\tELSE If (aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 1\n\t\t\t\tFI\n\t\tESAC\n\tENDFOR\nENDFOR\n\n// aggregate results\nCASE (imm[3:2]) OF\n\t0:  // equal any\n\t\tIntRes1 := 0\n\t\tFOR i := 0 to UpperBound\n\t\t\tFOR j := 0 to UpperBound\n\t\t\t\tIntRes1[i] := IntRes1[i] OR BoolRes[i][j]\n\t\t\tENDFOR\n\t\tENDFOR\n\t1:  // ranges\n\t\tIntRes1 := 0\n\t\tFOR i := 0 to UpperBound\n\t\t\tFOR j := 0 to UpperBound, j += 2\n\t\t\t\tIntRes1[i] := IntRes1[i] OR (BoolRes[i][j] AND BoolRes[i][j+1])\n\t\t\tENDFOR\n\t\tENDFOR\n\t2:  // equal each\n\t\tIntRes1 := 0\n\t\tFOR i := 0 to UpperBound\n\t\t\tIntRes1[i] := BoolRes[i][i]\n\t\tENDFOR\n\t3:  // equal ordered\n\t\tIntRes1 := (imm[0] ? 0xFF : 0xFFFF)\n\t\tFOR i := 0 to UpperBound\n\t\t\tk := i\n\t\t\tFOR j := 0 to UpperBound-i\n\t\t\t\tIntRes1[i] := IntRes1[i] AND BoolRes[k][j]\n\t\t\t\tk++\n\t\t\tENDFOR\n\t\tENDFOR\nESAC\n\n// optionally negate results\nFOR i := 0 to UpperBound\n\tIF imm[4]\n\t\tIF imm[5] // only negate valid\n\t\t\tIF i >= lb // invalid, don't negate\n\t\t\t\tIntRes2[i] := IntRes1[i]\n\t\t\tELSE // valid, negate\n\t\t\t\tIntRes2[i] := -1 XOR IntRes1[i]\n\t\t\tFI\n\t\tELSE // negate all\n\t\t\tIntRes2[i] := -1 XOR IntRes1[i]\n\t\tFI\n\tELSE // don't negate\n\t\tIntRes2[i] := IntRes1[i]\n\tFI\nENDFOR\n\n// output\nIF imm[6] // most significant bit\n\ttmp := UpperBound\n\tdst := tmp\n\tDO WHILE ((tmp >= 0) AND a[tmp] = 0)\n\t\ttmp := tmp - 1\n\t\tdst := tmp\n\tOD\nELSE // least significant bit\n\ttmp := 0\n\tdst := tmp\n\tDO WHILE ((tmp <= UpperBound) AND a[tmp] = 0)\n\t\ttmp := tmp + 1\n\t\tdst := tmp\n\tOD\nFI","header":"nmmintrin.h","instruction":"pcmpestri","parameters":[{"type":"__m128i","name":"a"},{"type":"int","name":"la"},{"type":"__m128i","name":"b"},{"type":"int","name":"lb"},{"type":"const int","name":"imm"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm, imm","latency":"11","throughput":"3"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm, imm","latency":"7","throughput":"2"}]},{"name":"_mm_cmpestrz","tech":"SSE4.2","returnType":"int","cpuId":"SSE4.2","category":"String Compare","description":"Compare packed strings in \"a\" and \"b\" with lengths \"la\" and \"lb\" using the control in \"imm\", and returns 1 if any character in \"b\" was null, and 0 otherwise.\n\t[strcmp_note]","code":"size := (imm[0] ? 16 : 8) // 8 or 16-bit characters\nUpperBound := (128 / size) - 1\n\ndst := (lb <= UpperBound)","header":"nmmintrin.h","instruction":"pcmpestri","parameters":[{"type":"__m128i","name":"a"},{"type":"int","name":"la"},{"type":"__m128i","name":"b"},{"type":"int","name":"lb"},{"type":"const int","name":"imm"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm, imm","latency":"11","throughput":"3"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm, imm","latency":"7","throughput":"2"}]},{"name":"_mm_cmpestrc","tech":"SSE4.2","returnType":"int","cpuId":"SSE4.2","category":"String Compare","description":"Compare packed strings in \"a\" and \"b\" with lengths \"la\" and \"lb\" using the control in \"imm\", and returns 1 if the resulting mask was non-zero, and 0 otherwise.\n\t[strcmp_note]","code":"size := (imm[0] ? 16 : 8) // 8 or 16-bit characters\nUpperBound := (128 / size) - 1\n\n// compare all characters\naInvalid := 0\nbInvalid := 0\nFOR i := 0 to UpperBound\n\tm := i*size\n\tFOR j := 0 to UpperBound\n\t\tn := j*size\n\t\tBoolRes[i][j] := (a[m+size-1:m] == b[n+size-1:n])\n\t\t\n\t\t// invalidate characters after EOS\n\t\tIF i == la\n\t\t\taInvalid := 1\n\t\tFI\n\t\tIF j == lb\n\t\t\tbInvalid := 1\n\t\tFI\n\t\t\n\t\t// override comparisons for invalid characters\n\t\tCASE (imm[3:2]) OF\n\t\t\t0:  // equal any\n\t\t\t\tIF (!aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE IF (aInvalid && !bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE If (aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tFI\n\t\t\t1:  // ranges\n\t\t\t\tIF (!aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE IF (aInvalid && !bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE If (aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tFI\n\t\t\t2:  // equal each\n\t\t\t\tIF (!aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE IF (aInvalid && !bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE If (aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 1\n\t\t\t\tFI\n\t\t\t3:  // equal ordered\n\t\t\t\tIF (!aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE IF (aInvalid && !bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 1\n\t\t\t\tELSE If (aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 1\n\t\t\t\tFI\n\t\tESAC\n\tENDFOR\nENDFOR\n\n// aggregate results\nCASE (imm[3:2]) OF\n\t0:  // equal any\n\t\tIntRes1 := 0\n\t\tFOR i := 0 to UpperBound\n\t\t\tFOR j := 0 to UpperBound\n\t\t\t\tIntRes1[i] := IntRes1[i] OR BoolRes[i][j]\n\t\t\tENDFOR\n\t\tENDFOR\n\t1:  // ranges\n\t\tIntRes1 := 0\n\t\tFOR i := 0 to UpperBound\n\t\t\tFOR j := 0 to UpperBound, j += 2\n\t\t\t\tIntRes1[i] := IntRes1[i] OR (BoolRes[i][j] AND BoolRes[i][j+1])\n\t\t\tENDFOR\n\t\tENDFOR\n\t2:  // equal each\n\t\tIntRes1 := 0\n\t\tFOR i := 0 to UpperBound\n\t\t\tIntRes1[i] := BoolRes[i][i]\n\t\tENDFOR\n\t3:  // equal ordered\n\t\tIntRes1 := (imm[0] ? 0xFF : 0xFFFF)\n\t\tFOR i := 0 to UpperBound\n\t\t\tk := i\n\t\t\tFOR j := 0 to UpperBound-i\n\t\t\t\tIntRes1[i] := IntRes1[i] AND BoolRes[k][j]\n\t\t\t\tk++\n\t\t\tENDFOR\n\t\tENDFOR\nESAC\n\n// optionally negate results\nFOR i := 0 to UpperBound\n\tIF imm[4]\n\t\tIF imm[5] // only negate valid\n\t\t\tIF i >= lb // invalid, don't negate\n\t\t\t\tIntRes2[i] := IntRes1[i]\n\t\t\tELSE // valid, negate\n\t\t\t\tIntRes2[i] := -1 XOR IntRes1[i]\n\t\t\tFI\n\t\tELSE // negate all\n\t\t\tIntRes2[i] := -1 XOR IntRes1[i]\n\t\tFI\n\tELSE // don't negate\n\t\tIntRes2[i] := IntRes1[i]\n\tFI\nENDFOR\n\n// output\ndst := (IntRes2 != 0)","header":"nmmintrin.h","instruction":"pcmpestri","parameters":[{"type":"__m128i","name":"a"},{"type":"int","name":"la"},{"type":"__m128i","name":"b"},{"type":"int","name":"lb"},{"type":"const int","name":"imm"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm, imm","latency":"11","throughput":"3"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm, imm","latency":"7","throughput":"2"}]},{"name":"_mm_cmpestrs","tech":"SSE4.2","returnType":"int","cpuId":"SSE4.2","category":"String Compare","description":"Compare packed strings in \"a\" and \"b\" with lengths \"la\" and \"lb\" using the control in \"imm\", and returns 1 if any character in \"a\" was null, and 0 otherwise.\n\t[strcmp_note]","code":"size := (imm[0] ? 16 : 8) // 8 or 16-bit characters\nUpperBound := (128 / size) - 1\n\ndst := (la <= UpperBound)","header":"nmmintrin.h","instruction":"pcmpestri","parameters":[{"type":"__m128i","name":"a"},{"type":"int","name":"la"},{"type":"__m128i","name":"b"},{"type":"int","name":"lb"},{"type":"const int","name":"imm"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm, imm","latency":"11","throughput":"3"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm, imm","latency":"7","throughput":"2"}]},{"name":"_mm_cmpestro","tech":"SSE4.2","returnType":"int","cpuId":"SSE4.2","category":"String Compare","description":"Compare packed strings in \"a\" and \"b\" with lengths \"la\" and \"lb\" using the control in \"imm\", and returns bit 0 of the resulting bit mask.\n\t[strcmp_note]","code":"size := (imm[0] ? 16 : 8) // 8 or 16-bit characters\nUpperBound := (128 / size) - 1\n\n// compare all characters\naInvalid := 0\nbInvalid := 0\nFOR i := 0 to UpperBound\n\tm := i*size\n\tFOR j := 0 to UpperBound\n\t\tn := j*size\n\t\tBoolRes[i][j] := (a[m+size-1:m] == b[n+size-1:n])\n\t\t\n\t\t// invalidate characters after EOS\n\t\tIF i == la\n\t\t\taInvalid := 1\n\t\tFI\n\t\tIF j == lb\n\t\t\tbInvalid := 1\n\t\tFI\n\t\t\n\t\t// override comparisons for invalid characters\n\t\tCASE (imm[3:2]) OF\n\t\t\t0:  // equal any\n\t\t\t\tIF (!aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE IF (aInvalid && !bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE If (aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tFI\n\t\t\t1:  // ranges\n\t\t\t\tIF (!aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE IF (aInvalid && !bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE If (aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tFI\n\t\t\t2:  // equal each\n\t\t\t\tIF (!aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE IF (aInvalid && !bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE If (aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 1\n\t\t\t\tFI\n\t\t\t3:  // equal ordered\n\t\t\t\tIF (!aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE IF (aInvalid && !bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 1\n\t\t\t\tELSE If (aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 1\n\t\t\t\tFI\n\t\tESAC\n\tENDFOR\nENDFOR\n\n// aggregate results\nCASE (imm[3:2]) OF\n\t0:  // equal any\n\t\tIntRes1 := 0\n\t\tFOR i := 0 to UpperBound\n\t\t\tFOR j := 0 to UpperBound\n\t\t\t\tIntRes1[i] := IntRes1[i] OR BoolRes[i][j]\n\t\t\tENDFOR\n\t\tENDFOR\n\t1:  // ranges\n\t\tIntRes1 := 0\n\t\tFOR i := 0 to UpperBound\n\t\t\tFOR j := 0 to UpperBound, j += 2\n\t\t\t\tIntRes1[i] := IntRes1[i] OR (BoolRes[i][j] AND BoolRes[i][j+1])\n\t\t\tENDFOR\n\t\tENDFOR\n\t2:  // equal each\n\t\tIntRes1 := 0\n\t\tFOR i := 0 to UpperBound\n\t\t\tIntRes1[i] := BoolRes[i][i]\n\t\tENDFOR\n\t3:  // equal ordered\n\t\tIntRes1 := (imm[0] ? 0xFF : 0xFFFF)\n\t\tFOR i := 0 to UpperBound\n\t\t\tk := i\n\t\t\tFOR j := 0 to UpperBound-i\n\t\t\t\tIntRes1[i] := IntRes1[i] AND BoolRes[k][j]\n\t\t\t\tk++\n\t\t\tENDFOR\n\t\tENDFOR\nESAC\n\n// optionally negate results\nFOR i := 0 to UpperBound\n\tIF imm[4]\n\t\tIF imm[5] // only negate valid\n\t\t\tIF i >= lb // invalid, don't negate\n\t\t\t\tIntRes2[i] := IntRes1[i]\n\t\t\tELSE // valid, negate\n\t\t\t\tIntRes2[i] := -1 XOR IntRes1[i]\n\t\t\tFI\n\t\tELSE // negate all\n\t\t\tIntRes2[i] := -1 XOR IntRes1[i]\n\t\tFI\n\tELSE // don't negate\n\t\tIntRes2[i] := IntRes1[i]\n\tFI\nENDFOR\n\n// output\ndst := IntRes2[0","header":"nmmintrin.h","instruction":"pcmpestri","parameters":[{"type":"__m128i","name":"a"},{"type":"int","name":"la"},{"type":"__m128i","name":"b"},{"type":"int","name":"lb"},{"type":"const int","name":"imm"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm, imm","latency":"11","throughput":"3"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm, imm","latency":"7","throughput":"2"}]},{"name":"_mm_cmpestra","tech":"SSE4.2","returnType":"int","cpuId":"SSE4.2","category":"String Compare","description":"Compare packed strings in \"a\" and \"b\" with lengths \"la\" and \"lb\" using the control in \"imm\", and returns 1 if \"b\" did not contain a null character and the resulting mask was zero, and 0 otherwise.\n\t[strcmp_note]","code":"size := (imm[0] ? 16 : 8) // 8 or 16-bit characters\nUpperBound := (128 / size) - 1\n\n// compare all characters\naInvalid := 0\nbInvalid := 0\nFOR i := 0 to UpperBound\n\tm := i*size\n\tFOR j := 0 to UpperBound\n\t\tn := j*size\n\t\tBoolRes[i][j] := (a[m+size-1:m] == b[n+size-1:n])\n\t\t\n\t\t// invalidate characters after EOS\n\t\tIF i == la\n\t\t\taInvalid := 1\n\t\tFI\n\t\tIF j == lb\n\t\t\tbInvalid := 1\n\t\tFI\n\t\t\n\t\t// override comparisons for invalid characters\n\t\tCASE (imm[3:2]) OF\n\t\t\t0:  // equal any\n\t\t\t\tIF (!aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE IF (aInvalid && !bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE If (aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tFI\n\t\t\t1:  // ranges\n\t\t\t\tIF (!aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE IF (aInvalid && !bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE If (aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tFI\n\t\t\t2:  // equal each\n\t\t\t\tIF (!aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE IF (aInvalid && !bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE If (aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 1\n\t\t\t\tFI\n\t\t\t3:  // equal ordered\n\t\t\t\tIF (!aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 0\n\t\t\t\tELSE IF (aInvalid && !bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 1\n\t\t\t\tELSE If (aInvalid && bInvalid)\n\t\t\t\t\tBoolRes[i][j] := 1\n\t\t\t\tFI\n\t\tESAC\n\tENDFOR\nENDFOR\n\n// aggregate results\nCASE (imm[3:2]) OF\n\t0:  // equal any\n\t\tIntRes1 := 0\n\t\tFOR i := 0 to UpperBound\n\t\t\tFOR j := 0 to UpperBound\n\t\t\t\tIntRes1[i] := IntRes1[i] OR BoolRes[i][j]\n\t\t\tENDFOR\n\t\tENDFOR\n\t1:  // ranges\n\t\tIntRes1 := 0\n\t\tFOR i := 0 to UpperBound\n\t\t\tFOR j := 0 to UpperBound, j += 2\n\t\t\t\tIntRes1[i] := IntRes1[i] OR (BoolRes[i][j] AND BoolRes[i][j+1])\n\t\t\tENDFOR\n\t\tENDFOR\n\t2:  // equal each\n\t\tIntRes1 := 0\n\t\tFOR i := 0 to UpperBound\n\t\t\tIntRes1[i] := BoolRes[i][i]\n\t\tENDFOR\n\t3:  // equal ordered\n\t\tIntRes1 := (imm[0] ? 0xFF : 0xFFFF)\n\t\tFOR i := 0 to UpperBound\n\t\t\tk := i\n\t\t\tFOR j := 0 to UpperBound-i\n\t\t\t\tIntRes1[i] := IntRes1[i] AND BoolRes[k][j]\n\t\t\t\tk++\n\t\t\tENDFOR\n\t\tENDFOR\nESAC\n\n// optionally negate results\nFOR i := 0 to UpperBound\n\tIF imm[4]\n\t\tIF imm[5] // only negate valid\n\t\t\tIF i >= lb // invalid, don't negate\n\t\t\t\tIntRes2[i] := IntRes1[i]\n\t\t\tELSE // valid, negate\n\t\t\t\tIntRes2[i] := -1 XOR IntRes1[i]\n\t\t\tFI\n\t\tELSE // negate all\n\t\t\tIntRes2[i] := -1 XOR IntRes1[i]\n\t\tFI\n\tELSE // don't negate\n\t\tIntRes2[i] := IntRes1[i]\n\tFI\nENDFOR\n\n// output\ndst := (IntRes2 == 0) AND (lb > UpperBound)","header":"nmmintrin.h","instruction":"pcmpestri","parameters":[{"type":"__m128i","name":"a"},{"type":"int","name":"la"},{"type":"__m128i","name":"b"},{"type":"int","name":"lb"},{"type":"const int","name":"imm"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm, imm","latency":"11","throughput":"3"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm, imm","latency":"7","throughput":"2"}]},{"name":"_mm_cmpgt_epi64","tech":"SSE4.2","returnType":"__m128i","cpuId":"SSE4.2","category":"Compare","description":"Compare packed 64-bit integers in \"a\" and \"b\" for greater-than, and store the results in \"dst\".","code":"FOR j := 0 to 1\n  i := j*64\n  dst[i+63:i] := ( a[i+63:i] > b[i+63:i] ) ? 0xFFFFFFFFFFFFFFFF : 0\nENDFOR","header":"nmmintrin.h","instruction":"pcmpgtq","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"5","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"3","throughput":"1"}]},{"name":"_mm_crc32_u8","tech":"SSE4.2","returnType":"unsigned int","cpuId":"SSE4.2","category":"Cryptography","description":"Starting with the initial value in \"crc\", accumulates a CRC32 value for unsigned 8-bit integer \"v\", and stores the result in \"dst\".","code":"tmp1[7:0] := v[0:7] // bit reflection\ntmp2[31:0] := crc[0:31] // bit reflection\ntmp3[39:0] := tmp1[7:0] << 32 \ntmp4[39:0] := tmp2[31:0] << 8\ntmp5[39:0] := tmp3[39:0] XOR tmp4[39:0]\ntmp6[31:0] := tmp5[39:0] MOD2 0x11EDC6F41\ndst[31:0] := tmp6[0:31] // bit reflection","header":"nmmintrin.h","instruction":"crc32","parameters":[{"type":"unsigned int","name":"crc"},{"type":"unsigned char","name":"v"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"r32, r32","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"r32, r32","latency":"3","throughput":"1"}]},{"name":"_mm_crc32_u16","tech":"SSE4.2","returnType":"unsigned int","cpuId":"SSE4.2","category":"Cryptography","description":"Starting with the initial value in \"crc\", accumulates a CRC32 value for unsigned 16-bit integer \"v\", and stores the result in \"dst\".","code":"tmp1[15:0] := v[0:15] // bit reflection\ntmp2[31:0] := crc[0:31] // bit reflection\ntmp3[47:0] := tmp1[15:0] << 32\ntmp4[47:0] := tmp2[31:0] << 16\ntmp5[47:0] := tmp3[47:0] XOR tmp4[47:0]\ntmp6[31:0] := tmp5[47:0] MOD2 0x11EDC6F41\ndst[31:0] := tmp6[0:31] // bit reflection","header":"nmmintrin.h","instruction":"crc32","parameters":[{"type":"unsigned int","name":"crc"},{"type":"unsigned short","name":"v"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"r32, r32","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"r32, r32","latency":"3","throughput":"1"}]},{"name":"_mm_crc32_u32","tech":"SSE4.2","returnType":"unsigned int","cpuId":"SSE4.2","category":"Cryptography","description":"Starting with the initial value in \"crc\", accumulates a CRC32 value for unsigned 32-bit integer \"v\", and stores the result in \"dst\".","code":"tmp1[31:0] := v[0:31] // bit reflection\ntmp2[31:0] := crc[0:31] // bit reflection\ntmp3[63:0] := tmp1[31:0] << 32\ntmp4[63:0] := tmp2[31:0] << 32\ntmp5[63:0] := tmp3[63:0] XOR tmp4[63:0]\ntmp6[31:0] := tmp5[63:0] MOD2 0x11EDC6F41\ndst[31:0] := tmp6[0:31] // bit reflection","header":"nmmintrin.h","instruction":"crc32","parameters":[{"type":"unsigned int","name":"crc"},{"type":"unsigned int","name":"v"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"r32, r32","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"r32, r32","latency":"3","throughput":"1"}]},{"name":"_mm_crc32_u64","tech":"SSE4.2","returnType":"unsigned __int64","cpuId":"SSE4.2","category":"Cryptography","description":"Starting with the initial value in \"crc\", accumulates a CRC32 value for unsigned 64-bit integer \"v\", and stores the result in \"dst\".","code":"tmp1[63:0] := v[0:63] // bit reflection\ntmp2[31:0] := crc[0:31] // bit reflection\ntmp3[95:0] := tmp1[31:0] << 32\ntmp4[95:0] := tmp2[63:0] << 64\ntmp5[95:0] := tmp3[95:0] XOR tmp4[95:0]\ntmp6[31:0] := tmp5[95:0] MOD2 0x11EDC6F41\ndst[31:0] := tmp6[0:31] // bit reflection","header":"nmmintrin.h","instruction":"crc32","parameters":[{"type":"unsigned __int64","name":"crc"},{"type":"unsigned __int64","name":"v"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"r32, r32","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"r32, r32","latency":"3","throughput":"1"}]},{"name":"_mm_fmadd_pd","tech":"FMA","returnType":"__m128d","cpuId":"FMA","category":"Arithmetic","description":"Multiply packed double-precision (64-bit) floating-point elements in \"a\" and \"b\", add the intermediate result to packed elements in \"c\", and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := (a[i+63:i] * b[i+63:i]) + c[i+63:i]\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"vfmadd132pd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"},{"type":"__m128d","name":"c"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_fmadd_pd","tech":"FMA","returnType":"__m256d","cpuId":"FMA","category":"Arithmetic","description":"Multiply packed double-precision (64-bit) floating-point elements in \"a\" and \"b\", add the intermediate result to packed elements in \"c\", and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*64\n\tdst[i+63:i] := (a[i+63:i] * b[i+63:i]) + c[i+63:i]\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"vfmadd132pd","parameters":[{"type":"__m256d","name":"a"},{"type":"__m256d","name":"b"},{"type":"__m256d","name":"c"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_fmadd_ps","tech":"FMA","returnType":"__m128","cpuId":"FMA","category":"Arithmetic","description":"Multiply packed single-precision (32-bit) floating-point elements in \"a\" and \"b\", add the intermediate result to packed elements in \"c\", and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := (a[i+31:i] * b[i+31:i]) + c[i+31:i]\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"vfmadd132ps","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"},{"type":"__m128","name":"c"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_fmadd_ps","tech":"FMA","returnType":"__m256","cpuId":"FMA","category":"Arithmetic","description":"Multiply packed single-precision (32-bit) floating-point elements in \"a\" and \"b\", add the intermediate result to packed elements in \"c\", and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*32\n\tdst[i+31:i] := (a[i+31:i] * b[i+31:i]) + c[i+31:i]\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"vfmadd132ps","parameters":[{"type":"__m256","name":"a"},{"type":"__m256","name":"b"},{"type":"__m256","name":"c"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_fmadd_sd","tech":"FMA","returnType":"__m128d","cpuId":"FMA","category":"Arithmetic","description":"Multiply the lower double-precision (64-bit) floating-point elements in \"a\" and \"b\", and add the intermediate result to the lower element in \"c\". Store the result in the lower element of \"dst\", and copy the upper element from \"a\" to the upper element of \"dst\".","code":"dst[63:0] := (a[63:0] * b[63:0]) + c[63:0]\ndst[127:64] := a[127:64]\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"vfmadd132sd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"},{"type":"__m128d","name":"c"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_fmadd_ss","tech":"FMA","returnType":"__m128","cpuId":"FMA","category":"Arithmetic","description":"Multiply the lower single-precision (32-bit) floating-point elements in \"a\" and \"b\", and add the intermediate result to the lower element in \"c\". Store the result in the lower element of \"dst\", and copy the upper 3 packed elements from \"a\" to the upper elements of \"dst\".","code":"dst[31:0] := (a[31:0] * b[31:0]) + c[31:0]\ndst[127:32] := a[127:32]\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"vfmadd132ss","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"},{"type":"__m128","name":"c"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_fmaddsub_pd","tech":"FMA","returnType":"__m128d","cpuId":"FMA","category":"Arithmetic","description":"Multiply packed double-precision (64-bit) floating-point elements in \"a\" and \"b\", alternatively add and subtract packed elements in \"c\" to/from the intermediate result, and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tIF (j is even) \n\t\tdst[i+63:i] := (a[i+63:i] * b[i+63:i]) - c[i+63:i]\n\tELSE\n\t\tdst[i+63:i] := (a[i+63:i] * b[i+63:i]) + c[i+63:i]\n\tFI\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"vfmaddsub132pd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"},{"type":"__m128d","name":"c"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_fmaddsub_pd","tech":"FMA","returnType":"__m256d","cpuId":"FMA","category":"Arithmetic","description":"Multiply packed double-precision (64-bit) floating-point elements in \"a\" and \"b\", alternatively add and subtract packed elements in \"c\" to/from the intermediate result, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*64\n\tIF (j is even) \n\t\tdst[i+63:i] := (a[i+63:i] * b[i+63:i]) - c[i+63:i]\n\tELSE\n\t\tdst[i+63:i] := (a[i+63:i] * b[i+63:i]) + c[i+63:i]\n\tFI\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"vfmaddsub132pd","parameters":[{"type":"__m256d","name":"a"},{"type":"__m256d","name":"b"},{"type":"__m256d","name":"c"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_fmaddsub_ps","tech":"FMA","returnType":"__m128","cpuId":"FMA","category":"Arithmetic","description":"Multiply packed single-precision (32-bit) floating-point elements in \"a\" and \"b\", alternatively add and subtract packed elements in \"c\" to/from the intermediate result, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tIF (j is even) \n\t\tdst[i+31:i] := (a[i+31:i] * b[i+31:i]) - c[i+31:i]\n\tELSE\n\t\tdst[i+31:i] := (a[i+31:i] * b[i+31:i]) + c[i+31:i]\n\tFI\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"vfmaddsub132ps","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"},{"type":"__m128","name":"c"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_fmaddsub_ps","tech":"FMA","returnType":"__m256","cpuId":"FMA","category":"Arithmetic","description":"Multiply packed single-precision (32-bit) floating-point elements in \"a\" and \"b\", alternatively add and subtract packed elements in \"c\" to/from the intermediate result, and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*32\n\tIF (j is even) \n\t\tdst[i+31:i] := (a[i+31:i] * b[i+31:i]) - c[i+31:i]\n\tELSE\n\t\tdst[i+31:i] := (a[i+31:i] * b[i+31:i]) + c[i+31:i]\n\tFI\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"vfmaddsub132ps","parameters":[{"type":"__m256","name":"a"},{"type":"__m256","name":"b"},{"type":"__m256","name":"c"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_fmsub_pd","tech":"FMA","returnType":"__m128d","cpuId":"FMA","category":"Arithmetic","description":"Multiply packed double-precision (64-bit) floating-point elements in \"a\" and \"b\", subtract packed elements in \"c\" from the intermediate result, and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := (a[i+63:i] * b[i+63:i]) - c[i+63:i]\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"vfmsub132pd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"},{"type":"__m128d","name":"c"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_fmsub_pd","tech":"FMA","returnType":"__m256d","cpuId":"FMA","category":"Arithmetic","description":"Multiply packed double-precision (64-bit) floating-point elements in \"a\" and \"b\", subtract packed elements in \"c\" from the intermediate result, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*64\n\tdst[i+63:i] := (a[i+63:i] * b[i+63:i]) - c[i+63:i]\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"vfmsub132pd","parameters":[{"type":"__m256d","name":"a"},{"type":"__m256d","name":"b"},{"type":"__m256d","name":"c"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_fmsub_ps","tech":"FMA","returnType":"__m128","cpuId":"FMA","category":"Arithmetic","description":"Multiply packed single-precision (32-bit) floating-point elements in \"a\" and \"b\", subtract packed elements in \"c\" from the intermediate result, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := (a[i+31:i] * b[i+31:i]) - c[i+31:i]\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"vfmsub132ps","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"},{"type":"__m128","name":"c"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_fmsub_ps","tech":"FMA","returnType":"__m256","cpuId":"FMA","category":"Arithmetic","description":"Multiply packed single-precision (32-bit) floating-point elements in \"a\" and \"b\", subtract packed elements in \"c\" from the intermediate result, and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*32\n\tdst[i+31:i] := (a[i+31:i] * b[i+31:i]) - c[i+31:i]\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"vfmsub132ps","parameters":[{"type":"__m256","name":"a"},{"type":"__m256","name":"b"},{"type":"__m256","name":"c"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_fmsub_sd","tech":"FMA","returnType":"__m128d","cpuId":"FMA","category":"Arithmetic","description":"Multiply the lower double-precision (64-bit) floating-point elements in \"a\" and \"b\", and subtract the lower element in \"c\" from the intermediate result. Store the result in the lower element of \"dst\", and copy the upper element from \"a\" to the upper element of \"dst\".","code":"dst[63:0] := (a[63:0] * b[63:0]) - c[63:0]\ndst[127:64] := a[127:64]\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"vfmsub132sd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"},{"type":"__m128d","name":"c"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_fmsub_ss","tech":"FMA","returnType":"__m128","cpuId":"FMA","category":"Arithmetic","description":"Multiply the lower single-precision (32-bit) floating-point elements in \"a\" and \"b\", and subtract the lower element in \"c\" from the intermediate result. Store the result in the lower element of \"dst\", and copy the upper 3 packed elements from \"a\" to the upper elements of \"dst\".","code":"dst[31:0] := (a[31:0] * b[31:0]) - c[31:0]\ndst[127:32] := a[127:32]\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"vfmsub132ss","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"},{"type":"__m128","name":"c"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_fmsubadd_pd","tech":"FMA","returnType":"__m128d","cpuId":"FMA","category":"Arithmetic","description":"Multiply packed double-precision (64-bit) floating-point elements in \"a\" and \"b\", alternatively subtract and add packed elements in \"c\" from/to the intermediate result, and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tIF (j is even) \n\t\tdst[i+63:i] := (a[i+63:i] * b[i+63:i]) - c[i+63:i]\n\tELSE\n\t\tdst[i+63:i] := (a[i+63:i] * b[i+63:i]) + c[i+63:i]\n\tFI\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"vfmsubadd132pd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"},{"type":"__m128d","name":"c"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_fmsubadd_pd","tech":"FMA","returnType":"__m256d","cpuId":"FMA","category":"Arithmetic","description":"Multiply packed double-precision (64-bit) floating-point elements in \"a\" and \"b\", alternatively subtract and add packed elements in \"c\" from/to the intermediate result, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*64\n\tIF (j is even) \n\t\tdst[i+63:i] := (a[i+63:i] * b[i+63:i]) - c[i+63:i]\n\tELSE\n\t\tdst[i+63:i] := (a[i+63:i] * b[i+63:i]) + c[i+63:i]\n\tFI\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"vfmsubadd132pd","parameters":[{"type":"__m256d","name":"a"},{"type":"__m256d","name":"b"},{"type":"__m256d","name":"c"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_fmsubadd_ps","tech":"FMA","returnType":"__m128","cpuId":"FMA","category":"Arithmetic","description":"Multiply packed single-precision (32-bit) floating-point elements in \"a\" and \"b\", alternatively subtract and add packed elements in \"c\" from/to the intermediate result, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tIF (j is even) \n\t\tdst[i+31:i] := (a[i+31:i] * b[i+31:i]) - c[i+31:i]\n\tELSE\n\t\tdst[i+31:i] := (a[i+31:i] * b[i+31:i]) + c[i+31:i]\n\tFI\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"vfmsubadd132ps","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"},{"type":"__m128","name":"c"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_fmsubadd_ps","tech":"FMA","returnType":"__m256","cpuId":"FMA","category":"Arithmetic","description":"Multiply packed single-precision (32-bit) floating-point elements in \"a\" and \"b\", alternatively subtract and add packed elements in \"c\" from/to the intermediate result, and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*32\n\tIF (j is even) \n\t\tdst[i+31:i] := (a[i+31:i] * b[i+31:i]) - c[i+31:i]\n\tELSE\n\t\tdst[i+31:i] := (a[i+31:i] * b[i+31:i]) + c[i+31:i]\n\tFI\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"vfmsubadd132ps","parameters":[{"type":"__m256","name":"a"},{"type":"__m256","name":"b"},{"type":"__m256","name":"c"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_fnmadd_pd","tech":"FMA","returnType":"__m128d","cpuId":"FMA","category":"Arithmetic","description":"Multiply packed double-precision (64-bit) floating-point elements in \"a\" and \"b\", add the negated intermediate result to packed elements in \"c\", and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := -(a[i+63:i] * b[i+63:i]) + c[i+63:i]\nENDFOR\t\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"vfnmadd132pd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"},{"type":"__m128d","name":"c"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_fnmadd_pd","tech":"FMA","returnType":"__m256d","cpuId":"FMA","category":"Arithmetic","description":"Multiply packed double-precision (64-bit) floating-point elements in \"a\" and \"b\", add the negated intermediate result to packed elements in \"c\", and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*64\n\tdst[i+63:i] := -(a[i+63:i] * b[i+63:i]) + c[i+63:i]\nENDFOR\t\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"vfnmadd132pd","parameters":[{"type":"__m256d","name":"a"},{"type":"__m256d","name":"b"},{"type":"__m256d","name":"c"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_fnmadd_ps","tech":"FMA","returnType":"__m128","cpuId":"FMA","category":"Arithmetic","description":"Multiply packed single-precision (32-bit) floating-point elements in \"a\" and \"b\", add the negated intermediate result to packed elements in \"c\", and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\ta[i+31:i] := -(a[i+31:i] * b[i+31:i]) + c[i+31:i]\nENDFOR\t\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"vfnmadd132ps","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"},{"type":"__m128","name":"c"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_fnmadd_ps","tech":"FMA","returnType":"__m256","cpuId":"FMA","category":"Arithmetic","description":"Multiply packed single-precision (32-bit) floating-point elements in \"a\" and \"b\", add the negated intermediate result to packed elements in \"c\", and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*32\n\ta[i+31:i] := -(a[i+31:i] * b[i+31:i]) + c[i+31:i]\nENDFOR\t\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"vfnmadd132ps","parameters":[{"type":"__m256","name":"a"},{"type":"__m256","name":"b"},{"type":"__m256","name":"c"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_fnmadd_sd","tech":"FMA","returnType":"__m128d","cpuId":"FMA","category":"Arithmetic","description":"Multiply the lower double-precision (64-bit) floating-point elements in \"a\" and \"b\", and add the negated intermediate result to the lower element in \"c\". Store the result in the lower element of \"dst\", and copy the upper element from \"a\" to the upper element of \"dst\".","code":"dst[63:0] := -(a[63:0] * b[63:0]) + c[63:0]\ndst[127:64] := a[127:64]\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"vfnmadd132sd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"},{"type":"__m128d","name":"c"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_fnmadd_ss","tech":"FMA","returnType":"__m128","cpuId":"FMA","category":"Arithmetic","description":"Multiply the lower single-precision (32-bit) floating-point elements in \"a\" and \"b\", and add the negated intermediate result to the lower element in \"c\". Store the result in the lower element of \"dst\", and copy the upper 3 packed elements from \"a\" to the upper elements of \"dst\".","code":"dst[31:0] := -(a[31:0] * b[31:0]) + c[31:0]\ndst[127:32] := a[127:32]\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"vfnmadd132ss","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"},{"type":"__m128","name":"c"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_fnmsub_pd","tech":"FMA","returnType":"__m128d","cpuId":"FMA","category":"Arithmetic","description":"Multiply packed double-precision (64-bit) floating-point elements in \"a\" and \"b\", subtract packed elements in \"c\" from the negated intermediate result, and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := -(a[i+63:i] * b[i+63:i]) - c[i+63:i]\nENDFOR\t\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"vfnmsub132pd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"},{"type":"__m128d","name":"c"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_fnmsub_pd","tech":"FMA","returnType":"__m256d","cpuId":"FMA","category":"Arithmetic","description":"Multiply packed double-precision (64-bit) floating-point elements in \"a\" and \"b\", subtract packed elements in \"c\" from the negated intermediate result, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*64\n\tdst[i+63:i] := -(a[i+63:i] * b[i+63:i]) - c[i+63:i]\nENDFOR\t\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"vfnmsub132pd","parameters":[{"type":"__m256d","name":"a"},{"type":"__m256d","name":"b"},{"type":"__m256d","name":"c"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_fnmsub_ps","tech":"FMA","returnType":"__m128","cpuId":"FMA","category":"Arithmetic","description":"Multiply packed single-precision (32-bit) floating-point elements in \"a\" and \"b\", subtract packed elements in \"c\" from the negated intermediate result, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := -(a[i+31:i] * b[i+31:i]) - c[i+31:i]\nENDFOR\t\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"vfnmsub132ps","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"},{"type":"__m128","name":"c"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_fnmsub_ps","tech":"FMA","returnType":"__m256","cpuId":"FMA","category":"Arithmetic","description":"Multiply packed single-precision (32-bit) floating-point elements in \"a\" and \"b\", subtract packed elements in \"c\" from the negated intermediate result, and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*32\n\tdst[i+31:i] := -(a[i+31:i] * b[i+31:i]) - c[i+31:i]\nENDFOR\t\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"vfnmsub132ps","parameters":[{"type":"__m256","name":"a"},{"type":"__m256","name":"b"},{"type":"__m256","name":"c"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_fnmsub_sd","tech":"FMA","returnType":"__m128d","cpuId":"FMA","category":"Arithmetic","description":"Multiply the lower double-precision (64-bit) floating-point elements in \"a\" and \"b\", and subtract the lower element in \"c\" from the negated intermediate result. Store the result in the lower element of \"dst\", and copy the upper element from \"a\" to the upper element of \"dst\".","code":"dst[63:0] := -(a[63:0] * b[63:0]) - c[63:0]\ndst[127:64] := a[127:64]\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"vfnmsub132sd","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"},{"type":"__m128d","name":"c"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_fnmsub_ss","tech":"FMA","returnType":"__m128","cpuId":"FMA","category":"Arithmetic","description":"Multiply the lower single-precision (32-bit) floating-point elements in \"a\" and \"b\", and subtract the lower element in \"c\" from the negated intermediate result. Store the result in the lower element of \"dst\", and copy the upper 3 packed elements from \"a\" to the upper elements of \"dst\".","code":"dst[31:0] := -(a[31:0] * b[31:0]) - c[31:0]\ndst[127:32] := a[127:32]\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"vfnmsub132ss","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"},{"type":"__m128","name":"c"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_aesenc_si128","tech":"Misc","returnType":"__m128i","cpuId":"AES","category":"Cryptography","description":"Perform one round of an AES encryption flow on data (state) in \"a\" using the round key in \"RoundKey\", and store the result in \"dst\".\"","code":"state := a\na[127:0] := ShiftRows(a[127:0])\na[127:0] := SubBytes(a[127:0])\na[127:0] := MixColumns(a[127:0])\ndst[127:0] := a[127:0] XOR RoundKey[127:0]","header":"wmmintrin.h","instruction":"aesenc","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"RoundKey"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"7","throughput":"1"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"8","throughput":"1"},{"base":"06_25/2C/2F","parameters":"xmm, xmm","latency":"6","throughput":"2"}]},{"name":"_mm_aesenclast_si128","tech":"Misc","returnType":"__m128i","cpuId":"AES","category":"Cryptography","description":"Perform the last round of an AES encryption flow on data (state) in \"a\" using the round key in \"RoundKey\", and store the result in \"dst\".\"","code":"state := a\na[127:0] := ShiftRows(a[127:0])\na[127:0] := SubBytes(a[127:0])\ndst[127:0] := a[127:0] XOR RoundKey[127:0]","header":"wmmintrin.h","instruction":"aesenclast","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"RoundKey"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"7","throughput":"1"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"8","throughput":"1"},{"base":"06_25/2C/2F","parameters":"xmm, xmm","latency":"6","throughput":"2"}]},{"name":"_mm_aesdec_si128","tech":"Misc","returnType":"__m128i","cpuId":"AES","category":"Cryptography","description":"Perform one round of an AES decryption flow on data (state) in \"a\" using the round key in \"RoundKey\", and store the result in \"dst\".\"","code":"state := a\na[127:0] := InvShiftRows(a[127:0])\na[127:0] := InvSubBytes(a[127:0])\na[127:0] := InvMixColumns(a[127:0])\ndst[127:0] := a[127:0] XOR RoundKey[127:0]","header":"wmmintrin.h","instruction":"aesdec","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"RoundKey"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"7","throughput":"1"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"8","throughput":"1"},{"base":"06_25/2C/2F","parameters":"xmm, xmm","latency":"6","throughput":"2"}]},{"name":"_mm_aesdeclast_si128","tech":"Misc","returnType":"__m128i","cpuId":"AES","category":"Cryptography","description":"Perform the last round of an AES decryption flow on data (state) in \"a\" using the round key in \"RoundKey\", and store the result in \"dst\".\"","code":"state := a\na[127:0] := InvShiftRows(a[127:0])\na[127:0] := InvSubBytes(a[127:0])\ndst[127:0] := a[127:0] XOR RoundKey[127:0]","header":"wmmintrin.h","instruction":"aesdeclast","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"RoundKey"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm","latency":"7","throughput":"1"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm","latency":"8","throughput":"1"},{"base":"06_25/2C/2F","parameters":"xmm, xmm","latency":"6","throughput":"2"}]},{"name":"_mm_aesimc_si128","tech":"Misc","returnType":"__m128i","cpuId":"AES","category":"Cryptography","description":"Perform the InvMixColumns transformation on \"a\" and store the result in \"dst\".","code":"dst[127:0] := InvMixColumns(a[127:0])","header":"wmmintrin.h","instruction":"aesimc","parameters":[{"type":"__m128i","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"12","throughput":"2"},{"base":"06_25/2C/2F","parameters":"xmm, xmm","latency":"6","throughput":"2"}]},{"name":"_mm_aeskeygenassist_si128","tech":"Misc","returnType":"__m128i","cpuId":"AES","category":"Cryptography","description":"Assist in expanding the AES cipher key by computing steps towards generating a round key for encryption cipher using data from \"a\" and an 8-bit round constant specified in \"imm\", and store the result in \"dst\".\"","code":"X3[31:0] := a[127:96]\nX2[31:0] := a[95:64]\nX1[31:0] := a[63:32]\nX0[31:0] := a[31:0]\nRCON[31:0] := ZeroExtend(imm[7:0]);\ndst[31:0] := SubWord(X1)\ndst[63:32] := (RotWord(SubWord(X1)) XOR RCON;\ndst[95:64] := SubWord(X3)\ndst[127:96] := RotWord(SubWord(X3)) XOR RCON;","header":"wmmintrin.h","instruction":"aeskeygenassist","parameters":[{"type":"__m128i","name":"a"},{"type":"const int","name":"imm"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm, imm","latency":"10","throughput":"2"},{"base":"06_25/2C/2F","parameters":"xmm, xmm, imm","latency":"6","throughput":"2"}]},{"name":"_mm_clmulepi64_si128","tech":"Misc","returnType":"__m128i","cpuId":"PCLMULQDQ","category":"Application-Targeted","description":"Perform a carry-less multiplication of two 64-bit integers, selected from \"a\" and \"b\" according to \"imm8\", and store the results in \"dst\".","code":"IF (imm8[0] = 0)\n\tTEMP1 := a[63:0];\nELSE\n\tTEMP1 := a[127:64];\nFI \nIF (imm8[4] = 0)\n\tTEMP2 := b[63:0];\nELSE \n\tTEMP2 := b[127:64];\nFI\n\nFOR i := 0 to 63\n\tTEMP[i] := (TEMP1[0] and TEMP2[i]);\n\tFOR j := 1 to i\n\t\tTEMP [i] := TEMP [i] XOR (TEMP1[j] AND TEMP2[i-j])\n\tENDFOR \n\tdst[i] := TEMP[i];\nENDFOR\nFOR i := 64 to 127\n\tTEMP [i] := 0;\n\tFOR j := (i - 63) to 63\n\t\tTEMP [i] := TEMP [i] XOR (TEMP1[j] AND TEMP2[i-j])\n\tENDFOR\n\tdst[i] := TEMP[i];\nENDFOR\ndst[127] := 0","header":"wmmintrin.h","instruction":"pclmulqdq","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"},{"type":"const int","name":"imm8"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"xmm, xmm, imm","latency":"7","throughput":"2"},{"base":"06_2A/2D/3A/3E","parameters":"xmm, xmm, imm","latency":"14","throughput":"8"},{"base":"06_25/2C/2F","parameters":"xmm, xmm, imm","latency":"14","throughput":"8"}]},{"name":"_bextr_u32","tech":"Bit Manipulation","returnType":"unsigned int","cpuId":"BMI1","category":"Bit Manipulation","description":"Extract contiguous bits from unsigned 32-bit integer \"a\", and store the result in \"dst\". Extract the number of bits specified by \"len\", starting at the bit specified by \"start\".","code":"tmp := ZERO_EXTEND_TO_512(a)\ndst := ZERO_EXTEND(tmp[start+len-1:start])","header":"immintrin.h","instruction":"bextr","parameters":[{"type":"unsigned int","name":"a"},{"type":"unsigned int","name":"start"},{"type":"unsigned int","name":"len"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_bextr_u64","tech":"Bit Manipulation","returnType":"unsigned __int64","cpuId":"BMI1","category":"Bit Manipulation","description":"Extract contiguous bits from unsigned 64-bit integer \"a\", and store the result in \"dst\". Extract the number of bits specified by \"len\", starting at the bit specified by \"start\".","code":"tmp := ZERO_EXTEND_TO_512(a)\ndst := ZERO_EXTEND(tmp[start+len-1:start])","header":"immintrin.h","instruction":"bextr","parameters":[{"type":"unsigned __int64","name":"a"},{"type":"unsigned int","name":"start"},{"type":"unsigned int","name":"len"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_blsi_u32","tech":"Bit Manipulation","returnType":"unsigned int","cpuId":"BMI1","category":"Bit Manipulation","description":"Extract the lowest set bit from unsigned 32-bit integer \"a\" and set the corresponding bit in \"dst\". All other bits in \"dst\" are zeroed, and all bits are zeroed if no bits are set in \"a\".","code":"dst := (-a) BITWISE AND a","header":"immintrin.h","instruction":"blsi","parameters":[{"type":"unsigned int","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_blsi_u64","tech":"Bit Manipulation","returnType":"unsigned __int64","cpuId":"BMI1","category":"Bit Manipulation","description":"Extract the lowest set bit from unsigned 64-bit integer \"a\" and set the corresponding bit in \"dst\". All other bits in \"dst\" are zeroed, and all bits are zeroed if no bits are set in \"a\".","code":"dst := (-a) BITWISE AND a","header":"immintrin.h","instruction":"blsi","parameters":[{"type":"unsigned __int64","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_blsmsk_u32","tech":"Bit Manipulation","returnType":"unsigned int","cpuId":"BMI1","category":"Bit Manipulation","description":"Set all the lower bits of \"dst\" up to and including the lowest set bit in unsigned 32-bit integer \"a\".","code":"dst := (a - 1) XOR a","header":"immintrin.h","instruction":"blsmsk","parameters":[{"type":"unsigned int","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_blsmsk_u64","tech":"Bit Manipulation","returnType":"unsigned __int64","cpuId":"BMI1","category":"Bit Manipulation","description":"Set all the lower bits of \"dst\" up to and including the lowest set bit in unsigned 64-bit integer \"a\".","code":"dst := (a - 1) XOR a","header":"immintrin.h","instruction":"blsmsk","parameters":[{"type":"unsigned __int64","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_blsr_u32","tech":"Bit Manipulation","returnType":"unsigned int","cpuId":"BMI1","category":"Bit Manipulation","description":"Copy all bits from unsigned 32-bit integer \"a\" to \"dst\", and reset (set to 0) the bit in \"dst\" that corresponds to the lowest set bit in \"a\".","code":"dst := (a - 1) BITWISE AND a","header":"immintrin.h","instruction":"blsr","parameters":[{"type":"unsigned int","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_blsr_u64","tech":"Bit Manipulation","returnType":"unsigned __int64","cpuId":"BMI1","category":"Bit Manipulation","description":"Copy all bits from unsigned 64-bit integer \"a\" to \"dst\", and reset (set to 0) the bit in \"dst\" that corresponds to the lowest set bit in \"a\".","code":"dst := (a - 1) BITWISE AND a","header":"immintrin.h","instruction":"blsr","parameters":[{"type":"unsigned __int64","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_bzhi_u32","tech":"Bit Manipulation","returnType":"unsigned int","cpuId":"BMI2","category":"Bit Manipulation","description":"Copy all bits from unsigned 32-bit integer \"a\" to \"dst\", and reset (set to 0) the high bits in \"dst\" starting at \"index\".","code":"n := index[7:0]\ndst := a\nIF (n < 32)\n\tdst[31:n] := 0\nFI","header":"immintrin.h","instruction":"bzhi","parameters":[{"type":"unsigned int","name":"a"},{"type":"unsigned int","name":"index"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_bzhi_u64","tech":"Bit Manipulation","returnType":"unsigned __int64","cpuId":"BMI2","category":"Bit Manipulation","description":"Copy all bits from unsigned 64-bit integer \"a\" to \"dst\", and reset (set to 0) the high bits in \"dst\" starting at \"index\".","code":"n := index[7:0]\ndst := a\nIF (n < 64)\n\tdst[63:n] := 0\nFI","header":"immintrin.h","instruction":"bzhi","parameters":[{"type":"unsigned __int64","name":"a"},{"type":"unsigned int","name":"index"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_invpcid","tech":"OS","returnType":"void","cpuId":"INVPCID","category":"OS-Targeted","description":"Invalidate mappings in the Translation Lookaside Buffers (TLBs) and paging-structure caches for the processor context identifier (PCID) specified by \"descriptor\" based on the invalidation type specified in \"type\". \n\tThe PCID \"descriptor\" is specified as a 16-byte memory operand (with no alignment restrictions) where bits [11:0] specify the PCID, and bits [127:64] specify the linear address; bits [63:12] are reserved.\n\tThe types supported are:\n\t\t0) Individual-address invalidation: If \"type\" is 0, the logical processor invalidates mappings for a single linear address and tagged with the PCID specified in \"descriptor\", except global translations. The instruction may also invalidate global translations, mappings for other linear addresses, or mappings tagged with other PCIDs.\n\t\t1) Single-context invalidation: If \"type\" is 1, the logical processor invalidates all mappings tagged with the PCID specified in \"descriptor\" except global translations. In some cases, it may invalidate mappings for other PCIDs as well.\n\t\t2) All-context invalidation: If \"type\" is 2, the logical processor invalidates all mappings tagged with any PCID.\n\t\t3) All-context invalidation, retaining global translations: If \"type\" is 3, the logical processor invalidates all mappings tagged with any PCID except global translations, ignoring \"descriptor\". The instruction may also invalidate global translations as well.","code":"CASE type OF\n\t0: // individual-address invalidation retaining global translations\n\t\tOP_PCID := descriptor[11:0]\n\t\tADDR := descriptor[127:64]\n\t\tBREAK\n\t1: // single PCID invalidation retaining globals\n\t\tOP_PCID := descriptor[11:0]\n\t\t// invalidate all mappings tagged with OP_PCID except global translations\n\t\tBREAK\n\t2: // all PCID invalidation\n\t\t// invalidate all mappings tagged with any PCID\n\t\tBREAK\n\t3: // all PCID invalidation retaining global translations\n\t\t// invalidate all mappings tagged with any PCID except global translations\n\t\tBREAK\nESAC","header":"immintrin.h","instruction":"invpcid","parameters":[{"type":"unsigned int","name":"type"},{"type":"void*","name":"descriptor"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_lzcnt_u32","tech":"Bit Manipulation","returnType":"unsigned int","cpuId":"LZCNT","category":"Bit Manipulation","description":"Count the number of leading zero bits in unsigned 32-bit integer \"a\", and return that count in \"dst\".","code":"tmp := 31\ndst := 0\nDO WHILE (tmp >= 0 AND a[tmp] = 0)\n\ttmp := tmp - 1\n\tdst := dst + 1\nOD","header":"immintrin.h","instruction":"lzcnt","parameters":[{"type":"unsigned int","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_lzcnt_u64","tech":"Bit Manipulation","returnType":"unsigned __int64","cpuId":"LZCNT","category":"Bit Manipulation","description":"Count the number of leading zero bits in unsigned 64-bit integer \"a\", and return that count in \"dst\".","code":"tmp := 63\ndst := 0\nDO WHILE (tmp >= 0 AND a[tmp] = 0)\n\ttmp := tmp - 1\n\tdst := dst + 1\nOD","header":"immintrin.h","instruction":"lzcnt","parameters":[{"type":"unsigned __int64","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_pdep_u32","tech":"Bit Manipulation","returnType":"unsigned int","cpuId":"BMI2","category":"Bit Manipulation","description":"Deposit contiguous low bits from unsigned 32-bit integer \"a\" to \"dst\" at the corresponding bit locations specified by \"mask\"; all other bits in \"dst\" are set to zero.","code":"tmp := a\ndst := 0\nm := 0\nk := 0\nDO WHILE m < 32\n\tIF mask[m] = 1\n\t\tdst[m] := tmp[k]\n\t\tk := k + 1\n\tFI\n\tm := m + 1\nOD","header":"immintrin.h","instruction":"pdep","parameters":[{"type":"unsigned int","name":"a"},{"type":"unsigned int","name":"mask"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_pdep_u64","tech":"Bit Manipulation","returnType":"unsigned __int64","cpuId":"BMI2","category":"Bit Manipulation","description":"Deposit contiguous low bits from unsigned 64-bit integer \"a\" to \"dst\" at the corresponding bit locations specified by \"mask\"; all other bits in \"dst\" are set to zero.","code":"tmp := a\ndst := 0\nm := 0\nk := 0\nDO WHILE m < 64\n\tIF mask[m] = 1\n\t\tdst[m] := tmp[k]\n\t\tk := k + 1\n\tFI\n\tm := m + 1\nOD","header":"immintrin.h","instruction":"pdep","parameters":[{"type":"unsigned __int64","name":"a"},{"type":"unsigned __int64","name":"mask"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_pext_u32","tech":"Bit Manipulation","returnType":"unsigned int","cpuId":"BMI2","category":"Bit Manipulation","description":"Extract bits from unsigned 32-bit integer \"a\" at the corresponding bit locations specified by \"mask\" to contiguous low bits in \"dst\"; the remaining upper bits in \"dst\" are set to zero.","code":"tmp := a\ndst := 0\nm := 0\nk := 0\nDO WHILE m < 32\n\tIF mask[m] = 1\n\t\tdst[k] := tmp[m]\n\t\tk := k + 1\n\tFI\n\tm := m + 1\nOD","header":"immintrin.h","instruction":"pext","parameters":[{"type":"unsigned int","name":"a"},{"type":"unsigned int","name":"mask"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_pext_u64","tech":"Bit Manipulation","returnType":"unsigned __int64","cpuId":"BMI2","category":"Bit Manipulation","description":"Extract bits from unsigned 64-bit integer \"a\" at the corresponding bit locations specified by \"mask\" to contiguous low bits in \"dst\"; the remaining upper bits in \"dst\" are set to zero.","code":"tmp := a\ndst := 0\nm := 0\nk := 0\nDO WHILE m < 64\n\tIF mask[m] = 1\n\t\tdst[k] := tmp[m]\n\t\tk := k + 1\n\tFI\n\tm := m + 1\nOD","header":"immintrin.h","instruction":"pext","parameters":[{"type":"unsigned __int64","name":"a"},{"type":"unsigned __int64","name":"mask"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_tzcnt_u32","tech":"Bit Manipulation","returnType":"unsigned int","cpuId":"BMI1","category":"Bit Manipulation","description":"Count the number of trailing zero bits in unsigned 32-bit integer \"a\", and return that count in \"dst\".","code":"tmp := 0\ndst := 0\nDO WHILE ((tmp < 32) AND a[tmp] = 0)\n\ttmp := tmp + 1\n\tdst := dst + 1\nOD","header":"immintrin.h","instruction":"tzcnt","parameters":[{"type":"unsigned int","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_tzcnt_32","tech":"Bit Manipulation","returnType":"int","cpuId":"BMI1","category":"Bit Manipulation","description":"Count the number of trailing zero bits in unsigned 32-bit integer \"a\", and return that count in \"dst\".","code":"tmp := 0\ndst := 0\nDO WHILE ((tmp < 32) AND a[tmp] = 0)\n\ttmp := tmp + 1\n\tdst := dst + 1\nOD","header":"zmmintrin.h","instruction":"tzcnt","parameters":[{"type":"unsigned int","name":"a"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_tzcnt_u64","tech":"Bit Manipulation","returnType":"unsigned __int64","cpuId":"BMI1","category":"Bit Manipulation","description":"Count the number of trailing zero bits in unsigned 64-bit integer \"a\", and return that count in \"dst\".","code":"tmp := 0\ndst := 0\nDO WHILE ((tmp < 64) AND a[tmp] = 0)\n\ttmp := tmp + 1\n\tdst := dst + 1\nOD","header":"immintrin.h","instruction":"tzcnt","parameters":[{"type":"unsigned __int64","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_tzcnt_64","tech":"Bit Manipulation","returnType":"__int64","cpuId":"BMI1","category":"Bit Manipulation","description":"Count the number of trailing zero bits in unsigned 64-bit integer \"a\", and return that count in \"dst\".","code":"tmp := 0\ndst := 0\nDO WHILE ((tmp < 64) AND a[tmp] = 0)\n\ttmp := tmp + 1\n\tdst := dst + 1\nOD","header":"zmmintrin.h","instruction":"tzcnt","parameters":[{"type":"unsigned __int64","name":"a"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_xabort","tech":"Misc","returnType":"void","cpuId":"RTM","category":"General Support","description":"Force an RTM abort. The EAX register is updated to reflect an XABORT instruction caused the abort, and the \"imm\" parameter will be provided in bits [31:24] of EAX.\n\tFollowing an RTM abort, the logical processor resumes execution at the fallback address computed through the outermost XBEGIN instruction.","code":"IF RTM_ACTIVE = 0\n\t// nop\nELSE\n\t// restore architectural register state\n\t// discard memory updates performed in transaction\n\t// update EAX with status and imm value\n\tRTM_NEST_COUNT := 0\n\tRTM_ACTIVE := 0\n\tIF 64-bit Mode\n\t\tRIP := fallbackRIP\n\tELSE\n\t\tEIP := fallbackEIP\n\tFI\nFI","header":"immintrin.h","instruction":"xabort","parameters":[{"type":"const unsigned int","name":"imm"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_xbegin","tech":"Misc","returnType":"unsigned int","cpuId":"RTM","category":"General Support","description":"Specify the start of an RTM code region. \n\tIf the logical processor was not already in transactional execution, then this call causes the logical processor to transition into transactional execution. \n\tOn an RTM abort, the logical processor discards all architectural register and memory updates performed during the RTM execution, restores architectural state, and starts execution beginning at the fallback address computed from the outermost XBEGIN instruction.","code":"IF RTM_NEST_COUNT < MAX_RTM_NEST_COUNT\n\tRTM_NEST_COUNT := RTM_NEST_COUNT + 1\n\tIF RTM_NEST_COUNT = 1\n\t\tIF 64-bit Mode\n\t\t\tfallbackRIP := RIP + SignExtend(IMM)\n\t\tELSE IF 32-bit Mode\n\t\t\tfallbackEIP := EIP + SignExtend(IMM)\n\t\tELSE // 16-bit Mode\n\t\t\tfallbackEIP := (EIP + SignExtend(IMM)) AND 0x0000FFFF\n\t\tFI\n\t\t\n\t\tRTM_ACTIVE := 1\n\t\t// enter RTM execution, record register state, start tracking memory state\n\tFI\nELSE\n\t// RTM abort (see _xabort)\nFI","header":"immintrin.h","instruction":"xbegin","parameters":[{"type":"void","name":""}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_xend","tech":"Misc","returnType":"void","cpuId":"RTM","category":"General Support","description":"Specify the end of an RTM code region.\n\tIf this corresponds to the outermost scope, the logical processor will attempt to commit the logical processor state atomically. \n\tIf the commit fails, the logical processor will perform an RTM abort.","code":"IF RTM_ACTIVE = 1\n\tRTM_NEST_COUNT := RTM_NEST_COUNT - 1\n\tIF RTM_NEST_COUNT = 0\n\t\t// try to commit transaction\n\t\tIF fail to commit transaction\n\t\t\t// RTM abort (see _xabort)\n\t\tELSE\n\t\t\tRTM_ACTIVE = 0\n\t\tFI\n\tFI\nFI","header":"immintrin.h","instruction":"xend","parameters":[{"type":"void","name":""}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_xtest","tech":"Misc","returnType":"unsigned char","cpuId":"RTM","category":"General Support","description":"Query the transactional execution status, return 0 if inside a transactionally executing RTM or HLE region, and return 1 otherwise.","code":"IF (RTM_ACTIVE = 1 OR HLE_ACTIVE = 1)\n\tdst := 0\nELSE\n\tdst := 1\nFI","header":"immintrin.h","instruction":"xtest","parameters":[{"type":"void","name":""}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"__rdtscp","tech":"Other","returnType":"unsigned __int64","cpuId":"RDTSCP","category":"General Support","description":"Copy the current 64-bit value of the processor's time-stamp counter into \"dst\", and store the IA32_TSC_AUX MSR (signature value) into memory at \"mem_addr\".","code":"dst[63:0] := TimeStampCounter\nMEM[mem_addr+31:mem_addr] := IA32_TSC_AUX[31:0]","header":"immintrin.h","instruction":"rdtscp","parameters":[{"type":"unsigned int *","name":"mem_addr"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_bit_scan_forward","tech":"Bit Manipulation","returnType":"int","cpuId":null,"category":"Bit Manipulation","description":"Set \"dst\" to the index of the lowest set bit in 32-bit integer \"a\". If no bits are set in \"a\" then \"dst\" is undefined.","code":"tmp := 0\nIF a = 0\n\tdst := undefined\nELSE\n\tDO WHILE ((tmp < 32) AND a[tmp] = 0)\n\t\ttmp := tmp + 1\n\t\tdst := tmp\n\tOD\nFI","header":"immintrin.h","instruction":"bsf","parameters":[{"type":"int","name":"a"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_bit_scan_reverse","tech":"Bit Manipulation","returnType":"int","cpuId":null,"category":"Bit Manipulation","description":"Set \"dst\" to the index of the highest set bit in 32-bit integer \"a\". If no bits are set in \"a\" then \"dst\" is undefined.","code":"tmp := 31\nIF a = 0\n\tdst := undefined\nELSE\n\tDO WHILE ((tmp > 0) AND a[tmp] = 0)\n\t\ttmp := tmp - 1\n\t\tdst := tmp\n\tOD\nFI","header":"immintrin.h","instruction":"bsr","parameters":[{"type":"int","name":"a"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_bswap","tech":"Bit Manipulation","returnType":"int","cpuId":null,"category":"Bit Manipulation","description":"Reverse the byte order of 32-bit integer \"a\", and store the result in \"dst\". This intrinsic is provided for conversion between little and big endian values.","code":"dst[7:0] := a[31:24]\ndst[15:8] := a[23:16]\ndst[23:16] := a[15:8]\ndst[31:24] := a[7:0]","header":"immintrin.h","instruction":"bswap","parameters":[{"type":"int","name":"a"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"","latency":"1","throughput":"0.5"},{"base":"06_2A/2D/3A/3E","parameters":"","latency":"2","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"","latency":"3","throughput":"1"},{"base":"06_17","parameters":"","latency":"4","throughput":"1"},{"base":"06_0F","parameters":"","latency":"2","throughput":"0.5"},{"base":"06_0E","parameters":"","latency":"2","throughput":"1"},{"base":"06_0D","parameters":"","latency":"2","throughput":"1"},{"base":"0F_03","parameters":"","latency":"1","throughput":"0.5"},{"base":"0F_02","parameters":"","latency":"7","throughput":"1"}]},{"name":"_bswap64","tech":"Bit Manipulation","returnType":"__int64","cpuId":null,"category":"Bit Manipulation","description":"Reverse the byte order of 64-bit integer \"a\", and store the result in \"dst\". This intrinsic is provided for conversion between little and big endian values.","code":"dst[7:0] := a[63:56]\ndst[15:8] := a[55:48]\ndst[23:16] := a[47:40]\ndst[31:24] := a[39:32]\ndst[39:32] := a[31:24]\ndst[47:40] := a[23:16]\ndst[55:48] := a[15:8]\ndst[63:56] := a[7:0]","header":"immintrin.h","instruction":"bswap","parameters":[{"type":"__int64","name":"a"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3C/45/46","parameters":"","latency":"1","throughput":"0.5"},{"base":"06_2A/2D/3A/3E","parameters":"","latency":"2","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"","latency":"3","throughput":"1"},{"base":"06_17","parameters":"","latency":"4","throughput":"1"},{"base":"06_0F","parameters":"","latency":"2","throughput":"0.5"},{"base":"06_0E","parameters":"","latency":"2","throughput":"1"},{"base":"06_0D","parameters":"","latency":"2","throughput":"1"},{"base":"0F_03","parameters":"","latency":"1","throughput":"0.5"},{"base":"0F_02","parameters":"","latency":"7","throughput":"1"}]},{"name":"_castf32_u32","tech":"Other","returnType":"unsigned __int32","cpuId":null,"category":"Cast","description":"Cast from type float to type unsigned __int32 without conversion.\n\tThis intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.","code":null,"header":"immintrin.h","instruction":"","parameters":[{"type":"float","name":"a"}],"isFloat":true,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_castf64_u64","tech":"Other","returnType":"unsigned __int64","cpuId":null,"category":"Cast","description":"Cast from type double to type unsigned __int64 without conversion.\n\tThis intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.","code":null,"header":"immintrin.h","instruction":"","parameters":[{"type":"double","name":"a"}],"isFloat":true,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_castu32_f32","tech":"Other","returnType":"float","cpuId":null,"category":"Cast","description":"Cast from type unsigned __int32 to type float without conversion.\n\tThis intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.","code":null,"header":"immintrin.h","instruction":"","parameters":[{"type":"unsigned __int32","name":"a"}],"isFloat":true,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_castu64_f64","tech":"Other","returnType":"double","cpuId":null,"category":"Cast","description":"Cast from type unsigned __int64 to type double without conversion.\n\tThis intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.","code":null,"header":"immintrin.h","instruction":"","parameters":[{"type":"unsigned __int64","name":"a"}],"isFloat":true,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_cvtsh_ss","tech":"Other","returnType":"float","cpuId":null,"category":"Convert","description":"Convert the half-precision (16-bit) floating-point value \"a\" to a single-precision (32-bit) floating-point value, and store the result in \"dst\".","code":"dst[31:0] := Convert_FP16_To_FP32(a[15:0])","header":"emmintrin.h","instruction":"","parameters":[{"type":"unsigned short","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_cvtss_sh","tech":"Other","returnType":"unsigned short","cpuId":null,"category":"Convert","description":"Convert the single-precision (32-bit) floating-point value \"a\" to a half-precision (16-bit) floating-point value, and store the result in \"dst\".","code":"dst[15:0] := Convert_FP32_To_FP16(a[31:0])","header":"emmintrin.h","instruction":"","parameters":[{"type":"float","name":"a"},{"type":"int","name":"imm"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_fxrstor","tech":"OS","returnType":"void","cpuId":"FXSR","category":"OS-Targeted","description":"Reload the x87 FPU, MMX technology, XMM, and MXCSR registers from the 512-byte memory image at \"mem_addr\". This data should have been written to memory previously using the FXSAVE instruction, and in the same format as required by the operating mode. \"mem_addr\" must be aligned on a 16-byte boundary.","code":"(x87 FPU, MMX, XMM7-XMM0, MXCSR) := Load(MEM[mem_addr])","header":"immintrin.h","instruction":"fxrstor","parameters":[{"type":"void *","name":"mem_addr"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"0F_02","parameters":"","latency":"150","throughput":""}]},{"name":"_fxrstor64","tech":"OS","returnType":"void","cpuId":"FXSR","category":"OS-Targeted","description":"Reload the x87 FPU, MMX technology, XMM, and MXCSR registers from the 512-byte memory image at \"mem_addr\". This data should have been written to memory previously using the FXSAVE64 instruction, and in the same format as required by the operating mode. \"mem_addr\" must be aligned on a 16-byte boundary.","code":"(x87 FPU, MMX, XMM7-XMM0, MXCSR) := Load(MEM[mem_addr])","header":"immintrin.h","instruction":"fxrstor64","parameters":[{"type":"void *","name":"mem_addr"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_fxsave","tech":"OS","returnType":"void","cpuId":"FXSR","category":"OS-Targeted","description":"Save the current state of the x87 FPU, MMX technology, XMM, and MXCSR registers to a 512-byte memory location at \"mem_addr\". The clayout of the 512-byte region depends on the operating mode. Bytes [511:464] are available for software use and will not be overwritten by the processor.","code":"MEM[mem_addr+511*8:mem_addr] := Fxsave(x87 FPU, MMX, XMM7-XMM0, MXCSR)","header":"immintrin.h","instruction":"fxsave","parameters":[{"type":"void *","name":"mem_addr"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"0F_02","parameters":"","latency":"100","throughput":""}]},{"name":"_fxsave64","tech":"OS","returnType":"void","cpuId":"FXSR","category":"OS-Targeted","description":"Save the current state of the x87 FPU, MMX technology, XMM, and MXCSR registers to a 512-byte memory location at \"mem_addr\". The layout of the 512-byte region depends on the operating mode. Bytes [511:464] are available for software use and will not be overwritten by the processor.","code":"MEM[mem_addr+511*8:mem_addr] := Fxsave64(x87 FPU, MMX, XMM7-XMM0, MXCSR)","header":"immintrin.h","instruction":"fxsave64","parameters":[{"type":"void *","name":"mem_addr"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_lrotl","tech":"Bit Manipulation","returnType":"unsigned long","cpuId":null,"category":"Shift","description":"Shift the bits of unsigned 64-bit integer \"a\" left by the number of bits specified in \"shift\", rotating the most-significant bit to the least-significant bit location, and store the unsigned result in \"dst\".","code":"dst := a\ncount := shift BITWISE AND 63\nDO WHILE (count > 0)\n\ttmp[0] := dst[63]\n\tdst := (dst << 1) OR tmp[0]\n\tcount := count - 1\nOD","header":"immintrin.h","instruction":"rol","parameters":[{"type":"unsigned long","name":"a"},{"type":"int","name":"shift"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_lrotr","tech":"Bit Manipulation","returnType":"unsigned long","cpuId":null,"category":"Shift","description":"Shift the bits of unsigned 64-bit integer \"a\" right by the number of bits specified in \"shift\", rotating the least-significant bit to the most-significant bit location, and store the unsigned result in \"dst\".","code":"dst := a\ncount := shift BITWISE AND 63\nDO WHILE (count > 0)\n\ttmp[63] := dst[0]\n\tdst := (dst >> 1) OR tmp[63]\n\tcount := count - 1\nOD","header":"immintrin.h","instruction":"ror","parameters":[{"type":"unsigned long","name":"a"},{"type":"int","name":"shift"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_allow_cpu_features","tech":"Other","returnType":"void","cpuId":null,"category":"General Support","description":"Treat the processor-specific feature(s) specified in \"a\" as available. Multiple features may be OR'd together. See the valid feature flags below:","code":"_FEATURE_GENERIC_IA32\n_FEATURE_FPU\n_FEATURE_CMOV\n_FEATURE_MMX\n_FEATURE_FXSAVE\n_FEATURE_SSE\n_FEATURE_SSE2\n_FEATURE_SSE3\n_FEATURE_SSSE3\n_FEATURE_SSE4_1\n_FEATURE_SSE4_2\n_FEATURE_MOVBE\n_FEATURE_POPCNT\n_FEATURE_PCLMULQDQ\n_FEATURE_AES\n_FEATURE_F16C\n_FEATURE_AVX\n_FEATURE_RDRND\n_FEATURE_FMA\n_FEATURE_BMI\n_FEATURE_LZCNT\n_FEATURE_HLE\n_FEATURE_RTM\n_FEATURE_AVX2\n_FEATURE_KNCNI\n_FEATURE_ADX\n_FEATURE_RDSEED","header":"immintrin.h","instruction":"","parameters":[{"type":"unsigned __int64","name":"a"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_may_i_use_cpu_feature","tech":"Other","returnType":"int","cpuId":null,"category":"General Support","description":"Dynamically query the processor to determine if the processor-specific feature(s) specified in \"a\" are available, and return true or false (1 or 0) if the set of features is available. Multiple features may be OR'd together. This intrinsic does not check the processor vendor. See the valid feature flags below:","code":"_FEATURE_GENERIC_IA32\n_FEATURE_FPU\n_FEATURE_CMOV\n_FEATURE_MMX\n_FEATURE_FXSAVE\n_FEATURE_SSE\n_FEATURE_SSE2\n_FEATURE_SSE3\n_FEATURE_SSSE3\n_FEATURE_SSE4_1\n_FEATURE_SSE4_2\n_FEATURE_MOVBE\n_FEATURE_POPCNT\n_FEATURE_PCLMULQDQ\n_FEATURE_AES\n_FEATURE_F16C\n_FEATURE_AVX\n_FEATURE_RDRND\n_FEATURE_FMA\n_FEATURE_BMI\n_FEATURE_LZCNT\n_FEATURE_HLE\n_FEATURE_RTM\n_FEATURE_AVX2\n_FEATURE_KNCNI\n_FEATURE_ADX\n_FEATURE_RDSEED","header":"immintrin.h","instruction":"","parameters":[{"type":"unsigned __int64","name":"a"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_acos_pd","tech":"SVML","returnType":"__m128d","cpuId":"SSE","category":"Trigonometry","description":"Compute the inverse cosine of packed double-precision (64-bit) floating-point elements in \"a\" expressed in radians, and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := ACOS(a[i+63:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_acos_ps","tech":"SVML","returnType":"__m128","cpuId":"SSE","category":"Trigonometry","description":"Compute the inverse cosine of packed single-precision (32-bit) floating-point elements in \"a\" expressed in radians, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := ACOS(a[i+31:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_acosh_pd","tech":"SVML","returnType":"__m128d","cpuId":"SSE","category":"Trigonometry","description":"Compute the inverse hyperbolic cosine of packed double-precision (64-bit) floating-point elements in \"a\" expressed in radians, and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := ACOSH(a[i+63:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_acosh_ps","tech":"SVML","returnType":"__m128","cpuId":"SSE","category":"Trigonometry","description":"Compute the inverse hyperbolic cosine of packed single-precision (32-bit) floating-point elements in \"a\" expressed in radians, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := ACOSH(a[i+31:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_asin_pd","tech":"SVML","returnType":"__m128d","cpuId":"SSE","category":"Trigonometry","description":"Compute the inverse sine of packed double-precision (64-bit) floating-point elements in \"a\" expressed in radians, and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := ASIN(a[i+63:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_asin_ps","tech":"SVML","returnType":"__m128","cpuId":"SSE","category":"Trigonometry","description":"Compute the inverse sine of packed single-precision (32-bit) floating-point elements in \"a\" expressed in radians, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := ASIN(a[i+31:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_asinh_pd","tech":"SVML","returnType":"__m128d","cpuId":"SSE","category":"Trigonometry","description":"Compute the inverse hyperbolic sine of packed double-precision (64-bit) floating-point elements in \"a\" expressed in radians, and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := ASINH(a[i+63:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_asinh_ps","tech":"SVML","returnType":"__m128","cpuId":"SSE","category":"Trigonometry","description":"Compute the inverse hyperbolic sine of packed single-precision (32-bit) floating-point elements in \"a\" expressed in radians, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := ASINH(a[i+31:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_atan_pd","tech":"SVML","returnType":"__m128d","cpuId":"SSE","category":"Trigonometry","description":"Compute the inverse tangent of packed double-precision (64-bit) floating-point elements in \"a\" expressed in radians, and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := ATAN(a[i+63:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_atan_ps","tech":"SVML","returnType":"__m128","cpuId":"SSE","category":"Trigonometry","description":"Compute the inverse tangent of packed single-precision (32-bit) floating-point elements in \"a\" expressed in radians, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := ATAN(a[i+31:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_atan2_pd","tech":"SVML","returnType":"__m128d","cpuId":"SSE","category":"Trigonometry","description":"Compute the inverse tangent of packed double-precision (64-bit) floating-point elements in \"a\" divided by packed elements in \"b\", and store the results in \"dst\" expressed in radians.","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := ATAN(a[i+63:i] / b[i+63:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_atan2_ps","tech":"SVML","returnType":"__m128","cpuId":"SSE","category":"Trigonometry","description":"Compute the inverse tangent of packed single-precision (32-bit) floating-point elements in \"a\" divided by packed elements in \"b\", and store the results in \"dst\" expressed in radians.","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := ATAN(a[i+31:i] / b[i+31:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_atanh_pd","tech":"SVML","returnType":"__m128d","cpuId":"SSE","category":"Trigonometry","description":"Compute the inverse hyperbolic tangent of packed double-precision (64-bit) floating-point elements in \"a\" expressed in radians, and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := ATANH(a[i+63:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_atanh_ps","tech":"SVML","returnType":"__m128","cpuId":"SSE","category":"Trigonometry","description":"Compute the inverse hyperbolic tangent of packed single-precision (32-bit) floating-point elements in \"a\" expressed in radians, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := ATANH(a[i+31:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_cbrt_pd","tech":"SVML","returnType":"__m128d","cpuId":"SSE","category":"Elementary Math Functions","description":"Compute the cube root of packed double-precision (64-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := CubeRoot(a[i+63:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_cbrt_ps","tech":"SVML","returnType":"__m128","cpuId":"SSE","category":"Elementary Math Functions","description":"Compute the cube root of packed single-precision (32-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := CubeRoot(a[i+31:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_cdfnorm_pd","tech":"SVML","returnType":"__m128d","cpuId":"SSE","category":"Probability/Statistics","description":"Compute the cumulative distribution function of packed double-precision (64-bit) floating-point elements in \"a\" using the normal distribution, and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := CDFNormal(a[i+63:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_cdfnorm_ps","tech":"SVML","returnType":"__m128","cpuId":"SSE","category":"Probability/Statistics","description":"Compute the cumulative distribution function of packed single-precision (32-bit) floating-point elements in \"a\" using the normal distribution, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := CDFNormal(a[i+31:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_cdfnorminv_pd","tech":"SVML","returnType":"__m128d","cpuId":"SSE","category":"Probability/Statistics","description":"Compute the inverse cumulative distribution function of packed double-precision (64-bit) floating-point elements in \"a\" using the normal distribution, and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := InverseCDFNormal(a[i+63:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_cdfnorminv_ps","tech":"SVML","returnType":"__m128","cpuId":"SSE","category":"Probability/Statistics","description":"Compute the inverse cumulative distribution function of packed single-precision (32-bit) floating-point elements in \"a\" using the normal distribution, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := InverseCDFNormal(a[i+31:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_cexp_ps","tech":"SVML","returnType":"__m128","cpuId":"SSE","category":"Elementary Math Functions","description":"Compute the exponential value of \"e\" raised to the power of packed complex single-precision (32-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := e^(a[i+31:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_clog_ps","tech":"SVML","returnType":"__m128","cpuId":"SSE","category":"Elementary Math Functions","description":"Compute the natural logarithm of packed complex single-precision (32-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := ln(a[i+31:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_cos_pd","tech":"SVML","returnType":"__m128d","cpuId":"SSE","category":"Trigonometry","description":"Compute the cosine of packed double-precision (64-bit) floating-point elements in \"a\" expressed in radians, and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := COS(a[i+63:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_cos_ps","tech":"SVML","returnType":"__m128","cpuId":"SSE","category":"Trigonometry","description":"Compute the cosine of packed single-precision (32-bit) floating-point elements in \"a\" expressed in radians, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := COS(a[i+31:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_cosd_pd","tech":"SVML","returnType":"__m128d","cpuId":"SSE","category":"Trigonometry","description":"Compute the cosine of packed double-precision (64-bit) floating-point elements in \"a\" expressed in degrees, and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := COSD(a[i+63:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_cosd_ps","tech":"SVML","returnType":"__m128","cpuId":"SSE","category":"Trigonometry","description":"Compute the cosine of packed single-precision (32-bit) floating-point elements in \"a\" expressed in degrees, and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*32\n\tdst[i+31:i] := COSD(a[i+31:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_cosh_pd","tech":"SVML","returnType":"__m128d","cpuId":"SSE","category":"Trigonometry","description":"Compute the hyperbolic cosine of packed double-precision (64-bit) floating-point elements in \"a\" expressed in radians, and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := COSH(a[i+63:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_cosh_ps","tech":"SVML","returnType":"__m128","cpuId":"SSE","category":"Trigonometry","description":"Compute the hyperbolic cosine of packed single-precision (32-bit) floating-point elements in \"a\" expressed in radians, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := COSH(a[i+31:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_csqrt_ps","tech":"SVML","returnType":"__m128","cpuId":"SSE","category":"Elementary Math Functions","description":"Compute the square root of packed complex single-precision (32-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := SQRT(a[i+31:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_div_epi8","tech":"SVML","returnType":"__m128i","cpuId":"SSE","category":"Arithmetic","description":"Divide packed 8-bit integers in \"a\" by packed elements in \"b\", and store the truncated results in \"dst\".","code":"FOR j := 0 to 15\n\ti := 8*j\n\tdst[i+7:i] := TRUNCATE(a[i+7:i] / b[i+7:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_div_epi16","tech":"SVML","returnType":"__m128i","cpuId":"SSE","category":"Arithmetic","description":"Divide packed 16-bit integers in \"a\" by packed elements in \"b\", and store the truncated results in \"dst\".","code":"FOR j := 0 to 7\n\ti := 16*j\n\tdst[i+15:i] := TRUNCATE(a[i+15:i] / b[i+15:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_div_epi32","tech":"SVML","returnType":"__m128i","cpuId":"SSE","category":"Arithmetic","description":"Divide packed 32-bit integers in \"a\" by packed elements in \"b\", and store the truncated results in \"dst\".","code":"FOR j := 0 to 3\n\ti := 32*j\n\tdst[i+31:i] := TRUNCATE(a[i+31:i] / b[i+31:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_div_epi64","tech":"SVML","returnType":"__m128i","cpuId":"SSE","category":"Arithmetic","description":"Divide packed 64-bit integers in \"a\" by packed elements in \"b\", and store the truncated results in \"dst\".","code":"FOR j := 0 to 1\n\ti := 64*j\n\tdst[i+63:i] := TRUNCATE(a[i+63:i] / b[i+63:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_div_epu8","tech":"SVML","returnType":"__m128i","cpuId":"SSE","category":"Arithmetic","description":"Divide packed unsigned 8-bit integers in \"a\" by packed elements in \"b\", and store the truncated results in \"dst\".","code":"FOR j := 0 to 15\n\ti := 8*j\n\tdst[i+7:i] := TRUNCATE(a[i+7:i] / b[i+7:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_div_epu16","tech":"SVML","returnType":"__m128i","cpuId":"SSE","category":"Arithmetic","description":"Divide packed unsigned 16-bit integers in \"a\" by packed elements in \"b\", and store the truncated results in \"dst\".","code":"FOR j := 0 to 7\n\ti := 16*j\n\tdst[i+15:i] := TRUNCATE(a[i+15:i] / b[i+15:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_div_epu32","tech":"SVML","returnType":"__m128i","cpuId":"SSE","category":"Arithmetic","description":"Divide packed unsigned 32-bit integers in \"a\" by packed elements in \"b\", and store the truncated results in \"dst\".","code":"FOR j := 0 to 3\n\ti := 32*j\n\tdst[i+31:i] := TRUNCATE(a[i+31:i] / b[i+31:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_div_epu64","tech":"SVML","returnType":"__m128i","cpuId":"SSE","category":"Arithmetic","description":"Divide packed unsigned 64-bit integers in \"a\" by packed elements in \"b\", and store the truncated results in \"dst\".","code":"FOR j := 0 to 1\n\ti := 64*j\n\tdst[i+63:i] := TRUNCATE(a[i+63:i] / b[i+63:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_erf_pd","tech":"SVML","returnType":"__m128d","cpuId":"SSE","category":"Arithmetic","description":"Compute the error function of packed double-precision (64-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := ERF(a[i+63:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_erf_ps","tech":"SVML","returnType":"__m128","cpuId":"SSE","category":"Probability/Statistics","description":"Compute the error function of packed single-precision (32-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := ERF(a[i+31:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_erfc_pd","tech":"SVML","returnType":"__m128d","cpuId":"SSE","category":"Probability/Statistics","description":"Compute the complementary error function of packed double-precision (64-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := 1.0 - ERF(a[i+63:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_erfc_ps","tech":"SVML","returnType":"__m128","cpuId":"SSE","category":"Probability/Statistics","description":"Compute the complementary error function of packed single-precision (32-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := 1.0 - ERF(a[i+31:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_erfcinv_pd","tech":"SVML","returnType":"__m128d","cpuId":"SSE","category":"Probability/Statistics","description":"Compute the inverse complementary error function of packed double-precision (64-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := 1.0 / (1.0 - ERF(a[i+63:i]))\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_erfcinv_ps","tech":"SVML","returnType":"__m128","cpuId":"SSE","category":"Probability/Statistics","description":"Compute the inverse complementary error function of packed single-precision (32-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := 1.0 / (1.0 - ERF(a[i+31:i]))\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_erfinv_pd","tech":"SVML","returnType":"__m128d","cpuId":"SSE","category":"Probability/Statistics","description":"Compute the inverse error function of packed double-precision (64-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := 1.0 / ERF(a[i+63:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_erfinv_ps","tech":"SVML","returnType":"__m128","cpuId":"SSE","category":"Probability/Statistics","description":"Compute the inverse error function of packed single-precision (32-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := 1.0 / ERF(a[i+31:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_exp_pd","tech":"SVML","returnType":"__m128d","cpuId":"SSE","category":"Elementary Math Functions","description":"Compute the exponential value of \"e\" raised to the power of packed double-precision (64-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := e^(a[i+63:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_exp_ps","tech":"SVML","returnType":"__m128","cpuId":"SSE","category":"Elementary Math Functions","description":"Compute the exponential value of \"e\" raised to the power of packed single-precision (32-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := e^(a[i+31:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_exp10_pd","tech":"SVML","returnType":"__m128d","cpuId":"SSE","category":"Elementary Math Functions","description":"Compute the exponential value of 10 raised to the power of packed double-precision (64-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := 10^(a[i+63:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_exp10_ps","tech":"SVML","returnType":"__m128","cpuId":"SSE","category":"Elementary Math Functions","description":"Compute the exponential value of 10 raised to the power of packed single-precision (32-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := 10^(a[i+31:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_exp2_pd","tech":"SVML","returnType":"__m128d","cpuId":"SSE","category":"Elementary Math Functions","description":"Compute the exponential value of 2 raised to the power of packed double-precision (64-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := 2^(a[i+63:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_exp2_ps","tech":"SVML","returnType":"__m128","cpuId":"SSE","category":"Elementary Math Functions","description":"Compute the exponential value of 2 raised to the power of packed single-precision (32-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := 2^(a[i+31:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_expm1_pd","tech":"SVML","returnType":"__m128d","cpuId":"SSE","category":"Elementary Math Functions","description":"Compute the exponential value of \"e\" raised to the power of packed double-precision (64-bit) floating-point elements in \"a\", subtract one from each element, and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := e^(a[i+63:i]) - 1.0\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_expm1_ps","tech":"SVML","returnType":"__m128","cpuId":"SSE","category":"Elementary Math Functions","description":"Compute the exponential value of \"e\" raised to the power of packed single-precision (32-bit) floating-point elements in \"a\", subtract one from each element, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := e^(a[i+31:i]) - 1.0\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_free","tech":"Other","returnType":"void","cpuId":"SSE","category":"General Support","description":"Free aligned memory that was allocated with \"_mm_malloc\".","code":null,"header":"xmmintrin.h","instruction":"","parameters":[{"type":"void *","name":"mem_addr"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_hypot_pd","tech":"SVML","returnType":"__m128d","cpuId":"SSE","category":"Trigonometry","description":"Compute the length of the hypotenous of a right triangle, with the lengths of the other two sides of the triangle stored as packed double-precision (64-bit) floating-point elements in \"a\" and \"b\", and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := SQRT(a[i+63:i]^2 + b[i+63:i]^2)\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_hypot_ps","tech":"SVML","returnType":"__m128","cpuId":"SSE","category":"Trigonometry","description":"Compute the length of the hypotenous of a right triangle, with the lengths of the other two sides of the triangle stored as packed single-precision (32-bit) floating-point elements in \"a\" and \"b\", and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := SQRT(a[i+31:i]^2 + b[i+31:i]^2)\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_idiv_epi32","tech":"SVML","returnType":"__m128i","cpuId":"SSE","category":"Arithmetic","description":"Divide packed 32-bit integers in \"a\" by packed elements in \"b\", and store the truncated results in \"dst\".","code":"FOR j := 0 to 3\n\ti := 32*j\n\tdst[i+31:i] := TRUNCATE(a[i+31:i] / b[i+31:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_idivrem_epi32","tech":"SVML","returnType":"__m128i","cpuId":"SSE","category":"Arithmetic","description":"Divide packed 32-bit integers in \"a\" by packed elements in \"b\", store the truncated results in \"dst\", and store the remainders as packed 32-bit integers into memory at \"mem_addr\".","code":"FOR j := 0 to 3\n\ti := 32*j\n\tdst[i+31:i] := TRUNCATE(a[i+31:i] / b[i+31:i])\n\tMEM[mem_addr+i+31:mem_addr+i] := REMAINDER(a[i+31:i] / b[i+31:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128i *","name":"mem_addr"},{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_invcbrt_pd","tech":"SVML","returnType":"__m128d","cpuId":"SSE","category":"Elementary Math Functions","description":"Compute the inverse cube root of packed double-precision (64-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := InvCubeRoot(a[i+63:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_invcbrt_ps","tech":"SVML","returnType":"__m128","cpuId":"SSE","category":"Elementary Math Functions","description":"Compute the inverse cube root of packed single-precision (32-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := InvCubeRoot(a[i+31:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_invsqrt_pd","tech":"SVML","returnType":"__m128d","cpuId":"SSE","category":"Elementary Math Functions","description":"Compute the inverse square root of packed double-precision (64-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := InvSQRT(a[i+63:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_invsqrt_ps","tech":"SVML","returnType":"__m128","cpuId":"SSE","category":"Elementary Math Functions","description":"Compute the inverse square root of packed single-precision (32-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := InvSQRT(a[i+31:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_irem_epi32","tech":"SVML","returnType":"__m128i","cpuId":"SSE","category":"Arithmetic","description":"Divide packed 32-bit integers in \"a\" by packed elements in \"b\", and store the remainders as packed 32-bit integers in \"dst\".","code":"FOR j := 0 to 3\n\ti := 32*j\n\tdst[i+31:i] := REMAINDER(a[i+31:i] / b[i+31:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_log_pd","tech":"SVML","returnType":"__m128d","cpuId":"SSE","category":"Elementary Math Functions","description":"Compute the natural logarithm of packed double-precision (64-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := ln(a[i+63:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_log_ps","tech":"SVML","returnType":"__m128","cpuId":"SSE","category":"Elementary Math Functions","description":"Compute the natural logarithm of packed single-precision (32-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := ln(a[i+31:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_log10_pd","tech":"SVML","returnType":"__m128d","cpuId":"SSE","category":"Elementary Math Functions","description":"Compute the base-10 logarithm of packed double-precision (64-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := log10(a[i+63:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_log10_ps","tech":"SVML","returnType":"__m128","cpuId":"SSE","category":"Elementary Math Functions","description":"Compute the base-10 logarithm of packed single-precision (32-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := log10(a[i+31:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_log1p_pd","tech":"SVML","returnType":"__m128d","cpuId":"SSE","category":"Elementary Math Functions","description":"Compute the natural logarithm of one plus packed double-precision (64-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := ln(1.0 + a[i+63:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_log1p_ps","tech":"SVML","returnType":"__m128","cpuId":"SSE","category":"Elementary Math Functions","description":"Compute the natural logarithm of one plus packed single-precision (32-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := ln(1.0 + a[i+31:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_log2_pd","tech":"SVML","returnType":"__m128d","cpuId":"SSE","category":"Elementary Math Functions","description":"Compute the base-2 logarithm of packed double-precision (64-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := log2(a[i+63:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_log2_ps","tech":"SVML","returnType":"__m128","cpuId":"SSE","category":"Elementary Math Functions","description":"Compute the base-2 logarithm of packed single-precision (32-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := log2(a[i+31:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_logb_pd","tech":"SVML","returnType":"__m128d","cpuId":"SSE","category":"Elementary Math Functions","description":"Convert the exponent of each packed double-precision (64-bit) floating-point element in \"a\" to a double-precision floating-point number representing the integer exponent, and store the results in \"dst\". This intrinsic essentially calculates \"floor(log2(x))\" for each element.","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := ConvertExpFP64(a[i+63:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_logb_ps","tech":"SVML","returnType":"__m128","cpuId":"SSE","category":"Elementary Math Functions","description":"Convert the exponent of each packed single-precision (32-bit) floating-point element in \"a\" to a single-precision floating-point number representing the integer exponent, and store the results in \"dst\". This intrinsic essentially calculates \"floor(log2(x))\" for each element.","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := ConvertExpFP32(a[i+31:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_malloc","tech":"Other","returnType":"void*","cpuId":"SSE","category":"General Support","description":"Allocate \"size\" bytes of memory, aligned to the alignment specified in \"align\", and return a pointer to the allocated memory. \"_mm_free\" should be used to free memory that is allocated with \"_mm_malloc\".","code":null,"header":"xmmintrin.h","instruction":"","parameters":[{"type":"size_t","name":"size"},{"type":"size_t","name":"align"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_pow_pd","tech":"SVML","returnType":"__m128d","cpuId":"SSE","category":"Elementary Math Functions","description":"Compute the exponential value of packed double-precision (64-bit) floating-point elements in \"a\" raised by packed elements in \"b\", and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := (a[i+63:i])^(b[i+63:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128d","name":"a"},{"type":"__m128d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_pow_ps","tech":"SVML","returnType":"__m128","cpuId":"SSE","category":"Elementary Math Functions","description":"Compute the exponential value of packed single-precision (32-bit) floating-point elements in \"a\" raised by packed elements in \"b\", and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := (a[i+31:i])^(b[i+31:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128","name":"a"},{"type":"__m128","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_rem_epi8","tech":"SVML","returnType":"__m128i","cpuId":"SSE","category":"Arithmetic","description":"Divide packed 8-bit integers in \"a\" by packed elements in \"b\", and store the remainders as packed 32-bit integers in \"dst\".","code":"FOR j := 0 to 15\n\ti := 8*j\n\tdst[i+7:i] := REMAINDER(a[i+7:i] / b[i+7:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_rem_epi16","tech":"SVML","returnType":"__m128i","cpuId":"SSE","category":"Arithmetic","description":"Divide packed 16-bit integers in \"a\" by packed elements in \"b\", and store the remainders as packed 32-bit integers in \"dst\".","code":"FOR j := 0 to 7\n\ti := 16*j\n\tdst[i+15:i] := REMAINDER(a[i+15:i] / b[i+15:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_rem_epi32","tech":"SVML","returnType":"__m128i","cpuId":"SSE","category":"Arithmetic","description":"Divide packed 32-bit integers in \"a\" by packed elements in \"b\", and store the remainders as packed 32-bit integers in \"dst\".","code":"FOR j := 0 to 3\n\ti := 32*j\n\tdst[i+31:i] := REMAINDER(a[i+31:i] / b[i+31:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_rem_epi64","tech":"SVML","returnType":"__m128i","cpuId":"SSE","category":"Arithmetic","description":"Divide packed 64-bit integers in \"a\" by packed elements in \"b\", and store the remainders as packed 32-bit integers in \"dst\".","code":"FOR j := 0 to 1\n\ti := 64*j\n\tdst[i+63:i] := REMAINDER(a[i+63:i] / b[i+63:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_rem_epu8","tech":"SVML","returnType":"__m128i","cpuId":"SSE","category":"Arithmetic","description":"Divide packed unsigned 8-bit integers in \"a\" by packed elements in \"b\", and store the remainders as packed unsigned 32-bit integers in \"dst\".","code":"FOR j := 0 to 15\n\ti := 8*j\n\tdst[i+7:i] := REMAINDER(a[i+7:i] / b[i+7:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_rem_epu16","tech":"SVML","returnType":"__m128i","cpuId":"SSE","category":"Arithmetic","description":"Divide packed unsigned 16-bit integers in \"a\" by packed elements in \"b\", and store the remainders as packed unsigned 32-bit integers in \"dst\".","code":"FOR j := 0 to 7\n\ti := 16*j\n\tdst[i+15:i] := REMAINDER(a[i+15:i] / b[i+15:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_rem_epu32","tech":"SVML","returnType":"__m128i","cpuId":"SSE","category":"Arithmetic","description":"Divide packed unsigned 32-bit integers in \"a\" by packed elements in \"b\", and store the remainders as packed unsigned 32-bit integers in \"dst\".","code":"FOR j := 0 to 3\n\ti := 32*j\n\tdst[i+31:i] := REMAINDER(a[i+31:i] / b[i+31:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_rem_epu64","tech":"SVML","returnType":"__m128i","cpuId":"SSE","category":"Arithmetic","description":"Divide packed unsigned 64-bit integers in \"a\" by packed elements in \"b\", and store the remainders as packed unsigned 32-bit integers in \"dst\".","code":"FOR j := 0 to 1\n\ti := 64*j\n\tdst[i+63:i] := REMAINDER(a[i+63:i] / b[i+63:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_sin_pd","tech":"SVML","returnType":"__m128d","cpuId":"SSE","category":"Trigonometry","description":"Compute the sine of packed double-precision (64-bit) floating-point elements in \"a\" expressed in radians, and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := SIN(a[i+63:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_sin_ps","tech":"SVML","returnType":"__m128","cpuId":"SSE","category":"Trigonometry","description":"Compute the sine of packed single-precision (32-bit) floating-point elements in \"a\" expressed in radians, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := SIN(a[i+31:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_sincos_pd","tech":"SVML","returnType":"__m128d","cpuId":"SSE","category":"Trigonometry","description":"Compute the sine and cosine of packed double-precision (64-bit) floating-point elements in \"a\" expressed in radians, store the sine in \"dst\", and store the cosine into memory at \"mem_addr\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := SIN(a[i+63:i])\n\tMEM[mem_addr+i+63:mem_addr+i] := COS(a[i+63:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128d *","name":"mem_addr"},{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_sincos_ps","tech":"SVML","returnType":"__m128","cpuId":"SSE","category":"Trigonometry","description":"Compute the sine and cosine of packed single-precision (32-bit) floating-point elements in \"a\" expressed in radians, store the sine in \"dst\", and store the cosine into memory at \"mem_addr\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := SIN(a[i+31:i])\n\tMEM[mem_addr+i+31:mem_addr+i] := COS(a[i+31:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128 *","name":"mem_addr"},{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_sind_pd","tech":"SVML","returnType":"__m128d","cpuId":"SSE","category":"Trigonometry","description":"Compute the sine of packed double-precision (64-bit) floating-point elements in \"a\" expressed in degrees, and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := SIND(a[i+63:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_sind_ps","tech":"SVML","returnType":"__m128","cpuId":"SSE","category":"Trigonometry","description":"Compute the sine of packed single-precision (32-bit) floating-point elements in \"a\" expressed in degrees, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := SIND(a[i+31:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_sinh_pd","tech":"SVML","returnType":"__m128d","cpuId":"SSE","category":"Trigonometry","description":"Compute the hyperbolic sine of packed double-precision (64-bit) floating-point elements in \"a\" expressed in radians, and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := SINH(a[i+63:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_sinh_ps","tech":"SVML","returnType":"__m128","cpuId":"SSE","category":"Trigonometry","description":"Compute the hyperbolic sine of packed single-precision (32-bit) floating-point elements in \"a\" expressed in radians, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := SINH(a[i+31:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_svml_ceil_pd","tech":"SVML","returnType":"__m128d","cpuId":"SSE","category":"Special Math Functions","description":"Round the packed double-precision (64-bit) floating-point elements in \"a\" up to an integer value, and store the results as packed double-precision floating-point elements in \"dst\". This intrinsic may generate the \"roundpd\"/\"vroundpd\" instruction.","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := CEIL(a[i+63:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_svml_ceil_ps","tech":"SVML","returnType":"__m128","cpuId":"SSE","category":"Special Math Functions","description":"Round the packed single-precision (32-bit) floating-point elements in \"a\" up to an integer value, and store the results as packed single-precision floating-point elements in \"dst\". This intrinsic may generate the \"roundps\"/\"vroundps\" instruction.","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := CEIL(a[i+31:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_svml_floor_pd","tech":"SVML","returnType":"__m128d","cpuId":"SSE","category":"Special Math Functions","description":"Round the packed double-precision (64-bit) floating-point elements in \"a\" down to an integer value, and store the results as packed double-precision floating-point elements in \"dst\". This intrinsic may generate the \"roundpd\"/\"vroundpd\" instruction.","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := FLOOR(a[i+63:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_svml_floor_ps","tech":"SVML","returnType":"__m128","cpuId":"SSE","category":"Special Math Functions","description":"Round the packed single-precision (32-bit) floating-point elements in \"a\" down to an integer value, and store the results as packed single-precision floating-point elements in \"dst\". This intrinsic may generate the \"roundps\"/\"vroundps\" instruction.","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := FLOOR(a[i+31:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_svml_round_pd","tech":"SVML","returnType":"__m128d","cpuId":"SSE","category":"Special Math Functions","description":"Round the packed double-precision (64-bit) floating-point elements in \"a\" to the nearest integer value, and store the results as packed double-precision floating-point elements in \"dst\". This intrinsic may generate the \"roundpd\"/\"vroundpd\" instruction.","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := ROUND(a[i+63:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_svml_round_ps","tech":"SVML","returnType":"__m128","cpuId":"SSE","category":"Special Math Functions","description":"Round the packed single-precision (32-bit) floating-point elements in \"a\" to the nearest integer value, and store the results as packed single-precision floating-point elements in \"dst\". This intrinsic may generate the \"roundps\"/\"vroundps\" instruction.","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := ROUND(a[i+31:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_svml_sqrt_pd","tech":"SVML","returnType":"__m128d","cpuId":"SSE","category":"Elementary Math Functions","description":"Compute the square root of packed double-precision (64-bit) floating-point elements in \"a\", and store the results in \"dst\". Note that this intrinsic is less efficient than \"_mm_sqrt_pd\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := SQRT(a[i+63:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_svml_sqrt_ps","tech":"SVML","returnType":"__m128","cpuId":"SSE","category":"Elementary Math Functions","description":"Compute the square root of packed single-precision (32-bit) floating-point elements in \"a\", and store the results in \"dst\".  Note that this intrinsic is less efficient than \"_mm_sqrt_ps\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := SQRT(a[i+31:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_tan_pd","tech":"SVML","returnType":"__m128d","cpuId":"SSE","category":"Trigonometry","description":"Compute the tangent of packed double-precision (64-bit) floating-point elements in \"a\" expressed in radians, and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := TAN(a[i+63:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_tan_ps","tech":"SVML","returnType":"__m128","cpuId":"SSE","category":"Trigonometry","description":"Compute the tangent of packed single-precision (32-bit) floating-point elements in \"a\" expressed in radians, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := TAN(a[i+31:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_tand_pd","tech":"SVML","returnType":"__m128d","cpuId":"SSE","category":"Trigonometry","description":"Compute the tangent of packed double-precision (64-bit) floating-point elements in \"a\" expressed in degrees, and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := TAND(a[i+63:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_tand_ps","tech":"SVML","returnType":"__m128","cpuId":"SSE","category":"Trigonometry","description":"Compute the tangent of packed single-precision (32-bit) floating-point elements in \"a\" expressed in degrees, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := TAND(a[i+31:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_tanh_pd","tech":"SVML","returnType":"__m128d","cpuId":"SSE","category":"Trigonometry","description":"Compute the hyperbolic tangent of packed double-precision (64-bit) floating-point elements in \"a\" expressed in radians, and store the results in \"dst\".","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := TANH(a[i+63:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_tanh_ps","tech":"SVML","returnType":"__m128","cpuId":"SSE","category":"Trigonometry","description":"Compute the hyperbolic tangent of packed single-precision (32-bit) floating-point elements in \"a\" expressed in radians, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := TANH(a[i+31:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_trunc_pd","tech":"SVML","returnType":"__m128d","cpuId":"SSE","category":"Miscellaneous","description":"Truncate the packed double-precision (64-bit) floating-point elements in \"a\", and store the results as packed double-precision floating-point elements in \"dst\". This intrinsic may generate the \"roundpd\"/\"vroundpd\" instruction.","code":"FOR j := 0 to 1\n\ti := j*64\n\tdst[i+63:i] := TRUNCATE(a[i+63:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_trunc_ps","tech":"SVML","returnType":"__m128","cpuId":"SSE","category":"Miscellaneous","description":"Truncate the packed single-precision (32-bit) floating-point elements in \"a\", and store the results as packed single-precision floating-point elements in \"dst\". This intrinsic may generate the \"roundps\"/\"vroundps\" instruction.","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := TRUNCATE(a[i+31:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_udiv_epi32","tech":"SVML","returnType":"__m128i","cpuId":"SSE","category":"Arithmetic","description":"Divide packed unsigned 32-bit integers in \"a\" by packed elements in \"b\", and store the truncated results in \"dst\".","code":"FOR j := 0 to 3\n\ti := 32*j\n\tdst[i+31:i] := TRUNCATE(a[i+31:i] / b[i+31:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_udivrem_epi32","tech":"SVML","returnType":"__m128i","cpuId":"SSE","category":"Arithmetic","description":"Divide packed unsigned 32-bit integers in \"a\" by packed elements in \"b\", store the truncated results in \"dst\", and store the remainders as packed unsigned 32-bit integers into memory at \"mem_addr\".","code":"FOR j := 0 to 3\n\ti := 32*j\n\tdst[i+31:i] := TRUNCATE(a[i+31:i] / b[i+31:i])\n\tMEM[mem_addr+i+31:mem_addr+i] := REMAINDER(a[i+31:i] / b[i+31:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128i *","name":"mem_addr"},{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_urem_epi32","tech":"SVML","returnType":"__m128i","cpuId":"SSE","category":"Arithmetic","description":"Divide packed unsigned 32-bit integers in \"a\" by packed elements in \"b\", and store the remainders as packed unsigned 32-bit integers in \"dst\".","code":"FOR j := 0 to 3\n\ti := 32*j\n\tdst[i+31:i] := REMAINDER(a[i+31:i] / b[i+31:i])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_acos_pd","tech":"SVML","returnType":"__m256d","cpuId":"AVX","category":"Trigonometry","description":"Compute the inverse cosine of packed double-precision (64-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*64\n\tdst[i+63:i] := ACOS(a[i+63:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_acos_ps","tech":"SVML","returnType":"__m256","cpuId":"AVX","category":"Trigonometry","description":"Compute the inverse cosine of packed single-precision (32-bit) floating-point elements in \"a\" expressed in radians, and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*32\n\tdst[i+31:i] := ACOS(a[i+31:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_acosh_pd","tech":"SVML","returnType":"__m256d","cpuId":"AVX","category":"Trigonometry","description":"Compute the inverse hyperbolic cosine of packed double-precision (64-bit) floating-point elements in \"a\" expressed in radians, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*64\n\tdst[i+63:i] := ACOSH(a[i+63:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_acosh_ps","tech":"SVML","returnType":"__m256","cpuId":"AVX","category":"Trigonometry","description":"Compute the inverse hyperbolic cosine of packed single-precision (32-bit) floating-point elements in \"a\" expressed in radians, and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*32\n\tdst[i+31:i] := ACOSH(a[i+31:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_asin_pd","tech":"SVML","returnType":"__m256d","cpuId":"AVX","category":"Trigonometry","description":"Compute the inverse sine of packed double-precision (64-bit) floating-point elements in \"a\" expressed in radians, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*64\n\tdst[i+63:i] := ASIN(a[i+63:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_asin_ps","tech":"SVML","returnType":"__m256","cpuId":"AVX","category":"Trigonometry","description":"Compute the inverse sine of packed single-precision (32-bit) floating-point elements in \"a\" expressed in radians, and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*32\n\tdst[i+31:i] := ASIN(a[i+31:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_asinh_pd","tech":"SVML","returnType":"__m256d","cpuId":"AVX","category":"Trigonometry","description":"Compute the inverse hyperbolic sine of packed double-precision (64-bit) floating-point elements in \"a\" expressed in radians, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*64\n\tdst[i+63:i] := ASINH(a[i+63:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_asinh_ps","tech":"SVML","returnType":"__m256","cpuId":"AVX","category":"Trigonometry","description":"Compute the inverse hyperbolic sine of packed single-precision (32-bit) floating-point elements in \"a\" expressed in radians, and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*32\n\tdst[i+31:i] := ASINH(a[i+31:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_atan_pd","tech":"SVML","returnType":"__m256d","cpuId":"AVX","category":"Trigonometry","description":"Compute the inverse tangent of packed double-precision (64-bit) floating-point elements in \"a\" expressed in radians, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*64\n\tdst[i+63:i] := ATAN(a[i+63:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_atan_ps","tech":"SVML","returnType":"__m256","cpuId":"AVX","category":"Trigonometry","description":"Compute the inverse tangent of packed single-precision (32-bit) floating-point elements in \"a\" expressed in radians, and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*32\n\tdst[i+31:i] := ATAN(a[i+31:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_atan2_pd","tech":"SVML","returnType":"__m256d","cpuId":"AVX","category":"Trigonometry","description":"Compute the inverse tangent of packed double-precision (64-bit) floating-point elements in \"a\" divided by packed elements in \"b\", and store the results in \"dst\" expressed in radians.","code":"FOR j := 0 to 3\n\ti := j*64\n\tdst[i+63:i] := ATAN(a[i+63:i] / b[i+63:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256d","name":"a"},{"type":"__m256d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_atan2_ps","tech":"SVML","returnType":"__m256","cpuId":"AVX","category":"Trigonometry","description":"Compute the inverse tangent of packed single-precision (32-bit) floating-point elements in \"a\" divided by packed elements in \"b\", and store the results in \"dst\" expressed in radians.","code":"FOR j := 0 to 7\n\ti := j*32\n\tdst[i+31:i] := ATAN(a[i+31:i] / b[i+31:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256","name":"a"},{"type":"__m256","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_atanh_pd","tech":"SVML","returnType":"__m256d","cpuId":"AVX","category":"Trigonometry","description":"Compute the inverse hyperbolic tangent of packed double-precision (64-bit) floating-point elements in \"a\" expressed in radians, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*64\n\tdst[i+63:i] := ATANH(a[i+63:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_atanh_ps","tech":"SVML","returnType":"__m256","cpuId":"AVX","category":"Trigonometry","description":"Compute the inverse hyperbolic tangent of packed single-precision (32-bit) floating-point elements in \"a\" expressed in radians, and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*32\n\tdst[i+31:i] := ATANH(a[i+31:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_cbrt_pd","tech":"SVML","returnType":"__m256d","cpuId":"AVX","category":"Elementary Math Functions","description":"Compute the cube root of packed double-precision (64-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*64\n\tdst[i+63:i] := CubeRoot(a[i+63:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_cbrt_ps","tech":"SVML","returnType":"__m256","cpuId":"AVX","category":"Elementary Math Functions","description":"Compute the cube root of packed single-precision (32-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*32\n\tdst[i+31:i] := CubeRoot(a[i+31:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_cdfnorm_pd","tech":"SVML","returnType":"__m256d","cpuId":"AVX","category":"Probability/Statistics","description":"Compute the cumulative distribution function of packed double-precision (64-bit) floating-point elements in \"a\" using the normal distribution, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*64\n\tdst[i+63:i] := CDFNormal(a[i+63:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_cdfnorm_ps","tech":"SVML","returnType":"__m256","cpuId":"AVX","category":"Probability/Statistics","description":"Compute the cumulative distribution function of packed single-precision (32-bit) floating-point elements in \"a\" using the normal distribution, and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*32\n\tdst[i+31:i] := CDFNormal(a[i+31:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_cdfnorminv_pd","tech":"SVML","returnType":"__m256d","cpuId":"AVX","category":"Probability/Statistics","description":"Compute the inverse cumulative distribution function of packed double-precision (64-bit) floating-point elements in \"a\" using the normal distribution, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*64\n\tdst[i+63:i] := InverseCDFNormal(a[i+63:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_cdfnorminv_ps","tech":"SVML","returnType":"__m256","cpuId":"AVX","category":"Probability/Statistics","description":"Compute the inverse cumulative distribution function of packed single-precision (32-bit) floating-point elements in \"a\" using the normal distribution, and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*32\n\tdst[i+31:i] := InverseCDFNormal(a[i+31:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_cexp_ps","tech":"SVML","returnType":"__m256","cpuId":"AVX","category":"Elementary Math Functions","description":"Compute the exponential value of \"e\" raised to the power of packed complex single-precision (32-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*32\n\tdst[i+31:i] := e^(a[i+31:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_clog_ps","tech":"SVML","returnType":"__m256","cpuId":"AVX","category":"Elementary Math Functions","description":"Compute the natural logarithm of packed complex single-precision (32-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*32\n\tdst[i+31:i] := ln(a[i+31:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_cos_pd","tech":"SVML","returnType":"__m256d","cpuId":"AVX","category":"Trigonometry","description":"Compute the cosine of packed double-precision (64-bit) floating-point elements in \"a\" expressed in radians, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*64\n\tdst[i+63:i] := COS(a[i+63:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_cos_ps","tech":"SVML","returnType":"__m256","cpuId":"AVX","category":"Trigonometry","description":"Compute the cosine of packed single-precision (32-bit) floating-point elements in \"a\" expressed in radians, and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*32\n\tdst[i+31:i] := COS(a[i+31:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_cosd_pd","tech":"SVML","returnType":"__m256d","cpuId":"AVX","category":"Trigonometry","description":"Compute the cosine of packed double-precision (64-bit) floating-point elements in \"a\" expressed in degrees, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*64\n\tdst[i+63:i] := COSD(a[i+63:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_cosd_ps","tech":"SVML","returnType":"__m256","cpuId":"AVX","category":"Trigonometry","description":"Compute the cosine of packed single-precision (32-bit) floating-point elements in \"a\" expressed in degrees, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tdst[i+31:i] := COSD(a[i+31:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_cosh_pd","tech":"SVML","returnType":"__m256d","cpuId":"AVX","category":"Trigonometry","description":"Compute the hyperbolic cosine of packed double-precision (64-bit) floating-point elements in \"a\" expressed in radians, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*64\n\tdst[i+63:i] := COSH(a[i+63:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_cosh_ps","tech":"SVML","returnType":"__m256","cpuId":"AVX","category":"Trigonometry","description":"Compute the hyperbolic cosine of packed single-precision (32-bit) floating-point elements in \"a\" expressed in radians, and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*32\n\tdst[i+31:i] := COSH(a[i+31:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_csqrt_ps","tech":"SVML","returnType":"__m256","cpuId":"AVX","category":"Elementary Math Functions","description":"Compute the square root of packed complex single-precision (32-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*32\n\tdst[i+31:i] := SQRT(a[i+31:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_div_epi8","tech":"SVML","returnType":"__m256i","cpuId":"AVX","category":"Arithmetic","description":"Divide packed 8-bit integers in \"a\" by packed elements in \"b\", and store the truncated results in \"dst\".","code":"FOR j := 0 to 31\n\ti := 8*j\n\tdst[i+7:i] := TRUNCATE(a[i+7:i] / b[i+7:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256i","name":"a"},{"type":"__m256i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_div_epi16","tech":"SVML","returnType":"__m256i","cpuId":"AVX","category":"Arithmetic","description":"Divide packed 16-bit integers in \"a\" by packed elements in \"b\", and store the truncated results in \"dst\".","code":"FOR j := 0 to 15\n\ti := 16*j\n\tdst[i+15:i] := TRUNCATE(a[i+15:i] / b[i+15:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256i","name":"a"},{"type":"__m256i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_div_epi32","tech":"SVML","returnType":"__m256i","cpuId":"AVX","category":"Arithmetic","description":"Divide packed 32-bit integers in \"a\" by packed elements in \"b\", and store the truncated results in \"dst\".","code":"FOR j := 0 to 7\n\ti := 32*j\n\tdst[i+31:i] := TRUNCATE(a[i+31:i] / b[i+31:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256i","name":"a"},{"type":"__m256i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_div_epi64","tech":"SVML","returnType":"__m256i","cpuId":"AVX","category":"Arithmetic","description":"Divide packed 64-bit integers in \"a\" by packed elements in \"b\", and store the truncated results in \"dst\".","code":"FOR j := 0 to 3\n\ti := 64*j\n\tdst[i+63:i] := TRUNCATE(a[i+63:i] / b[i+63:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256i","name":"a"},{"type":"__m256i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_div_epu8","tech":"SVML","returnType":"__m256i","cpuId":"AVX","category":"Arithmetic","description":"Divide packed unsigned 8-bit integers in \"a\" by packed elements in \"b\", and store the truncated results in \"dst\".","code":"FOR j := 0 to 31\n\ti := 8*j\n\tdst[i+7:i] := TRUNCATE(a[i+7:i] / b[i+7:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256i","name":"a"},{"type":"__m256i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_div_epu16","tech":"SVML","returnType":"__m256i","cpuId":"AVX","category":"Arithmetic","description":"Divide packed unsigned 16-bit integers in \"a\" by packed elements in \"b\", and store the truncated results in \"dst\".","code":"FOR j := 0 to 15\n\ti := 16*j\n\tdst[i+15:i] := TRUNCATE(a[i+15:i] / b[i+15:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256i","name":"a"},{"type":"__m256i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_div_epu32","tech":"SVML","returnType":"__m256i","cpuId":"AVX","category":"Arithmetic","description":"Divide packed unsigned 32-bit integers in \"a\" by packed elements in \"b\", and store the truncated results in \"dst\".","code":"FOR j := 0 to 7\n\ti := 32*j\n\tdst[i+31:i] := TRUNCATE(a[i+31:i] / b[i+31:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256i","name":"a"},{"type":"__m256i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_div_epu64","tech":"SVML","returnType":"__m256i","cpuId":"AVX","category":"Arithmetic","description":"Divide packed unsigned 64-bit integers in \"a\" by packed elements in \"b\", and store the truncated results in \"dst\".","code":"FOR j := 0 to 3\n\ti := 64*j\n\tdst[i+63:i] := TRUNCATE(a[i+63:i] / b[i+63:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256i","name":"a"},{"type":"__m256i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_erf_pd","tech":"SVML","returnType":"__m256d","cpuId":"AVX","category":"Probability/Statistics","description":"Compute the error function of packed double-precision (64-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*64\n\tdst[i+63:i] := ERF(a[i+63:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_erf_ps","tech":"SVML","returnType":"__m256","cpuId":"AVX","category":"Probability/Statistics","description":"Compute the error function of packed single-precision (32-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*32\n\tdst[i+31:i] := ERF(a[i+31:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_erfc_pd","tech":"SVML","returnType":"__m256d","cpuId":"AVX","category":"Probability/Statistics","description":"Compute the complementary error function of packed double-precision (64-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*64\n\tdst[i+63:i] := 1.0 - ERF(a[i+63:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_erfc_ps","tech":"SVML","returnType":"__m256","cpuId":"AVX","category":"Probability/Statistics","description":"Compute the complementary error function of packed single-precision (32-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*32\n\tdst[i+31:i] := 1.0 - ERF(a[i+31:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_erfcinv_pd","tech":"SVML","returnType":"__m256d","cpuId":"AVX","category":"Probability/Statistics","description":"Compute the inverse complementary error function of packed double-precision (64-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*64\n\tdst[i+63:i] := 1.0 / (1.0 - ERF(a[i+63:i]))\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_erfcinv_ps","tech":"SVML","returnType":"__m256","cpuId":"AVX","category":"Probability/Statistics","description":"Compute the inverse complementary error function of packed single-precision (32-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*32\n\tdst[i+31:i] := 1.0 / (1.0 - ERF(a[i+31:i]))\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_erfinv_pd","tech":"SVML","returnType":"__m256d","cpuId":"AVX","category":"Probability/Statistics","description":"Compute the inverse error function of packed double-precision (64-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*64\n\tdst[i+63:i] := 1.0 / ERF(a[i+63:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_erfinv_ps","tech":"SVML","returnType":"__m256","cpuId":"AVX","category":"Probability/Statistics","description":"Compute the inverse error function of packed single-precision (32-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*32\n\tdst[i+31:i] := 1.0 / ERF(a[i+31:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_exp_pd","tech":"SVML","returnType":"__m256d","cpuId":"AVX","category":"Elementary Math Functions","description":"Compute the exponential value of \"e\" raised to the power of packed double-precision (64-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*64\n\tdst[i+63:i] := e^(a[i+63:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_exp_ps","tech":"SVML","returnType":"__m256","cpuId":"AVX","category":"Elementary Math Functions","description":"Compute the exponential value of \"e\" raised to the power of packed single-precision (32-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*32\n\tdst[i+31:i] := e^(a[i+31:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_exp10_pd","tech":"SVML","returnType":"__m256d","cpuId":"AVX","category":"Elementary Math Functions","description":"Compute the exponential value of 10 raised to the power of packed double-precision (64-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*64\n\tdst[i+63:i] := 10^(a[i+63:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_exp10_ps","tech":"SVML","returnType":"__m256","cpuId":"AVX","category":"Elementary Math Functions","description":"Compute the exponential value of 10 raised to the power of packed single-precision (32-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*32\n\tdst[i+31:i] := 10^(a[i+31:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_exp2_pd","tech":"SVML","returnType":"__m256d","cpuId":"AVX","category":"Elementary Math Functions","description":"Compute the exponential value of 2 raised to the power of packed double-precision (64-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*64\n\tdst[i+63:i] := 2^(a[i+63:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_exp2_ps","tech":"SVML","returnType":"__m256","cpuId":"AVX","category":"Elementary Math Functions","description":"Compute the exponential value of 2 raised to the power of packed single-precision (32-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*32\n\tdst[i+31:i] := 2^(a[i+31:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_expm1_pd","tech":"SVML","returnType":"__m256d","cpuId":"AVX","category":"Elementary Math Functions","description":"Compute the exponential value of \"e\" raised to the power of packed double-precision (64-bit) floating-point elements in \"a\", subtract one from each element, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*64\n\tdst[i+63:i] := e^(a[i+63:i]) - 1.0\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_expm1_ps","tech":"SVML","returnType":"__m256","cpuId":"AVX","category":"Elementary Math Functions","description":"Compute the exponential value of \"e\" raised to the power of packed single-precision (32-bit) floating-point elements in \"a\", subtract one from each element, and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*32\n\tdst[i+31:i] := e^(a[i+31:i]) - 1.0\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_hypot_pd","tech":"SVML","returnType":"__m256d","cpuId":"AVX","category":"Trigonometry","description":"Compute the length of the hypotenous of a right triangle, with the lengths of the other two sides of the triangle stored as packed double-precision (64-bit) floating-point elements in \"a\" and \"b\", and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*64\n\tdst[i+63:i] := SQRT(a[i+63:i]^2 + b[i+63:i]^2)\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256d","name":"a"},{"type":"__m256d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_hypot_ps","tech":"SVML","returnType":"__m256","cpuId":"AVX","category":"Trigonometry","description":"Compute the length of the hypotenous of a right triangle, with the lengths of the other two sides of the triangle stored as packed single-precision (32-bit) floating-point elements in \"a\" and \"b\", and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*32\n\tdst[i+31:i] := SQRT(a[i+31:i]^2 + b[i+31:i]^2)\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256","name":"a"},{"type":"__m256","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_idiv_epi32","tech":"SVML","returnType":"__m256i","cpuId":"AVX","category":"Arithmetic","description":"Divide packed 32-bit integers in \"a\" by packed elements in \"b\", and store the truncated results in \"dst\".","code":"FOR j := 0 to 7\n\ti := 32*j\n\tdst[i+31:i] := TRUNCATE(a[i+31:i] / b[i+31:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256i","name":"a"},{"type":"__m256i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_idivrem_epi32","tech":"SVML","returnType":"__m256i","cpuId":"AVX","category":"Arithmetic","description":"Divide packed 32-bit integers in \"a\" by packed elements in \"b\", store the truncated results in \"dst\", and store the remainders as packed 32-bit integers into memory at \"mem_addr\".","code":"FOR j := 0 to 7\n\ti := 32*j\n\tdst[i+31:i] := TRUNCATE(a[i+31:i] / b[i+31:i])\n\tMEM[mem_addr+i+31:mem_addr+i] := REMAINDER(a[i+31:i] / b[i+31:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256i *","name":"mem_addr"},{"type":"__m256i","name":"a"},{"type":"__m256i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_invcbrt_pd","tech":"SVML","returnType":"__m256d","cpuId":"AVX","category":"Elementary Math Functions","description":"Compute the inverse cube root of packed double-precision (64-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*64\n\tdst[i+63:i] := InvCubeRoot(a[i+63:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_invcbrt_ps","tech":"SVML","returnType":"__m256","cpuId":"AVX","category":"Elementary Math Functions","description":"Compute the inverse cube root of packed single-precision (32-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*32\n\tdst[i+31:i] := InvCubeRoot(a[i+31:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_invsqrt_pd","tech":"SVML","returnType":"__m256d","cpuId":"AVX","category":"Elementary Math Functions","description":"Compute the inverse square root of packed double-precision (64-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*64\n\tdst[i+63:i] := InvSQRT(a[i+63:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_invsqrt_ps","tech":"SVML","returnType":"__m256","cpuId":"AVX","category":"Elementary Math Functions","description":"Compute the inverse square root of packed single-precision (32-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*32\n\tdst[i+31:i] := InvSQRT(a[i+31:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_irem_epi32","tech":"SVML","returnType":"__m256i","cpuId":"AVX","category":"Arithmetic","description":"Divide packed 32-bit integers in \"a\" by packed elements in \"b\", and store the remainders as packed 32-bit integers in \"dst\".","code":"FOR j := 0 to 7\n\ti := 32*j\n\tdst[i+31:i] := REMAINDER(a[i+31:i] / b[i+31:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256i","name":"a"},{"type":"__m256i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_log_pd","tech":"SVML","returnType":"__m256d","cpuId":"AVX","category":"Elementary Math Functions","description":"Compute the natural logarithm of packed double-precision (64-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*64\n\tdst[i+63:i] := ln(a[i+63:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_log_ps","tech":"SVML","returnType":"__m256","cpuId":"AVX","category":"Elementary Math Functions","description":"Compute the natural logarithm of packed single-precision (32-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*32\n\tdst[i+31:i] := ln(a[i+31:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_log10_pd","tech":"SVML","returnType":"__m256d","cpuId":"AVX","category":"Elementary Math Functions","description":"Compute the base-10 logarithm of packed double-precision (64-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*64\n\tdst[i+63:i] := log10(a[i+63:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_log10_ps","tech":"SVML","returnType":"__m256","cpuId":"AVX","category":"Elementary Math Functions","description":"Compute the base-10 logarithm of packed single-precision (32-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*32\n\tdst[i+31:i] := log10(a[i+31:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_log1p_pd","tech":"SVML","returnType":"__m256d","cpuId":"AVX","category":"Elementary Math Functions","description":"Compute the natural logarithm of one plus packed double-precision (64-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*64\n\tdst[i+63:i] := ln(1.0 + a[i+63:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_log1p_ps","tech":"SVML","returnType":"__m256","cpuId":"AVX","category":"Elementary Math Functions","description":"Compute the natural logarithm of one plus packed single-precision (32-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*32\n\tdst[i+31:i] := ln(1.0 + a[i+31:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_log2_pd","tech":"SVML","returnType":"__m256d","cpuId":"AVX","category":"Elementary Math Functions","description":"Compute the base-2 logarithm of packed double-precision (64-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*64\n\tdst[i+63:i] := log2(a[i+63:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_log2_ps","tech":"SVML","returnType":"__m256","cpuId":"AVX","category":"Elementary Math Functions","description":"Compute the base-2 logarithm of packed single-precision (32-bit) floating-point elements in \"a\", and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*32\n\tdst[i+31:i] := log2(a[i+31:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_logb_pd","tech":"SVML","returnType":"__m256d","cpuId":"AVX","category":"Elementary Math Functions","description":"Convert the exponent of each packed double-precision (64-bit) floating-point element in \"a\" to a double-precision floating-point number representing the integer exponent, and store the results in \"dst\". This intrinsic essentially calculates \"floor(log2(x))\" for each element.","code":"FOR j := 0 to 3\n\ti := j*64\n\tdst[i+63:i] := ConvertExpFP64(a[i+63:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_logb_ps","tech":"SVML","returnType":"__m256","cpuId":"AVX","category":"Elementary Math Functions","description":"Convert the exponent of each packed single-precision (32-bit) floating-point element in \"a\" to a single-precision floating-point number representing the integer exponent, and store the results in \"dst\". This intrinsic essentially calculates \"floor(log2(x))\" for each element.","code":"FOR j := 0 to 7\n\ti := j*32\n\tdst[i+31:i] := ConvertExpFP32(a[i+31:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_pow_pd","tech":"SVML","returnType":"__m256d","cpuId":"AVX","category":"Elementary Math Functions","description":"Compute the exponential value of packed double-precision (64-bit) floating-point elements in \"a\" raised by packed elements in \"b\", and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*64\n\tdst[i+63:i] := (a[i+63:i])^(b[i+63:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256d","name":"a"},{"type":"__m256d","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_pow_ps","tech":"SVML","returnType":"__m256","cpuId":"AVX","category":"Elementary Math Functions","description":"Compute the exponential value of packed single-precision (32-bit) floating-point elements in \"a\" raised by packed elements in \"b\", and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*32\n\tdst[i+31:i] := (a[i+31:i])^(b[i+31:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256","name":"a"},{"type":"__m256","name":"b"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_rem_epi8","tech":"SVML","returnType":"__m256i","cpuId":"AVX","category":"Arithmetic","description":"Divide packed 8-bit integers in \"a\" by packed elements in \"b\", and store the remainders as packed 32-bit integers in \"dst\".","code":"FOR j := 0 to 31\n\ti := 8*j\n\tdst[i+7:i] := REMAINDER(a[i+7:i] / b[i+7:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256i","name":"a"},{"type":"__m256i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_rem_epi16","tech":"SVML","returnType":"__m256i","cpuId":"AVX","category":"Arithmetic","description":"Divide packed 16-bit integers in \"a\" by packed elements in \"b\", and store the remainders as packed 32-bit integers in \"dst\".","code":"FOR j := 0 to 15\n\ti := 16*j\n\tdst[i+15:i] := REMAINDER(a[i+15:i] / b[i+15:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256i","name":"a"},{"type":"__m256i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_rem_epi32","tech":"SVML","returnType":"__m256i","cpuId":"AVX","category":"Arithmetic","description":"Divide packed 32-bit integers in \"a\" by packed elements in \"b\", and store the remainders as packed 32-bit integers in \"dst\".","code":"FOR j := 0 to 7\n\ti := 32*j\n\tdst[i+31:i] := REMAINDER(a[i+31:i] / b[i+31:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256i","name":"a"},{"type":"__m256i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_rem_epi64","tech":"SVML","returnType":"__m256i","cpuId":"AVX","category":"Arithmetic","description":"Divide packed 64-bit integers in \"a\" by packed elements in \"b\", and store the remainders as packed 32-bit integers in \"dst\".","code":"FOR j := 0 to 3\n\ti := 64*j\n\tdst[i+63:i] := REMAINDER(a[i+63:i] / b[i+63:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256i","name":"a"},{"type":"__m256i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_rem_epu8","tech":"SVML","returnType":"__m256i","cpuId":"AVX","category":"Arithmetic","description":"Divide packed unsigned 8-bit integers in \"a\" by packed elements in \"b\", and store the remainders as packed unsigned 32-bit integers in \"dst\".","code":"FOR j := 0 to 31\n\ti := 8*j\n\tdst[i+7:i] := REMAINDER(a[i+7:i] / b[i+7:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256i","name":"a"},{"type":"__m256i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_rem_epu16","tech":"SVML","returnType":"__m256i","cpuId":"AVX","category":"Arithmetic","description":"Divide packed unsigned 16-bit integers in \"a\" by packed elements in \"b\", and store the remainders as packed unsigned 32-bit integers in \"dst\".","code":"FOR j := 0 to 15\n\ti := 16*j\n\tdst[i+15:i] := REMAINDER(a[i+15:i] / b[i+15:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256i","name":"a"},{"type":"__m256i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_rem_epu32","tech":"SVML","returnType":"__m256i","cpuId":"AVX","category":"Arithmetic","description":"Divide packed unsigned 32-bit integers in \"a\" by packed elements in \"b\", and store the remainders as packed unsigned 32-bit integers in \"dst\".","code":"FOR j := 0 to 7\n\ti := 32*j\n\tdst[i+31:i] := REMAINDER(a[i+31:i] / b[i+31:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256i","name":"a"},{"type":"__m256i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_rem_epu64","tech":"SVML","returnType":"__m256i","cpuId":"AVX","category":"Arithmetic","description":"Divide packed unsigned 64-bit integers in \"a\" by packed elements in \"b\", and store the remainders as packed unsigned 32-bit integers in \"dst\".","code":"FOR j := 0 to 3\n\ti := 64*j\n\tdst[i+63:i] := REMAINDER(a[i+63:i] / b[i+63:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256i","name":"a"},{"type":"__m256i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_sin_pd","tech":"SVML","returnType":"__m256d","cpuId":"AVX","category":"Trigonometry","description":"Compute the sine of packed double-precision (64-bit) floating-point elements in \"a\" expressed in radians, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*64\n\tdst[i+63:i] := SIN(a[i+63:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_sin_ps","tech":"SVML","returnType":"__m256","cpuId":"AVX","category":"Trigonometry","description":"Compute the sine of packed single-precision (32-bit) floating-point elements in \"a\" expressed in radians, and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*32\n\tdst[i+31:i] := SIN(a[i+31:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_sincos_pd","tech":"SVML","returnType":"__m256d","cpuId":"AVX","category":"Trigonometry","description":"Compute the sine and cosine of packed double-precision (64-bit) floating-point elements in \"a\" expressed in radians, store the sine in \"dst\", and store the cosine into memory at \"mem_addr\".","code":"FOR j := 0 to 3\n\ti := j*64\n\tdst[i+63:i] := SIN(a[i+63:i])\n\tMEM[mem_addr+i+63:mem_addr+i] := COS(a[i+63:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256d *","name":"mem_addr"},{"type":"__m256d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_sincos_ps","tech":"SVML","returnType":"__m256","cpuId":"AVX","category":"Trigonometry","description":"Compute the sine and cosine of packed single-precision (32-bit) floating-point elements in \"a\" expressed in radians, store the sine in \"dst\", and store the cosine into memory at \"mem_addr\".","code":"FOR j := 0 to 7\n\ti := j*32\n\tdst[i+31:i] := SIN(a[i+31:i])\n\tMEM[mem_addr+i+31:mem_addr+i] := COS(a[i+31:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256 *","name":"mem_addr"},{"type":"__m256","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_sind_pd","tech":"SVML","returnType":"__m256d","cpuId":"AVX","category":"Trigonometry","description":"Compute the sine of packed double-precision (64-bit) floating-point elements in \"a\" expressed in degrees, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*64\n\tdst[i+63:i] := SIND(a[i+63:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_sind_ps","tech":"SVML","returnType":"__m256","cpuId":"AVX","category":"Trigonometry","description":"Compute the sine of packed single-precision (32-bit) floating-point elements in \"a\" expressed in degrees, and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*32\n\tdst[i+31:i] := SIND(a[i+31:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_sinh_pd","tech":"SVML","returnType":"__m256d","cpuId":"AVX","category":"Trigonometry","description":"Compute the hyperbolic sine of packed double-precision (64-bit) floating-point elements in \"a\" expressed in radians, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*64\n\tdst[i+63:i] := SINH(a[i+63:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_sinh_ps","tech":"SVML","returnType":"__m256","cpuId":"AVX","category":"Trigonometry","description":"Compute the hyperbolic sine of packed single-precision (32-bit) floating-point elements in \"a\" expressed in radians, and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*32\n\tdst[i+31:i] := SINH(a[i+31:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_svml_ceil_pd","tech":"SVML","returnType":"__m256d","cpuId":"AVX","category":"Special Math Functions","description":"Round the packed double-precision (64-bit) floating-point elements in \"a\" up to an integer value, and store the results as packed double-precision floating-point elements in \"dst\". This intrinsic may generate the \"roundpd\"/\"vroundpd\" instruction.","code":"FOR j := 0 to 3\n\ti := j*64\n\tdst[i+63:i] := CEIL(a[i+63:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_svml_ceil_ps","tech":"SVML","returnType":"__m256","cpuId":"AVX","category":"Special Math Functions","description":"Round the packed single-precision (32-bit) floating-point elements in \"a\" up to an integer value, and store the results as packed single-precision floating-point elements in \"dst\". This intrinsic may generate the \"roundps\"/\"vroundps\" instruction.","code":"FOR j := 0 to 7\n\ti := j*32\n\tdst[i+31:i] := CEIL(a[i+31:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_svml_floor_pd","tech":"SVML","returnType":"__m256d","cpuId":"AVX","category":"Special Math Functions","description":"Round the packed double-precision (64-bit) floating-point elements in \"a\" down to an integer value, and store the results as packed double-precision floating-point elements in \"dst\". This intrinsic may generate the \"roundpd\"/\"vroundpd\" instruction.","code":"FOR j := 0 to 3\n\ti := j*64\n\tdst[i+63:i] := FLOOR(a[i+63:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_svml_floor_ps","tech":"SVML","returnType":"__m256","cpuId":"AVX","category":"Special Math Functions","description":"Round the packed single-precision (32-bit) floating-point elements in \"a\" down to an integer value, and store the results as packed single-precision floating-point elements in \"dst\". This intrinsic may generate the \"roundps\"/\"vroundps\" instruction.","code":"FOR j := 0 to 7\n\ti := j*32\n\tdst[i+31:i] := FLOOR(a[i+31:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_svml_round_pd","tech":"SVML","returnType":"__m256d","cpuId":"AVX","category":"Special Math Functions","description":"Round the packed double-precision (64-bit) floating-point elements in \"a\" to the nearest integer value, and store the results as packed double-precision floating-point elements in \"dst\". This intrinsic may generate the \"roundpd\"/\"vroundpd\" instruction.","code":"FOR j := 0 to 3\n\ti := j*64\n\tdst[i+63:i] := ROUND(a[i+63:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_svml_round_ps","tech":"SVML","returnType":"__m256","cpuId":"AVX","category":"Special Math Functions","description":"Round the packed single-precision (32-bit) floating-point elements in \"a\" to the nearest integer value, and store the results as packed single-precision floating-point elements in \"dst\". This intrinsic may generate the \"roundps\"/\"vroundps\" instruction.","code":"FOR j := 0 to 7\n\ti := j*32\n\tdst[i+31:i] := ROUND(a[i+31:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_svml_sqrt_pd","tech":"SVML","returnType":"__m256d","cpuId":"AVX","category":"Elementary Math Functions","description":"Compute the square root of packed double-precision (64-bit) floating-point elements in \"a\", and store the results in \"dst\". Note that this intrinsic is less efficient than \"_mm_sqrt_pd\".","code":"FOR j := 0 to 3\n\ti := j*64\n\tdst[i+63:i] := SQRT(a[i+63:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_svml_sqrt_ps","tech":"SVML","returnType":"__m256","cpuId":"AVX","category":"Elementary Math Functions","description":"Compute the square root of packed single-precision (32-bit) floating-point elements in \"a\", and store the results in \"dst\".  Note that this intrinsic is less efficient than \"_mm_sqrt_ps\".","code":"FOR j := 0 to 7\n\ti := j*32\n\tdst[i+31:i] := SQRT(a[i+31:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_tan_pd","tech":"SVML","returnType":"__m256d","cpuId":"AVX","category":"Trigonometry","description":"Compute the tangent of packed double-precision (64-bit) floating-point elements in \"a\" expressed in radians, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*64\n\tdst[i+63:i] := TAN(a[i+63:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_tan_ps","tech":"SVML","returnType":"__m256","cpuId":"AVX","category":"Trigonometry","description":"Compute the tangent of packed single-precision (32-bit) floating-point elements in \"a\" expressed in radians, and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*32\n\tdst[i+31:i] := TAN(a[i+31:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_tand_pd","tech":"SVML","returnType":"__m256d","cpuId":"AVX","category":"Trigonometry","description":"Compute the tangent of packed double-precision (64-bit) floating-point elements in \"a\" expressed in degrees, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*64\n\tdst[i+63:i] := TAND(a[i+63:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_tand_ps","tech":"SVML","returnType":"__m256","cpuId":"AVX","category":"Trigonometry","description":"Compute the tangent of packed single-precision (32-bit) floating-point elements in \"a\" expressed in degrees, and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*32\n\tdst[i+31:i] := TAND(a[i+31:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_tanh_pd","tech":"SVML","returnType":"__m256d","cpuId":"AVX","category":"Trigonometry","description":"Compute the hyperbolic tangent of packed double-precision (64-bit) floating-point elements in \"a\" expressed in radians, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*64\n\tdst[i+63:i] := TANH(a[i+63:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_tanh_ps","tech":"SVML","returnType":"__m256","cpuId":"AVX","category":"Trigonometry","description":"Compute the hyperbolic tangent of packed single-precision (32-bit) floating-point elements in \"a\" expressed in radians, and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*32\n\tdst[i+31:i] := TANH(a[i+31:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_trunc_pd","tech":"SVML","returnType":"__m256d","cpuId":"AVX","category":"Miscellaneous","description":"Truncate the packed double-precision (64-bit) floating-point elements in \"a\", and store the results as packed double-precision floating-point elements in \"dst\". This intrinsic may generate the \"roundpd\"/\"vroundpd\" instruction.","code":"FOR j := 0 to 3\n\ti := j*64\n\tdst[i+63:i] := TRUNCATE(a[i+63:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256d","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_trunc_ps","tech":"SVML","returnType":"__m256","cpuId":"AVX","category":"Miscellaneous","description":"Truncate the packed single-precision (32-bit) floating-point elements in \"a\", and store the results as packed single-precision floating-point elements in \"dst\". This intrinsic may generate the \"roundps\"/\"vroundps\" instruction.","code":"FOR j := 0 to 7\n\ti := j*32\n\tdst[i+31:i] := TRUNCATE(a[i+31:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_udiv_epi32","tech":"SVML","returnType":"__m256i","cpuId":"AVX","category":"Arithmetic","description":"Divide packed unsigned 32-bit integers in \"a\" by packed elements in \"b\", and store the truncated results in \"dst\".","code":"FOR j := 0 to 7\n\ti := 32*j\n\tdst[i+31:i] := TRUNCATE(a[i+31:i] / b[i+31:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256i","name":"a"},{"type":"__m256i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_udivrem_epi32","tech":"SVML","returnType":"__m256i","cpuId":"AVX","category":"Arithmetic","description":"Divide packed unsigned 32-bit integers in \"a\" by packed elements in \"b\", store the truncated results in \"dst\", and store the remainders as packed unsigned 32-bit integers into memory at \"mem_addr\".","code":"FOR j := 0 to 7\n\ti := 32*j\n\tdst[i+31:i] := TRUNCATE(a[i+31:i] / b[i+31:i])\n\tMEM[mem_addr+i+31:mem_addr+i] := REMAINDER(a[i+31:i] / b[i+31:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256i *","name":"mem_addr"},{"type":"__m256i","name":"a"},{"type":"__m256i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm256_urem_epi32","tech":"SVML","returnType":"__m256i","cpuId":"AVX","category":"Arithmetic","description":"Divide packed unsigned 32-bit integers in \"a\" by packed elements in \"b\", and store the remainders as packed unsigned 32-bit integers in \"dst\".","code":"FOR j := 0 to 7\n\ti := 32*j\n\tdst[i+31:i] := REMAINDER(a[i+31:i] / b[i+31:i])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"","parameters":[{"type":"__m256i","name":"a"},{"type":"__m256i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_popcnt32","tech":"Bit Manipulation","returnType":"int","cpuId":"POPCNT","category":"Bit Manipulation","description":"Count the number of bits set to 1 in 32-bit integer \"a\", and return that count in \"dst\".","code":"dst := 0\nFOR i := 0 to 31\n\tIF a[i]\n\t\tdst := dst + 1\n\tFI\nENDFOR","header":"immintrin.h","instruction":"popcnt","parameters":[{"type":"int","name":"a"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"r32, r32","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"r32, r32","latency":"3","throughput":"1"},{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"r/2F64, r64","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E","parameters":"r64, r64","latency":"3","throughput":"1"}]},{"name":"_popcnt64","tech":"Bit Manipulation","returnType":"int","cpuId":"POPCNT","category":"Bit Manipulation","description":"Count the number of bits set to 1 in 64-bit integer \"a\", and return that count in \"dst\".","code":"dst := 0\nFOR i := 0 to 63\n\tIF a[i]\n\t\tdst := dst + 1\n\tFI\nENDFOR","header":"immintrin.h","instruction":"popcnt","parameters":[{"type":"__int64","name":"a"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"r32, r32","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"r32, r32","latency":"3","throughput":"1"},{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"r/2F64, r64","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E","parameters":"r64, r64","latency":"3","throughput":"1"}]},{"name":"_mm_popcnt_u32","tech":"Bit Manipulation","returnType":"int","cpuId":"POPCNT","category":"Bit Manipulation","description":"Count the number of bits set to 1 in unsigned 32-bit integer \"a\", and return that count in \"dst\".","code":"dst := 0\nFOR i := 0 to 31\n\tIF a[i]\n\t\tdst := dst + 1\n\tFI\nENDFOR","header":"nmmintrin.h","instruction":"popcnt","parameters":[{"type":"unsigned int","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"r32, r32","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"r32, r32","latency":"3","throughput":"1"},{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"r/2F64, r64","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E","parameters":"r64, r64","latency":"3","throughput":"1"}]},{"name":"_mm_popcnt_u64","tech":"Bit Manipulation","returnType":"__int64","cpuId":"POPCNT","category":"Bit Manipulation","description":"Count the number of bits set to 1 in unsigned 64-bit integer \"a\", and return that count in \"dst\".","code":"dst := 0\nFOR i := 0 to 63\n\tIF a[i]\n\t\tdst := dst + 1\n\tFI\nENDFOR","header":"nmmintrin.h","instruction":"popcnt","parameters":[{"type":"unsigned __int64","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"r32, r32","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"r32, r32","latency":"3","throughput":"1"},{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"r/2F64, r64","latency":"3","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E","parameters":"r64, r64","latency":"3","throughput":"1"}]},{"name":"_rdpmc","tech":"Other","returnType":"__int64","cpuId":null,"category":"General Support","description":"Read the Performance Monitor Counter (PMC) specified by \"a\", and store up to 64-bits in \"dst\". The width of performance counters is implementation specific.","code":"dst[63:0] := ReadPMC(a)","header":"immintrin.h","instruction":"rdpmc","parameters":[{"type":"int","name":"a"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_rdtsc","tech":"TSC","returnType":"__int64","cpuId":"TSC","category":"General Support","description":"Copy the current 64-bit value of the processor's time-stamp counter into \"dst\".","code":"dst[63:0] := TimeStampCounter","header":"immintrin.h","instruction":"rdtsc","parameters":[{"type":"void","name":""}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_rotl","tech":"Bit Manipulation","returnType":"unsigned int","cpuId":null,"category":"Shift","description":"Shift the bits of unsigned 32-bit integer \"a\" left by the number of bits specified in \"shift\", rotating the most-significant bit to the least-significant bit location, and store the unsigned result in \"dst\".","code":"dst := a\ncount := shift BITWISE AND 31\nDO WHILE (count > 0)\n\ttmp[0] := dst[31]\n\tdst := (dst << 1) OR tmp[0]\n\tcount := count - 1\nOD","header":"immintrin.h","instruction":"rol","parameters":[{"type":"unsigned int","name":"a"},{"type":"int","name":"shift"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_rotr","tech":"Bit Manipulation","returnType":"unsigned int","cpuId":null,"category":"Shift","description":"Shift the bits of unsigned 32-bit integer \"a\" right by the number of bits specified in \"shift\", rotating the least-significant bit to the most-significant bit location, and store the unsigned result in \"dst\".","code":"dst := a\ncount := shift BITWISE AND 31\nDO WHILE (count > 0)\n\ttmp[31] := dst[0]\n\tdst := (dst >> 1) OR tmp[31]\n\tcount := count - 1\nOD","header":"immintrin.h","instruction":"ror","parameters":[{"type":"unsigned int","name":"a"},{"type":"int","name":"shift"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_rotwl","tech":"Bit Manipulation","returnType":"unsigned short","cpuId":null,"category":"Shift","description":"Shift the bits of unsigned 16-bit integer \"a\" left by the number of bits specified in \"shift\", rotating the most-significant bit to the least-significant bit location, and store the unsigned result in \"dst\".","code":"dst := a\ncount := shift BITWISE AND 15\nDO WHILE (count > 0)\n\ttmp[0] := dst[15]\n\tdst := (dst << 1) OR tmp[0]\n\tcount := count - 1\nOD","header":"immintrin.h","instruction":"rol","parameters":[{"type":"unsigned short","name":"a"},{"type":"int","name":"shift"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_rotwr","tech":"Bit Manipulation","returnType":"unsigned short","cpuId":null,"category":"Shift","description":"Shift the bits of unsigned 16-bit integer \"a\" right by the number of bits specified in \"shift\", rotating the least-significant bit to the most-significant bit location, and store the unsigned result in \"dst\".","code":"dst := a\ncount := shift BITWISE AND 15\nDO WHILE (count > 0)\n\ttmp[15] := dst[0]\n\tdst := (dst >> 1) OR tmp[15]\n\tcount := count - 1\nOD","header":"immintrin.h","instruction":"ror","parameters":[{"type":"unsigned short","name":"a"},{"type":"int","name":"shift"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_xgetbv","tech":"OS","returnType":"unsigned __int64","cpuId":"XSAVE","category":"OS-Targeted","description":"Copy up to 64-bits from the value of the extended control register (XCR) specified by \"a\" into \"dst\". Currently only XFEATURE_ENABLED_MASK XCR is supported.","code":"dst[63:0] := XCR[a]","header":"immintrin.h","instruction":"xgetbv","parameters":[{"type":"unsigned int","name":"a"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_xrstor","tech":"OS","returnType":"void","cpuId":"XSAVE","category":"OS-Targeted","description":"Perform a full or partial restore of the enabled processor states using the state information stored in memory at \"mem_addr\". State is restored based on bits [62:0] in \"rs_mask\", \"XCR0\", and \"mem_addr.HEADER.XSTATE_BV\". \"mem_addr\" must be aligned on a 64-byte boundary.","code":"st_mask = mem_addr.HEADER.XSTATE_BV[62:0]\nFOR i := 0 to 62\n\tIF (rs_mask[i] AND XCR0[i])\n\t\tIF st_mask[i]\n\t\t\tCASE (i) OF\n\t\t\t\t0: ProcessorState[x87 FPU] := mem_addr.FPUSSESave_Area[FPU]\n\t\t\t\t1: ProcessorState[SSE] := mem_addr.FPUSSESaveArea[SSE]\n\t\t\t\tDEFAULT: ProcessorState[i] := mem_addr.Ext_Save_Area[i]\n\t\t\tESAC\n\t\tELSE\n\t\t\t// ProcessorExtendedState := Processor Supplied Values\n\t\t\tCASE (i) OF\n\t\t\t\t1: MXCSR := mem_addr.FPUSSESave_Area[SSE]\n\t\t\tESAC\n\t\tFI\n\tFI\n\ti := i + 1\nENDFOR","header":"immintrin.h","instruction":"xrstor","parameters":[{"type":"void *","name":"mem_addr"},{"type":"unsigned __int64","name":"rs_mask"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_xrstor64","tech":"OS","returnType":"void","cpuId":"XSAVE","category":"OS-Targeted","description":"Perform a full or partial restore of the enabled processor states using the state information stored in memory at \"mem_addr\". State is restored based on bits [62:0] in \"rs_mask\", \"XCR0\", and \"mem_addr.HEADER.XSTATE_BV\". \"mem_addr\" must be aligned on a 64-byte boundary.","code":"st_mask = mem_addr.HEADER.XSTATE_BV[62:0]\nFOR i := 0 to 62\n\tIF (rs_mask[i] AND XCR0[i])\n\t\tIF st_mask[i]\n\t\t\tCASE (i) OF\n\t\t\t\t0: ProcessorState[x87 FPU] := mem_addr.FPUSSESave_Area[FPU]\n\t\t\t\t1: ProcessorState[SSE] := mem_addr.FPUSSESaveArea[SSE]\n\t\t\t\tDEFAULT: ProcessorState[i] := mem_addr.Ext_Save_Area[i]\n\t\t\tESAC\n\t\tELSE\n\t\t\t// ProcessorExtendedState := Processor Supplied Values\n\t\t\tCASE (i) OF\n\t\t\t\t1: MXCSR := mem_addr.FPUSSESave_Area[SSE]\n\t\t\tESAC\n\t\tFI\n\tFI\n\ti := i + 1\nENDFOR","header":"immintrin.h","instruction":"xrstor64","parameters":[{"type":"void *","name":"mem_addr"},{"type":"unsigned __int64","name":"rs_mask"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_xsave","tech":"OS","returnType":"void","cpuId":"XSAVE","category":"OS-Targeted","description":"Perform a full or partial save of the enabled processor states to memory at \"mem_addr\". State is saved based on bits [62:0] in \"save_mask\" and \"XCR0\". \"mem_addr\" must be aligned on a 64-byte boundary.","code":"mask[62:0] := save_mask[62:0] BITWISE AND XCR0[62:0]\nFOR i := 0 to 62\n\tIF mask[i]\n\t\tCASE (i) OF\n\t\t\t0: mem_addr.FPUSSESave_Area[FPU] := ProcessorState[x87 FPU]\n\t\t\t1: mem_addr.FPUSSESaveArea[SSE] := ProcessorState[SSE]\n\t\t\tDEFAULT: mem_addr.Ext_Save_Area[i] := ProcessorState[i]\n\t\tESAC\n\t\tmem_addr.HEADER.XSTATE_BV[i] := INIT_FUNCTION[i]\n\tFI\n\ti := i + 1\nENDFOR","header":"immintrin.h","instruction":"xsave","parameters":[{"type":"void *","name":"mem_addr"},{"type":"unsigned __int64","name":"save_mask"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_xsave64","tech":"OS","returnType":"void","cpuId":"XSAVE","category":"OS-Targeted","description":"Perform a full or partial save of the enabled processor states to memory at \"mem_addr\". State is saved based on bits [62:0] in \"save_mask\" and \"XCR0\". \"mem_addr\" must be aligned on a 64-byte boundary.","code":"mask[62:0] := save_mask[62:0] BITWISE AND XCR0[62:0]\nFOR i := 0 to 62\n\tIF mask[i]\n\t\tCASE (i) OF\n\t\t\t0: mem_addr.FPUSSESave_Area[FPU] := ProcessorState[x87 FPU]\n\t\t\t1: mem_addr.FPUSSESaveArea[SSE] := ProcessorState[SSE]\n\t\t\tDEFAULT: mem_addr.Ext_Save_Area[i] := ProcessorState[i]\n\t\tESAC\n\t\tmem_addr.HEADER.XSTATE_BV[i] := INIT_FUNCTION[i]\n\tFI\n\ti := i + 1\nENDFOR","header":"immintrin.h","instruction":"xsave64","parameters":[{"type":"void *","name":"mem_addr"},{"type":"unsigned __int64","name":"save_mask"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_xsaveopt","tech":"OS","returnType":"void","cpuId":"XSAVE","category":"OS-Targeted","description":"Perform a full or partial save of the enabled processor states to memory at \"mem_addr\". State is saved based on bits [62:0] in \"save_mask\" and \"XCR0\". \"mem_addr\" must be aligned on a 64-byte boundary. The hardware may optimize the manner in which data is saved. The performance of this instruction will be equal to or better than using the XSAVE instruction.","code":"mask[62:0] := save_mask[62:0] BITWISE AND XCR0[62:0]\nFOR i := 0 to 62\n\tIF mask[i]\n\t\tCASE (i) OF\n\t\t\t0: mem_addr.FPUSSESave_Area[FPU] := ProcessorState[x87 FPU]\n\t\t\t1: mem_addr.FPUSSESaveArea[SSE] := ProcessorState[SSE]\n\t\t\t2: mem_addr.EXT_SAVE_Area2[YMM] := ProcessorState[YMM]\n\t\t\tDEFAULT: mem_addr.Ext_Save_Area[i] := ProcessorState[i]\n\t\tESAC\n\t\tmem_addr.HEADER.XSTATE_BV[i] := INIT_FUNCTION[i]\n\tFI\n\ti := i + 1\nENDFOR","header":"immintrin.h","instruction":"xsaveopt","parameters":[{"type":"void *","name":"mem_addr"},{"type":"unsigned __int64","name":"save_mask"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_xsaveopt64","tech":"OS","returnType":"void","cpuId":"XSAVE","category":"OS-Targeted","description":"Perform a full or partial save of the enabled processor states to memory at \"mem_addr\". State is saved based on bits [62:0] in \"save_mask\" and \"XCR0\". \"mem_addr\" must be aligned on a 64-byte boundary. The hardware may optimize the manner in which data is saved. The performance of this instruction will be equal to or better than using the XSAVE64 instruction.","code":"mask[62:0] := save_mask[62:0] BITWISE AND XCR0[62:0]\nFOR i := 0 to 62\n\tIF mask[i]\n\t\tCASE (i) OF\n\t\t\t0: mem_addr.FPUSSESave_Area[FPU] := ProcessorState[x87 FPU]\n\t\t\t1: mem_addr.FPUSSESaveArea[SSE] := ProcessorState[SSE]\n\t\t\t2: mem_addr.EXT_SAVE_Area2[YMM] := ProcessorState[YMM]\n\t\t\tDEFAULT: mem_addr.Ext_Save_Area[i] := ProcessorState[i]\n\t\tESAC\n\t\tmem_addr.HEADER.XSTATE_BV[i] := INIT_FUNCTION[i]\n\tFI\n\ti := i + 1\nENDFOR","header":"immintrin.h","instruction":"xsaveopt64","parameters":[{"type":"void *","name":"mem_addr"},{"type":"unsigned __int64","name":"save_mask"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_xsetbv","tech":"OS","returnType":"void","cpuId":"XSAVE","category":"OS-Targeted","description":"Copy 64-bits from \"val\" to the extended control register (XCR) specified by \"a\". Currently only XFEATURE_ENABLED_MASK XCR is supported.","code":"XCR[a] := val[63:0]","header":"immintrin.h","instruction":"xsetbv","parameters":[{"type":"unsigned int","name":"a"},{"type":"unsigned __int64","name":"val"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_loadu_si32","tech":"Other","returnType":"__m128i","cpuId":"SSE","category":"Load","description":"Load unaligned 32-bit integer from memory into the first element of \"dst\".","code":"dst[31:0] := MEM[mem_addr+31:mem_addr]\ndst[MAX:32] := 0","header":"immintrin.h","instruction":"movd","parameters":[{"type":"void const*","name":"mem_addr"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, r32","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, r32","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, r32","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, r32","latency":"1","throughput":"0.5"},{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, r64","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, r64","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, r64","latency":"1","throughput":"0.5"},{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"r32, xmm","latency":"2","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"r32, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"r32, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"r32, xmm","latency":"1","throughput":"0.33"},{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"r64, xmm","latency":"1","throughput":"0.33"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"r64, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"r64, xmm","latency":"1","throughput":"0.33"},{"base":"0F_03","parameters":"r32, xmm","latency":"10","throughput":"1"},{"base":"0F_02","parameters":"r32, xmm","latency":"10","throughput":"1"},{"base":"0F_03","parameters":"xmm, r32","latency":"6","throughput":"2"},{"base":"0F_02","parameters":"xmm, r32","latency":"6","throughput":"2"},{"base":"06_0F","parameters":"mm, r32","latency":"1","throughput":"0.5"},{"base":"06_0E","parameters":"mm, r32","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, r32","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"r32, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"r32, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"r32, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, r32","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, r32","latency":"2","throughput":"1"},{"base":"0F_03","parameters":"r32, mm","latency":"5","throughput":"1"},{"base":"0F_02","parameters":"r32, mm","latency":"5","throughput":"1"}]},{"name":"_mm_storeu_si32","tech":"Other","returnType":"void","cpuId":"SSE","category":"Store","description":"Store 32-bit integer from the first element of \"a\" into memory.  \"mem_addr\" does not need to be aligned on any particular boundary.","code":"MEM[mem_addr+31:mem_addr] := a[31:0]","header":"immintrin.h","instruction":"movd","parameters":[{"type":"void*","name":"mem_addr"},{"type":"__m128i","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, r32","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, r32","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, r32","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, r32","latency":"1","throughput":"0.5"},{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, r64","latency":"1","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, r64","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, r64","latency":"1","throughput":"0.5"},{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"r32, xmm","latency":"2","throughput":"1"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"r32, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"r32, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"r32, xmm","latency":"1","throughput":"0.33"},{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"r64, xmm","latency":"1","throughput":"0.33"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"r64, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"r64, xmm","latency":"1","throughput":"0.33"},{"base":"0F_03","parameters":"r32, xmm","latency":"10","throughput":"1"},{"base":"0F_02","parameters":"r32, xmm","latency":"10","throughput":"1"},{"base":"0F_03","parameters":"xmm, r32","latency":"6","throughput":"2"},{"base":"0F_02","parameters":"xmm, r32","latency":"6","throughput":"2"},{"base":"06_0F","parameters":"mm, r32","latency":"1","throughput":"0.5"},{"base":"06_0E","parameters":"mm, r32","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, r32","latency":"1","throughput":"0.5"},{"base":"06_0F","parameters":"r32, mm","latency":"1","throughput":"0.33"},{"base":"06_0E","parameters":"r32, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"r32, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, r32","latency":"2","throughput":"1"},{"base":"0F_02","parameters":"mm, r32","latency":"2","throughput":"1"},{"base":"0F_03","parameters":"r32, mm","latency":"5","throughput":"1"},{"base":"0F_02","parameters":"r32, mm","latency":"5","throughput":"1"}]},{"name":"_mm_storeu_si16","tech":"Other","returnType":"void","cpuId":"SSE","category":"Store","description":"Store 16-bit integer from the first element of \"a\" into memory.  \"mem_addr\" does not need to be aligned on any particular boundary.","code":"MEM[mem_addr+15:mem_addr] := a[15:0]","header":"immintrin.h","instruction":"movd+movw","parameters":[{"type":"void*","name":"mem_addr"},{"type":"__m128i","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_loadu_si64","tech":"Other","returnType":"__m128i","cpuId":"SSE","category":"Load","description":"Load unaligned 64-bit integer from memory into the first element of \"dst\".","code":"dst[63:0] := MEM[mem_addr+63:mem_addr]\ndst[MAX:64] := 0","header":"immintrin.h","instruction":"movq","parameters":[{"type":"void const*","name":"mem_addr"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"6","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"6","throughput":"1"}]},{"name":"_mm_storeu_si64","tech":"Other","returnType":"void","cpuId":"SSE","category":"Store","description":"Store 64-bit integer from the first element of \"a\" into memory.  \"mem_addr\" does not need to be aligned on any particular boundary.","code":"MEM[mem_addr+63:mem_addr] := a[63:0]","header":"immintrin.h","instruction":"movq","parameters":[{"type":"void*","name":"mem_addr"},{"type":"__m128i","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":[{"base":"06_2A/2D/3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_25/2C/1A/1E/1F/2E/2F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_17/1D","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"xmm, xmm","latency":"1","throughput":"0.33"},{"base":"06_0D","parameters":"xmm, xmm","latency":"1","throughput":"1"},{"base":"0F_03","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"0F_02","parameters":"xmm, xmm","latency":"2","throughput":"2"},{"base":"06_17","parameters":"mm, mm","latency":"1","throughput":"0.33"},{"base":"06_0F","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0E","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"06_0D","parameters":"mm, mm","latency":"1","throughput":"0.5"},{"base":"0F_03","parameters":"mm, mm","latency":"6","throughput":"1"},{"base":"0F_02","parameters":"mm, mm","latency":"6","throughput":"1"}]},{"name":"_mm_loadu_si16","tech":"Other","returnType":"__m128i","cpuId":"SSE","category":"Load","description":"Load unaligned 16-bit integer from memory into the first element of \"dst\".","code":"dst[15:0] := MEM[mem_addr+15:mem_addr]\ndst[MAX:16] := 0","header":"immintrin.h","instruction":"movzwl+movd","parameters":[{"type":"void const*","name":"mem_addr"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_readfsbase_u32","tech":"OS","returnType":"unsigned int","cpuId":"FSGSBASE","category":"General Support","description":"Read the FS segment base register and store the 32-bit result in \"dst\".","code":"dst[31:0] := FS_Segment_Base_Register;\ndst[63:32] := 0","header":"immintrin.h","instruction":"rdfsbase r32","parameters":[],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_readfsbase_u64","tech":"OS","returnType":"unsigned __int64","cpuId":"FSGSBASE","category":"General Support","description":"Read the FS segment base register and store the 64-bit result in \"dst\".","code":"dst[63:0] := FS_Segment_Base_Register;","header":"immintrin.h","instruction":"rdfsbase r64","parameters":[],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_readgsbase_u32","tech":"OS","returnType":"unsigned int","cpuId":"FSGSBASE","category":"General Support","description":"Read the GS segment base register and store the 32-bit result in \"dst\".","code":"dst[31:0] := GS_Segment_Base_Register;\ndst[63:32] := 0","header":"immintrin.h","instruction":"rdgsbase r32","parameters":[],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_readgsbase_u64","tech":"OS","returnType":"unsigned __int64","cpuId":"FSGSBASE","category":"General Support","description":"Read the GS segment base register and store the 64-bit result in \"dst\".","code":"dst[63:0] := GS_Segment_Base_Register;","header":"immintrin.h","instruction":"rdgsbase r64","parameters":[],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_rdrand16_step","tech":"Misc","returnType":"int","cpuId":"RDRAND","category":"Random","description":"Read a hardware generated 16-bit random value and store the result in \"val\". Return 1 if a random value was generated, and 0 otherwise.","code":"IF HW_RND_GEN.ready = 1\n\tval[15:0] := HW_RND_GEN.data;\n\tRETURN 1;\nELSE\n\tval[15:0] := 0;\n\tRETURN 0;\nFI","header":"immintrin.h","instruction":"rdrand r16","parameters":[{"type":"unsigned short*","name":"val"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_rdrand32_step","tech":"Misc","returnType":"int","cpuId":"RDRAND","category":"Random","description":"Read a hardware generated 32-bit random value and store the result in \"val\". Return 1 if a random value was generated, and 0 otherwise.","code":"IF HW_RND_GEN.ready = 1\n\tval[31:0] := HW_RND_GEN.data;\n\tRETURN 1;\nELSE\n\tval[31:0] := 0;\n\tRETURN 0;\nFI","header":"immintrin.h","instruction":"rdrand r32","parameters":[{"type":"unsigned int*","name":"val"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_rdrand64_step","tech":"Misc","returnType":"int","cpuId":"RDRAND","category":"Random","description":"Read a hardware generated 64-bit random value and store the result in \"val\". Return 1 if a random value was generated, and 0 otherwise.","code":"IF HW_RND_GEN.ready = 1\n\tval[63:0] := HW_RND_GEN.data;\n\tRETURN 1;\nELSE\n\tval[63:0] := 0;\n\tRETURN 0;\nFI","header":"immintrin.h","instruction":"rdrand r64","parameters":[{"type":"unsigned __int64*","name":"val"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_writefsbase_u32","tech":"OS","returnType":"void","cpuId":"FSGSBASE","category":"General Support","description":"Write the unsigned 32-bit integer \"a\" to the FS segment base register.","code":"FS_Segment_Base_Register[31:0] := a[31:0];\nFS_Segment_Base_Register[63:32] := 0","header":"immintrin.h","instruction":"wrfsbase r32","parameters":[{"type":"unsigned int","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_writefsbase_u64","tech":"OS","returnType":"void","cpuId":"FSGSBASE","category":"General Support","description":"Write the unsigned 64-bit integer \"a\" to the FS segment base register.","code":"FS_Segment_Base_Register[63:0] := a[63:0];","header":"immintrin.h","instruction":"wrfsbase r64","parameters":[{"type":"unsigned __int64","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_writegsbase_u32","tech":"OS","returnType":"void","cpuId":"FSGSBASE","category":"General Support","description":"Write the unsigned 32-bit integer \"a\" to the GS segment base register.","code":"GS_Segment_Base_Register[31:0] := a[31:0];\nGS_Segment_Base_Register[63:32] := 0","header":"immintrin.h","instruction":"wrgsbase r32","parameters":[{"type":"unsigned int","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_writegsbase_u64","tech":"OS","returnType":"void","cpuId":"FSGSBASE","category":"General Support","description":"Write the unsigned 64-bit integer \"a\" to the GS segment base register.","code":"GS_Segment_Base_Register[63:0] := a[63:0];","header":"immintrin.h","instruction":"wrgsbase r64","parameters":[{"type":"unsigned __int64","name":"a"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_cvtph_ps","tech":"Misc","returnType":"__m128","cpuId":"FP16C","category":"Convert","description":"Convert packed half-precision (16-bit) floating-point elements in \"a\" to packed single-precision (32-bit) floating-point elements, and store the results in \"dst\".","code":"FOR j := 0 to 3\n\ti := j*32\n\tm := j*16\n\tdst[i+31:i] := Convert_FP16_To_FP32(a[m+15:m])\nENDFOR\ndst[MAX:128] := 0","header":"emmintrin.h","instruction":"vcvtph2ps","parameters":[{"type":"__m128i","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3A/3E/3C/45/46","parameters":"ymm, xmm","latency":"7","throughput":"1"},{"base":"06_3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"6","throughput":"1"}]},{"name":"_mm256_cvtph_ps","tech":"Misc","returnType":"__m256","cpuId":"FP16C","category":"Convert","description":"Convert packed half-precision (16-bit) floating-point elements in \"a\" to packed single-precision (32-bit) floating-point elements, and store the results in \"dst\".","code":"FOR j := 0 to 7\n\ti := j*32\n\tm := j*16\n\tdst[i+31:i] := Convert_FP16_To_FP32(a[m+15:m])\nENDFOR\ndst[MAX:256] := 0","header":"immintrin.h","instruction":"vcvtph2ps","parameters":[{"type":"__m128i","name":"a"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3A/3E/3C/45/46","parameters":"ymm, xmm","latency":"7","throughput":"1"},{"base":"06_3A/3E/3C/45/46","parameters":"xmm, xmm","latency":"6","throughput":"1"}]},{"name":"_mm_cvtps_ph","tech":"Misc","returnType":"__m128i","cpuId":"FP16C","category":"Convert","description":"Convert packed single-precision (32-bit) floating-point elements in \"a\" to packed half-precision (16-bit) floating-point elements, and store the results in \"dst\".\n\t[round_note]","code":"FOR j := 0 to 3\n\ti := 16*j\n\tl := 32*j\n\tdst[i+15:i] := Convert_FP32_To_FP16FP(a[l+31:l])\nENDFOR\ndst[MAX:128] := 0","header":"emmintrin.h","instruction":"vcvtps2ph","parameters":[{"type":"__m128","name":"a"},{"type":"int","name":"rounding"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3A/3E/3C/45/46","parameters":"ymm, xmm, imm","latency":"10","throughput":"1"},{"base":"06_3A/3E/3C/45/46","parameters":"xmm, xmm, imm","latency":"9","throughput":"1"}]},{"name":"_mm256_cvtps_ph","tech":"Misc","returnType":"__m128i","cpuId":"FP16C","category":"Convert","description":"Convert packed single-precision (32-bit) floating-point elements in \"a\" to packed half-precision (16-bit) floating-point elements, and store the results in \"dst\".\n\t[round_note]","code":"FOR j := 0 to 7\n\ti := 16*j\n\tl := 32*j\n\tdst[i+15:i] := Convert_FP32_To_FP16FP(a[l+31:l])\nENDFOR\ndst[MAX:128] := 0","header":"immintrin.h","instruction":"vcvtps2ph","parameters":[{"type":"__m256","name":"a"},{"type":"int","name":"rounding"}],"isFloat":true,"isInt":false,"isMask":false,"latencyAndThroughput":[{"base":"06_3A/3E/3C/45/46","parameters":"ymm, xmm, imm","latency":"10","throughput":"1"},{"base":"06_3A/3E/3C/45/46","parameters":"xmm, xmm, imm","latency":"9","throughput":"1"}]},{"name":"_rdseed16_step","tech":"Misc","returnType":"int","cpuId":"RDSEED","category":"Random","description":"Read a 16-bit NIST SP800-90B and SP800-90C compliant random value and store in \"val\". Return 1 if a random value was generated, and 0 otherwise.","code":"IF HW_NRND_GEN.ready = 1 THEN\n\tval[15:0] := HW_NRND_GEN.data\n\tRETURN 1\nELSE\n\tval[15:0] := 0\n\tRETURN 0\nFI","header":"immintrin.h","instruction":"rdseed","parameters":[{"type":"unsigned short *","name":"val"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_rdseed32_step","tech":"Misc","returnType":"int","cpuId":"RDSEED","category":"Random","description":"Read a 32-bit NIST SP800-90B and SP800-90C compliant random value and store in \"val\". Return 1 if a random value was generated, and 0 otherwise.","code":"IF HW_NRND_GEN.ready = 1 THEN\n\tdest[31:0] := HW_NRND_GEN.data\n\tRETURN 1\nELSE\n\tdest[31:0] := 0\n\tRETURN 0\nFI","header":"immintrin.h","instruction":"rdseed","parameters":[{"type":"unsigned int *","name":"val"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_rdseed64_step","tech":"Misc","returnType":"int","cpuId":"RDSEED","category":"Random","description":"Read a 64-bit NIST SP800-90B and SP800-90C compliant random value and store in \"val\". Return 1 if a random value was generated, and 0 otherwise.","code":"IF HW_NRND_GEN.ready = 1 THEN\n\tval[63:0] := HW_NRND_GEN.data\n\tRETURN 1\nELSE\n\tval[63:0] := 0\n\tRETURN 0\nFI","header":"immintrin.h","instruction":"rdseed","parameters":[{"type":"unsigned __int64 *","name":"val"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_addcarry_u32","tech":"Other","returnType":"unsigned char","cpuId":"ADX","category":"Arithmetic","description":"Add unsigned 32-bit integers \"a\" and \"b\" with unsigned 8-bit carry-in \"c_in\" (carry flag), and store the unsigned 32-bit result in \"out\", and the carry-out in \"dst\" (carry flag).","code":"dst:out[31:0] := a[31:0] + b[31:0] + c_in;","header":"immintrin.h","instruction":"adcx","parameters":[{"type":"unsigned char","name":"c_in"},{"type":"unsigned int","name":"a"},{"type":"unsigned int","name":"b"},{"type":"unsigned int *","name":"out"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_addcarry_u64","tech":"Other","returnType":"unsigned char","cpuId":"ADX","category":"Arithmetic","description":"Add unsigned 64-bit integers \"a\" and \"b\" with unsigned 8-bit carry-in \"c_in\" (carry flag), and store the unsigned 64-bit result in \"out\", and the carry-out in \"dst\" (carry flag).","code":"dst:out[63:0] := a[63:0] + b[63:0] + c_in;","header":"immintrin.h","instruction":"adcx","parameters":[{"type":"unsigned char","name":"c_in"},{"type":"unsigned __int64","name":"a"},{"type":"unsigned __int64","name":"b"},{"type":"unsigned __int64 *","name":"out"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_subborrow_u32","tech":"Other","returnType":"unsigned char","cpuId":"ADX","category":"Arithmetic","description":"Add unsigned 8-bit borrow \"b_in\" (carry flag) to unsigned 32-bit integer \"a\", and subtract the result from unsigned 32-bit integer \"b\". Store the unsigned 32-bit result in \"out\", and the carry-out in \"dst\" (carry flag).","code":"dst:out[31:0] := (b[31:0] - (a[31:0] + b_in));","header":"immintrin.h","instruction":"sbb","parameters":[{"type":"unsigned char","name":"b_in"},{"type":"unsigned int","name":"a"},{"type":"unsigned int","name":"b"},{"type":"unsigned int *","name":"out"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_subborrow_u64","tech":"Other","returnType":"unsigned char","cpuId":"ADX","category":"Arithmetic","description":"Add unsigned 8-bit borrow \"b_in\" (carry flag) to unsigned 64-bit integer \"a\", and subtract the result from unsigned 64-bit integer \"b\". Store the unsigned 64-bit result in \"out\", and the carry-out in \"dst\" (carry flag).","code":"dst:out[63:0] := (b[63:0] - (a[63:0] + b_in));","header":"immintrin.h","instruction":"sbb","parameters":[{"type":"unsigned char","name":"b_in"},{"type":"unsigned __int64","name":"a"},{"type":"unsigned __int64","name":"b"},{"type":"unsigned __int64 *","name":"out"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_addcarryx_u32","tech":"Other","returnType":"unsigned char","cpuId":"ADX","category":"Arithmetic","description":"Add unsigned 32-bit integers \"a\" and \"b\" with unsigned 8-bit carry-in \"c_in\" (overflow flag), and store the unsigned 32-bit result in \"out\", and the carry-out in \"dst\" (overflow flag).","code":"dst:out[31:0] := a[31:0] + b[31:0] + c_in;","header":"immintrin.h","instruction":"adox","parameters":[{"type":"unsigned char","name":"c_in"},{"type":"unsigned int","name":"a"},{"type":"unsigned int","name":"b"},{"type":"unsigned int *","name":"out"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_addcarryx_u64","tech":"Other","returnType":"unsigned char","cpuId":"ADX","category":"Arithmetic","description":"Add unsigned 64-bit integers \"a\" and \"b\" with unsigned 8-bit carry-in \"c_in\" (overflow flag), and store the unsigned 64-bit result in \"out\", and the carry-out in \"dst\" (overflow flag).","code":"dst:out[63:0] := a[63:0] + b[63:0] + c_in;","header":"immintrin.h","instruction":"adox","parameters":[{"type":"unsigned char","name":"c_in"},{"type":"unsigned __int64","name":"a"},{"type":"unsigned __int64","name":"b"},{"type":"unsigned __int64 *","name":"out"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_sha1msg1_epu32","tech":"Misc","returnType":"__m128i","cpuId":"SHA","category":"Cryptography","description":"Perform an intermediate calculation for the next four SHA1 message values (unsigned 32-bit integers) using previous message values from \"a\" and \"b\", and store the result in \"dst\".","code":"W0 := a[127:96];\nW1 := a[95:64];\nW2 := a[63:32];\nW3 := a[31:0];\nW4 := b[127:96];\nW5 := b[95:64];\n\ndst[127:96] := W2 XOR W0;\ndst[95:64] := W3 XOR W1;\ndst[63:32] := W4 XOR W2;\ndst[31:0] := W5 XOR W3;","header":"immintrin.h","instruction":"sha1msg1","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_sha1msg2_epu32","tech":"Misc","returnType":"__m128i","cpuId":"SHA","category":"Cryptography","description":"Perform the final calculation for the next four SHA1 message values (unsigned 32-bit integers) using the intermediate result in \"a\" and the previous message values in \"b\", and store the result in \"dst\".","code":"W13 := b[95:64];\nW14 := b[63:32];\nW15 := b[31:0];\nW16 := (a[127:96] XOR W13) << 1;\nW17 := (a[95:64] XOR W14) << 1;\nW18 := (a[63:32] XOR W15) << 1;\nW19 := (a[31:0] XOR W16) << 1;\n\ndst[127:96] := W16;\ndst[95:64] := W17;\ndst[63:32] := W18;\ndst[31:0] := W19;","header":"immintrin.h","instruction":"sha1msg2","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_sha1nexte_epu32","tech":"Misc","returnType":"__m128i","cpuId":"SHA","category":"Cryptography","description":"Calculate SHA1 state variable E after four rounds of operation from the current SHA1 state variable \"a\", add that value to the scheduled values (unsigned 32-bit integers) in \"b\", and store the result in \"dst\".","code":"tmp := (a[127:96] << 30);\ndst[127:96] := b[127:96] + tmp;\ndst[95:64] := b[95:64];\ndst[63:32] := b[63:32];\ndst[31:0] := b[31:0];","header":"immintrin.h","instruction":"sha1nexte","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_sha1rnds4_epu32","tech":"Misc","returnType":"__m128i","cpuId":"SHA","category":"Cryptography","description":"Perform four rounds of SHA1 operation using an initial SHA1 state (A,B,C,D) from \"a\" and some pre-computed sum of the next 4 round message values (unsigned 32-bit integers), and state variable E from \"b\", and store the updated SHA1 state (A,B,C,D) in \"dst\". \"func\" contains the logic functions and round constants.","code":"IF (func[1:0] = 0) THEN\n\tf() := f0(), K := K0;\nELSE IF (func[1:0] = 1) THEN\n\tf() := f1(), K := K1;\nELSE IF (func[1:0] = 2) THEN\n\tf() := f2(), K := K2;\nELSE IF (func[1:0] = 3) THEN\n\tf() := f3(), K := K3;\nFI;\n\nA := a[127:96];\nB := a[95:64];\nC := a[63:32];\nD := a[31:0];\n\nW[0] := b[127:96];\nW[1] := b[95:64];\nW[2] := b[63:32];\nW[3] := b[31:0];\n\nA[1] := f(B, C, D) + (A << 5) + W[0] + K;\nB[1] := A;\nC[1] := B << 30;\nD[1] := C;\nE[1] := D;\n\nFOR i = 1 to 3\n        A[i+1] := f(B[i], C[i], D[i]) + (A[i] << 5) + W[i] + E[i] + K;\n        B[i+1] := A[i];\n        C[i+1] := B[i] << 30;\n        D[i+1] := C[i];\n        E[i+1] := D[i];\nENDFOR;\n\ndst[127:96] := A[4];\ndst[95:64] := B[4];\ndst[63:32] := C[4];\ndst[31:0] := D[4];","header":"immintrin.h","instruction":"sha1rnds4","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"},{"type":"const int","name":"func"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_sha256msg1_epu32","tech":"Misc","returnType":"__m128i","cpuId":"SHA","category":"Cryptography","description":"Perform an intermediate calculation for the next four SHA256 message values (unsigned 32-bit integers) using previous message values from \"a\" and \"b\", and store the result in \"dst\".","code":"W4 := b[31:0];\nW3 := a[127:96];\nW2 := a[95:64];\nW1 := a[63:32];\nW0 := a[31:0];\n\ndst[127:96] := W3 + sigma0(W4);\ndst[95:64] := W2 + sigma0(W3);\ndst[63:32] := W1 + sigma0(W2);\ndst[31:0] := W0 + sigma0(W1);","header":"immintrin.h","instruction":"sha256msg1","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_sha256msg2_epu32","tech":"Misc","returnType":"__m128i","cpuId":"SHA","category":"Cryptography","description":"Perform the final calculation for the next four SHA256 message values (unsigned 32-bit integers) using previous message values from \"a\" and \"b\", and store the result in \"dst\".\"","code":"W14 := b[95:64];\nW15 := b[127:96];\nW16 := a[31:0] + sigma1(W14);\nW17 := a[63:32] + sigma1(W15);\nW18 := a[95:64] + sigma1(W16);\nW19 := a[127:96] + sigma1(W17);\n\ndst[127:96] := W19;\ndst[95:64] := W18;\ndst[63:32] := W17;\ndst[31:0] := W16;","header":"immintrin.h","instruction":"sha256msg2","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_mm_sha256rnds2_epu32","tech":"Misc","returnType":"__m128i","cpuId":"SHA","category":"Cryptography","description":"Perform 2 rounds of SHA256 operation using an initial SHA256 state (C,D,G,H) from \"a\", an initial SHA256 state (A,B,E,F) from \"b\", and a pre-computed sum of the next 2 round message values (unsigned 32-bit integers) and the corresponding round constants from \"k\", and store the updated SHA256 state (A,B,E,F) in \"dst\".","code":"A[0] := b[127:96];\nB[0] := b[95:64];\nC[0] := a[127:96];\nD[0] := a[95:64];\nE[0] := b[63:32];\nF[0] := b[31:0];\nG[0] := a[63:32];\nH[0] := a[31:0];\n\nW_K0 := XMM0[31:0];\nW_K1 := XMM0[63:32];\n\nFOR i = 0 to 1\n        A_(i+1) := Ch(E[i], F[i], G[i]) + sum1(E[i]) + WKi + H[i] + Maj(A[i], B[i], C[i]) + sum0(A[i]);\n        B_(i+1) := A[i];\n        C_(i+1) := B[i];\n        D_(i+1) := C[i];\n        E_(i+1) := Ch(E[i], F[i], G[i]) + sum1(E[i]) + WKi + H[i] + D[i];\n        F_(i+1) := E[i];\n        G_(i+1) := F[i];\n        H_(i+1) := G[i];\nENDFOR;\n\ndst[127:96] := A[2];\ndst[95:64] := B[2];\ndst[63:32] := E[2];\ndst[31:0] := F[2];","header":"immintrin.h","instruction":"sha256rnds2","parameters":[{"type":"__m128i","name":"a"},{"type":"__m128i","name":"b"},{"type":"__m128i","name":"k"}],"isFloat":false,"isInt":true,"isMask":false,"latencyAndThroughput":null},{"name":"_bnd_set_ptr_bounds","tech":"Misc","returnType":"void *","cpuId":"MPX","category":"Miscellaneous","description":"Make a pointer with the value of \"srcmem\" and bounds set to [\"srcmem\", \"srcmem\" + \"size\" - 1], and store the result in \"dst\".","code":"dst := srcmem;\ndst.LB := srcmem.LB;\ndst.UB := srcmem + size - 1;","header":"immintrin.h","instruction":"bndmk","parameters":[{"type":"const void *","name":"srcmem"},{"type":"size_t","name":"size"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_bnd_narrow_ptr_bounds","tech":"Misc","returnType":"void *","cpuId":"MPX","category":"Miscellaneous","description":"Narrow the bounds for pointer \"q\" to the intersection of the bounds of \"r\" and the bounds [\"q\", \"q\" + \"size\" - 1], and store the result in \"dst\".","code":"dst := q;\nIF r.LB > (q + size - 1) OR r.UB < q THEN\n\tdst.LB := 1;\n\tdst.UB := 0;\nELSE\n\tdst.LB := MAX(r.LB, q);\n\tdst.UB := MIN(r.UB, (q + size - 1));\nFI;","header":"immintrin.h","instruction":null,"parameters":[{"type":"const void *","name":"q"},{"type":"const void *","name":"r"},{"type":"size_t","name":"size"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_bnd_copy_ptr_bounds","tech":"Misc","returnType":"void *","cpuId":"MPX","category":"Miscellaneous","description":"Make a pointer with the value of \"q\" and bounds set to the bounds of \"r\" (e.g. copy the bounds of \"r\" to pointer \"q\"), and store the result in \"dst\".","code":"dst := q;\ndst.LB := r.LB;\ndst.UB := r.UB;","header":"immintrin.h","instruction":null,"parameters":[{"type":"const void *","name":"q"},{"type":"const void *","name":"r"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_bnd_init_ptr_bounds","tech":"Misc","returnType":"void *","cpuId":"MPX","category":"Miscellaneous","description":"Make a pointer with the value of \"q\" and open bounds, which allow the pointer to access the entire virtual address space, and store the result in \"dst\".","code":"dst := q;\ndst.LB := 0;\ndst.UB := 0;","header":"immintrin.h","instruction":null,"parameters":[{"type":"const void *","name":"q"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_bnd_store_ptr_bounds","tech":"Misc","returnType":"void","cpuId":"MPX","category":"Miscellaneous","description":"Stores the bounds of \"ptr_val\" pointer in memory at address \"ptr_addr\".","code":"MEM[ptr_addr].LB := ptr_val.LB;\nMEM[ptr_addr].UB := ptr_val.UB;","header":"immintrin.h","instruction":"bndstx","parameters":[{"type":"const void **","name":"ptr_addr"},{"type":"const void *","name":"ptr_val"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_bnd_chk_ptr_lbounds","tech":"Misc","returnType":"void","cpuId":"MPX","category":"Miscellaneous","description":"Checks if \"q\" is within its lower bound, and throws a #BR if not.","code":"IF q < q.LB THEN\n\t#BR;\nFI;","header":"immintrin.h","instruction":"bndcl","parameters":[{"type":"const void *","name":"q"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_bnd_chk_ptr_ubounds","tech":"Misc","returnType":"void","cpuId":"MPX","category":"Miscellaneous","description":"Checks if \"q\" is within its upper bound, and throws a #BR if not.","code":"IF q > q.UB THEN\n\t#BR;\nFI;","header":"immintrin.h","instruction":"bndcu","parameters":[{"type":"const void *","name":"q"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_bnd_chk_ptr_bounds","tech":"Misc","returnType":"void","cpuId":"MPX","category":"Miscellaneous","description":"Checks if [\"q\", \"q\" + \"size\" - 1] is within the lower and upper bounds of \"q\" and throws a #BR if not.","code":"IF (q + size - 1) < q.LB OR (q + size - 1) > q.UB THEN\n\t#BR;\nFI;","header":"immintrin.h","instruction":"bndcu","parameters":[{"type":"const void *","name":"q"},{"type":"size_t","name":"size"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_bnd_get_ptr_lbound","tech":"Misc","returnType":"const void *","cpuId":"MPX","category":"Miscellaneous","description":"Return the lower bound of \"q\".","code":"dst := q.LB","header":"immintrin.h","instruction":null,"parameters":[{"type":"const void *","name":"q"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null},{"name":"_bnd_get_ptr_ubound","tech":"Misc","returnType":"const void *","cpuId":"MPX","category":"Miscellaneous","description":"Return the upper bound of \"q\".","code":"dst := q.UB","header":"immintrin.h","instruction":null,"parameters":[{"type":"const void *","name":"q"}],"isFloat":false,"isInt":false,"isMask":false,"latencyAndThroughput":null}];
        </script>
        <script src="http://ajax.googleapis.com/ajax/libs/angularjs/1.1.5/angular.min.js"></script>
        <script>
		function SelectItem(n,t){this.name=n,this.selected=t}function IifController(n,t){function u(n){return new SelectItem(n,!1)}function e(n){return!!n}function i(n){return n.selected}function f(t,r){n.$watch(t,function(u){!u&&r.none(i)?n[t]=!0:u&&(r.forEach(function(n){n.selected=!1}),n.updateFilter())})}var r,s,o;n.techs=["MMX","SSE","SSE2","SSE3","SSSE3","SSE4.1","SSE4.2","AVX","AVX2","AVX-512","FMA","Misc","Bit Manipulation","OS","SVML","Other"].map(u),n.types=["Floating point","Integer","Inter-Type","Mask","Other"].map(u),n.allCategoriesSelected=!0,n.allTypesSelected=!0,n.allTechsSelected=!0,n.allReturnTypesSelected=!0,r=t.FUNCTIONS_DATA,r.forEach(function(n){n.isCollapsed=!0,n.isVisible=!0}),s=r.map(function(n){return n.tech}).filter(e).unique(),o=[],n.techs.forEach(function(n){s.indexOf(n.name)!=-1&&o.push(n)}),n.techs=o,n.returnTypes=r.map(function(n){return n.returnType.replace("unsigned ","")}).filter(e).unique().sort().reverse().map(u),n.categories=r.map(function(n){return n.category}).filter(e).unique().sort().map(u),n.items=r,n.setAllCollapsed=function(t){n.items.forEach(function(n){n.isCollapsed=t})},n.resetSearchQuery=function(){n.searchQuery="",n.updateFilter()},n.updateFilter=function(){function t(n){return n.name}var u,f,e,o,r;n.allTypesSelected=n.types.none(i),n.allCategoriesSelected=n.categories.none(i),n.allTechsSelected=n.techs.none(i),n.allReturnTypesSelected=n.returnTypes.none(i),n.items.forEach(function(n){n.isVisible=!0}),n.allTechsSelected||(u=n.techs.filter(i).map(t),n.items.forEach(function(n){u.indexOf(n.tech)==-1&&(n.isVisible=!1)})),n.allCategoriesSelected||(f=n.categories.filter(i).map(t),n.items.forEach(function(n){n.isVisible&&f.indexOf(n.category)==-1&&(n.isVisible=!1)})),n.allReturnTypesSelected||(e=n.returnTypes.filter(i).map(t),n.items.forEach(function(n){n.isVisible&&e.indexOf(n.returnType.replace("unsigned ",""))==-1&&(n.isVisible=!1)})),n.allTypesSelected||(o=n.types.filter(i).map(t),n.items.forEach(function(n){n.isVisible&&(n.isVisible=!1,o.forEach(function(t){t=="Floating point"?n.isFloat&&(n.isVisible=!0):t=="Integer"?n.isInt&&(n.isVisible=!0):t=="Inter-Type"?n.isFloat&&n.isInt&&(n.isVisible=!0):t=="Mask"?n.isMask&&(n.isVisible=!0):n.isFloat||n.isInt||(n.isVisible=!0)}))})),!n.searchQuery||(r=new RegExp(n.searchQuery.replace(/\s+/g,".*"),"i"),n.items.filter(function(n){return n.isVisible}).forEach(function(n){r.test(n.name)||!!n.instruction&&r.test(n.instruction)||!!n.description&&r.test(n.description)||(n.isVisible=!1)}))},f("allCategoriesSelected",n.categories),f("allTypesSelected",n.types),f("allTechsSelected",n.techs),f("allReturnTypesSelected",n.returnTypes)}Array.prototype.unique=function(){for(var t={},i=[],n=0,r=this.length;n<r;++n)t.hasOwnProperty(this[n])||(i.push(this[n]),t[this[n]]=1);return i},Array.prototype.none=function(n){for(var t=0,i=this.length;t<i;++t)if(n(this[t]))return!1;return!0};var app=angular.module("iif",[]).filter("formatParameters",function(){return function(n){return n.map(function(n){return'<span class="type">'+n.type+"<\/span> "+n.name}).join('<span class="text-gray">,<\/span> ')}});IifController.$inject=["$scope","$window"];
		</script>
    </head>
    <body ng-app="iif" ng-controller="IifController">

        <div class="container">
            <div class="row">
                <div class="left-column">
                    <div>
                        <input type="text" class="input" ng-model="searchQuery" ng-change="updateFilter()" placeholder="Search..." />
                        <i class="icon-remove" ng-click="resetSearchQuery()"></i>
                    </div>
                    <div class="btn-group">
                        <button class="btn" ng-click="setAllCollapsed(false)">Expand all</button>
                        <button class="btn" ng-click="setAllCollapsed(true)">Collapse all</button>
                    </div>
                
                    <h3>Technologies</h3>
                    <label class="checkbox">
                        <input type="checkbox" ng-model="allTechsSelected">All
                    </label>
                    <div ng-repeat="tech in techs">
                        <label class="checkbox">
                            <input type="checkbox" ng-model="tech.selected" ng-change="updateFilter()">{{tech.name}}
                        </label>
                    </div>
                
                    <h3>Types</h3>
                    <label class="checkbox">
                        <input type="checkbox" ng-model="allTypesSelected">All
                    </label>
                    <div ng-repeat="type in types">
                        <label class="checkbox">
                            <input type="checkbox" ng-model="type.selected" ng-change="updateFilter()">{{type.name}}
                        </label>
                    </div>
                
                    <h3>Categories</h3>
                    <label class="checkbox">
                        <input type="checkbox" ng-model="allCategoriesSelected">All
                    </label>
                    <div ng-repeat="cat in categories">
                        <label class="checkbox">
                            <input type="checkbox" ng-model="cat.selected" ng-change="updateFilter()">{{cat.name}}
                        </label>
                    </div>
                
                    <h3>Return types</h3>
                    <label class="checkbox">
                        <input type="checkbox" ng-model="allReturnTypesSelected">All
                    </label>
                    <div ng-repeat="type in returnTypes">
                        <label class="checkbox">
                            <input type="checkbox" ng-model="type.selected" ng-change="updateFilter()">{{type.name}}
                        </label>
                    </div>
                </div>
                <div class="right-column">
                    <div ng-repeat="item in items" ng-show="item.isVisible" class="item">
                        <div ng-click="item.isCollapsed = !item.isCollapsed" class="header" ng-class="{collapsed: item.isCollapsed}">
                            <span class="type">{{item.returnType}}</span> {{item.name}} <span class="text-gray">(</span><span ng-bind-html-unsafe="item.parameters|formatParameters"></span><span class="text-gray">)</span>
                            <div class="pull-right instruction">
                                {{item.instruction}}
                            </div>
                        </div>
                        <div ng-if="!item.isCollapsed" class="body">
                            <h5>Synopsis</h5>
                            <p>#include "{{item.header}}"</p>
                            <p>Instruction: {{item.instruction}}</p>
                            <p>CPUID Feature Flag: {{item.cpuId}}</p>
                        
                            <h5>Description</h5>
                            <p class="description">{{item.description}}</p>
                        
                            <div ng-if="!!item.code">
                                <h5>Operation</h5>
                                <div class="code">{{item.code}}</div>
                            </div>
                        
                            <div ng-if="!!item.latencyAndThroughput">
                                <h5>Latency & Throughput Information</h5>
                                <table class="table">
                                    <tr>
                                        <th>CPUID(s)</th>
                                        <th>Parameters</th>
                                        <th>Latency</th>
                                        <th>Throughput</th>
                                    </tr>
                                    <tr ng-repeat="family in item.latencyAndThroughput | orderBy:'base'">
                                        <td>{{family.base}}</td>
                                        <td>{{family.parameters}}</td>
                                        <td>{{family.latency}}</td>
                                        <td>{{family.throughput}}</td>
                                    </tr>
                                </table>
                            </div>
                        </div>    
                    </div>
                </div>
            </div>
        </div>
    </body>
</html>